require({cache:{
'Sage/Data/BaseSDataStore':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
        'Sage/Utility',
        'Sage/Data/SDataServiceRegistry',
        'dojo/_base/declare',
        'dojo/_base/lang'
],
function (Utility, SDataServiceRegistry, declare, lang) {
    var baseStore = declare('Sage.Data.BaseSDataStore', null, {
        queryName: null,
        ignoreETag: null,
        constructor: function (o) {
            lang.mixin(this, o);
            this.features = {
                'dojo.data.api.Read': true
            };
            if (!this.identityAttributes) {
                this.identityAttributes = [this.identityAttribute || '$key'];
            }
            if (!this.labelAttributes) {
                this.labelAttributes = ['$descriptor'];
            }
            this.features['dojo.data.api.Identity'] = true;
            this.dataCache = { query: '' };
        },
        fetch: function (context) {
            if (!this.isNewContext(context) && this.feed) {
                this.onSuccess(context, this.feed);
                return;
            }

            this.setContext(context);
            if (context.count === Infinity) {
                context.count = 500;  //500 is almost Infinity, right?
            }

            var pagesize = (context.count - 0) || this.pageSize || 15;
            var startIdx = (context.start - 0) || 1;
            if (startIdx > 1) {
                startIdx = startIdx + 1;
            }

            this.verifyService();
            var request = this.getCollectionRequestObj(context);
            if (!request) {
                if (context.onError) {
                    context.onError.call(context.scope || this, "Invalid data url", context);
                }
                return;
            }

            request.setQueryArg(Sage.SData.Client.SDataUri.QueryArgNames.StartIndex, (isNaN(startIdx)) ? 1 : startIdx);
            var qry = '';

            // New dojo 1.7 controls will clobber this.query.
            // Issue a warn if this.query was set to an object or string
            if (this.query && typeof this.query !== 'function') {
                console.warn('BaseSDataStore.query should not be set. Use directQuery instead.');

                // Set the new property so we don't break anything.
                if (!this.directQuery) {
                    this.directQuery = this.query;
                }
            }

            // Check to see if a query has been added directly to the store, for binding with native dojo components, ie. ComboBox
            // TODO: Determine patterns for mixin, replacement, seed value, etc. of query,
            if (this.directQuery) {
                if (!context.query) {
                    context.query = {};
                }
                lang.mixin(context.query, this.directQuery);
            }
            if (context.query) {
                if (typeof context.query === 'function') {
                    qry = context.query();
                } else if (typeof context.query === 'string') {
                    qry = context.query;
                } else if (typeof context.query === 'object') {
                    for (var queryItem in context.query) {
                        //Initial context based query
                        if (queryItem === 'fn') {
                            qry = context.query.fn.call(context.query.scope || this);
                        }
                        //Additional conditions.  Typically from the ConditionManager.
                        else if (queryItem === 'conditions') {
                            if (typeof context.query.conditions === 'string' && context.query.conditions !== '') {
                                qry += (qry && qry.length > 0) ? ' and ' + context.query.conditions : context.query.conditions;
                            }
                        }
                        //In the case of ComboBoxes and FilteringTextBoxes, we need to include the user input into the query.
                        else if (queryItem !== 'scope') {
                            if (context.query.hasOwnProperty(queryItem)) {
                                var userInput = [queryItem, ' like ', "'", context.query[queryItem].replace('*', '%'), "'"].join('');
                                qry += (qry.length > 0) ? ' and ' + userInput : userInput;
                            }
                        }
                    }
                }
            }

            context.evaluatedQuery = qry || '';
            if (qry && qry !== '') {
                request.setQueryArg('where', qry);
            }

            if (this.select && this.select.length > 0)
                request.setQueryArg('select', this.select.join(','));

            if (this.include && this.include.length > 0)
                request.setQueryArg('include', this.include.join(','));
            if (this.sort) {
                // add the "intrinsic" sort (specified in store options)
                // take care not to re-add an attribute that is already specified in the context sort 
                // (or sdata will give an error)
                context.sort = context.sort || [];

                dojo.forEach(this.sort, function (sortItem) {
                    if (dojo.filter(context.sort, function (existingSort) {
                        return sortItem.attribute == existingSort.attribute;
                    }).length === 0) {
                        context.sort.push(sortItem);
                    }
                });
            }

            if (typeof context.resourcePredicate !== 'undefined') {
                request.getUri().setCollectionPredicate(context.resourcePredicate);
            }

            this._setQueryArgsOnRequest(context.queryArgs, request);

            if (context.sort && context.sort.length > 0) {
                var order = [];
                dojo.forEach(context.sort, function (v) {
                    if (v.descending)
                        this.push(v.attribute + ' desc');
                    else
                        this.push(v.attribute);
                }, order);
                // ProxySDataStore hits this, and it should be camel-case to follow our SData spec
                //  Our system is case-insensitive, but other systems following the spec may not be (X3 for instance)
                request.setQueryArg('orderBy', order.join(','));
            }

            if (this.beforeRequest && typeof this.beforeRequest === 'function') {
                this.beforeRequest.call(context.scope || this, request);
            }
            var key = request.read({
                success: lang.hitch(this, this.onSuccess, context),
                failure: lang.hitch(this, this.onFailure, context)
            });

            return {
                abort: lang.hitch(this, this.abortRequest, key)
            };
        },
        getCollectionRequestObj: function (context) {
            var request = this.queryName
                ? new Sage.SData.Client.SDataNamedQueryRequest(this.service).setQueryName(this.queryName)
                : new Sage.SData.Client.SDataResourceCollectionRequest(this.service);

            request.setResourceKind(this.resourceKind);
            request.setStartIndex(context.start + 1);

            if (this.resourcePredicate
                && this.resourcePredicate !== "''") {
                request.getUri().setCollectionPredicate(this.resourcePredicate);
            }

            this._setQueryArgsOnRequest(this.queryArgs, request);

            if (!context.count && this.count) {
                context.count = this.count;
            }
            request.setCount(context.count);
            return request;
        },
        _setQueryArgsOnRequest: function (queryArgs, request) {
            if (queryArgs) {
                for (var prop in queryArgs) {
                    if (queryArgs.hasOwnProperty(prop)) {
                        request.setQueryArg(prop, queryArgs[prop]);
                    }
                }
            }
        },
        abortRequest: function (key) {
            this.service.abortRequest(key);
        },
        onSuccess: function (context, feed) {
            if (context.onBegin) {
                if (typeof feed.$totalResults === 'undefined') {
                    feed.$totalResults = feed.$itemsPerPage + feed.$startIndex;// the previous value of 500000 allowed users to scroll past the last page.
                }
                context.onBegin.call(context.scope || this, feed.$totalResults, context);
            }
            if (context.onComplete) context.onComplete.call(context.scope || this, feed.$resources, context);
            this.addToCache(context, feed);
        },
        onFailure: function (context, request, o) {
            var msg = 'An unknown exception occurred obtaining data.';
            if (request.responseText) {
                var responseJObj = Sys.Serialization.JavaScriptSerializer.deserialize(request.responseText);
                if (dojo.isArray(responseJObj)) {
                    msg = responseJObj[0].message;
                } else {
                    msg = request.responseText;
                }
            }
            if (context && context.onError) {
                context.onError.call(context.scope || this, msg, context);
            }
            else {
                if (typeof msg === 'string' && typeof console !== 'undefined') {
                    if (request && request.status) {
                        msg += ' (HTTP status = %o; statusText = %o)';
                        console.error(msg, request.status, request.statusText);
                    }
                    else
                        console.error(msg);
                }
            }
        },
        setContext: function (newContext) {
            this.context = {
                start: newContext.start,
                count: newContext.count,
                query: newContext.query,
                queryOptions: newContext.queryOptions,
                sort: newContext.sort
            };
        },
        addToCache: function (context, feed) {
            var i, item, key;
            if (context.evaluatedQuery !== this.dataCache.query) {
                this.clearCache();
                this.dataCache.query = context.evaluatedQuery;
            }
            if (feed.$resources) {
                for (i = 0; i < feed.$resources.length; i++) {
                    item = feed.$resources[i];
                    key = this.getIdentity(item);
                    this.dataCache[key] = item;
                }
            }
        },
        clearCache: function () {
            for (var key in this.dataCache) {
                if (key !== 'query') {
                    delete this.dataCache[key];
                }
            }
            this.dataCache.query = '';
        },
        isNewContext: function (newContext) {
            if (typeof this.context !== 'object') return true;
            if (this.context.start !== newContext.start) return true;
            if (this.context.count !== newContext.count) return true;
            return false;
        },
        verifyService: function (contract) {
            if (!this.service) {
                this.service = SDataServiceRegistry.getSDataService(contract || 'dynamic');
            }
        },
        getValue: function (item, attribute, defaultValue) {
            return Utility.getValue(item, attribute);
        },
        getFeatures: function () {
            return this.features;
        },
        //dojo.data.api.Read implementations....
        getLabel: function (item) {
            var lbl = [];
            for (var i = 0; i < this.labelAttributes.length; i++) {
                if (item.hasOwnProperty(this.labelAttributes[i])) {
                    lbl.push(item[this.labelAttributes[i]]);
                }
            }
            return lbl.join(' ');
        },
        getLabelAttributes: function (item) {
            return this.labelAttributes;
        },
        //dojo.data.api.Identity implementations...
        getIdentity: function (item) {
            //summary:
            //  Returns the value of the unique identifier for the item passed
            //item:
            //  The item from which to obtain its identifier.
            if (item) {
                var identity = [];
                for (var i = 0; i < this.identityAttributes.length; i++) {
                    if (item.hasOwnProperty(this.identityAttributes[i])) {
                        identity.push(item[this.identityAttributes[i]]);
                    }
                }
                return identity.join('');
            }
        },
        getIdentityAttributes: function (item) {
            return this.identityAttributes;
        },
        fetchItemByIdentity: function (keywordArgs) {
            //summary:
            //  returns the item from the store that matches the identity passed in the keywordArgs object.
            //keywordArgs:
            //  object that defines the item to locate and callback methods to invoke when the item has been located and loaded.
            //  {
            //      identity: string|object,    //id
            //      onItem: function(item),     //called when item has been loaded
            //      onError: function(error),   //called when an error occurred or item could not be loaded.
            //      scope: object,              //the scope in which to call the onItem and onError functions
            //  }
            if (this.dataCache.hasOwnProperty(keywordArgs.identity)) {
                keywordArgs.onItem.call(keywordArgs.scope || this, this.dataCache[keywordArgs.identity]);
            } else {
                var msg = 'Item with that key does not exist in the data cache: ' + keywordArgs.identity;
                if (keywordArgs.onError) {
                    keywordArgs.onError.call(keywordArgs.scope || this, { 'error': msg });
                } else {
                    if (typeof console !== 'undefined') { console.info(msg); }
                }
            }
        },
        containsValue: function (item, attr, value) {
            var val = Utility.getValue(item, attr);
            return val !== '';
        }
    });

    return baseStore;
});

},
'Sage/Utility':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define,infor, mingleConfig */
define([
        'dojo/parser',
        'Sage/Data/SDataServiceRegistry',
        'Sage/UI/Dialogs',
        'Sage/Utility/ErrorHandler', // Circular
        'dojox/validate/regexp',
        'dojo/i18n!./Utility/nls/Utility',
        'dojo/has',
        'dojo/ready',
        'dojo/string',
        'dojo/_base/array',
        'dojo/_base/lang',
        'dojo/_base/xhr',
        'dojo/date'
    ],
function (
        parser,
        SDataServiceRegistry,
        Dialogs,
        ErrorHandler,
        regexp,
        resource,
        has,
        ready,
        dString,
        array,
        lang,
        xhr,
        dojoDate
    ) {
    Sage.namespace('Utility');
    dojo.mixin(Sage.Utility, {
        _timeZones: null,
        _ownersCache: null,
        _ownersCacheKey: 'SecCodeCache',
        _userCache: null,
        _userCacheKey: '_userCacheKey',
        isIE: (typeof ActiveXObject !== 'undefined' || has('trident')),
        nameToPathCache: {},
        nlsStrings: resource,
        regexp: {
            // The invalidInput RegExp is designed to provide input validation in order to avoid the
            // "A potentially dangerous Request.Form value was detected from the client..." error.
            // The error is the result of a System.Web.HttpRequestValidationException when form fields,
            // etc., contain character sequences Microsoft considers dangerous. The error will
            // occur under the following conditions if the requestValidationMode has [not] been set to
            // ASP.NET 2.0 in Web.Config, etc.:
            //
            // 1. If the < (less than sign) is followed by a letter, ! (exclamation), / (slash), or
            //    ? (question mark) (i.e. if it looks like a tag or an HTML comment).
            // 2. If the & (ampersand) is followed by a # (pound sign) (e.g. &#169;).
            //
            // The logic that introduced the HttpRequestValidationException began with ASP.NET 4.0 and
            // is the result of a call to System.Web.HttpRequest.ValidateString() (internal method).
            // It is considered a breaking change with ASP.NET 4.0 (see http://www.asp.net/whitepapers/aspnet4/breaking-changes).
            //
            // The invalidInput RegExp is designed to be used with the dijit.form.ValidationTextBox
            // control by setting its regExp property.
            invalidInput: '^((?!(<([!\\/?A-Za-z])|(&#))).)*$',

            // The invalidInputFmt format string is provided so that another RegExp can be combined with
            // the invalidInput RegExp. See example in joinInvalidInputRegExpWith().
            invalidInputFmt: '^((?!(<([!\\/?A-Za-z])|(&#)|(${0}))).)*$',

            // The invalidInputMatch RegExp can be used to return the matches in an invalid input string,
            // as described in the invalidInput RegExp. See example in getInvalidInputMatches().
            invalidInputMatch: '<[!\\/?A-Za-z]|&#'
        },
        /**
         * Takes a string template, slits it, and passes it to new Simplate,
         * filtering out undefined, null, and trimmed empty string values.
         * @param {String} template The string template to split
         * @param {String} split Separator for the split
         */
        makeTemplateFromString: function(template, split) {
            var templateResults, widgetTemplate;
            if (typeof split === 'undefined' || split === null) {
                split = '\r';
            }

            templateResults = array.filter(template.split(split), function(item) {
                return typeof item !== 'undefined' && item !== null && dString.trim(item) !== '';
            });

            widgetTemplate = new Simplate(templateResults);
            return widgetTemplate;
        },
        // Combines the aRegExp with the invalidInput RegExp for use with the dijit.form.ValidationTextBox.
        joinInvalidInputRegExpWith: function (aRegExp) {
            if (aRegExp && dojo.isString(aRegExp) && aRegExp.length > 0) {
                return dString.substitute(this.regexp.invalidInputFmt, [aRegExp]);
            }
            return aRegExp;
        },
        // Gets all matches in the string s that match the RegExp invalidInputMatch.
        getInvalidInputMatches: function (s) {
            if (s && dojo.isString(s) && s.length > 0) {
                var matches = s.match(this.regexp.invalidInputMatch, 'g');
                if (matches && dojo.isArray(matches)) {
                    return matches;
                }
            }
            return [];
        },
        // Returns true if the string s does not contain invalidInput character sequences (or if s is null).
        // Returns false if s is not a string or if s contains invalidInput character sequences.
        // Note: It's ok to POST data that has invalid input characters, as long as they are [not] part of
        // a Request.Form POST (e.g. application/x-www-form-urlencoded). For example, if the invalid characters
        // are in JSON data that is part of an application/json POST, there is no need to call the isSafeForPosting()
        // function against those strings.
        isSafeForPosting: function (s) {
            if (s && dojo.isString(s)) {
                if (s.length === 0) {
                    return true;
                }
                var match = s.match(this.regexp.invalidInputMatch);
                if (match === null) {
                    return true;
                }
                if (dojo.isArray(match) && match.length === 0) {
                    return true;
                }
            }
            if (!s && s === null) {
                return true;
            }
            return false;
        },
        makeSafeForPosting: function (s) {
            var matches = this.getInvalidInputMatches(s);
            if (matches && dojo.isArray(matches) && matches.length > 0) {
                array.forEach(matches, function (match) {
                    var safeValue = match;
                    if (match.length >= 2) {
                        // e.g. replace '<!' with '< !', etc.
                        // e.g. 'Hello<!World Hello</World Hello<?World' becomes 'Hello< !World Hello< /World Hello< ?World'
                        safeValue = match.substr(0, 1) + ' ' + match.substr(1);
                    }
                    if (safeValue !== match) {
                        s = s.replace(match, safeValue);
                    }
                });
            }
            return s;
        },
        nameToPath: function (name) {
            var parts, path, i, match;

            if (typeof name !== 'string') {
                return [];
            }

            if (Sage.Utility.nameToPathCache[name]) {
                return Sage.Utility.nameToPathCache[name];
            }

            parts = name.split('.');
            path = [];
            for (i = 0; i < parts.length; i++) {
                match = parts[i].match(/([a-zA-Z0-9_$]+)\[([^\]]+)\]/);
                if (match) {
                    path.push(match[1]);
                    if (/^\d+$/.test(match[2])) {
                        path.push(parseInt(match[2], 10));
                    } else {
                        path.push(match[2]);
                    }
                }
                else {
                    path.push(parts[i]);
                }
            }

            Sage.Utility.nameToPathCache[name] = path.reverse();
            return Sage.Utility.nameToPathCache[name];
        },
        expand: function (scope, expression) {
            if (typeof expression === 'function') {
                return expression.apply(scope, Array.prototype.slice.call(arguments, 2));
            } else {
                return expression;
            }
        },
        getValue: function (o, name, defaultValue) {
            defaultValue = (typeof defaultValue !== 'undefined' && defaultValue !== null) ? defaultValue : '';
            var path = Sage.Utility.nameToPath(name).slice(0);
            var current = o;
            while (current && path.length > 0) {
                var key = path.pop();
                if (typeof current[key] !== 'undefined' && current[key] !== null) current = current[key]; else return defaultValue;
            }
            return current;
        },
        setValue: function (o, name, val) {
            var current = o;
            var path = Sage.Utility.nameToPath(name).slice(0);
            while ((typeof current !== "undefined") && path.length > 1) {
                var key = path.pop();
                if (path.length > 0) {
                    var next = path[path.length - 1];
                    current = current[key] = (typeof current[key] !== "undefined") ? current[key] : (typeof next === "number") ? [] : {};
                }
            }
            if (current !== null && typeof path[0] !== "undefined")
                current[path[0]] = val;
            return o;
        },
        getPlainText: function (node) {
            // returns formatted innerText similar to IE,
            // but works for all browsers

            var normalize = function (a) {
                // clean up double line breaks and spaces
                if (!a) return "";
                return a.replace(/ +/g, " ")
                        .replace(/[\t]+/gm, "")
                        .replace(/[ ]+$/gm, "")
                        .replace(/^[ ]+/gm, "")
                        .replace(/\n+/g, "\n")
                        .replace(/\n+$/, "")
                        .replace(/^\n+/, "")
                        .replace(/\nNEWLINE\n/g, "\n\n")
                        .replace(/NEWLINE\n/g, "\n\n"); // IE
            };
            var removeWhiteSpace = function (node) {
                // getting rid of empty text nodes
                var isWhite = function (node) {
                    return !(/[^\t\n\r ]/.test(node.nodeValue));
                };
                var ws = [];
                var findWhite = function (node) {
                    for (var i = 0; i < node.childNodes.length; i++) {
                        var n = node.childNodes[i];
                        if (n.nodeType == 3 && isWhite(n)) {
                            ws.push(n);
                        } else if (n.hasChildNodes()) {
                            findWhite(n);
                        }
                    }
                };
                findWhite(node);
                for (var i = 0; i < ws.length; i++) {
                    ws[i].parentNode.removeChild(ws[i]);
                }

            };
            var sty = function (n, prop) {
                // Get the style of the node.
                // Assumptions are made here based on tagName.
                if (n.style[prop]) return n.style[prop];
                var s = n.currentStyle || n.ownerDocument.defaultView.getComputedStyle(n, null);
                if (n.tagName == "SCRIPT") return "none";
                if (!s[prop]) return "LI,P,TR".indexOf(n.tagName) > -1 ? "block" : n.style[prop];
                if (s[prop] == "block" && n.tagName == "TD") return "feaux-inline";
                return s[prop];
            };

            var blockTypeNodes = "table-row,block,list-item";
            var isBlock = function (n) {
                // diaply:block or something else
                var s = sty(n, "display") || "feaux-inline";
                if (blockTypeNodes.indexOf(s) > -1) return true;
                return false;
            };

            var recurse = function (n) {
                // Loop through all the child nodes
                // and collect the text, noting whether
                // spaces or line breaks are needed.
                if (/pre/.test(sty(n, "whiteSpace"))) {
                    t += n.innerHTML
                        .replace(/\t/g, " ")
                        .replace(/\n/g, " "); // to match IE
                    return "";
                }
                var s = sty(n, "display");
                if (s == "none") return "";
                var gap = isBlock(n) ? "\n" : " ";
                t += gap;
                for (var i = 0; i < n.childNodes.length; i++) {
                    var c = n.childNodes[i];
                    if (c.nodeType == 3) t += c.nodeValue;
                    if (c.childNodes.length) recurse(c);
                }
                t += gap;
                return t;
            };
            // Use a copy because stuff gets changed
            node = node.cloneNode(true);
            // Line breaks aren't picked up by textContent
            node.innerHTML = node.innerHTML.replace(/<br>/g, "\n");

            // Double line breaks after P tags are desired, but would get
            // stripped by the final RegExp. Using placeholder text.
            var paras = node.getElementsByTagName("p");
            for (var i = 0; i < paras.length; i++) {
                paras[i].innerHTML += "NEWLINE";
            }

            var t = "";
            removeWhiteSpace(node);

            return normalize(recurse(node));
        },
        /*
        debounce taken from underscore.js.

        Underscore.js 1.3.3
        (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
        Underscore is freely distributable under the MIT license.
        Portions of Underscore are inspired or borrowed from Prototype,
        Oliver Steele's Functional, and John Resig's Micro-Templating.
        For all details and documentation:
        http://documentcloud.github.com/underscore
        */
        debounce: function (func, wait, immediate) {
            var timeout;
            return function () {
                var context = this, args = arguments;
                var later = function () {
                    timeout = null;
                    if (!immediate) func.apply(context, args);
                };
                if (immediate && !timeout) func.apply(context, args);
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        },
        /*
        * Original version of .extend from...
        * jQuery 1.2.6 - New Wave Javascript
        *
        * Copyright (c) 2008 John Resig (jquery.com)
        * Dual licensed under the MIT (MIT-LICENSE.txt)
        * and GPL (GPL-LICENSE.txt) licenses.
        *
        * $Date: 2008-05-24 14:22:17 -0400 (Sat, 24 May 2008) $
        * $Rev: 5685 $
        */
        extend: function () {
            // copy reference to target object
            var target = arguments[0] || {}, i = 1, length = arguments.length, deep = false, options;

            // Handle a deep copy situation
            if (target.constructor == Boolean) {
                deep = target;
                target = arguments[1] || {};
                // skip the boolean and the target
                i = 2;
            }

            // Handle case when target is a string or something (possible in deep copy)
            if (typeof target != "object" && typeof target != "function")
                target = {};

            // Single parameter extends Sage.Utilities
            if (length == i) {
                target = this;
                --i;
            }

            for (; i < length; i++)
            // Only deal with non-null/undefined values
                if ((options = arguments[i]) != null) // jshint ignore:line
                // Extend the base object
                    for (var name in options) {
                        var src = target[name], copy = options[name];

                        // Prevent never-ending loop
                        if (target === copy)
                            continue;

                        // Recurse if we're merging object values
                        if (deep && copy && typeof copy == "object" && !copy.nodeType)
                            target[name] = Sage.Utility.extend(deep,
                            // Never move original objects, clone them
                            src || (copy.length != null ? [] : {}), copy);// jshint ignore:line

                        // Don't bring in undefined values
                        else if (copy !== undefined)
                            target[name] = copy;

                    }

            // Return the modified object
            return target;
        },
        getCurrentEntityId: function () {
            var contextservice = Sage.Services.getService('ClientEntityContext');
            var eContext = contextservice.getContext();
            return eContext.EntityId;
        },
        getCurrentEntityName: function () {
            var contextservice = Sage.Services.getService('ClientEntityContext');
            var eContext = contextservice.getContext();
            return eContext.DisplayName;
        },
        getClientContextByKey: function (key) {
            var res = '';
            if (Sage.Services) {
                var contextservice = Sage.Services.getService("ClientContextService");
                if ((contextservice) && (contextservice.containsKey(key))) {
                    res = contextservice.getValue(key);
                }
            }
            return res;
        },
        setClientContextByKey: function (key, value) {
            if (Sage.Services) {
                var contextservice = Sage.Services.getService("ClientContextService");
                if (contextservice) {
                    if (contextservice.containsKey(key)) {
                        contextservice.setValue(key, value);
                    } else {
                        contextservice.add(key, value);
                    }
                    return true;
                }
            }
            return false;
        },
        getVirtualDirectoryName: function () {
            // returns the name of the virtual directory from the url to the current page.
            var reg = new RegExp(window.location.host + "/([A-Za-z0-9\\-_]+)/");
            var arr = reg.exec(window.location.href);
            if (arr)
                return arr[1];
            return '';
        },
        getSDataService: function (contract, keepUnique, useJson, cacheResult) {
            console.warn('Deprecated: Sage.Utility.getSDataService(). Use: Sage.Data.SDataServiceRegistry.getSDataService()');
            // returns the instance of the service for the specific contract requested.
            // For example, if the data source needs an SData service for the dynamic or system feeds,
            // the code would pass 'dynamic' or 'system' to this method.
            //the proxy datastore needs to always keep it's own unique instance of the service.
            return Sage.Data.SDataServiceRegistry.getSDataService(contract, keepUnique, useJson, cacheResult);
        },
        // BEGIN Ajax/Dojo Patch.  Notifies dojo to reparse partial postback content.
        appLoadHandler: function (sender, args) {
            Sys.WebForms.PageRequestManager.getInstance().add_pageLoaded(Sage.Utility.pageLoaded);
            Sys.WebForms.PageRequestManager.getInstance().add_pageLoading(Sage.Utility.pageLoading);
            Sys.WebForms.PageRequestManager.getInstance().add_initializeRequest(Sage.Utility.showRequestIndicator);
            Sys.WebForms.PageRequestManager.getInstance().add_endRequest(Sage.Utility.hideRequestIndicator);
            Sys.WebForms.PageRequestManager.getInstance().add_initializeRequest(window.AutoLogout.resetTimer);
        },
        pageLoaded: function (sender, args) {
            var updatedPanels = args.get_panelsUpdated();
            if (typeof (updatedPanels) === "undefined") {
                return;
            }
            //call the dojo parser on the newly loaded html
            //in each panel so the new elements are instantiated
            for (var i = 0; i < updatedPanels.length; i++) {
                dojo.parser.parse(updatedPanels[i]);
            }
        },
        pageLoading: function (sender, args) {
            var updatedPanels = args.get_panelsUpdating();
            if (typeof (updatedPanels) === "undefined") {
                return;
            }
            //remove all the widgets in the outgoing panel
            //so the dojo parser doesn't throw
            //an error when it reloads them.
            for (var i = 0; i < updatedPanels.length; i++) {
                var panel = updatedPanels[i],
                widgets = dijit.findWidgets(panel);
                // can use preserveDom (true) here as the update panel load will destroy the DOM for us.
                // some DOM will be destroyed, regardless.
                dojo.forEach(widgets, function (widget) {
                    widget.destroyRecursive(true);
                });
            }
        },
        destroyWidget: function (widget) {
            var widgetId = dojo.attr(widget, 'widgetId');
            if (dijit.byId(widgetId)) {
                dijit.byId(widgetId).destroyRecursive();
            }
        },
        // END Ajax/Dojo Patch.
        //Begin ajax request indicator handling.
        showRequestIndicator: function () {
            var elem = document.getElementById("asyncpostbackindicator");
            if (elem) { elem.style.visibility = "visible"; }
        },
        // Ajax endRequest handler
        hideRequestIndicator: function (sender, args) {
            var elem = dojo.byId("asyncpostbackindicator");
            if (elem) { elem.style.visibility = "hidden"; }
            ErrorHandler.handleEndRequestError(args);
        },
        //end ajax request indicator handling.
        // BEGIN - common numeric / currency functions
        isAllowedNavigationKey: function (charCode) {
            return (charCode == 8   // backspace
            || charCode == 9    // tab
            || charCode == 46   // delete
            || charCode == 37   // left arrow
            || charCode == 39); // right arrow
        },
        restrictDecimalDigit: function (value, places, decimalSeparator) {
            var retVal = value;
            if (typeof places === 'undefined') {
                places = Sys.CultureInfo.CurrentCulture.numberFormat.NumberDecimalDigits;
            }
            // If the places param has provided a range, find the end of the range and use that
            // as the length to restrict to.
            if (places.length > 1) {
                var range = places.split(',');
                places = parseInt(range[1], 10);
            }
            if (typeof decimalSeparator === 'undefined') {
                decimalSeparator = Sys.CultureInfo.CurrentCulture.numberFormat.NumberDecimalSeparator;
            }
            var restriction = value.indexOf(decimalSeparator) + 1 + places;
            if (places === 0) {
                restriction = restriction - 1;
            }
            //To handle negative
            if (value.indexOf(")") > 0) {
                restriction += 1;
            }
            if (value.lastIndexOf(decimalSeparator) > -1) {
                retVal = value.substr(0, restriction);
            }
            return retVal;

        },
        maximizeDecimalDigit: function (value, decimalDigits, decimalSeparator) {
            var diff;
            var retVal = value;
            if (typeof decimalDigits === 'undefined') {
                decimalDigits = Sys.CultureInfo.CurrentCulture.numberFormat.NumberDecimalDigits;
            }
            if (typeof decimalSeparator === 'undefined') {
                decimalSeparator = Sys.CultureInfo.CurrentCulture.numberFormat.NumberDecimalSeparator;
            }
            //If there isn't a separator but we require a decimal digit position, place the separator before adding digits.
            if (decimalDigits > 0 && value.lastIndexOf(decimalSeparator) == -1 && value.length > 0) {
                retVal = [value, decimalSeparator].join('');
            }

            var restriction = retVal.lastIndexOf(decimalSeparator) + 1 + decimalDigits;
            if (retVal.lastIndexOf(decimalSeparator) > -1) {
                diff = restriction - retVal.length;
                if (diff > 0) {
                    for (var i = 0; i < diff; i++) {
                        retVal += 0;
                    }
                }
            }
            return retVal;
        },
        restrictToNumber: function (e, /*currency, number, percent*/type) {
            var SystemFormat = Sys.CultureInfo.CurrentCulture.numberFormat;
            var code = e.charCode || e.keyCode;
            var keyChar = e.keyChar;

            if (e.keyCode && Sage.Utility.isAllowedNavigationKey(e.keyCode)) return true;
            // 0-9 Keyboard and numberpad.
            if ((code >= 48 && code <= 57 && !e.shiftKey) || (code >= 96 && code <= 105 && !e.shiftKey)) return true;
            // Negative, ".", "-"
            if (keyChar === SystemFormat.NegativeSign || code == 109 || code == 110) return true;
            //Separators
            switch (type) {
                case 'currency':
                    if (keyChar == SystemFormat.CurrencyGroupSeparator || keyChar == SystemFormat.CurrencyDecimalSeparator) return true;
                    break;
                case 'percent':
                    if (keyChar == SystemFormat.PercentGroupSeparator || keyChar == SystemFormat.PercentDecimalSeparator) return true;
                    break;
                default: //number
                    if (keyChar == SystemFormat.NumberGroupSeparator || keyChar == SystemFormat.NumberDecimalSeparator) return true;
                    break;
            }
            return false;
        },
        restrictToNumberOnKeyPress: function (e, type) {
            if (e.keyCode && Sage.Utility.isAllowedNavigationKey(e.keyCode)) return true;

            var SystemFormat = Sys.CultureInfo.CurrentCulture.numberFormat;
            var code = e.charCode || e.keyCode;
            var keyChar = String.fromCharCode(code);
            var validChar = '0123456789' + SystemFormat.NegativeSign;
            switch (type) {
                case 'currency':
                    validChar += SystemFormat.CurrencyGroupSeparator + SystemFormat.CurrencyDecimalSeparator;
                    break;
                case 'percent':
                    validChar += SystemFormat.PercentGroupSeparator + SystemFormat.PercentDecimalSeparator;
                    break;
                default: //number
                    validChar += SystemFormat.NumberGroupSeparator + SystemFormat.NumberDecimalSeparator;
                    break;
            }
            return (validChar.indexOf(keyChar) >= 0);
        },
        // END - common numeric / currency functions
        /* Sage.Utility.Convert methods...  */
        Convert: function () {
            var trueRE = /^(true|T)$/i,
                isoDate = /(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(Z|(-|\+)(\d{2}):(\d{2}))/,
                isoDateOnly = /^(\d{4})-(\d{2})-(\d{2})$/,
                jsonDate = /\/Date\((-?\d+)(?:(-|\+)(\d{2})(\d{2}))?\)\//,
                pad = function (n) { return n < 10 ? '0' + n : n; },
                unpad = function (str) { return (str[0] === '0') ? str.substring(1) : str; };
            return {
                toBoolean: function (value) {
                    return trueRE.test(value);
                },
                isDateString: function (value) {
                    if (typeof value !== 'string')
                        return false;

                    return isoDate.test(value) || isoDateOnly.test(value) || jsonDate.test(value);
                },
                dateToTimeless: function (d) {
                    var timelessDate = new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), 0, 0, 5);
                    return timelessDate;
                },
                toIsoStringFromDate: function (value) {
                    // adapted from: https://developer.mozilla.org/en/JavaScript/Reference/global_objects/date
                    if ((value.getHours() === 0) && (value.getMinutes() === 0) && (value.getSeconds() === 5)) {
                        return value.getFullYear() + '-'
                        + pad(value.getMonth() + 1) + '-'
                        + pad(value.getDate()) + 'T00:00:05Z';
                    }

                    return value.getUTCFullYear() + '-'
                        + pad(value.getUTCMonth() + 1) + '-'
                        + pad(value.getUTCDate()) + 'T'
                        + pad(value.getUTCHours()) + ':'
                        + pad(value.getUTCMinutes()) + ':'
                        + pad(value.getUTCSeconds()) + 'Z';
                },
                toIsoStringFromDateNonUTC: function (value) {
                    return value.getFullYear() + '-'
                        + pad(value.getMonth() + 1) + '-'
                        + pad(value.getDate()) + 'T'
                        + pad(value.getHours()) + ':'
                        + pad(value.getMinutes()) + ':'
                        + pad(value.getSeconds()) + 'Z';
                },
                toJsonStringFromDate: function (value) {
                    return '/Date(' + value.getTime() + ')/';
                },
                toDateFromString: function (value, useOffset) {
                    if (typeof value !== 'string') {
                        return value;
                    }

                    var match,
                        utc,
                        h, m,
                        offset;

                    if ((match = jsonDate.exec(value))) {
                        utc = new Date(parseInt(match[1], 10));
                        if (useOffset === true) {
                            if (match[2]) {
                                h = parseInt(match[3], 10);
                                m = parseInt(match[4], 10);

                                offset = (h * 60) + m;

                                if (match[2] === '-') {
                                    offset = -1 * offset;
                                }
                                utc.setMinutes(utc.getMinutes() + offset);
                            }
                        }
                        value = utc;
                    }
                    else if ((match = isoDate.exec(value))) {
                        utc = new Date(Date.UTC(
                            parseInt(match[1], 10),
                            parseInt(unpad(match[2]), 10) - 1, // zero based
                            parseInt(unpad(match[3]), 10),
                            parseInt(unpad(match[4]), 10),
                            parseInt(unpad(match[5]), 10),
                            parseInt(unpad(match[6]), 10)
                        ));

                        if (match[8] !== 'Z') {
                            h = parseInt(match[10], 10);
                            m = parseInt(match[11], 10);
                            offset = (h * 60) + m;
                            if (match[9] === '-') {
                                offset = -1 * offset;
                            }
                            utc.setMinutes(utc.getMinutes() + offset);
                        }

                        value = utc;
                    }
                    else if ((match = isoDateOnly.exec(value))) {
                        value = new Date();
                        value.setYear(parseInt(match[1], 10));
                        value.setMonth(parseInt(match[2], 10) - 1);
                        value.setDate(parseInt(match[3], 10));
                        value.setHours(0, 0, 0, 0);
                    }

                    return value;
                },
                toArrayFromObject: function (object) {
                    // ensure this isn't already an array first
                    if (object
                        && typeof object.length == 'undefined') {
                        var array = [];
                        array.push(object);
                        return array;
                    }
                    return object;
                }
            };
        } (),
        getModeId: function () {
            //summary:
            //Retrieves the current page mode from the Client Context Service.	Values will be: insert, list or detail
            var ctxSvc = Sage.Services.getService('ClientContextService');
            if ((ctxSvc) && (ctxSvc.containsKey('modeid'))) {
                var mode = ctxSvc.getValue('modeid');
                return mode.toLowerCase();
            }
            // if modeid isn't in the context service, it might be in the url...
            //ToDo: add support to look in the url:
            var u = document.location.href;
            var idx = u.indexOf('?');
            if (idx > 0) {
                var qry = u.substring(idx + 1);
                var parts = qry.split('&');
                for (var i = 0; i < parts.length; i++) {
                    var pair = parts[i].split('=');
                    if (pair.length > 1) {
                        if (pair[0].toLowerCase() === 'modeid') {
                            return pair[1];
                        }
                    }
                }
            }
            return 'None';
        },
        getPageName: function () {
            var url = document.location.href;
            var pagename = url.substring(url.lastIndexOf('/') + 1);
            return pagename;
        },
        openHelp: function (topic, subsystem) {
            var url = Sage.Link.getHelpUrl(topic, subsystem);
            var target = Sage.Link.getHelpUrlTarget();
            window.open(url, target);
        },
        openPdfDoc: function (topic) {
            var helpPath = Sage.Utility.getClientContextByKey('WebHelpUrlFmt');
            helpPath = helpPath.replace(helpPath.substring(helpPath.lastIndexOf('/') + 1), '');
            window.open(helpPath + topic);
        },
        fragger: function (frag, doc) {
            // frag must be a string
            if (typeof frag !== 'string') { return; }
            doc = doc || dojo.doc;
            var outer = doc.createElement('div');
            var inner = dojo._toDom(frag, doc);
            // copy the frag contents into the master
            // only the children of the frag will copy over
            outer.appendChild(inner);
            return outer;
        },
        fragToDijits: function (frag, ns) {
            // if using another dijit's addChild you will want noStart = true
            var parsed = dojo.parser.parse(frag, { noStart: ns || true });
            // parser returns an array of each dijit in document order
            return parsed;
        },
        strToDijits: function (tpl, ns) {
            // tpl must be a string
            if (typeof tpl !== 'string') { return; }
            // convert it into a parse-able document fragment
            var frag = this.toMasterFrag(tpl);
            return this.fragToDijits(frag, ns);
        },
        // perform a depth-first search of a a 'MasterFrag'
        // and execute fn on each node
        fragWalker: function walk(node, fn) {
            fn(node);
            node = node.firstChild;
            while (node) {
                walk(node, fn);
                node = node.nextSibling;
            }
        },
        // used by size, keys and values
        extract: function (obj, what) {
            var count = (what === 2), out = (count) ? 0 : [], i;
            for (i in obj) {
                if (count) {
                    out++;
                } else {
                    if (window.has(obj, i)) {
                        out.push((what) ? obj[i] : i);
                    }
                }
            }
            return out;
        },
        keys: function (obj) {
            return Sage.Utility.extract(obj);
        },
        size: function (obj) {
            return Sage.Utility.extract(obj, 2);
        },
        loadDetailsDialog: function (obj) {
            Sage.ClientLinkHandler.request({
                request: 'ShowDialog', type: obj.entityType, smartPart: obj.smartPart, entityId: obj.entityId, dialogTitle: obj.dialogTitle,
                isCentered: obj.isCentered, dialogTop: obj.dialogTop, dialogLeft: obj.dialogLeft, dialogHeight: obj.dialogHeight, dialogWidth: obj.dialogWidth,
                dialogParameters: obj.dialogParameters, childInsertInfo: obj.childInsertInfo
            });
        },
        values: function (obj) {
            return Sage.Utility.extract(obj, 1);
        },
        // safeMixin still mixes in too much
        mixOwn: function (target, source) {
            for (var p in source) {
                if (source.hasOwnProperty(p)) {
                    target[p] = source[p];
                }
            }
            return target;
        },
        // extract info from item.formatString in listPanel
        getPrecision: function (str) {
            var match = str.match(/\.(\d+)/), precision;
            if (match) {
                precision = parseInt(match[1], 10);
            }
            return precision ? precision : 0;
        },
		// extract currency symbo info from item.formatString in listPanel
         getCurrencySymbol: function (str) {
			var currencySymbol = '';
			if (str) {
				var currencySymbols = window.currencySymbolGlobalObj;
				if (currencySymbols) {
					var symbolItems = currencySymbols.split('|');
					for (var i = 0; i < symbolItems.length; i++) {
						if (str.indexOf(symbolItems[i]) > -1) {
							currencySymbol = symbolItems[i];
							return currencySymbol;
						}
					}
				}
			}
			return currencySymbol;
            },
        // Recursively loop the object and encode it's strings so they are safe for displaying
        encodeObjectStrings: function(object) {
            var dataType = typeof object;
            if (dataType === 'object') {
                for (var key in object) {
                    if (object[key]) {
                        object[key] = this.encodeObjectStrings(object[key]);
                    }
                }
                return object;
            }
            return this.htmlEncode(object);
        },
        htmlEncode: function (str) {
            if (typeof str != "string") { return str; }
            if (!str) { return ''; }

            return str.replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
        },
        // This is here for speed's sake.
        _hiddenPre: document.createElement("pre"),
        htmlDecode: function (str) {
            if (typeof str != "string") { return str; }
            //This needs to decode standard HTML encoded strings
            // This is how angular.js does it (see sanatize.decodeEntities)
            this._hiddenPre.innerHTML = str.replace(/</g,"&lt;");
            // innerText depends on styling as it doesn't display hidden elements.
            // Therefore, it's better to use textContent not to cause unnecessary reflows.
            return this._hiddenPre.textContent;
        },
        getSelectionInfo: function () {
            var panel = dijit.byId('list');
            if (panel) {
                return panel.getSelectionInfo();
            }
            return false;
        },
getEQLogicalId: function () {
            var eqLogicalId="";
                  this.loadEQLogicalId();
            if(localStorage.getItem('eqLogicalId'))
                eqLogicalId = localStorage.getItem('eqLogicalId');
           return eqLogicalId;
        },
        loadEQLogicalId: function () {
            var eqLogicalId = "";
            var cpqEQ = {
                "$name": "GetEqCustomSetting",
            "request": {
                    "recordName": "CPQ EQ Logical ID"
                    }
                };            
            var request = new Sage.SData.Client.SDataServiceOperationRequest(Sage.Data.SDataServiceRegistry.getSDataService('dynamic'))
                .setResourceKind('Integrations')
                .setOperationName('GetEqCustomSetting');
                request.execute(cpqEQ, {
                async:false,
                success: function (result) {
                    eqLogicalId = result.response.Result;
                    localStorage.setItem('eqLogicalId', eqLogicalId);
                },
                failure: function (result) {
                    Sage.UI.Dialogs.showError(result);
                }
            });
        },
        loadEQEnabled: function () {
            var isEQEnabled = "";
            var cpqEQ = {
                "$name": "GetEqCustomSetting",
            "request": {
                    "recordName": "CPQ EQ Enabled"
                   }
                };            
            var request = new Sage.SData.Client.SDataServiceOperationRequest(Sage.Data.SDataServiceRegistry.getSDataService('dynamic'))
                .setResourceKind('Integrations')
                .setOperationName('GetEqCustomSetting');
                request.execute(cpqEQ, {
                async:false,
                success: function (result) {
                    isEQEnabled = result.response.Result;
                    localStorage.setItem('isEQEnabled', isEQEnabled);
                },
                failure: function (result) {
                    Sage.UI.Dialogs.showError(result);
                }
            });           
        },
        isEQEnabled: function () {
            var service = Sage.Services.getService('IntegrationContractService');
            var isEQEnabled=false;
                this.loadEQEnabled();
                
                if(localStorage.getItem('isEQEnabled'))
                {
                    if(localStorage.getItem('isEQEnabled').toLowerCase() == 'true')
                        isEQEnabled=true;
                }
           return service.isCPQIntegrationEnabled && isEQEnabled;
        },
        isMingleEnabled: function () {            
           return mingleConfig.isMingleEnabled;
        },
        showEQForm: function(ViewId,Id){
        var alternateDocumentId  ="";	
        var LogicalId = this.getEQLogicalId();
        var quote = {
            "$name": "GetQuoteAlternateDocumentId",
            "request": {
                    "quoteId": Id
                }
            };
            var request = new Sage.SData.Client.SDataServiceOperationRequest(Sage.Data.SDataServiceRegistry.getSDataService('dynamic'))
            .setResourceKind(Sage.Utility.pluralize(ViewId))
            .setOperationName('GetQuoteAlternateDocumentId');
            request.execute(quote, {
                async:false,
                success: function (result) {
                    alternateDocumentId = result.response.Result;
                },
                failure: function (result) {
                    Sage.UI.Dialogs.showError(result);
                }
            });
            infor.companyon.client.sendPrepareDrillbackMessage('?LogicalId='+LogicalId+'&EntityType='+ViewId+'&Id1='+alternateDocumentId);
        },
        showDetailForm: function(ViewId,Id){
            if(this.isEQEnabled())
            {
                var alternateDocumentId  ="";    
                var LogicalId = this.getEQLogicalId();
                var quote = {
                    "$name": "GetQuoteAlternateDocumentId",
                    "request": {
                    "quoteId": Id
                    }
                };
                var request = new Sage.SData.Client.SDataServiceOperationRequest(Sage.Data.SDataServiceRegistry.getSDataService('dynamic'))
                .setResourceKind(Sage.Utility.pluralize(ViewId))
                .setOperationName('GetQuoteAlternateDocumentId');
                request.execute(quote, {
                    async:false,
                    success: function (result) {
                        alternateDocumentId = result.response.Result;
                    },
                    failure: function (result) {
                        Sage.UI.Dialogs.showError(result);
                    }
                });
                infor.companyon.client.sendPrepareDrillbackMessage('?LogicalId='+LogicalId+'&EntityType='+ViewId+'&Id1='+alternateDocumentId);
            }
            else
            {
                window.document.location = ViewId+'.aspx?entityId='+Id;
            }    
        },
        Timezone_populatelist: function (controlId, autoPostBack) {
            var sel, selectedKeyname;
            if (controlId === 'TimezoneList') {
                sel = dijit.byId(controlId);
                selectedKeyname = dojo.byId(controlId + '_Selected');
            }
            else {
                // Get the widget markup.
                sel = $("#" + controlId + " #TimezoneList")[0];
                // Get the widget from the markup.
                sel = dijit.getEnclosingWidget(sel);
                selectedKeyname = $("#" + controlId).find('input').filter('[@type=hidden]')[0];
            }
            if (sel && typeof sel !== 'undefined' && sel.options.length == 1) {
                sel.options.length = 0;
                var self = this;
                var addTimeZoneItems = function addTimeZoneItems() {
                    var options = [];
                    var sSelectedKey = null;
                    dojo.forEach(self._timeZones, function (tz) {
                        var option = { label: tz.Displayname, value: tz.Keyname, selected: false };
                        options.push(option);
                        if (tz.Keyname == selectedKeyname.value) {
                            sSelectedKey = tz.Keyname;
                            option.selected = true;
                        }
                    });
                    sel.addOption(options);
                    if (sSelectedKey !== null) {
                        sel.set('value', sSelectedKey);
                    }
                    dojo.connect(sel, 'onBlur', function () {
                        selectedKeyname.value = sel.get('value');
                    });
                    dojo.connect(sel, 'onChange', function () {
                        if (autoPostBack) {
                            selectedKeyname.value = sel.get('value');
                            __doPostBack(sel.id, '');
                        }
                    });
                };

                if (this._timeZones !== null) {
                    addTimeZoneItems();
                }
                else {
                    dojo.xhrGet({
                        url: 'slxdata.ashx/slx/crm/-/timezones/p',
                        handleAs: 'json',
                        load: function (list) {
                            self._timeZones = list;
                            addTimeZoneItems();
                        },
                        error: function (error, ioargs) {
                            ErrorHandler.handleHttpError(error, ioargs);
                            return error;
                        }
                    });
                }
            }
            return true;
        },
        getTimeZones: function (callBack) {
            var timeZones = JSON.parse(sessionStorage.getItem("_timeZones"));
            if (timeZones && timeZones.length > 0) {
                callBack(timeZones);
            } else {
                dojo.xhrGet({
                    url: 'slxdata.ashx/slx/crm/-/timezones/p',
                    handleAs: 'json',
                    load: function (list) {
                        sessionStorage.setItem("_timeZones", JSON.stringify(list));
                        callBack(list);
                    },
                    error: function (error, ioargs) {
                        ErrorHandler.handleHttpError(error, ioargs);
                        callBack(false);
                    }
                });
            }
        },

        //@param coll is either an array of strings or a single string
        //@param num is the max length desired for the string(s)
        //return it/them at max length with '...'
        truncate: function (val, num) {
            var i = 0, len = val.length, res = [];
            //num needs to be an int
            if (typeof num === 'string') {
                num = parseInt(num, 10);
            }
            //we might just be truncating a string, not an array of them
            if (typeof val === 'string') {
                //don't slice and append to strings smaller than num
                return val.length > num ? val.slice(0, num) + '...' : val;
            }
            //good browsers will provide higher-order functions (fast)
            if (val.map && typeof val.map === 'function') {
                //map calls the anon func with val[i], i, and val
                return val.map(function (v, i, c) {
                    return v.length > num ? v.slice(0, num) + '...' : v;
                });
            }
            //fallback for IE
            else {
                for (i; i < len; i++) {
                    res.push(val[i].slice(0, num) + '...');
                }
                return res;
            }
        },
        //end truncate
        // parses xml nodes
        parseXMLNode: function (xmlNode, result) {
            var aTags = ['[', ']'], jsonObj = {}, length = -1, i = -1, name = xmlNode.nodeName;
            if (name === "#text" && xmlNode.nodeValue.trim() === "") {
                return;
            }
            var  existing = result[name], children = xmlNode.childNodes, attributes = xmlNode.attributes;
            try {
                if (existing) {
                    if (!dojo.isArray(existing)) {
                        result[name] = [existing, jsonObj];
                    }
                    else {
                        result[name].push(jsonObj);
                    }
                }
                else {
                    if (aTags && aTags.indexOf(name) != -1) {
                        result[name] = [jsonObj];
                    }
                    else {
                        result[name] = jsonObj;
                    }
                }
                if (attributes) {
                    for (i = 0, length = attributes.length; i < length; i++) {
                        var attribute = attributes[i];
                        jsonObj[attribute.nodeName] = attribute.nodeValue;
                    }
                }
                for (i = 0, length = children.length; i < length; i++) {
                    this.parseXMLNode(children[i], jsonObj);
                }
            } catch (e) {
                console.log(e);
            }
            return jsonObj;
        },
        // end parseXMLNode
        // General Dashboard helper functions
        Dashboard: {
            // An incremental counter used by generateString()
            counter: 1,
            /** So that dynamically generated elements can get a
            unique number appended to their name, ie 'wgt1', 'wgt2'...
            @param str a string passed in to which a number will be appended
            */
            generateString: function (str) {
                return str + Sage.Utility.Dashboard.counter++;
            },
            // A function to return an array object
            //populated with the color items in our palette
            //@param num is the number of colors you want back (in an array)
            getColors: function (num) {

                if (!num) { return; }

                var lookupLg = ['blue 6', 'green 3', 'pink 5', 'orange 2', 'blue 4', 'green 6',
                'pink 2', 'orange 7', 'blue 3', 'green 8', 'pink 4', 'orange 3',
                'blue 7', 'green 5', 'pink 8', 'orange 6', 'blue 2', 'green 7',
                'pink 3', 'orange 8', 'blue 5', 'green 2', 'pink 6', 'orange 5',
                'blue 8', 'green 4', 'pink 7', 'orange 4'],

            lookupSm = ['green 5', 'blue 3', 'green 7', 'blue 6',
                'green 3', 'blue 7'],
            ret = [], i, j;

                //the palette for num <= 6 is different than a larger set.
                if (num <= 6) {
                    for (i = 0; i < num; i++) {
                        ret[i] = Sage.Utility.Dashboard.colorPalette[lookupSm[i]];
                    }
                }
                else {
                    for (j = 0; j < num; j++) {
                        ret[j] = Sage.Utility.Dashboard.colorPalette[lookupLg[j]];
                    }
                }
                return ret;
            },
            //looping template functions need to get a single color at a time
            //by passing in an Int
            //@param idx the index passed in by the looping function
            getColor: function (idx) {
                var lookup = ['blue 6', 'green 3', 'pink 5', 'orange 2', 'blue 4', 'green 6',
                'pink 2', 'orange 7', 'blue 3', 'green 8', 'pink 4', 'orange 3',
                'blue 7', 'green 5', 'pink 8', 'orange 6', 'blue 2', 'green 7',
                'pink 3', 'orange 8', 'blue 5', 'green 2', 'pink 6', 'orange 5',
                'blue 8', 'green 4', 'pink 7', 'orange 4'];
                return Sage.Utility.Dashboard.colorPalette[lookup[idx]];
            },
            //Saleslogix colors
            colorPalette: {
                'blue 0': 'dfe8f6', //widget bg color. will not be returned in getColors()
                'blue 6': '00a1de',
                'green 3': 'c1d59f',
                'pink 5': 'a44e81',
                'orange 2': 'f8d6aa',
                'blue 4': '55c0e9',
                'green 6': '69923a',
                'pink 2': 'e2afcd',
                'orange 7': 'af6200',
                'blue 3': '80d0ef',
                'green 8': '35491d',
                'pink 4': 'c55e9b',
                'orange 3': 'f4c180',
                'blue 7': '0079a7',
                'green 5': '86a85c',
                'pink 8': '421f34',
                'orange 6': 'e98300',
                'blue 2': 'aae0f4',
                'green 7': '4f6e2c',
                'pink 3': 'd486b4',
                'orange 8': '754200',
                'blue 5': '2bb1e4',
                'green 2': 'd6e3bf',
                'pink 6': '833f67',
                'orange 5': 'ed982b',
                'blue 8': '00516f',
                'green 4': 'a4bf7d',
                'pink 7': '632f4e',
                'orange 4': 'f0ac55'
            }
        },
        isBoolean: function (value) {
            return typeof value === "boolean";
        },
        isDefined: function (value) {
            return typeof value !== "undefined";
        },
        isEmptyString: function (value) {
            return (dojo.isString(value) && value === "");
        },
        isStringWithLength: function (value) {
            return (dojo.isString(value) && value !== "");
        },
        isTrue: function (value) {
            return (this.isBoolean(value)) ? (value === true) : false;
        },
        getOwnerName: function(secCodeId) {
            if (!secCodeId) {
                return '';
            }
            var trimmed = secCodeId.replace(/^\s+|\s+$/g, '');
            this.buildOwnersCache(null, null, trimmed);
            var owner = this._ownersCache[trimmed];
            return owner ? owner.name : secCodeId;
        },
        buildOwnersCache: function (count, start, trimmedSecCodeId) {
            if (sessionStorage.getItem(this._ownersCacheKey)) {
                this._ownersCache = JSON.parse(sessionStorage.getItem(this._ownersCacheKey));
                return;
            }
            var self = this;
            if (!this._ownersCache) {
                self._ownersCache = {};
            }
            var defaultPageSize = 100;
            count = count || defaultPageSize;
            start = start || 1;
            var defaultUrl = dString.substitute("slxdata.ashx/slx/dynamic/-/owners?select=Type&orderBy=$key&format=json&count=${0}&startIndex=${1}", [count, start]);
            return xhr('GET', {
                url: trimmedSecCodeId ?
                    defaultUrl + "&where=$key eq '"+trimmedSecCodeId+"'" // we should retrieve one owner by passing the corresponding scecodeid instead of retrieving all the owners to avoid the performance issue
                    :defaultUrl,
                handleAs: "json",
                sync: true  // we have to do a sync call here, because the grid column needs to get HTML.
                // but, most of the time this will be cached, so it should not be a big impact.
            }).then(function (data) {
                var totalResults = data.$totalResults;
                for (var i = 0; i < data.$resources.length; i++) {
                    var u = data.$resources[i];
                    self._ownersCache[u.$key.trim()] = {
                        type: u.Type,
                        name: u.$descriptor
                    };
                }
                if (totalResults > defaultPageSize && totalResults >= (start + count)) {
                    start = start + count;
                    self.buildOwnersCache(count, start);
                }
                sessionStorage.setItem(self._ownersCacheKey, JSON.stringify(self._ownersCache));
            });
        },
        getUserName: function (userid) {
            if (!userid) {
                return "";
            }
            var trimmed = userid.replace(/^\s+|\s+$/g, '');
            this.buildUserCache(null, null,trimmed);
            //var trimmed = userid.replace(/^\s+|\s+$/g, '');
            var u = this._userCache[trimmed];
            return u ? u.name : userid;
        },
        buildUserCache: function (count, start, trimmedUserid) {
            if (sessionStorage.getItem(this._userCacheKey)) {
                this._userCache = JSON.parse(sessionStorage.getItem(this._userCacheKey));
				if(this._userCache[trimmedUserid])
                return;
            }
            var self = this;
            if (!this._userCache) {
                self._userCache = {};
            }
            var defaultPageSize = 100;
            count = count || defaultPageSize;
            start = start || 1;
            var defatultUrl = dString.substitute("slxdata.ashx/slx/dynamic/-/users?select=Enabled&format=json&Count=${0}&StartIndex=${1}", [count, start]);
            return xhr('GET', {
                url: trimmedUserid ?
                     defatultUrl + "&where=$key eq '"+trimmedUserid+"'" // we should retrieve one user by passing the corresponding userid instead of retrieving all the users to avoid the performance issue
                    : defatultUrl,
                handleAs: "json",
                sync: true  // we have to do a sync call here, because the grid column needs to get HTML.
                // but, most of the time this will be cached, so it should not be a big impact.
            }).then(function (data) {
                var totalResults = data.$totalResults;
                for (var i = 0; i < data.$resources.length; i++) {
                    var u = data.$resources[i];
                    self._userCache[u.$key] = {
                        enabled: u.Enabled,
                        name: u.$descriptor
                    };
                }
                if (totalResults > defaultPageSize && totalResults >= (start + count)) {
                    start = start + count;
                    self.buildUserCache(count, start);
                }
                sessionStorage.setItem(self._userCacheKey, JSON.stringify(self._userCache));
            });
        },
        isItemInArray: function include(arr, stringVal) {
            for (var i = 0; i < arr.length; i++) {
                if (lang.trim(arr[i]) == lang.trim(stringVal)) return true;
            }
        },
        pluralize: function (stringVal, revert) {//revert is true if your input is plural and output is singler
            if (revert === undefined) {
                revert = false;
            }
            var plural = {
                '(quiz)$': "$1zes",
                '^(ox)$': "$1en",
                '([m|l])ouse$': "$1ice",
                '(matr|vert|ind)ix|ex$': "$1ices",
                '(x|ch|ss|sh)$': "$1es",
                '([^aeiouy]|qu)y$': "$1ies",
                '(hive)$': "$1s",
                '(?:([^f])fe|([lr])f)$': "$1$2ves",
                '(shea|lea|loa|thie)f$': "$1ves",
                'sis$': "ses",
                '([ti])um$': "$1a",
                '(tomat|potat|ech|her|vet)o$': "$1oes",
                '(bu)s$': "$1ses",
                '(alias)$': "$1es",
                '(octop)us$': "$1i",
                '(ax|test)is$': "$1es",
                '(us)$': "$1es",
                '([^s]+)$': "$1s"
            };

            var singular = {
                '(quiz)zes$': "$1",
                '(matr)ices$': "$1ix",
                '(vert|ind)ices$': "$1ex",
                '^(ox)en$': "$1",
                '(alias)es$': "$1",
                '(octop|vir)i$': "$1us",
                '(cris|ax|test)es$': "$1is",
                '(shoe)s$': "$1",
                '(o)es$': "$1",
                '(bus)es$': "$1",
                '([m|l])ice$': "$1ouse",
                '(x|ch|ss|sh)es$': "$1",
                '(m)ovies$': "$1ovie",
                '(s)eries$': "$1eries",
                '([^aeiouy]|qu)ies$': "$1y",
                '([lr])ves$': "$1f",
                '(tive)s$': "$1",
                '(hive)s$': "$1",
                '(li|wi|kni)ves$': "$1fe",
                '(shea|loa|lea|thie)ves$': "$1f",
                '(^analy)ses$': "$1sis",
                '((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$': "$1$2sis",
                '([ti])a$': "$1um",
                '(n)ews$': "$1ews",
                '(h|bl)ouses$': "$1ouse",
                '(corpse)s$': "$1",
                '(us)es$': "$1",
                's$': ""
            };

            var irregular = {
                'move': 'moves',
                'foot': 'feet',
                'goose': 'geese',
                'sex': 'sexes',
                'child': 'children',
                'man': 'men',
                'tooth': 'teeth',
                'person': 'people'
            };

            var uncountable = [
                'sheep',
                'fish',
                'deer',
                'series',
                'species',
                'money',
                'rice',
                'information',
                'equipment'
            ];


            // save some time in the case that singular and plural are the same
            if (uncountable.indexOf(stringVal.toLowerCase()) >= 0)
                return stringVal;
            var pattern, replace, array;
            // check for irregular forms
            for(var word in irregular){

                if(revert){
                    pattern = new RegExp(irregular[word]+'$', 'i');
                    replace = word;
                } else {
                    pattern = new RegExp(word + '$', 'i');
                    replace = irregular[word];
                }
                if (pattern.test(stringVal))
                    return stringVal.replace(pattern, replace);
            }

            if (revert)
                array = singular;
            else
                array = plural;

            // check for matches using regular expressions
            for(var reg in array){

                pattern = new RegExp(reg, 'i');

                if (pattern.test(stringVal))
                    return stringVal.replace(pattern, array[reg]);
            }

            return stringVal;
        },
        getParameterByName: function (name, url) {
            if (!url) url = window.location.href;
            name = name.replace(/[\[\]]/g, "\\$&");
            var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
                results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2].replace(/\+/g, " "));
        },
        specialDates: {
            ':now': function (today) {
                today = new Date();
                return today;
            },
            // today and todaystart are the same
            ':today': function (today) {
                today.setHours(0);
                today.setMinutes(0);
                today.setSeconds(0);
                return today;
            },
            ':todaystart': function (today) {
                today.setHours(0);
                today.setMinutes(0);
                today.setSeconds(0);
                return today;
            },
            ':todayend': function (today) {
                today.setHours(23);
                today.setMinutes(59);
                today.setSeconds(59);
                return today;
            },
            // yesterday and yesterdaystart are the same
            ':yesterday': function (today) {
                today.setDate(today.getDate() - 1);
                today.setHours(0);
                today.setMinutes(0);
                today.setSeconds(0);
                return today;
            },
            ':yesterdaystart': function (today) {
                today.setDate(today.getDate() - 1);
                today.setHours(0);
                today.setMinutes(0);
                today.setSeconds(0);
                return today;
            },
            ':yesterdayend': function (today) {
                today.setDate(today.getDate() - 1);
                today.setHours(23);
                today.setMinutes(59);
                today.setSeconds(59);
                return today;
            },
            // tomorrow and tomorrowstart are the same
            ':tomorrow': function (today) {
                today.setDate(today.getDate() + 1);
                today.setHours(0);
                today.setMinutes(0);
                today.setSeconds(0);
                return today;
            },
            ':tomorrowstart': function (today) {
                today.setDate(today.getDate() + 1);
                today.setHours(0);
                today.setMinutes(0);
                today.setSeconds(0);
                return today;
            },
            ':tomorrowend': function (today) {
                today.setDate(today.getDate() + 1);
                today.setHours(23);
                today.setMinutes(59);
                today.setSeconds(59);
                return today;
            },
            ':thisweekstart': function (today) {
                today.setDate(today.getDate() - today.getDay());
                today.setHours(0);
                today.setMinutes(0);
                today.setSeconds(0);
                return today;
            },
            ':thisweekend': function (today) {
                today.setDate(today.getDate() + (6 - today.getDay()));
                today.setHours(23);
                today.setMinutes(59);
                today.setSeconds(59);
                return today;
            },
            ':thismonthstart': function (today) {
                today.setDate(1);
                today.setHours(0);
                today.setMinutes(0);
                today.setSeconds(0);
                return today;
            },
            ':thismonthend': function (today) {
                today.setDate(dojoDate.getDaysInMonth(today));
                today.setHours(23);
                today.setMinutes(59);
                today.setSeconds(59);
                return today;
            },
            ':thisyearstart': function (today) {
                today.setDate(1);
                today.setMonth(0);
                today.setHours(0);
                today.setMinutes(0);
                today.setSeconds(0);
                return today;
            },
            ':thisyearend': function (today) {
                today.setDate(31);
                today.setMonth(11);
                today.setHours(23);
                today.setMinutes(59);
                today.setSeconds(59);
                return today;
            },
            ':thisquarterstart': function (today) {
                // 1 | jan (0), feb (1), march (2)
                // 2 | april (3), may (4), june (5)
                // 3 | july (6), august (7), sept (8)
                // 4 | oct (9), nov (10), dec (11)
                var month = today.getMonth(),
                    mod = month % 3;
                today.setMonth(month - mod);
                today.setDate(1);
                today.setHours(0);
                today.setMinutes(0);
                today.setSeconds(0);
                return today;
            },
            ':thisquarterend': function (today) {
                var month = today.getMonth(),
                    mod = 2 - (month % 3);
                today.setMonth(month + mod);
                today.setDate(dojoDate.getDaysInMonth(today));
                today.setHours(23);
                today.setMinutes(59);
                today.setSeconds(59);
                return today;
            },
            ':nextweekstart': function (today) {
                today.setDate(today.getDate() + (7 - today.getDay()));
                today.setHours(0);
                today.setMinutes(0);
                today.setSeconds(0);
                return today;
            },
            ':nextweekend': function (today) {
                today.setDate(today.getDate() + (7 - today.getDay()) + 6);
                today.setHours(23);
                today.setMinutes(59);
                today.setSeconds(59);
                return today;
            },
            ':nextmonthstart': function (today) {
                today.setMonth(today.getMonth() + 1);
                today.setDate(1);
                today.setHours(0);
                today.setMinutes(0);
                today.setSeconds(0);
                return today;
            },
            ':nextmonthend': function (today) {
                today.setMonth(today.getMonth() + 1);
                today.setDate(dojoDate.getDaysInMonth(today));
                today.setHours(23);
                today.setMinutes(59);
                today.setSeconds(59);
                return today;
            },
            ':nextyearstart': function (today) {
                today.setFullYear(today.getFullYear() + 1);
                today.setMonth(0);
                today.setDate(1);
                today.setHours(0);
                today.setMinutes(0);
                today.setSeconds(0);
                return today;
            },
            ':nextyearend': function (today) {
                today.setFullYear(today.getFullYear() + 1);
                today.setMonth(11);
                today.setDate(31);
                today.setHours(23);
                today.setMinutes(59);
                today.setSeconds(59);
                return today;
            },
            ':nextquarterstart': function (today) {
                var month = today.getMonth(),
                    mod = 2 - (month % 3);
                today.setMonth(month + mod + 1);
                today.setDate(1);
                today.setHours(0);
                today.setMinutes(0);
                today.setSeconds(0);
                return today;
            },
            ':nextquarterend': function (today) {
                var month = today.getMonth(),
                    mod = 2 - (month % 3);
                today.setMonth(month + mod + 3);
                today.setDate(dojoDate.getDaysInMonth(today));
                today.setHours(23);
                today.setMinutes(59);
                today.setSeconds(59);
                return today;
            },
            ':lastweekstart': function (today) {
                today.setDate(today.getDate() - today.getDay() - 7);
                today.setHours(0);
                today.setMinutes(0);
                today.setSeconds(0);
                return today;
            },
            ':lastweekend': function (today) {
                today.setDate(today.getDate() - today.getDay() - 1);
                today.setHours(23);
                today.setMinutes(59);
                today.setSeconds(59);
                return today;
            },
            ':lastmonthstart': function (today) {
                today.setMonth(today.getMonth() - 1);
                today.setDate(1);
                today.setHours(0);
                today.setMinutes(0);
                today.setSeconds(0);
                return today;
            },
            ':lastmonthend': function (today) {
                today.setMonth(today.getMonth() - 1);
                today.setDate(dojoDate.getDaysInMonth(today));
                today.setHours(23);
                today.setMinutes(59);
                today.setSeconds(59);
                return today;
            },
            ':lastyearstart': function (today) {
                today.setFullYear(today.getFullYear() - 1);
                today.setMonth(0);
                today.setDate(1);
                today.setHours(0);
                today.setMinutes(0);
                today.setSeconds(0);
                return today;
            },
            ':lastyearend': function (today) {
                today.setFullYear(today.getFullYear() - 1);
                today.setMonth(11);
                today.setDate(31);
                today.setHours(23);
                today.setMinutes(59);
                today.setSeconds(59);
                return today;
            },
            ':lastquarterstart': function (today) {
                var month = today.getMonth(),
                    mod = month % 3;
                today.setMonth(month - mod - 3);
                today.setDate(1);
                today.setHours(0);
                today.setMinutes(0);
                today.setSeconds(0);
                return today;
            },
            ':lastquarterend': function (today) {
                var month = today.getMonth(),
                    mod = month % 3;
                today.setMonth(month - mod - 1);
                today.setDate(dojoDate.getDaysInMonth(today));
                today.setHours(23);
                today.setMinutes(59);
                today.setSeconds(59);
                return today;
            },
            ':beforelastyearend': function (today) {
                today.setFullYear(today.getFullYear() - 2);
                today.setMonth(0);
                today.setDate(1);
                today.setHours(0);
                today.setMinutes(0);
                today.setSeconds(0);
                return today;
            }
         },
        /**
        * @param {item} dataItem
        * @param {fieldProperty} field property
        * Return string value of dot notated field
        *
        */
        splitField: function (item, fieldProperty) {
            var sp = fieldProperty.split(".");
            var field = item;
            for (var i = 0; i < sp.length; i++) {
                if (field === null) {
                    return '';
                }
                field = field[sp[i]];
            }
            return field;
        },
        /**
        * @param {item} dataItem
        * @param {fieldProperty} field property
        * @param {value} value to be set
        *
        */
        setField: function (item, fieldProperty, value) {
            var sp = fieldProperty.split(".");
            var field = item;
            for (var i = 0; i < sp.length - 1; i++) {
                if (field.hasOwnProperty(sp[i])) {
                    field = field[sp[i]];
                }
            }
            if (field) {
                field[sp[sp.length - 1]] = value;
            }
        },
        dynamicSort: function dynamicSort(property, sortOrder) {
            // 1 for ascending
            sortOrder = sortOrder === true ? 0 : 1;

            return function (a,b) {
                var result = (Sage.Utility.splitField(a, property) < Sage.Utility.splitField(b, property))
                    ? -1
                    : (Sage.Utility.splitField(a, property) > Sage.Utility.splitField(b, property))
                        ? 1
                        : 0;
                return result * sortOrder;
            };
        }
    }); //end dojo.mixin

    // Ajax/Dojo Patch.  Notifies dojo to reparse partial postback content.
    ready(function () {
        Sage.Utility.appLoadHandler();
    });

    return Sage.Utility;
});

},
'Sage/Data/SDataServiceRegistry':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define, sessionStorage */
define(['Sage/Utility', 'dojo/json'],
function (utility, json) {
    var _services = {},
    _defaultService = false;

    Sage.namespace('Data.SDataServiceRegistry');
    Sage.Data.SDataServiceRegistry = {
        registerService: function (name, s, o) {
            o = o || {};
            var service = s instanceof Sage.SData.Client.SDataService ?
                s : new Sage.SData.Client.SDataService(s);

            _services[name] = service;

            if (o.isDefault || !_defaultService) {
                _defaultService = service;
            }
            return service;
        },
        hasService: function (name) {
            return (typeof _services[name] !== 'undefined');
        },
        getService: function (name) {
            if (typeof name === 'string' && _services[name]) {
                return _services[name];
            }
            return _defaultService;
        },
        _createCacheKey: function (request) {
            var key = request.build();
            key = key.replace(/[^a-zA-Z0-9_]/g, '');
            var ns = request.getResourceKind().text;
            key = ns + "_" + key;
            return key;
        },
        _loadSDataRequest: function (request, o) {
            var key = this._createCacheKey(request);
            var feed = this._getFromLocalStorage(key);
            if (feed) {
                o.result = feed;
            }
        },
        _cacheSDataRequest: function (request, o, feed) {
            /* todo: decide how to handle PUT/POST/DELETE */
            if (/get/i.test(o.method) && typeof feed === 'object') {
                var key = this._createCacheKey(request);
                this._saveToLocalStorage(key, feed);
            }
        },
        _saveToLocalStorage: function (key, value) {
            sessionStorage.setItem(key, json.stringify(value));
        },
        _getFromLocalStorage: function (key) {
            return json.parse(sessionStorage.getItem(key));
        },
        _removeFromLocalStorage: function (resourceKind) {
            var keysCount = sessionStorage.length;
            var keys = [];
            for (var i = 0; i < keysCount; i++) {
                var key = sessionStorage.key(i);
                if (key.indexOf(resourceKind) > -1) {
                    keys.push(key);
                }
            }
            for (var j = 0; j < keys.length; j++) {
                sessionStorage.removeItem(keys[j]);
            }
        },
        getSDataService: function (contract, keepUnique, useJson, cacheResult, compactMode) {
            // Returns the instance of the service for the specific contract requested.
            // For example, if the data source needs an SData service for the dynamic or system feeds,
            // the code would pass 'dynamic' or 'system' to this method.
            // Proxy datastore needs to always keep it's own unique instance of the service.
            // cacheResult uses a service with overridden beforerequest and requestcomplete methods
            keepUnique = contract === 'proxy' ? true : keepUnique;
            contract = contract || 'dynamic';
            var svcKey = "SDataService_" + contract;
            //Create a SDataService that caches its results
            svcKey = cacheResult ? [svcKey, '_cacheResult'].join('') : svcKey;

            if (this.hasService(svcKey) && !keepUnique) {
                return this.getService(svcKey);
            }

            var bJson = true;
            if (typeof useJson === 'boolean') {
                bJson = useJson;
            }
            var compact = true;
            if (typeof compactMode === 'boolean') {
                compact = compactMode;
            }

            var svc = new Sage.SData.Client.SDataService({
                serverName: window.location.hostname,
                virtualDirectory: Sage.Utility.getVirtualDirectoryName() + '/slxdata.ashx',
                applicationName: 'slx',
                contractName: contract,
                port: window.location.port && window.location.port !== 80 ? window.location.port : false,
                protocol: /https/i.test(window.location.protocol) ? 'https' : false,
                json: bJson,
                compact: compact
            });

            if (cacheResult) {
                svc.on('beforerequest', this._loadSDataRequest, this);
                svc.on('requestcomplete', this._cacheSDataRequest, this);
            }

            if (!keepUnique) {
                this.registerService(svcKey, svc);
            }
            return svc;
        }
    };
    return Sage.Data.SDataServiceRegistry;
});
/*
 *Usage:
(function() {
     var virdir = function() {
        var match = /^\/([^\/]+)\//.exec(location.pathname);               
        return match ? match[1] : '';
    }; 
    
     Sage.Data.SDataServiceRegistry.registerService('dynamic', {
           serverName: window.location.hostname,
           virtualDirectory: virdir() + '/slxdata.ashx',
           applicationName: 'slx',
           contractName: 'dynamic',
           port: window.location.port && window.location.port != 80 ? window.location.port : false,
           protocol: /https/i.test(window.location.protocol) ? 'https' : false
     }, { isDefault: true});
    
     Sage.Data.SDataServiceRegistry.registerService('system', {
           serverName: window.location.hostname,
           virtualDirectory: virdir() + '/slxdata.ashx',
           applicationName: 'slx',
           contractName: 'system',
           port: window.location.port && window.location.port != 80 ? window.location.port : false,
           protocol: /https/i.test(window.location.protocol) ? 'https' : false
     }); 
})();
 
*in code 
returns the 'dynamic' service since it's the default 
Sage.Data.SDataServiceRegistry.getService();
 
*returns the 'system' service since it was explicitly selected 
Sage.Data.SDataServiceRegistry.getService('system');
 
*returns the 'dynamic' service since it was explicitly selected 
Sage.Data.SDataServiceRegistry.getService('dynamic');
 
*in customizations, 3rd party developers could register their own services 
Sage.Data.SDataServiceRegistry.registerService('sage50', {
     serverName: 'ec2-67-202-57-59.compute-1.amazonaws.com',
     virtualDirectory: 'sage50',
     applicationName: 'accounts50',
     contractName: 'gcrm',
     port: 80,
     protocol: /https/i.test(window.location.protocol) ? 'https' : false,
     userName: 'manager',
     password: '',
     version: { major: 0, minor: 9 }
}); 
 
*and use them* 
Sage.Data.SDataServiceRegistry.getService('sage50');
 
*this is probably best used with a mixin* 
define(['Sage.Data.SDataServiceRegistry', 'dojo/_base/declare'], 
function(sDataServiceRegistry, declare) {
     var _sDataServiceAware = declare('Sage.UI._SDataServiceAware', null, {
           serviceName: false,
           getService: function() {
                sDataServiceRegistry.getService(this.serviceName)
           }
     });
     return _sDataServiceAware;
});
 
any widget that mixes in that class can specify a 'serviceName' property as 
part of their prototype, or in their constructor, or passed in via constructor 
options, or even assigned later on.  if no name is specified, it just gets the default service, if one was registered    
*/

},
'Sage/UI/Dialogs':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dijit/form/Button',
    'dijit/Dialog',
    'dijit/ProgressBar',
    'dijit/form/TextBox',
    'dijit/form/ValidationTextBox',
    'dojo/i18n!./nls/Dialogs',
    'dojo/_base/array'
],
function (Button, Dialog, ProgressBar, TextBox, ValidationTextBox, nlsResources, array) {
    Sage.namespace('UI.Dialogs');
    dojo.mixin(Sage.UI.Dialogs, {
        raiseQueryDialog: function (title, query, callbackFn, yesText, noText, messageIcon) {
            //ToDo:  add icon: <question>
            return this.raiseQueryDialogExt({ title: title, query: query, callbackFn: callbackFn, yesText: yesText, noText: noText, icon: messageIcon });
        },
        raiseQueryDialogExt: function (opts) {
            var dlg = dijit.byId('queryDialog'),
                iWidth,
                queryDialog,
                commonCallback,
                questionDivs,
                i,
                buttonDiv,
                yesButton,
                noButton;

            if (dlg) {
                dlg.destroyRecursive();
            }

            iWidth = (opts && typeof opts.width === 'number') ? opts.width : 700;
            queryDialog = new dijit.Dialog({ id: 'queryDialog', title: opts.title, style: opts.style || { 'width': iWidth} });
            // When either button is pressed, kill the dialog and call the callbackFn.
            commonCallback = function (result) {
                queryDialog.hide();
                if (!opts.callbackFn || typeof opts.callbackFn !== 'function') {
                    return;
                }

                if (result) { //Yes was clicked
                    opts.callbackFn.call(opts.scope || this, true);
                } else {
                    opts.callbackFn.call(opts.scope || this, false);
                }
            };

            queryDialog.on('hide', function () {
                queryDialog.destroyRecursive();
            });


            if (opts.icon) {
                var iconDiv = new dojo.create('div', { id: 'queryDialog-iconDiv', 'class': 'messageIcon ' + opts.icon });
                queryDialog.containerNode.appendChild(iconDiv);
            }

            questionDivs = [];

            if (opts.query instanceof Array) {
                for (i = 0; i < opts.query.length; i++) {
                    questionDivs.push(dojo.create('div', { id: 'queryDialog-questionDiv_' + i, innerHTML: opts.query[i] }));
                }
            }
            else {
                var div = dojo.create('div', { id: 'queryDialog-questionDiv', innerHTML: opts.query });

                // Check for scripts contained in opts.query; scripts will not work in div.innerHTML, so process them so they will work.                
                var arrScripts = div.getElementsByTagName('script');
                array.forEach(arrScripts, function (script) {
                    var src = script.getAttribute('src');
                    if (src === null && script.innerHTML !== '') {
                        // Script should be in the form window.someFunction = function() {};
                        eval(script.innerHTML);
                    }
                    else if (src !== null && script.innerHTML === '') {
                        var head = document.getElementsByTagName('head')[0];
                        // Must be cloned; otherwise, div.removeChild(script) will fail.
                        var clone = dojo.clone(script);
                        (head || document.body).appendChild(clone);
                    }
                    else {
                        if (typeof console !== 'undefined') {
                            console.warn('Unable to process script in Sage.UI.Dialogs.');
                        }
                    }
                    div.removeChild(script);
                });
                questionDivs.push(div);
            }

            buttonDiv = new dojo.create("div", { id: 'queryDialog-buttonDiv', style: "text-align: " + (opts.align || "center") + "; margin-top: 10px" });

            yesButton = new dijit.form.Button({
                label: opts.yesText || nlsResources.yesText,
                id: 'qry_yesButton',
                onClick: function (result) { commonCallback(true); }
            });

            buttonDiv.appendChild(yesButton.domNode);
            if ((opts.noText) || (opts.showNoButton)) {
                noButton = new dijit.form.Button({
                    label: opts.noText || nlsResources.noText,
                    id: 'qry_noButton',
                    style: 'padding-left: 10px',
                    onClick: function (result) { commonCallback(false); }
                });
                buttonDiv.appendChild(noButton.domNode);
            }

            dojo.forEach(questionDivs, function (questionDiv) {
                queryDialog.containerNode.appendChild(questionDiv);
            });

            queryDialog.containerNode.appendChild(buttonDiv);
            queryDialog.show();
        },
        raiseInputDialog: function (title, query, callbackFn, yesText, noText, defaultValue, regExp, invalidMessage) {
            return this.raiseInputDialogExt(
                {
                    title: title,
                    query: query,
                    callbackFn: callbackFn,
                    yesText: yesText,
                    noText: noText,
                    defaultValue: defaultValue,
                    regExp: regExp,
                    invalidMessage: invalidMessage
                });
        },
        raiseInputDialogExt: function (opts) {
            //ToDo: implement the icon property from opts...
            var inputDialog, questionDiv, inputBox, commonCallback, yesButton, noButton, buttonDiv;
            
            inputDialog = dijit.byId('inputDialog');
            if (inputDialog) {
                inputDialog.destroyRecursive();
            }
            
            inputDialog = new dijit.Dialog({ id: 'inputDialog', title: opts.title });
            questionDiv = dojo.create('div', { id: 'inputDialog-questionDiv', innerHTML: opts.query });
            inputBox = (opts.regExp && dojo.isString(opts.regExp)) ?
                new dijit.form.ValidationTextBox({
                    id: 'inputDialog-inputBox',
                    value: opts.defaultValue || '',
                    style: 'margin-top: 8px',
                    regExp: opts.regExp || '',
                    invalidMessage: opts.invalidMessage || ''
                })
                : new dijit.form.TextBox({
                    id: 'inputDialog-inputBox',
                    value: opts.defaultValue || '',
                    style: 'margin-top: 8px'
                });
            commonCallback = function (result) {
                if (result) {
                    opts.callbackFn(true, inputBox.get('value'));
                } else {
                    opts.callbackFn(false, inputBox.get('value'));
                }
                inputDialog.hide();
            };
            yesButton = new dijit.form.Button({
                label: opts.yesText || nlsResources.yesText,
                id: 'inp_yesButton',
                onClick: function (result) { commonCallback(true); }
            });
            noButton = new dijit.form.Button({
                label: opts.noText || nlsResources.noText,
                id: 'inp_noButton',
                onClick: function (result) { commonCallback(false); }
            });
            buttonDiv = new dojo.create("div", { id: 'inputDialog-buttonDiv' });

            inputDialog.on('hide', function () {
                inputDialog.destroyRecursive();
            });

            buttonDiv.appendChild(yesButton.domNode);
            buttonDiv.appendChild(noButton.domNode);

            inputDialog.containerNode.appendChild(questionDiv);
            inputDialog.containerNode.appendChild(inputBox.domNode);
            inputDialog.containerNode.appendChild(buttonDiv);

            if (opts.closable === false) {
                dojo.destroy(inputDialog.closeButtonNode);
            }

            inputDialog.show();
        },
        showProgressBar: function (opts) {
            var iMax = (opts && typeof opts.maximum !== "undefined") ? opts.maximum : 100,
                prog,
                iWidth = (opts && typeof opts.width === 'number') ? opts.width : 300,
                iHeight = (opts && typeof opts.width === 'number') ? opts.height : 125,
                sStyle = dojo.string.substitute('width: ${0}px; height: ${1}px', [iWidth, iHeight]),
                bCanClose = (opts && typeof opts.canclose === 'boolean') ? opts.canclose : true,
                progressDialog,
                sMsg,
                msgDiv,
                bar,
                msg;

            if (!dijit.byId('progressDialog')) {
                prog = new dijit.ProgressBar({
                    id: 'progressDialogBar',
                    style: 'margin-top: 10px; margin-bottom: 10px',
                    indeterminate: (opts && opts.indeterminate !== "undefined") ? opts.indeterminate : false,
                    maximum: iMax
                });
                progressDialog = new dijit.Dialog({ id: 'progressDialog', title: opts.title, style: sStyle, closable: bCanClose });
                if (opts && typeof opts.showmessage === 'boolean' && opts.showmessage) {
                    sMsg = (opts && typeof opts.message === 'string') ? opts.message : "";
                    msgDiv = new dojo.create('div', { innerHTML: sMsg, style: 'text-align: left; margin-top: 10px; margin-bottom: 10px', id: 'progressDialogMessage' });
                    progressDialog.containerNode.appendChild(msgDiv);
                }

                progressDialog.containerNode.appendChild(prog.domNode);
                progressDialog.show();
            }

            bar = dijit.byId('progressDialogBar');
            bar.update({ progress: opts.pct, title: opts.title });
            if (opts && typeof opts.showmessage === 'boolean' && opts.showmessage && typeof opts.message === 'string') {
                msg = dojo.byId('progressDialogMessage');
                if (msg) {
                    msg.innerHTML = opts.message;
                }
            }
        },
        closeProgressBar: function (opts) {
            var dlg = dijit.byId("progressDialog");
            if (dlg) {
                dlg.hide();
                dlg.destroyRecursive();
            }
        },
        alert: function (msg, title, icon) {
            var opts = {
                title: title || 'Infor CRM',   //  ToDo:  Localize   <---<<<   <---<<<   <---<<<
                query: msg,
                callbackFn: false,
                yesText: nlsResources.okText || 'OK',
                noText: false,
                scope: window,
                icon: icon || 'noIcon',
                style: { width: '700px' }
            };
            Sage.UI.Dialogs.raiseQueryDialogExt(opts);
        },
        showInfo: function (msg, title) {
            this.alert(msg, title, 'infoIcon');
        },
        showWarning: function (msg, title) {
            this.alert(msg, title, 'warningIcon');
        },
        showError: function (msg, title) {
            this.alert(msg, title, 'errorIcon');
        }
    });

    //Backward compatability - marked as deprecated
    Sage.WebClientMessageService = function (options) {

    };
    Sage.WebClientMessageService.prototype.hideClientMessage = function () {
        //Ext.Msg.hide();
        if (typeof console !== 'undefined') {
            console.warn(['DEPRECATED: The WebClientMessageService is deprecated.  (hideClientMessage)',
                'Use Sage.UI.Dialogs instead.'].join('\n'));
        }
    };
    Sage.WebClientMessageService.prototype.showClientMessage = function (title, msg, fn, scope) {
        if (typeof console !== 'undefined') {
            console.warn(['DEPRECATED: The WebClientMessageService is deprecated.  ',
                'Use Sage.UI.Dialogs instead.',
                'Change code like:',
                'var svc = Sage.Services.getService("WebClientMessageService");',
                'if (svc) {',
                '    Sage.UserOptionsService.showClientMessage(<title>, <msg>, <callback>, <scope>);',
                '}',
                'to this: ',
                'Sage.UI.Dialogs.raiseQueryDialog(<title>, <msg>, <callback>, <yesText>, <noText>);'
                ].join('\n'));
        }
        if (typeof title === 'object') {
            Sage.UI.Dialog.raiseQueryDialogEx(title);
        }
        var o = {
            title: (typeof msg === "string") ? title : '',
            query: (typeof msg === "string") ? msg : title,
            callbackFn: fn,
            yesText: nlsResources.yesText || 'Yes',
            noText: nlsResources.noText || 'No',
            scope: scope
        };
        Sage.UI.Dialogs.raiseQueryDialogExt(o);
    };
    Sage.Services.addService("WebClientMessageService", new Sage.WebClientMessageService());

    return Sage.UI.Dialogs;
});

},
'dijit/form/Button':function(){
define([
	"require",
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.toggle
	"dojo/has", // has("dijit-legacy-requires")
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.trim
	"dojo/ready",
	"./_FormWidget",
	"./_ButtonMixin",
	"dojo/text!./templates/Button.html",
	"../a11yclick"	// template uses ondijitclick
], function(require, declare, domClass, has, kernel, lang, ready, _FormWidget, _ButtonMixin, template){

	// module:
	//		dijit/form/Button

	// Back compat w/1.6, remove for 2.0
	if(has("dijit-legacy-requires")){
		ready(0, function(){
			var requires = ["dijit/form/DropDownButton", "dijit/form/ComboButton", "dijit/form/ToggleButton"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	var Button = declare("dijit.form.Button" + (has("dojo-bidi") ? "_NoBidi" : ""), [_FormWidget, _ButtonMixin], {
		// summary:
		//		Basically the same thing as a normal HTML button, but with special styling.
		// description:
		//		Buttons can display a label, an icon, or both.
		//		A label should always be specified (through innerHTML) or the label
		//		attribute.  It can be hidden via showLabel=false.
		// example:
		// |	<button data-dojo-type="dijit/form/Button" onClick="...">Hello world</button>
		//
		// example:
		// |	var button1 = new Button({label: "hello world", onClick: foo});
		// |	dojo.body().appendChild(button1.domNode);

		// showLabel: Boolean
		//		Set this to true to hide the label text and display only the icon.
		//		(If showLabel=false then iconClass must be specified.)
		//		Especially useful for toolbars.
		//		If showLabel=true, the label will become the title (a.k.a. tooltip/hint) of the icon.
		//
		//		The exception case is for computers in high-contrast mode, where the label
		//		will still be displayed, since the icon doesn't appear.
		showLabel: true,

		// iconClass: String
		//		Class to apply to DOMNode in button to make it display an icon
		iconClass: "dijitNoIcon",
		_setIconClassAttr: { node: "iconNode", type: "class" },

		baseClass: "dijitButton",

		templateString: template,

		// Map widget attributes to DOMNode attributes.
		_setValueAttr: "valueNode",
		_setNameAttr: function(name){
			// avoid breaking existing subclasses where valueNode undefined.  Perhaps in 2.0 require it to be defined?
			if(this.valueNode){
				this.valueNode.setAttribute("name", name);
			}
		},

		_fillContent: function(/*DomNode*/ source){
			// Overrides _Templated._fillContent().
			// If button label is specified as srcNodeRef.innerHTML rather than
			// this.params.label, handle it here.
			// TODO: remove the method in 2.0, parser will do it all for me
			if(source && (!this.params || !("label" in this.params))){
				var sourceLabel = lang.trim(source.innerHTML);
				if(sourceLabel){
					this.label = sourceLabel; // _applyAttributes will be called after buildRendering completes to update the DOM
				}
			}
		},

		_setShowLabelAttr: function(val){
			if(this.containerNode){
				domClass.toggle(this.containerNode, "dijitDisplayNone", !val);
			}
			this._set("showLabel", val);
		},

		setLabel: function(/*String*/ content){
			// summary:
			//		Deprecated.  Use set('label', ...) instead.
			kernel.deprecated("dijit.form.Button.setLabel() is deprecated.  Use set('label', ...) instead.", "", "2.0");
			this.set("label", content);
		},

		_setLabelAttr: function(/*String*/ content){
			// summary:
			//		Hook for set('label', ...) to work.
			// description:
			//		Set the label (text) of the button; takes an HTML string.
			//		If the label is hidden (showLabel=false) then and no title has
			//		been specified, then label is also set as title attribute of icon.
			this.inherited(arguments);
			if(!this.showLabel && !("title" in this.params)){
				this.titleNode.title = lang.trim(this.containerNode.innerText || this.containerNode.textContent || '');
			}
		}
	});

	if(has("dojo-bidi")){
		Button = declare("dijit.form.Button", Button, {
			_setLabelAttr: function(/*String*/ content){
				this.inherited(arguments);
				if(this.titleNode.title){
					this.applyTextDir(this.titleNode, this.titleNode.title);
				}
			},

			_setTextDirAttr: function(/*String*/ textDir){
				if(this._created && this.textDir != textDir){
					this._set("textDir", textDir);
					this._setLabelAttr(this.label); // call applyTextDir on both focusNode and titleNode
				}
			}
		});
	}

	return Button;
});

},
'dijit/form/_FormWidget':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/sniff", // has("dijit-legacy-requires"), has("msapp")
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/ready",
	"../_Widget",
	"../_CssStateMixin",
	"../_TemplatedMixin",
	"./_FormWidgetMixin"
], function(declare, has, kernel, ready, _Widget, _CssStateMixin, _TemplatedMixin, _FormWidgetMixin){

	// module:
	//		dijit/form/_FormWidget

	// Back compat w/1.6, remove for 2.0
	if(has("dijit-legacy-requires")){
		ready(0, function(){
			var requires = ["dijit/form/_FormValueWidget"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	return declare("dijit.form._FormWidget", [_Widget, _TemplatedMixin, _CssStateMixin, _FormWidgetMixin], {
		// summary:
		//		Base class for widgets corresponding to native HTML elements such as `<checkbox>` or `<button>`,
		//		which can be children of a `<form>` node or a `dijit/form/Form` widget.
		//
		// description:
		//		Represents a single HTML element.
		//		All these widgets should have these attributes just like native HTML input elements.
		//		You can set them during widget construction or afterwards, via `dijit/_WidgetBase.set()`.
		//
		//		They also share some common methods.

		setDisabled: function(/*Boolean*/ disabled){
			// summary:
			//		Deprecated.  Use set('disabled', ...) instead.
			kernel.deprecated("setDisabled(" + disabled + ") is deprecated. Use set('disabled'," + disabled + ") instead.", "", "2.0");
			this.set('disabled', disabled);
		},

		setValue: function(/*String*/ value){
			// summary:
			//		Deprecated.  Use set('value', ...) instead.
			kernel.deprecated("dijit.form._FormWidget:setValue(" + value + ") is deprecated.  Use set('value'," + value + ") instead.", "", "2.0");
			this.set('value', value);
		},

		getValue: function(){
			// summary:
			//		Deprecated.  Use get('value') instead.
			kernel.deprecated(this.declaredClass + "::getValue() is deprecated. Use get('value') instead.", "", "2.0");
			return this.get('value');
		},

		postMixInProperties: function(){
			// Setup name=foo string to be referenced from the template (but only if a name has been specified).
			// Unfortunately we can't use _setNameAttr to set the name in IE due to IE limitations, see #8484, #8660.
			// But when IE6 and IE7 are desupported, then we probably don't need this anymore, so should remove it in 2.0.
			// Also, don't do this for Windows 8 Store Apps because it causes a security exception (see #16452).
			// Regarding escaping, see heading "Attribute values" in
			// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
			this.nameAttrSetting = (this.name && !has("msapp")) ? ('name="' + this.name.replace(/"/g, "&quot;") + '"') : '';
			this.inherited(arguments);
		}
	});
});

},
'dijit/_Widget':function(){
define([
	"dojo/aspect",	// aspect.around
	"dojo/_base/config",	// config.isDebug
	"dojo/_base/connect",	// connect.connect
	"dojo/_base/declare", // declare
	"dojo/has",
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.hitch
	"dojo/query",
	"dojo/ready",
	"./registry",	// registry.byNode
	"./_WidgetBase",
	"./_OnDijitClickMixin",
	"./_FocusMixin",
	"dojo/uacss",		// browser sniffing (included for back-compat; subclasses may be using)
	"./hccss"		// high contrast mode sniffing (included to set CSS classes on <body>, module ret value unused)
], function(aspect, config, connect, declare, has, kernel, lang, query, ready,
			registry, _WidgetBase, _OnDijitClickMixin, _FocusMixin){


// module:
//		dijit/_Widget


function connectToDomNode(){
	// summary:
	//		If user connects to a widget method === this function, then they will
	//		instead actually be connecting the equivalent event on this.domNode
}

// Trap dojo.connect() calls to connectToDomNode methods, and redirect to _Widget.on()
function aroundAdvice(originalConnect){
	return function(obj, event, scope, method){
		if(obj && typeof event == "string" && obj[event] == connectToDomNode){
			return obj.on(event.substring(2).toLowerCase(), lang.hitch(scope, method));
		}
		return originalConnect.apply(connect, arguments);
	};
}
aspect.around(connect, "connect", aroundAdvice);
if(kernel.connect){
	aspect.around(kernel, "connect", aroundAdvice);
}

var _Widget = declare("dijit._Widget", [_WidgetBase, _OnDijitClickMixin, _FocusMixin], {
	// summary:
	//		Old base class for widgets.   New widgets should extend `dijit/_WidgetBase` instead
	// description:
	//		Old Base class for Dijit widgets.
	//
	//		Extends _WidgetBase, adding support for:
	//
	//		- declaratively/programatically specifying widget initialization parameters like
	//			onMouseMove="foo" that call foo when this.domNode gets a mousemove event
	//		- ondijitclick:
	//			Support new data-dojo-attach-event="ondijitclick: ..." that is triggered by a mouse click or a SPACE/ENTER keypress
	//		- focus related functions:
	//			In particular, the onFocus()/onBlur() callbacks.   Driven internally by
	//			dijit/_base/focus.js.
	//		- deprecated methods
	//		- onShow(), onHide(), onClose()
	//
	//		Also, by loading code in dijit/_base, turns on:
	//
	//		- browser sniffing (putting browser class like `dj_ie` on `<html>` node)
	//		- high contrast mode sniffing (add `dijit_a11y` class to `<body>` if machine is in high contrast mode)


	////////////////// DEFERRED CONNECTS ///////////////////

	onClick: connectToDomNode,
	/*=====
	onClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onDblClick: connectToDomNode,
	/*=====
	onDblClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse double click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onKeyDown: connectToDomNode,
	/*=====
	onKeyDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being pressed down.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyPress: connectToDomNode,
	/*=====
	onKeyPress: function(event){
		// summary:
		//		Connect to this function to receive notifications of printable keys being typed.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyUp: connectToDomNode,
	/*=====
	onKeyUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being released.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onMouseDown: connectToDomNode,
	/*=====
	onMouseDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is pressed down.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseMove: connectToDomNode,
	/*=====
	onMouseMove: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOut: connectToDomNode,
	/*=====
	onMouseOut: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOver: connectToDomNode,
	/*=====
	onMouseOver: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseLeave: connectToDomNode,
	/*=====
	onMouseLeave: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseEnter: connectToDomNode,
	/*=====
	onMouseEnter: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseUp: connectToDomNode,
	/*=====
	onMouseUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is released.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/

	constructor: function(params /*===== ,srcNodeRef =====*/){
		// summary:
		//		Create the widget.
		// params: Object|null
		//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
		//		and functions, typically callbacks like onClick.
		//		The hash can contain any of the widget's properties, excluding read-only properties.
		// srcNodeRef: DOMNode|String?
		//		If a srcNodeRef (DOM node) is specified:
		//
		//		- use srcNodeRef.innerHTML as my contents
		//		- if this is a behavioral widget then apply behavior to that srcNodeRef
		//		- otherwise, replace srcNodeRef with my generated DOM tree

		// extract parameters like onMouseMove that should connect directly to this.domNode
		this._toConnect = {};
		for(var name in params){
			if(this[name] === connectToDomNode){
				this._toConnect[name.replace(/^on/, "").toLowerCase()] = params[name];
				delete params[name];
			}
		}
	},

	postCreate: function(){
		this.inherited(arguments);

		// perform connection from this.domNode to user specified handlers (ex: onMouseMove)
		for(var name in this._toConnect){
			this.on(name, this._toConnect[name]);
		}
		delete this._toConnect;
	},

	on: function(/*String|Function*/ type, /*Function*/ func){
		if(this[this._onMap(type)] === connectToDomNode){
			// Use connect.connect() rather than on() to get handling for "onmouseenter" on non-IE,
			// normalization of onkeypress/onkeydown to behave like firefox, etc.
			// Also, need to specify context as "this" rather than the default context of the DOMNode
			// Remove in 2.0.
			return connect.connect(this.domNode, type.toLowerCase(), this, func);
		}
		return this.inherited(arguments);
	},

	_setFocusedAttr: function(val){
		// Remove this method in 2.0 (or sooner), just here to set _focused == focused, for back compat
		// (but since it's a private variable we aren't required to keep supporting it).
		this._focused = val;
		this._set("focused", val);
	},

	////////////////// DEPRECATED METHODS ///////////////////

	setAttribute: function(/*String*/ attr, /*anything*/ value){
		// summary:
		//		Deprecated.  Use set() instead.
		// tags:
		//		deprecated
		kernel.deprecated(this.declaredClass+"::setAttribute(attr, value) is deprecated. Use set() instead.", "", "2.0");
		this.set(attr, value);
	},

	attr: function(/*String|Object*/name, /*Object?*/value){
		// summary:
		//		This method is deprecated, use get() or set() directly.
		// name:
		//		The property to get or set. If an object is passed here and not
		//		a string, its keys are used as names of attributes to be set
		//		and the value of the object as values to set in the widget.
		// value:
		//		Optional. If provided, attr() operates as a setter. If omitted,
		//		the current value of the named property is returned.
		// tags:
		//		deprecated

		var args = arguments.length;
		if(args >= 2 || typeof name === "object"){ // setter
			return this.set.apply(this, arguments);
		}else{ // getter
			return this.get(name);
		}
	},

	getDescendants: function(){
		// summary:
		//		Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
		//		This method should generally be avoided as it returns widgets declared in templates, which are
		//		supposed to be internal/hidden, but it's left here for back-compat reasons.

		kernel.deprecated(this.declaredClass+"::getDescendants() is deprecated. Use getChildren() instead.", "", "2.0");
		return this.containerNode ? query('[widgetId]', this.containerNode).map(registry.byNode) : []; // dijit/_WidgetBase[]
	},

	////////////////// MISCELLANEOUS METHODS ///////////////////

	_onShow: function(){
		// summary:
		//		Internal method called when this widget is made visible.
		//		See `onShow` for details.
		this.onShow();
	},

	onShow: function(){
		// summary:
		//		Called when this widget becomes the selected pane in a
		//		`dijit/layout/TabContainer`, `dijit/layout/StackContainer`,
		//		`dijit/layout/AccordionContainer`, etc.
		//
		//		Also called to indicate display of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
		// tags:
		//		callback
	},

	onHide: function(){
		// summary:
		//		Called when another widget becomes the selected pane in a
		//		`dijit/layout/TabContainer`, `dijit/layout/StackContainer`,
		//		`dijit/layout/AccordionContainer`, etc.
		//
		//		Also called to indicate hide of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
		// tags:
		//		callback
	},

	onClose: function(){
		// summary:
		//		Called when this widget is being displayed as a popup (ex: a Calendar popped
		//		up from a DateTextBox), and it is hidden.
		//		This is called from the dijit.popup code, and should not be called directly.
		//
		//		Also used as a parameter for children of `dijit/layout/StackContainer` or subclasses.
		//		Callback if a user tries to close the child.   Child will be closed if this function returns true.
		// tags:
		//		extension

		return true;		// Boolean
	}
});

// For back-compat, remove in 2.0.
if(has("dijit-legacy-requires")){
	ready(0, function(){
		var requires = ["dijit/_base"];
		require(requires);	// use indirection so modules not rolled into a build
	});
}
return _Widget;
});

},
'dijit/registry':function(){
define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/window", // win.body
	"./main"	// dijit._scopeName
], function(array, win, dijit){

	// module:
	//		dijit/registry

	var _widgetTypeCtr = {}, hash = {};

	var registry =  {
		// summary:
		//		Registry of existing widget on page, plus some utility methods.

		// length: Number
		//		Number of registered widgets
		length: 0,

		add: function(widget){
			// summary:
			//		Add a widget to the registry. If a duplicate ID is detected, a error is thrown.
			// widget: dijit/_WidgetBase
			//		Any dijit/_WidgetBase subclass.
			if(hash[widget.id]){
				throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
			}
			hash[widget.id] = widget;
			this.length++;
		},

		remove: function(/*String*/ id){
			// summary:
			//		Remove a widget from the registry. Does not destroy the widget; simply
			//		removes the reference.
			if(hash[id]){
				delete hash[id];
				this.length--;
			}
		},

		byId: function(/*String|Widget*/ id){
			// summary:
			//		Find a widget by it's id.
			//		If passed a widget then just returns the widget.
			return typeof id == "string" ? hash[id] : id;	// dijit/_WidgetBase
		},

		byNode: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget corresponding to the given DOMNode
			return hash[node.getAttribute("widgetId")]; // dijit/_WidgetBase
		},

		toArray: function(){
			// summary:
			//		Convert registry into a true Array
			//
			// example:
			//		Work with the widget .domNodes in a real Array
			//		|	array.map(registry.toArray(), function(w){ return w.domNode; });

			var ar = [];
			for(var id in hash){
				ar.push(hash[id]);
			}
			return ar;	// dijit/_WidgetBase[]
		},

		getUniqueId: function(/*String*/widgetType){
			// summary:
			//		Generates a unique id for a given widgetType

			var id;
			do{
				id = widgetType + "_" +
					(widgetType in _widgetTypeCtr ?
						++_widgetTypeCtr[widgetType] : _widgetTypeCtr[widgetType] = 0);
			}while(hash[id]);
			return dijit._scopeName == "dijit" ? id : dijit._scopeName + "_" + id; // String
		},

		findWidgets: function(root, skipNode){
			// summary:
			//		Search subtree under root returning widgets found.
			//		Doesn't search for nested widgets (ie, widgets inside other widgets).
			// root: DOMNode
			//		Node to search under.
			// skipNode: DOMNode
			//		If specified, don't search beneath this node (usually containerNode).

			var outAry = [];

			function getChildrenHelper(root){
				for(var node = root.firstChild; node; node = node.nextSibling){
					if(node.nodeType == 1){
						var widgetId = node.getAttribute("widgetId");
						if(widgetId){
							var widget = hash[widgetId];
							if(widget){	// may be null on page w/multiple dojo's loaded
								outAry.push(widget);
							}
						}else if(node !== skipNode){
							getChildrenHelper(node);
						}
					}
				}
			}

			getChildrenHelper(root);
			return outAry;
		},

		_destroyAll: function(){
			// summary:
			//		Code to destroy all widgets and do other cleanup on page unload

			// Clean up focus manager lingering references to widgets and nodes
			dijit._curFocus = null;
			dijit._prevFocus = null;
			dijit._activeStack = [];

			// Destroy all the widgets, top down
			array.forEach(registry.findWidgets(win.body()), function(widget){
				// Avoid double destroy of widgets like Menu that are attached to <body>
				// even though they are logically children of other widgets.
				if(!widget._destroyed){
					if(widget.destroyRecursive){
						widget.destroyRecursive();
					}else if(widget.destroy){
						widget.destroy();
					}
				}
			});
		},

		getEnclosingWidget: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget whose DOM tree contains the specified DOMNode, or null if
			//		the node is not contained within the DOM tree of any widget
			while(node){
				var id = node.nodeType == 1 && node.getAttribute("widgetId");
				if(id){
					return hash[id];
				}
				node = node.parentNode;
			}
			return null;
		},

		// In case someone needs to access hash.
		// Actually, this is accessed from WidgetSet back-compatibility code
		_hash: hash
	};

	dijit.registry = registry;

	return registry;
});

},
'dijit/main':function(){
define([
	"dojo/_base/kernel"
], function(dojo){
	// module:
	//		dijit/main

/*=====
return {
	// summary:
	//		The dijit package main module.
	//		Deprecated.   Users should access individual modules (ex: dijit/registry) directly.
};
=====*/

	return dojo.dijit;
});

},
'dijit/_WidgetBase':function(){
define([
	"require", // require.toUrl
	"dojo/_base/array", // array.forEach array.map
	"dojo/aspect",
	"dojo/_base/config", // config.blankGif
	"dojo/_base/connect", // connect.connect
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.byId
	"dojo/dom-attr", // domAttr.set domAttr.remove
	"dojo/dom-class", // domClass.add domClass.replace
	"dojo/dom-construct", // domConstruct.destroy domConstruct.place
	"dojo/dom-geometry", // isBodyLtr
	"dojo/dom-style", // domStyle.set, domStyle.get
	"dojo/has",
	"dojo/_base/kernel",
	"dojo/_base/lang", // mixin(), isArray(), etc.
	"dojo/on",
	"dojo/ready",
	"dojo/Stateful", // Stateful
	"dojo/topic",
	"dojo/_base/window", // win.body()
	"./Destroyable",
	"dojo/has!dojo-bidi?./_BidiMixin",
	"./registry"    // registry.getUniqueId(), registry.findWidgets()
], function(require, array, aspect, config, connect, declare,
			dom, domAttr, domClass, domConstruct, domGeometry, domStyle, has, kernel,
			lang, on, ready, Stateful, topic, win, Destroyable, _BidiMixin, registry){

	// module:
	//		dijit/_WidgetBase

	// Flag to make dijit load modules the app didn't explicitly request, for backwards compatibility
	has.add("dijit-legacy-requires", !kernel.isAsync);

	// Flag to enable support for textdir attribute
	has.add("dojo-bidi", false);


	// For back-compat, remove in 2.0.
	if(has("dijit-legacy-requires")){
		ready(0, function(){
			var requires = ["dijit/_base/manager"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	// Nested hash listing attributes for each tag, all strings in lowercase.
	// ex: {"div": {"style": true, "tabindex" true}, "form": { ...
	var tagAttrs = {};

	function getAttrs(obj){
		var ret = {};
		for(var attr in obj){
			ret[attr.toLowerCase()] = true;
		}
		return ret;
	}

	function nonEmptyAttrToDom(attr){
		// summary:
		//		Returns a setter function that copies the attribute to this.domNode,
		//		or removes the attribute from this.domNode, depending on whether the
		//		value is defined or not.
		return function(val){
			domAttr[val ? "set" : "remove"](this.domNode, attr, val);
			this._set(attr, val);
		};
	}

	function isEqual(a, b){
		//	summary:
		//		Function that determines whether two values are identical,
		//		taking into account that NaN is not normally equal to itself
		//		in JS.

		return a === b || (/* a is NaN */ a !== a && /* b is NaN */ b !== b);
	}

	var _WidgetBase = declare("dijit._WidgetBase", [Stateful, Destroyable], {
		// summary:
		//		Future base class for all Dijit widgets.
		// description:
		//		Future base class for all Dijit widgets.
		//		_Widget extends this class adding support for various features needed by desktop.
		//
		//		Provides stubs for widget lifecycle methods for subclasses to extend, like postMixInProperties(), buildRendering(),
		//		postCreate(), startup(), and destroy(), and also public API methods like set(), get(), and watch().
		//
		//		Widgets can provide custom setters/getters for widget attributes, which are called automatically by set(name, value).
		//		For an attribute XXX, define methods _setXXXAttr() and/or _getXXXAttr().
		//
		//		_setXXXAttr can also be a string/hash/array mapping from a widget attribute XXX to the widget's DOMNodes:
		//
		//		- DOM node attribute
		// |		_setFocusAttr: {node: "focusNode", type: "attribute"}
		// |		_setFocusAttr: "focusNode"	(shorthand)
		// |		_setFocusAttr: ""		(shorthand, maps to this.domNode)
		//		Maps this.focus to this.focusNode.focus, or (last example) this.domNode.focus
		//
		//		- DOM node innerHTML
		//	|		_setTitleAttr: { node: "titleNode", type: "innerHTML" }
		//		Maps this.title to this.titleNode.innerHTML
		//
		//		- DOM node innerText
		//	|		_setTitleAttr: { node: "titleNode", type: "innerText" }
		//		Maps this.title to this.titleNode.innerText
		//
		//		- DOM node CSS class
		// |		_setMyClassAttr: { node: "domNode", type: "class" }
		//		Maps this.myClass to this.domNode.className
		//
		//		If the value of _setXXXAttr is an array, then each element in the array matches one of the
		//		formats of the above list.
		//
		//		If the custom setter is null, no action is performed other than saving the new value
		//		in the widget (in this).
		//
		//		If no custom setter is defined for an attribute, then it will be copied
		//		to this.focusNode (if the widget defines a focusNode), or this.domNode otherwise.
		//		That's only done though for attributes that match DOMNode attributes (title,
		//		alt, aria-labelledby, etc.)

		// id: [const] String
		//		A unique, opaque ID string that can be assigned by users or by the
		//		system. If the developer passes an ID which is known not to be
		//		unique, the specified ID is ignored and the system-generated ID is
		//		used instead.
		id: "",
		_setIdAttr: "domNode", // to copy to this.domNode even for auto-generated id's

		// lang: [const] String
		//		Rarely used.  Overrides the default Dojo locale used to render this widget,
		//		as defined by the [HTML LANG](http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang) attribute.
		//		Value must be among the list of locales specified during by the Dojo bootstrap,
		//		formatted according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt) (like en-us).
		lang: "",
		// set on domNode even when there's a focus node.	but don't set lang="", since that's invalid.
		_setLangAttr: nonEmptyAttrToDom("lang"),

		// dir: [const] String
		//		Bi-directional support, as defined by the [HTML DIR](http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir)
		//		attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
		//		default direction.
		dir: "",
		// set on domNode even when there's a focus node.	but don't set dir="", since that's invalid.
		_setDirAttr: nonEmptyAttrToDom("dir"), // to set on domNode even when there's a focus node

		// class: String
		//		HTML class attribute
		"class": "",
		_setClassAttr: { node: "domNode", type: "class" },

		// Override automatic assigning type --> focusNode, it causes exception on IE6-8.
		// Instead, type must be specified as ${type} in the template, as part of the original DOM.
		_setTypeAttr: null,

		// style: String||Object
		//		HTML style attributes as cssText string or name/value hash
		style: "",

		// title: String
		//		HTML title attribute.
		//
		//		For form widgets this specifies a tooltip to display when hovering over
		//		the widget (just like the native HTML title attribute).
		//
		//		For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
		//		etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
		//		interpreted as HTML.
		title: "",

		// tooltip: String
		//		When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
		//		this specifies the tooltip to appear when the mouse is hovered over that text.
		tooltip: "",

		// baseClass: [protected] String
		//		Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate
		//		widget state.
		baseClass: "",

		// srcNodeRef: [readonly] DomNode
		//		pointer to original DOM node
		srcNodeRef: null,

		// domNode: [readonly] DomNode
		//		This is our visible representation of the widget! Other DOM
		//		Nodes may by assigned to other properties, usually through the
		//		template system's data-dojo-attach-point syntax, but the domNode
		//		property is the canonical "top level" node in widget UI.
		domNode: null,

		// containerNode: [readonly] DomNode
		//		Designates where children of the source DOM node will be placed.
		//		"Children" in this case refers to both DOM nodes and widgets.
		//		For example, for myWidget:
		//
		//		|	<div data-dojo-type=myWidget>
		//		|		<b> here's a plain DOM node
		//		|		<span data-dojo-type=subWidget>and a widget</span>
		//		|		<i> and another plain DOM node </i>
		//		|	</div>
		//
		//		containerNode would point to:
		//
		//		|		<b> here's a plain DOM node
		//		|		<span data-dojo-type=subWidget>and a widget</span>
		//		|		<i> and another plain DOM node </i>
		//
		//		In templated widgets, "containerNode" is set via a
		//		data-dojo-attach-point assignment.
		//
		//		containerNode must be defined for any widget that accepts innerHTML
		//		(like ContentPane or BorderContainer or even Button), and conversely
		//		is null for widgets that don't, like TextBox.
		containerNode: null,

		// ownerDocument: [const] Document?
		//		The document this widget belongs to.  If not specified to constructor, will default to
		//		srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
		ownerDocument: null,
		_setOwnerDocumentAttr: function(val){
			// this setter is merely to avoid automatically trying to set this.domNode.ownerDocument
			this._set("ownerDocument", val);
		},

		/*=====
		// _started: [readonly] Boolean
		//		startup() has completed.
		_started: false,
		=====*/

		// attributeMap: [protected] Object
		//		Deprecated.	Instead of attributeMap, widget should have a _setXXXAttr attribute
		//		for each XXX attribute to be mapped to the DOM.
		//
		//		attributeMap sets up a "binding" between attributes (aka properties)
		//		of the widget and the widget's DOM.
		//		Changes to widget attributes listed in attributeMap will be
		//		reflected into the DOM.
		//
		//		For example, calling set('title', 'hello')
		//		on a TitlePane will automatically cause the TitlePane's DOM to update
		//		with the new title.
		//
		//		attributeMap is a hash where the key is an attribute of the widget,
		//		and the value reflects a binding to a:
		//
		//		- DOM node attribute
		// |		focus: {node: "focusNode", type: "attribute"}
		//		Maps this.focus to this.focusNode.focus
		//
		//		- DOM node innerHTML
		//	|		title: { node: "titleNode", type: "innerHTML" }
		//		Maps this.title to this.titleNode.innerHTML
		//
		//		- DOM node innerText
		//	|		title: { node: "titleNode", type: "innerText" }
		//		Maps this.title to this.titleNode.innerText
		//
		//		- DOM node CSS class
		// |		myClass: { node: "domNode", type: "class" }
		//		Maps this.myClass to this.domNode.className
		//
		//		If the value is an array, then each element in the array matches one of the
		//		formats of the above list.
		//
		//		There are also some shorthands for backwards compatibility:
		//
		//		- string --> { node: string, type: "attribute" }, for example:
		//
		//	|	"focusNode" ---> { node: "focusNode", type: "attribute" }
		//
		//		- "" --> { node: "domNode", type: "attribute" }
		attributeMap: {},

		// _blankGif: [protected] String
		//		Path to a blank 1x1 image.
		//		Used by `<img>` nodes in templates that really get their image via CSS background-image.
		_blankGif: config.blankGif || require.toUrl("dojo/resources/blank.gif"),

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		/*=====
		constructor: function(params, srcNodeRef){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified:
			//
			//		- use srcNodeRef.innerHTML as my contents
			//		- if this is a behavioral widget then apply behavior to that srcNodeRef
			//		- otherwise, replace srcNodeRef with my generated DOM tree
		},
		=====*/

		_introspect: function(){
			// summary:
			//		Collect metadata about this widget (only once per class, not once per instance):
			//
			//			- list of attributes with custom setters, storing in this.constructor._setterAttrs
			//			- generate this.constructor._onMap, mapping names like "mousedown" to functions like onMouseDown

			var ctor = this.constructor;
			if(!ctor._setterAttrs){
				var proto = ctor.prototype,
					attrs = ctor._setterAttrs = [], // attributes with custom setters
					onMap = (ctor._onMap = {});

				// Items in this.attributeMap are like custom setters.  For back-compat, remove for 2.0.
				for(var name in proto.attributeMap){
					attrs.push(name);
				}

				// Loop over widget properties, collecting properties with custom setters and filling in ctor._onMap.
				for(name in proto){
					if(/^on/.test(name)){
						onMap[name.substring(2).toLowerCase()] = name;
					}

					if(/^_set[A-Z](.*)Attr$/.test(name)){
						name = name.charAt(4).toLowerCase() + name.substr(5, name.length - 9);
						if(!proto.attributeMap || !(name in proto.attributeMap)){
							attrs.push(name);
						}
					}
				}

				// Note: this isn't picking up info on properties like aria-label and role, that don't have custom setters
				// but that set() maps to attributes on this.domNode or this.focusNode
			}
		},

		postscript: function(/*Object?*/params, /*DomNode|String*/srcNodeRef){
			// summary:
			//		Kicks off widget instantiation.  See create() for details.
			// tags:
			//		private

			// Note that we skip calling this.inherited(), i.e. dojo/Stateful::postscript(), because 1.x widgets don't
			// expect their custom setters to get called until after buildRendering().  Consider changing for 2.0.

			this.create(params, srcNodeRef);
		},

		create: function(params, srcNodeRef){
			// summary:
			//		Kick off the life-cycle of a widget
			// description:
			//		Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,
			//		etc.), some of which of you'll want to override. See http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html
			//		for a discussion of the widget creation lifecycle.
			//
			//		Of course, adventurous developers could override create entirely, but this should
			//		only be done as a last resort.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified:
			//
			//		- use srcNodeRef.innerHTML as my contents
			//		- if this is a behavioral widget then apply behavior to that srcNodeRef
			//		- otherwise, replace srcNodeRef with my generated DOM tree
			// tags:
			//		private

			// First time widget is instantiated, scan prototype to figure out info about custom setters etc.
			this._introspect();

			// store pointer to original DOM tree
			this.srcNodeRef = dom.byId(srcNodeRef);

			// No longer used, remove for 2.0.
			this._connects = [];
			this._supportingWidgets = [];

			// this is here for back-compat, remove in 2.0 (but check NodeList-instantiate.html test)
			if(this.srcNodeRef && (typeof this.srcNodeRef.id == "string")){
				this.id = this.srcNodeRef.id;
			}

			// mix in our passed parameters
			if(params){
				this.params = params;
				lang.mixin(this, params);
			}
			this.postMixInProperties();

			// Generate an id for the widget if one wasn't specified, or it was specified as id: undefined.
			// Do this before buildRendering() because it might expect the id to be there.
			if(!this.id){
				this.id = registry.getUniqueId(this.declaredClass.replace(/\./g, "_"));
				if(this.params){
					// if params contains {id: undefined}, prevent _applyAttributes() from processing it
					delete this.params.id;
				}
			}

			// The document and <body> node this widget is associated with
			this.ownerDocument = this.ownerDocument || (this.srcNodeRef ? this.srcNodeRef.ownerDocument : document);
			this.ownerDocumentBody = win.body(this.ownerDocument);

			registry.add(this);

			this.buildRendering();

			var deleteSrcNodeRef;

			if(this.domNode){
				// Copy attributes listed in attributeMap into the [newly created] DOM for the widget.
				// Also calls custom setters for all attributes with custom setters.
				this._applyAttributes();

				// If srcNodeRef was specified, then swap out original srcNode for this widget's DOM tree.
				// For 2.0, move this after postCreate().  postCreate() shouldn't depend on the
				// widget being attached to the DOM since it isn't when a widget is created programmatically like
				// new MyWidget({}).	See #11635.
				var source = this.srcNodeRef;
				if(source && source.parentNode && this.domNode !== source){
					source.parentNode.replaceChild(this.domNode, source);
					deleteSrcNodeRef = true;
				}

				// Note: for 2.0 may want to rename widgetId to dojo._scopeName + "_widgetId",
				// assuming that dojo._scopeName even exists in 2.0
				this.domNode.setAttribute("widgetId", this.id);
			}
			this.postCreate();

			// If srcNodeRef has been processed and removed from the DOM (e.g. TemplatedWidget) then delete it to allow GC.
			// I think for back-compatibility it isn't deleting srcNodeRef until after postCreate() has run.
			if(deleteSrcNodeRef){
				delete this.srcNodeRef;
			}

			this._created = true;
		},

		_applyAttributes: function(){
			// summary:
			//		Step during widget creation to copy  widget attributes to the
			//		DOM according to attributeMap and _setXXXAttr objects, and also to call
			//		custom _setXXXAttr() methods.
			//
			//		Skips over blank/false attribute values, unless they were explicitly specified
			//		as parameters to the widget, since those are the default anyway,
			//		and setting tabIndex="" is different than not setting tabIndex at all.
			//
			//		For backwards-compatibility reasons attributeMap overrides _setXXXAttr when
			//		_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.
			// tags:
			//		private

			// Call this.set() for each property that was either specified as parameter to constructor,
			// or is in the list found above.	For correlated properties like value and displayedValue, the one
			// specified as a parameter should take precedence.
			// Particularly important for new DateTextBox({displayedValue: ...}) since DateTextBox's default value is
			// NaN and thus is not ignored like a default value of "".

			// Step 1: Save the current values of the widget properties that were specified as parameters to the constructor.
			// Generally this.foo == this.params.foo, except if postMixInProperties() changed the value of this.foo.
			var params = {};
			for(var key in this.params || {}){
				params[key] = this._get(key);
			}

			// Step 2: Call set() for each property with a non-falsy value that wasn't passed as a parameter to the constructor
			array.forEach(this.constructor._setterAttrs, function(key){
				if(!(key in params)){
					var val = this._get(key);
					if(val){
						this.set(key, val);
					}
				}
			}, this);

			// Step 3: Call set() for each property that was specified as parameter to constructor.
			// Use params hash created above to ignore side effects from step #2 above.
			for(key in params){
				this.set(key, params[key]);
			}
		},

		postMixInProperties: function(){
			// summary:
			//		Called after the parameters to the widget have been read-in,
			//		but before the widget template is instantiated. Especially
			//		useful to set properties that are referenced in the widget
			//		template.
			// tags:
			//		protected
		},

		buildRendering: function(){
			// summary:
			//		Construct the UI for this widget, setting this.domNode.
			//		Most widgets will mixin `dijit._TemplatedMixin`, which implements this method.
			// tags:
			//		protected

			if(!this.domNode){
				// Create root node if it wasn't created by _TemplatedMixin
				this.domNode = this.srcNodeRef || this.ownerDocument.createElement("div");
			}

			// baseClass is a single class name or occasionally a space-separated list of names.
			// Add those classes to the DOMNode.  If RTL mode then also add with Rtl suffix.
			// TODO: make baseClass custom setter
			if(this.baseClass){
				var classes = this.baseClass.split(" ");
				if(!this.isLeftToRight()){
					classes = classes.concat(array.map(classes, function(name){
						return name + "Rtl";
					}));
				}
				domClass.add(this.domNode, classes);
			}
		},

		postCreate: function(){
			// summary:
			//		Processing after the DOM fragment is created
			// description:
			//		Called after the DOM fragment has been created, but not necessarily
			//		added to the document.  Do not include any operations which rely on
			//		node dimensions or placement.
			// tags:
			//		protected
		},

		startup: function(){
			// summary:
			//		Processing after the DOM fragment is added to the document
			// description:
			//		Called after a widget and its children have been created and added to the page,
			//		and all related widgets have finished their create() cycle, up through postCreate().
			//
			//		Note that startup() may be called while the widget is still hidden, for example if the widget is
			//		inside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.
			//		For widgets that need to do layout, it's best to put that layout code inside resize(), and then
			//		extend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.
			if(this._started){
				return;
			}
			this._started = true;
			array.forEach(this.getChildren(), function(obj){
				if(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){
					obj.startup();
					obj._started = true;
				}
			});
		},

		//////////// DESTROY FUNCTIONS ////////////////////////////////

		destroyRecursive: function(/*Boolean?*/ preserveDom){
			// summary:
			//		Destroy this widget and its descendants
			// description:
			//		This is the generic "destructor" function that all widget users
			//		should call to cleanly discard with a widget. Once a widget is
			//		destroyed, it is removed from the manager object.
			// preserveDom:
			//		If true, this method will leave the original DOM structure
			//		alone of descendant Widgets. Note: This will NOT work with
			//		dijit._TemplatedMixin widgets.

			this._beingDestroyed = true;
			this.destroyDescendants(preserveDom);
			this.destroy(preserveDom);
		},

		destroy: function(/*Boolean*/ preserveDom){
			// summary:
			//		Destroy this widget, but not its descendants.  Descendants means widgets inside of
			//		this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
			//
			//		This method will also destroy internal widgets such as those created from a template,
			//		assuming those widgets exist inside of this.domNode but outside of this.containerNode.
			//
			//		For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
			//		depend on the current ability to destroy a widget without destroying its descendants.   Generally
			//		they should use destroyRecursive() for widgets with children.
			// preserveDom: Boolean
			//		If true, this method will leave the original DOM structure alone.
			//		Note: This will not yet work with _TemplatedMixin widgets

			this._beingDestroyed = true;
			this.uninitialize();

			function destroy(w){
				if(w.destroyRecursive){
					w.destroyRecursive(preserveDom);
				}else if(w.destroy){
					w.destroy(preserveDom);
				}
			}

			// Back-compat, remove for 2.0
			array.forEach(this._connects, lang.hitch(this, "disconnect"));
			array.forEach(this._supportingWidgets, destroy);

			// Destroy supporting widgets, but not child widgets under this.containerNode (for 2.0, destroy child widgets
			// here too).   if() statement is to guard against exception if destroy() called multiple times (see #15815).
			if(this.domNode){
				array.forEach(registry.findWidgets(this.domNode, this.containerNode), destroy);
			}

			this.destroyRendering(preserveDom);
			registry.remove(this.id);
			this._destroyed = true;
		},

		destroyRendering: function(/*Boolean?*/ preserveDom){
			// summary:
			//		Destroys the DOM nodes associated with this widget.
			// preserveDom:
			//		If true, this method will leave the original DOM structure alone
			//		during tear-down. Note: this will not work with _Templated
			//		widgets yet.
			// tags:
			//		protected

			if(this.bgIframe){
				this.bgIframe.destroy(preserveDom);
				delete this.bgIframe;
			}

			if(this.domNode){
				if(preserveDom){
					domAttr.remove(this.domNode, "widgetId");
				}else{
					domConstruct.destroy(this.domNode);
				}
				delete this.domNode;
			}

			if(this.srcNodeRef){
				if(!preserveDom){
					domConstruct.destroy(this.srcNodeRef);
				}
				delete this.srcNodeRef;
			}
		},

		destroyDescendants: function(/*Boolean?*/ preserveDom){
			// summary:
			//		Recursively destroy the children of this widget and their
			//		descendants.
			// preserveDom:
			//		If true, the preserveDom attribute is passed to all descendant
			//		widget's .destroy() method. Not for use with _Templated
			//		widgets.

			// get all direct descendants and destroy them recursively
			array.forEach(this.getChildren(), function(widget){
				if(widget.destroyRecursive){
					widget.destroyRecursive(preserveDom);
				}
			});
		},

		uninitialize: function(){
			// summary:
			//		Deprecated. Override destroy() instead to implement custom widget tear-down
			//		behavior.
			// tags:
			//		protected
			return false;
		},

		////////////////// GET/SET, CUSTOM SETTERS, ETC. ///////////////////

		_setStyleAttr: function(/*String||Object*/ value){
			// summary:
			//		Sets the style attribute of the widget according to value,
			//		which is either a hash like {height: "5px", width: "3px"}
			//		or a plain string
			// description:
			//		Determines which node to set the style on based on style setting
			//		in attributeMap.
			// tags:
			//		protected

			var mapNode = this.domNode;

			// Note: technically we should revert any style setting made in a previous call
			// to his method, but that's difficult to keep track of.

			if(lang.isObject(value)){
				domStyle.set(mapNode, value);
			}else{
				if(mapNode.style.cssText){
					mapNode.style.cssText += "; " + value;
				}else{
					mapNode.style.cssText = value;
				}
			}

			this._set("style", value);
		},

		_attrToDom: function(/*String*/ attr, /*String*/ value, /*Object?*/ commands){
			// summary:
			//		Reflect a widget attribute (title, tabIndex, duration etc.) to
			//		the widget DOM, as specified by commands parameter.
			//		If commands isn't specified then it's looked up from attributeMap.
			//		Note some attributes like "type"
			//		cannot be processed this way as they are not mutable.
			// attr:
			//		Name of member variable (ex: "focusNode" maps to this.focusNode) pointing
			//		to DOMNode inside the widget, or alternately pointing to a subwidget
			// tags:
			//		private

			commands = arguments.length >= 3 ? commands : this.attributeMap[attr];

			array.forEach(lang.isArray(commands) ? commands : [commands], function(command){

				// Get target node and what we are doing to that node
				var mapNode = this[command.node || command || "domNode"];	// DOM node
				var type = command.type || "attribute";	// class, innerHTML, innerText, or attribute

				switch(type){
					case "attribute":
						if(lang.isFunction(value)){ // functions execute in the context of the widget
							value = lang.hitch(this, value);
						}

						// Get the name of the DOM node attribute; usually it's the same
						// as the name of the attribute in the widget (attr), but can be overridden.
						// Also maps handler names to lowercase, like onSubmit --> onsubmit
						var attrName = command.attribute ? command.attribute :
							(/^on[A-Z][a-zA-Z]*$/.test(attr) ? attr.toLowerCase() : attr);

						if(mapNode.tagName){
							// Normal case, mapping to a DOMNode.  Note that modern browsers will have a mapNode.set()
							// method, but for consistency we still call domAttr
							domAttr.set(mapNode, attrName, value);
						}else{
							// mapping to a sub-widget
							mapNode.set(attrName, value);
						}
						break;
					case "innerText":
						mapNode.innerHTML = "";
						mapNode.appendChild(this.ownerDocument.createTextNode(value));
						break;
					case "innerHTML":
						mapNode.innerHTML = value;
						break;
					case "class":
						domClass.replace(mapNode, value, this[attr]);
						break;
				}
			}, this);
		},

		get: function(name){
			// summary:
			//		Get a property from a widget.
			// name:
			//		The property to get.
			// description:
			//		Get a named property from a widget. The property may
			//		potentially be retrieved via a getter method. If no getter is defined, this
			//		just retrieves the object's property.
			//
			//		For example, if the widget has properties `foo` and `bar`
			//		and a method named `_getFooAttr()`, calling:
			//		`myWidget.get("foo")` would be equivalent to calling
			//		`widget._getFooAttr()` and `myWidget.get("bar")`
			//		would be equivalent to the expression
			//		`widget.bar2`
			var names = this._getAttrNames(name);
			return this[names.g] ? this[names.g]() : this._get(name);
		},

		set: function(name, value){
			// summary:
			//		Set a property on a widget
			// name:
			//		The property to set.
			// value:
			//		The value to set in the property.
			// description:
			//		Sets named properties on a widget which may potentially be handled by a
			//		setter in the widget.
			//
			//		For example, if the widget has properties `foo` and `bar`
			//		and a method named `_setFooAttr()`, calling
			//		`myWidget.set("foo", "Howdy!")` would be equivalent to calling
			//		`widget._setFooAttr("Howdy!")` and `myWidget.set("bar", 3)`
			//		would be equivalent to the statement `widget.bar = 3;`
			//
			//		set() may also be called with a hash of name/value pairs, ex:
			//
			//	|	myWidget.set({
			//	|		foo: "Howdy",
			//	|		bar: 3
			//	|	});
			//
			//	This is equivalent to calling `set(foo, "Howdy")` and `set(bar, 3)`

			if(typeof name === "object"){
				for(var x in name){
					this.set(x, name[x]);
				}
				return this;
			}
			var names = this._getAttrNames(name),
				setter = this[names.s];
			if(lang.isFunction(setter)){
				// use the explicit setter
				var result = setter.apply(this, Array.prototype.slice.call(arguments, 1));
			}else{
				// Mapping from widget attribute to DOMNode/subwidget attribute/value/etc.
				// Map according to:
				//		1. attributeMap setting, if one exists (TODO: attributeMap deprecated, remove in 2.0)
				//		2. _setFooAttr: {...} type attribute in the widget (if one exists)
				//		3. apply to focusNode or domNode if standard attribute name, excluding funcs like onClick.
				// Checks if an attribute is a "standard attribute" by whether the DOMNode JS object has a similar
				// attribute name (ex: accept-charset attribute matches jsObject.acceptCharset).
				// Note also that Tree.focusNode() is a function not a DOMNode, so test for that.
				var defaultNode = this.focusNode && !lang.isFunction(this.focusNode) ? "focusNode" : "domNode",
					tag = this[defaultNode] && this[defaultNode].tagName,
					attrsForTag = tag && (tagAttrs[tag] || (tagAttrs[tag] = getAttrs(this[defaultNode]))),
					map = name in this.attributeMap ? this.attributeMap[name] :
						names.s in this ? this[names.s] :
							((attrsForTag && names.l in attrsForTag && typeof value != "function") ||
								/^aria-|^data-|^role$/.test(name)) ? defaultNode : null;
				if(map != null){
					this._attrToDom(name, value, map);
				}
				this._set(name, value);
			}
			return result || this;
		},

		_attrPairNames: {}, // shared between all widgets
		_getAttrNames: function(name){
			// summary:
			//		Helper function for get() and set().
			//		Caches attribute name values so we don't do the string ops every time.
			// tags:
			//		private

			var apn = this._attrPairNames;
			if(apn[name]){
				return apn[name];
			}
			var uc = name.replace(/^[a-z]|-[a-zA-Z]/g, function(c){
				return c.charAt(c.length - 1).toUpperCase();
			});
			return (apn[name] = {
				n: name + "Node",
				s: "_set" + uc + "Attr", // converts dashes to camel case, ex: accept-charset --> _setAcceptCharsetAttr
				g: "_get" + uc + "Attr",
				l: uc.toLowerCase()        // lowercase name w/out dashes, ex: acceptcharset
			});
		},

		_set: function(/*String*/ name, /*anything*/ value){
			// summary:
			//		Helper function to set new value for specified property, and call handlers
			//		registered with watch() if the value has changed.
			var oldValue = this[name];
			this[name] = value;
			if(this._created && !isEqual(oldValue, value)){
				if(this._watchCallbacks){
					this._watchCallbacks(name, oldValue, value);
				}
				this.emit("attrmodified-" + name, {
					detail: {
						prevValue: oldValue,
						newValue: value
					}
				});
			}
		},

		_get: function(/*String*/ name){
			// summary:
			//		Helper function to get value for specified property stored by this._set(),
			//		i.e. for properties with custom setters.  Used mainly by custom getters.
			//
			//		For example, CheckBox._getValueAttr() calls this._get("value").

			// future: return name in this.props ? this.props[name] : this[name];
			return this[name];
		},

		emit: function(/*String*/ type, /*Object?*/ eventObj, /*Array?*/ callbackArgs){
			// summary:
			//		Used by widgets to signal that a synthetic event occurred, ex:
			//	|	myWidget.emit("attrmodified-selectedChildWidget", {}).
			//
			//		Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
			//		Also calls onType() method, if present, and returns value from that method.
			//		By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
			//		Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
			// tags:
			//		protected

			// Specify fallback values for bubbles, cancelable in case they are not set in eventObj.
			// Also set pointer to widget, although since we can't add a pointer to the widget for native events
			// (see #14729), maybe we shouldn't do it here?
			eventObj = eventObj || {};
			if(eventObj.bubbles === undefined){
				eventObj.bubbles = true;
			}
			if(eventObj.cancelable === undefined){
				eventObj.cancelable = true;
			}
			if(!eventObj.detail){
				eventObj.detail = {};
			}
			eventObj.detail.widget = this;

			var ret, callback = this["on" + type];
			if(callback){
				ret = callback.apply(this, callbackArgs ? callbackArgs : [eventObj]);
			}

			// Emit event, but avoid spurious emit()'s as parent sets properties on child during startup/destroy
			if(this._started && !this._beingDestroyed){
				on.emit(this.domNode, type.toLowerCase(), eventObj);
			}

			return ret;
		},

		on: function(/*String|Function*/ type, /*Function*/ func){
			// summary:
			//		Call specified function when event occurs, ex: myWidget.on("click", function(){ ... }).
			// type:
			//		Name of event (ex: "click") or extension event like touch.press.
			// description:
			//		Call specified function when event `type` occurs, ex: `myWidget.on("click", function(){ ... })`.
			//		Note that the function is not run in any particular scope, so if (for example) you want it to run in the
			//		widget's scope you must do `myWidget.on("click", lang.hitch(myWidget, func))`.

			// For backwards compatibility, if there's an onType() method in the widget then connect to that.
			// Remove in 2.0.
			var widgetMethod = this._onMap(type);
			if(widgetMethod){
				return aspect.after(this, widgetMethod, func, true);
			}

			// Otherwise, just listen for the event on this.domNode.
			return this.own(on(this.domNode, type, func))[0];
		},

		_onMap: function(/*String|Function*/ type){
			// summary:
			//		Maps on() type parameter (ex: "mousemove") to method name (ex: "onMouseMove").
			//		If type is a synthetic event like touch.press then returns undefined.
			var ctor = this.constructor, map = ctor._onMap;
			if(!map){
				map = (ctor._onMap = {});
				for(var attr in ctor.prototype){
					if(/^on/.test(attr)){
						map[attr.replace(/^on/, "").toLowerCase()] = attr;
					}
				}
			}
			return map[typeof type == "string" && type.toLowerCase()];	// String
		},

		toString: function(){
			// summary:
			//		Returns a string that represents the widget.
			// description:
			//		When a widget is cast to a string, this method will be used to generate the
			//		output. Currently, it does not implement any sort of reversible
			//		serialization.
			return '[Widget ' + this.declaredClass + ', ' + (this.id || 'NO ID') + ']'; // String
		},

		getChildren: function(){
			// summary:
			//		Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
			//		is this widget.   Note that it does not return all descendants, but rather just direct children.
			//		Analogous to [Node.childNodes](https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes),
			//		except containing widgets rather than DOMNodes.
			//
			//		The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
			//		outside of this.containerNode.
			//
			//		Note that the array returned is a simple array.  Application code should not assume
			//		existence of methods like forEach().

			return this.containerNode ? registry.findWidgets(this.containerNode) : []; // dijit/_WidgetBase[]
		},

		getParent: function(){
			// summary:
			//		Returns the parent widget of this widget.

			return registry.getEnclosingWidget(this.domNode.parentNode);
		},

		connect: function(/*Object|null*/ obj, /*String|Function*/ event, /*String|Function*/ method){
			// summary:
			//		Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
			//
			//		Connects specified obj/event to specified method of this object
			//		and registers for disconnect() on widget destroy.
			//
			//		Provide widget-specific analog to dojo.connect, except with the
			//		implicit use of this widget as the target object.
			//		Events connected with `this.connect` are disconnected upon
			//		destruction.
			// returns:
			//		A handle that can be passed to `disconnect` in order to disconnect before
			//		the widget is destroyed.
			// example:
			//	|	var btn = new Button();
			//	|	// when foo.bar() is called, call the listener we're going to
			//	|	// provide in the scope of btn
			//	|	btn.connect(foo, "bar", function(){
			//	|		console.debug(this.toString());
			//	|	});
			// tags:
			//		protected

			return this.own(connect.connect(obj, event, this, method))[0];	// handle
		},

		disconnect: function(handle){
			// summary:
			//		Deprecated, will be removed in 2.0, use handle.remove() instead.
			//
			//		Disconnects handle created by `connect`.
			// tags:
			//		protected

			handle.remove();
		},

		subscribe: function(t, method){
			// summary:
			//		Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
			//
			//		Subscribes to the specified topic and calls the specified method
			//		of this object and registers for unsubscribe() on widget destroy.
			//
			//		Provide widget-specific analog to dojo.subscribe, except with the
			//		implicit use of this widget as the target object.
			// t: String
			//		The topic
			// method: Function
			//		The callback
			// example:
			//	|	var btn = new Button();
			//	|	// when /my/topic is published, this button changes its label to
			//	|	// be the parameter of the topic.
			//	|	btn.subscribe("/my/topic", function(v){
			//	|		this.set("label", v);
			//	|	});
			// tags:
			//		protected
			return this.own(topic.subscribe(t, lang.hitch(this, method)))[0];	// handle
		},

		unsubscribe: function(/*Object*/ handle){
			// summary:
			//		Deprecated, will be removed in 2.0, use handle.remove() instead.
			//
			//		Unsubscribes handle created by this.subscribe.
			//		Also removes handle from this widget's list of subscriptions
			// tags:
			//		protected

			handle.remove();
		},

		isLeftToRight: function(){
			// summary:
			//		Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
			// tags:
			//		protected
			return this.dir ? (this.dir.toLowerCase() == "ltr") : domGeometry.isBodyLtr(this.ownerDocument); //Boolean
		},

		isFocusable: function(){
			// summary:
			//		Return true if this widget can currently be focused
			//		and false if not
			return this.focus && (domStyle.get(this.domNode, "display") != "none");
		},

		placeAt: function(/*String|DomNode|DocumentFragment|dijit/_WidgetBase*/ reference, /*String|Int?*/ position){
			// summary:
			//		Place this widget somewhere in the DOM based
			//		on standard domConstruct.place() conventions.
			// description:
			//		A convenience function provided in all _Widgets, providing a simple
			//		shorthand mechanism to put an existing (or newly created) Widget
			//		somewhere in the dom, and allow chaining.
			// reference:
			//		Widget, DOMNode, DocumentFragment, or id of widget or DOMNode
			// position:
			//		If reference is a widget (or id of widget), and that widget has an ".addChild" method,
			//		it will be called passing this widget instance into that method, supplying the optional
			//		position index passed.  In this case position (if specified) should be an integer.
			//
			//		If reference is a DOMNode (or id matching a DOMNode but not a widget),
			//		the position argument can be a numeric index or a string
			//		"first", "last", "before", or "after", same as dojo/dom-construct::place().
			// returns: dijit/_WidgetBase
			//		Provides a useful return of the newly created dijit._Widget instance so you
			//		can "chain" this function by instantiating, placing, then saving the return value
			//		to a variable.
			// example:
			//	|	// create a Button with no srcNodeRef, and place it in the body:
			//	|	var button = new Button({ label:"click" }).placeAt(win.body());
			//	|	// now, 'button' is still the widget reference to the newly created button
			//	|	button.on("click", function(e){ console.log('click'); }));
			// example:
			//	|	// create a button out of a node with id="src" and append it to id="wrapper":
			//	|	var button = new Button({},"src").placeAt("wrapper");
			// example:
			//	|	// place a new button as the first element of some div
			//	|	var button = new Button({ label:"click" }).placeAt("wrapper","first");
			// example:
			//	|	// create a contentpane and add it to a TabContainer
			//	|	var tc = dijit.byId("myTabs");
			//	|	new ContentPane({ href:"foo.html", title:"Wow!" }).placeAt(tc)

			var refWidget = !reference.tagName && registry.byId(reference);
			if(refWidget && refWidget.addChild && (!position || typeof position === "number")){
				// Adding this to refWidget and can use refWidget.addChild() to handle everything.
				refWidget.addChild(this, position);
			}else{
				// "reference" is a plain DOMNode, or we can't use refWidget.addChild().   Use domConstruct.place() and
				// target refWidget.containerNode for nested placement (position==number, "first", "last", "only"), and
				// refWidget.domNode otherwise ("after"/"before"/"replace").  (But not supported officially, see #14946.)
				var ref = refWidget && ("domNode" in refWidget) ?
					(refWidget.containerNode && !/after|before|replace/.test(position || "") ?
						refWidget.containerNode : refWidget.domNode) : dom.byId(reference, this.ownerDocument);
				domConstruct.place(this.domNode, ref, position);

				// Start this iff it has a parent widget that's already started.
				// TODO: for 2.0 maybe it should also start the widget when this.getParent() returns null??
				if(!this._started && (this.getParent() || {})._started){
					this.startup();
				}
			}
			return this;
		},

		defer: function(fcn, delay){
			// summary:
			//		Wrapper to setTimeout to avoid deferred functions executing
			//		after the originating widget has been destroyed.
			//		Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
			// fcn: Function
			//		Function reference.
			// delay: Number?
			//		Delay, defaults to 0.
			// tags:
			//		protected

			var timer = setTimeout(lang.hitch(this,
				function(){
					if(!timer){
						return;
					}
					timer = null;
					if(!this._destroyed){
						lang.hitch(this, fcn)();
					}
				}),
				delay || 0
			);
			return {
				remove: function(){
					if(timer){
						clearTimeout(timer);
						timer = null;
					}
					return null; // so this works well: handle = handle.remove();
				}
			};
		}
	});

	if(has("dojo-bidi")){
		_WidgetBase.extend(_BidiMixin);
	}

	return _WidgetBase;
});

},
'dijit/Destroyable':function(){
define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/aspect",
	"dojo/_base/declare"
], function(array, aspect, declare){

	// module:
	//		dijit/Destroyable

	return declare("dijit.Destroyable", null, {
		// summary:
		//		Mixin to track handles and release them when instance is destroyed.
		// description:
		//		Call this.own(...) on list of handles (returned from dojo/aspect, dojo/on,
		//		dojo/Stateful::watch, or any class (including widgets) with a destroyRecursive() or destroy() method.
		//		Then call destroy() later to destroy this instance and release the resources.

		destroy: function(/*Boolean*/ preserveDom){
			// summary:
			//		Destroy this class, releasing any resources registered via own().
			this._destroyed = true;
		},

		own: function(){
			// summary:
			//		Track specified handles and remove/destroy them when this instance is destroyed, unless they were
			//		already removed/destroyed manually.
			// tags:
			//		protected
			// returns:
			//		The array of specified handles, so you can do for example:
			//	|		var handle = this.own(on(...))[0];

			var cleanupMethods = [
				"destroyRecursive",
				"destroy",
				"remove"
			];

			array.forEach(arguments, function(handle){
				// When this.destroy() is called, destroy handle.  Since I'm using aspect.before(),
				// the handle will be destroyed before a subclass's destroy() method starts running, before it calls
				// this.inherited() or even if it doesn't call this.inherited() at all.  If that's an issue, make an
				// onDestroy() method and connect to that instead.
				var destroyMethodName;
				var odh = aspect.before(this, "destroy", function (preserveDom){
					handle[destroyMethodName](preserveDom);
				});

				// Callback for when handle is manually destroyed.
				var hdhs = [];
				function onManualDestroy(){
					odh.remove();
					array.forEach(hdhs, function(hdh){
						hdh.remove();
					});
				}

				// Setup listeners for manual destroy of handle.
				// Also computes destroyMethodName, used in listener above.
				if(handle.then){
					// Special path for Promises.  Detect when Promise is resolved, rejected, or
					// canceled (nb: cancelling a Promise causes it to be rejected).
					destroyMethodName = "cancel";
					handle.then(onManualDestroy, onManualDestroy);
				}else{
					// Path for other handles.  Just use AOP to detect when handle is manually destroyed.
					array.forEach(cleanupMethods, function(cleanupMethod){
						if(typeof handle[cleanupMethod] === "function"){
							if(!destroyMethodName){
								// Use first matching method name in above listener (prefer destroyRecursive() to destroy())
								destroyMethodName = cleanupMethod;
							}
							hdhs.push(aspect.after(handle, cleanupMethod, onManualDestroy, true));
						}
					});
				}
			}, this);

			return arguments;		// handle
		}
	});
});

},
'dijit/_OnDijitClickMixin':function(){
define([
	"dojo/on",
	"dojo/_base/array", // array.forEach
	"dojo/keys", // keys.ENTER keys.SPACE
	"dojo/_base/declare", // declare
	"dojo/has", // has("dom-addeventlistener")
	"./a11yclick"
], function(on, array, keys, declare, has, a11yclick){

	// module:
	//		dijit/_OnDijitClickMixin

	var ret = declare("dijit._OnDijitClickMixin", null, {
		// summary:
		//		Deprecated.   New code should access the dijit/a11yclick event directly, ex:
		//		|	this.own(on(node, a11yclick, function(){ ... }));
		//
		//		Mixing in this class will make _WidgetBase.connect(node, "ondijitclick", ...) work.
		//		It also used to be necessary to make templates with ondijitclick work, but now you can just require
		//		dijit/a11yclick.

		connect: function(obj, event, method){
			// override _WidgetBase.connect() to make this.connect(node, "ondijitclick", ...) work
			return this.inherited(arguments, [obj, event == "ondijitclick" ? a11yclick : event, method]);
		}
	});

	ret.a11yclick = a11yclick;	// back compat

	return ret;
});

},
'dijit/a11yclick':function(){
define([
	"dojo/keys", // keys.ENTER keys.SPACE
	"dojo/mouse",
	"dojo/on",
	"dojo/touch" // touch support for click is now there
], function(keys, mouse, on, touch){

	// module:
	//		dijit/a11yclick

	/*=====
	return {
		// summary:
		//		Custom press, release, and click synthetic events
		//		which trigger on a left mouse click, touch, or space/enter keyup.

		click: function(node, listener){
			// summary:
			//		Logical click operation for mouse, touch, or keyboard (space/enter key)
		},
		press: function(node, listener){
			// summary:
			//		Mousedown (left button), touchstart, or keydown (space or enter) corresponding to logical click operation.
		},
		release: function(node, listener){
			// summary:
			//		Mouseup (left button), touchend, or keyup (space or enter) corresponding to logical click operation.
		},
		move: function(node, listener){
			// summary:
			//		Mouse cursor or a finger is dragged over the given node.
		}
	};
	=====*/

	function clickKey(/*Event*/ e){
		// Test if this keyboard event should be tracked as the start (if keydown) or end (if keyup) of a click event.
		// Only track for nodes marked to be tracked, and not for buttons or inputs,
		// since buttons handle keyboard click natively, and text inputs should not
		// prevent typing spaces or newlines.
		if((e.keyCode === keys.ENTER || e.keyCode === keys.SPACE) && !/input|button|textarea/i.test(e.target.nodeName)){

			// Test if a node or its ancestor has been marked with the dojoClick property to indicate special processing
			for(var node = e.target; node; node = node.parentNode){
				if(node.dojoClick){ return true; }
			}
		}
	}

	var lastKeyDownNode;

	on(document, "keydown", function(e){
		//console.log("a11yclick: onkeydown, e.target = ", e.target, ", lastKeyDownNode was ", lastKeyDownNode, ", equality is ", (e.target === lastKeyDownNode));
		if(clickKey(e)){
			// needed on IE for when focus changes between keydown and keyup - otherwise dropdown menus do not work
			lastKeyDownNode = e.target;

			// Prevent viewport scrolling on space key in IE<9.
			// (Reproducible on test_Button.html on any of the first dijit/form/Button examples)
			e.preventDefault();
		}else{
			lastKeyDownNode = null;
		}
	});

	on(document, "keyup", function(e){
		//console.log("a11yclick: onkeyup, e.target = ", e.target, ", lastKeyDownNode was ", lastKeyDownNode, ", equality is ", (e.target === lastKeyDownNode));
		if(clickKey(e) && e.target == lastKeyDownNode){	// === breaks greasemonkey
			//need reset here or have problems in FF when focus returns to trigger element after closing popup/alert
			lastKeyDownNode = null;

			on.emit(e.target, "click", {
				cancelable: true,
				bubbles: true,
				ctrlKey: e.ctrlKey,
				shiftKey: e.shiftKey,
				metaKey: e.metaKey,
				altKey: e.altKey,
				_origType: e.type
			});
		}
	});

	// I want to return a hash of the synthetic events, but for backwards compatibility the main return value
	// needs to be the click event.   Change for 2.0.

	var click = function(node, listener){
		// Set flag on node so that keydown/keyup above emits click event.
		// Also enables fast click processing from dojo/touch.
		node.dojoClick = true;

		return on(node, "click", listener);
	};
	click.click = click;	// forward compatibility with 2.0

	click.press =  function(node, listener){
		var touchListener = on(node, touch.press, function(evt){
			if(evt.type == "mousedown" && !mouse.isLeft(evt)){
				// Ignore right click
				return;
			}
			listener(evt);
		}), keyListener = on(node, "keydown", function(evt){
			if(evt.keyCode === keys.ENTER || evt.keyCode === keys.SPACE){
				listener(evt);
			}
		});
		return {
			remove: function(){
				touchListener.remove();
				keyListener.remove();
			}
		};
	};

	click.release =  function(node, listener){
		var touchListener = on(node, touch.release, function(evt){
			if(evt.type == "mouseup" && !mouse.isLeft(evt)){
				// Ignore right click
				return;
			}
			listener(evt);
		}), keyListener = on(node, "keyup", function(evt){
			if(evt.keyCode === keys.ENTER || evt.keyCode === keys.SPACE){
				listener(evt);
			}
		});
		return {
			remove: function(){
				touchListener.remove();
				keyListener.remove();
			}
		};
	};

	click.move = touch.move;	// just for convenience

	return click;
});

},
'dijit/_FocusMixin':function(){
define([
	"./focus",
	"./_WidgetBase",
	"dojo/_base/declare", // declare
	"dojo/_base/lang" // lang.extend
], function(focus, _WidgetBase, declare, lang){

	// module:
	//		dijit/_FocusMixin

	// We don't know where _FocusMixin will occur in the inheritance chain, but we need the _onFocus()/_onBlur() below
	// to be last in the inheritance chain, so mixin to _WidgetBase.
	lang.extend(_WidgetBase, {
		// focused: [readonly] Boolean
		//		This widget or a widget it contains has focus, or is "active" because
		//		it was recently clicked.
		focused: false,

		onFocus: function(){
			// summary:
			//		Called when the widget becomes "active" because
			//		it or a widget inside of it either has focus, or has recently
			//		been clicked.
			// tags:
			//		callback
		},

		onBlur: function(){
			// summary:
			//		Called when the widget stops being "active" because
			//		focus moved to something outside of it, or the user
			//		clicked somewhere outside of it, or the widget was
			//		hidden.
			// tags:
			//		callback
		},

		_onFocus: function(){
			// summary:
			//		This is where widgets do processing for when they are active,
			//		such as changing CSS classes.  See onFocus() for more details.
			// tags:
			//		protected
			this.onFocus();
		},

		_onBlur: function(){
			// summary:
			//		This is where widgets do processing for when they stop being active,
			//		such as changing CSS classes.  See onBlur() for more details.
			// tags:
			//		protected
			this.onBlur();
		}
	});

	return declare("dijit._FocusMixin", null, {
		// summary:
		//		Mixin to widget to provide _onFocus() and _onBlur() methods that
		//		fire when a widget or its descendants get/lose focus

		// flag that I want _onFocus()/_onBlur() notifications from focus manager
		_focusManager: focus
	});

});

},
'dijit/focus':function(){
define([
	"dojo/aspect",
	"dojo/_base/declare", // declare
	"dojo/dom", // domAttr.get dom.isDescendant
	"dojo/dom-attr", // domAttr.get dom.isDescendant
	"dojo/dom-class",
	"dojo/dom-construct", // connect to domConstruct.empty, domConstruct.destroy
	"dojo/Evented",
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/domReady",
	"dojo/sniff", // has("ie")
	"dojo/Stateful",
	"dojo/_base/window", // win.body
	"dojo/window", // winUtils.get
	"./a11y",	// a11y.isTabNavigable
	"./registry",	// registry.byId
	"./main"		// to set dijit.focus
], function(aspect, declare, dom, domAttr, domClass, domConstruct, Evented, lang, on, domReady, has, Stateful, win, winUtils,
			a11y, registry, dijit){

	// module:
	//		dijit/focus

	// Time of the last focusin event
	var lastFocusin;

	// Time of the last touch/mousedown or focusin event
	var lastTouchOrFocusin;

	var FocusManager = declare([Stateful, Evented], {
		// summary:
		//		Tracks the currently focused node, and which widgets are currently "active".
		//		Access via require(["dijit/focus"], function(focus){ ... }).
		//
		//		A widget is considered active if it or a descendant widget has focus,
		//		or if a non-focusable node of this widget or a descendant was recently clicked.
		//
		//		Call focus.watch("curNode", callback) to track the current focused DOMNode,
		//		or focus.watch("activeStack", callback) to track the currently focused stack of widgets.
		//
		//		Call focus.on("widget-blur", func) or focus.on("widget-focus", ...) to monitor when
		//		when widgets become active/inactive
		//
		//		Finally, focus(node) will focus a node, suppressing errors if the node doesn't exist.

		// curNode: DomNode
		//		Currently focused item on screen
		curNode: null,

		// activeStack: dijit/_WidgetBase[]
		//		List of currently active widgets (focused widget and it's ancestors)
		activeStack: [],

		constructor: function(){
			// Don't leave curNode/prevNode pointing to bogus elements
			var check = lang.hitch(this, function(node){
				if(dom.isDescendant(this.curNode, node)){
					this.set("curNode", null);
				}
				if(dom.isDescendant(this.prevNode, node)){
					this.set("prevNode", null);
				}
			});
			aspect.before(domConstruct, "empty", check);
			aspect.before(domConstruct, "destroy", check);
		},

		registerIframe: function(/*DomNode*/ iframe){
			// summary:
			//		Registers listeners on the specified iframe so that any click
			//		or focus event on that iframe (or anything in it) is reported
			//		as a focus/click event on the `<iframe>` itself.
			// description:
			//		Currently only used by editor.
			// returns:
			//		Handle with remove() method to deregister.
			return this.registerWin(iframe.contentWindow, iframe);
		},

		registerWin: function(/*Window?*/targetWindow, /*DomNode?*/ effectiveNode){
			// summary:
			//		Registers listeners on the specified window (either the main
			//		window or an iframe's window) to detect when the user has clicked somewhere
			//		or focused somewhere.
			// description:
			//		Users should call registerIframe() instead of this method.
			// targetWindow:
			//		If specified this is the window associated with the iframe,
			//		i.e. iframe.contentWindow.
			// effectiveNode:
			//		If specified, report any focus events inside targetWindow as
			//		an event on effectiveNode, rather than on evt.target.
			// returns:
			//		Handle with remove() method to deregister.

			// TODO: make this function private in 2.0; Editor/users should call registerIframe(),

			// Listen for blur and focus events on targetWindow's document.
			var _this = this,
				body = targetWindow.document && targetWindow.document.body;

			if(body){
				// Listen for touches or mousedowns... could also use dojo/touch.press here.
				var event = has("pointer-events") ? "pointerdown" : has("MSPointer") ? "MSPointerDown" :
					has("touch-events") ? "mousedown, touchstart" : "mousedown";
				var mdh = on(targetWindow.document, event, function(evt){
					// workaround weird IE bug where the click is on an orphaned node
					// (first time clicking a Select/DropDownButton inside a TooltipDialog).
					// actually, strangely this is happening on latest chrome too.
					if(evt && evt.target && evt.target.parentNode == null){
						return;
					}

					_this._onTouchNode(effectiveNode || evt.target, "mouse");
				});

				var fih = on(body, 'focusin', function(evt){
					// When you refocus the browser window, IE gives an event with an empty srcElement
					if(!evt.target.tagName) { return; }

					// IE reports that nodes like <body> have gotten focus, even though they have tabIndex=-1,
					// ignore those events
					var tag = evt.target.tagName.toLowerCase();
					if(tag == "#document" || tag == "body"){ return; }

					if(a11y.isFocusable(evt.target)){
						_this._onFocusNode(effectiveNode || evt.target);
					}else{
						// Previous code called _onTouchNode() for any activate event on a non-focusable node.   Can
						// probably just ignore such an event as it will be handled by onmousedown handler above, but
						// leaving the code for now.
						_this._onTouchNode(effectiveNode || evt.target);
					}
				});

				var foh = on(body, 'focusout', function(evt){
					_this._onBlurNode(effectiveNode || evt.target);
				});

				return {
					remove: function(){
						mdh.remove();
						fih.remove();
						foh.remove();
						mdh = fih = foh = null;
						body = null;	// prevent memory leak (apparent circular reference via closure)
					}
				};
			}
		},

		_onBlurNode: function(/*DomNode*/ node){
			// summary:
			//		Called when focus leaves a node.
			//		Usually ignored, _unless_ it *isn't* followed by touching another node,
			//		which indicates that we tabbed off the last field on the page,
			//		in which case every widget is marked inactive

			var now = (new Date()).getTime();

			// IE9+ and chrome have a problem where focusout events come after the corresponding focusin event.
			// For chrome problem see https://bugs.dojotoolkit.org/ticket/17668.
			// IE problem happens when moving focus from the Editor's <iframe> to a normal DOMNode.
			if(now < lastFocusin + 100){
				return;
			}

			// If the blur event isn't followed by a focus event, it means the user clicked on something unfocusable,
			// so clear focus.
			if(this._clearFocusTimer){
				clearTimeout(this._clearFocusTimer);
			}
			this._clearFocusTimer = setTimeout(lang.hitch(this, function(){
				this.set("prevNode", this.curNode);
				this.set("curNode", null);
			}), 0);

			// Unset timer to zero-out widget stack; we'll reset it below if appropriate.
			if(this._clearActiveWidgetsTimer){
				clearTimeout(this._clearActiveWidgetsTimer);
			}

			if(now < lastTouchOrFocusin + 100){
				// This blur event is coming late (after the call to _onTouchNode() rather than before.
				// So let _onTouchNode() handle setting the widget stack.
				// See https://bugs.dojotoolkit.org/ticket/17668
				return;
			}

			// If the blur event isn't followed (or preceded) by a focus or touch event then mark all widgets as inactive.
			this._clearActiveWidgetsTimer = setTimeout(lang.hitch(this, function(){
				delete this._clearActiveWidgetsTimer;
				this._setStack([]);
			}), 0);
		},

		_onTouchNode: function(/*DomNode*/ node, /*String*/ by){
			// summary:
			//		Callback when node is focused or touched.
			//		Note that _onFocusNode() calls _onTouchNode().
			// node:
			//		The node that was touched.
			// by:
			//		"mouse" if the focus/touch was caused by a mouse down event

			// Keep track of time of last focusin or touch event.
			lastTouchOrFocusin = (new Date()).getTime();

			if(this._clearActiveWidgetsTimer){
				// forget the recent blur event
				clearTimeout(this._clearActiveWidgetsTimer);
				delete this._clearActiveWidgetsTimer;
			}

			// if the click occurred on the scrollbar of a dropdown, treat it as a click on the dropdown,
			// even though the scrollbar is technically on the popup wrapper (see #10631)
			if(domClass.contains(node, "dijitPopup")){
				node = node.firstChild;
			}

			// compute stack of active widgets (ex: ComboButton --> Menu --> MenuItem)
			var newStack=[];
			try{
				while(node){
					var popupParent = domAttr.get(node, "dijitPopupParent");
					if(popupParent){
						node=registry.byId(popupParent).domNode;
					}else if(node.tagName && node.tagName.toLowerCase() == "body"){
						// is this the root of the document or just the root of an iframe?
						if(node === win.body()){
							// node is the root of the main document
							break;
						}
						// otherwise, find the iframe this node refers to (can't access it via parentNode,
						// need to do this trick instead). window.frameElement is supported in IE/FF/Webkit
						node=winUtils.get(node.ownerDocument).frameElement;
					}else{
						// if this node is the root node of a widget, then add widget id to stack,
						// except ignore clicks on disabled widgets (actually focusing a disabled widget still works,
						// to support MenuItem)
						var id = node.getAttribute && node.getAttribute("widgetId"),
							widget = id && registry.byId(id);
						if(widget && !(by == "mouse" && widget.get("disabled"))){
							newStack.unshift(id);
						}
						node=node.parentNode;
					}
				}
			}catch(e){ /* squelch */ }

			this._setStack(newStack, by);
		},

		_onFocusNode: function(/*DomNode*/ node){
			// summary:
			//		Callback when node is focused

			if(!node){
				return;
			}

			if(node.nodeType == 9){
				// Ignore focus events on the document itself.  This is here so that
				// (for example) clicking the up/down arrows of a spinner
				// (which don't get focus) won't cause that widget to blur. (FF issue)
				return;
			}

			// Keep track of time of last focusin event.
			lastFocusin = (new Date()).getTime();

			// There was probably a blur event right before this event, but since we have a new focus,
			// forget about the blur
			if(this._clearFocusTimer){
				clearTimeout(this._clearFocusTimer);
				delete this._clearFocusTimer;
			}

			this._onTouchNode(node);

			if(node == this.curNode){ return; }
			this.set("prevNode", this.curNode);
			this.set("curNode", node);
		},

		_setStack: function(/*String[]*/ newStack, /*String*/ by){
			// summary:
			//		The stack of active widgets has changed.  Send out appropriate events and records new stack.
			// newStack:
			//		array of widget id's, starting from the top (outermost) widget
			// by:
			//		"mouse" if the focus/touch was caused by a mouse down event

			var oldStack = this.activeStack, lastOldIdx = oldStack.length - 1, lastNewIdx = newStack.length - 1;

			if(newStack[lastNewIdx] == oldStack[lastOldIdx]){
				// no changes, return now to avoid spurious notifications about changes to activeStack
				return;
			}

			this.set("activeStack", newStack);

			var widget, i;

			// for all elements that have gone out of focus, set focused=false
			for(i = lastOldIdx; i >= 0 && oldStack[i] != newStack[i]; i--){
				widget = registry.byId(oldStack[i]);
				if(widget){
					widget._hasBeenBlurred = true;		// TODO: used by form widgets, should be moved there
					widget.set("focused", false);
					if(widget._focusManager == this){
						widget._onBlur(by);
					}
					this.emit("widget-blur", widget, by);
				}
			}

			// for all element that have come into focus, set focused=true
			for(i++; i <= lastNewIdx; i++){
				widget = registry.byId(newStack[i]);
				if(widget){
					widget.set("focused", true);
					if(widget._focusManager == this){
						widget._onFocus(by);
					}
					this.emit("widget-focus", widget, by);
				}
			}
		},

		focus: function(node){
			// summary:
			//		Focus the specified node, suppressing errors if they occur
			if(node){
				try{ node.focus(); }catch(e){/*quiet*/}
			}
		}
	});

	var singleton = new FocusManager();

	// register top window and all the iframes it contains
	domReady(function(){
		var handle = singleton.registerWin(winUtils.get(document));
		if(has("ie")){
			on(window, "unload", function(){
				if(handle){	// because this gets called twice when doh.robot is running
					handle.remove();
					handle = null;
				}
			});
		}
	});

	// Setup dijit.focus as a pointer to the singleton but also (for backwards compatibility)
	// as a function to set focus.   Remove for 2.0.
	dijit.focus = function(node){
		singleton.focus(node);	// indirection here allows dijit/_base/focus.js to override behavior
	};
	for(var attr in singleton){
		if(!/^_/.test(attr)){
			dijit.focus[attr] = typeof singleton[attr] == "function" ? lang.hitch(singleton, attr) : singleton[attr];
		}
	}
	singleton.watch(function(attr, oldVal, newVal){
		dijit.focus[attr] = newVal;
	});

	return singleton;
});

},
'dijit/a11y':function(){
define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/dom",			// dom.byId
	"dojo/dom-attr", // domAttr.attr domAttr.has
	"dojo/dom-style", // domStyle.style
	"dojo/_base/lang", // lang.mixin()
	"dojo/sniff", // has("ie")  1 
	"./main"	// for exporting methods to dijit namespace
], function(array, dom, domAttr, domStyle, lang, has, dijit){

	// module:
	//		dijit/a11y

	var undefined;

	var a11y = {
		// summary:
		//		Accessibility utility functions (keyboard, tab stops, etc.)

		_isElementShown: function(/*Element*/ elem){
			var s = domStyle.get(elem);
			return (s.visibility != "hidden")
				&& (s.visibility != "collapsed")
				&& (s.display != "none")
				&& (domAttr.get(elem, "type") != "hidden");
		},

		hasDefaultTabStop: function(/*Element*/ elem){
			// summary:
			//		Tests if element is tab-navigable even without an explicit tabIndex setting

			// No explicit tabIndex setting, need to investigate node type
			switch(elem.nodeName.toLowerCase()){
				case "a":
					// An <a> w/out a tabindex is only navigable if it has an href
					return domAttr.has(elem, "href");
				case "area":
				case "button":
				case "input":
				case "object":
				case "select":
				case "textarea":
					// These are navigable by default
					return true;
				case "iframe":
					// If it's an editor <iframe> then it's tab navigable.
					var body;
					try{
						// non-IE
						var contentDocument = elem.contentDocument;
						if("designMode" in contentDocument && contentDocument.designMode == "on"){
							return true;
						}
						body = contentDocument.body;
					}catch(e1){
						// contentWindow.document isn't accessible within IE7/8
						// if the iframe.src points to a foreign url and this
						// page contains an element, that could get focus
						try{
							body = elem.contentWindow.document.body;
						}catch(e2){
							return false;
						}
					}
					return body && (body.contentEditable == 'true' ||
						(body.firstChild && body.firstChild.contentEditable == 'true'));
				default:
					return elem.contentEditable == 'true';
			}
		},

		effectiveTabIndex: function(/*Element*/ elem){
			// summary:
			//		Returns effective tabIndex of an element, either a number, or undefined if element isn't focusable.

			if(domAttr.get(elem, "disabled")){
				return undefined;
			}else if(domAttr.has(elem, "tabIndex")){
				// Explicit tab index setting
				return +domAttr.get(elem, "tabIndex");// + to convert string --> number
			}else{
				// No explicit tabIndex setting, so depends on node type
				return a11y.hasDefaultTabStop(elem) ? 0 : undefined;
			}
		},

		isTabNavigable: function(/*Element*/ elem){
			// summary:
			//		Tests if an element is tab-navigable

			return a11y.effectiveTabIndex(elem) >= 0;
		},

		isFocusable: function(/*Element*/ elem){
			// summary:
			//		Tests if an element is focusable by tabbing to it, or clicking it with the mouse.

			return a11y.effectiveTabIndex(elem) >= -1;
		},

		_getTabNavigable: function(/*DOMNode*/ root){
			// summary:
			//		Finds descendants of the specified root node.
			// description:
			//		Finds the following descendants of the specified root node:
			//
			//		- the first tab-navigable element in document order
			//		  without a tabIndex or with tabIndex="0"
			//		- the last tab-navigable element in document order
			//		  without a tabIndex or with tabIndex="0"
			//		- the first element in document order with the lowest
			//		  positive tabIndex value
			//		- the last element in document order with the highest
			//		  positive tabIndex value
			var first, last, lowest, lowestTabindex, highest, highestTabindex, radioSelected = {};

			function radioName(node){
				// If this element is part of a radio button group, return the name for that group.
				return node && node.tagName.toLowerCase() == "input" &&
					node.type && node.type.toLowerCase() == "radio" &&
					node.name && node.name.toLowerCase();
			}

			var shown = a11y._isElementShown, effectiveTabIndex = a11y.effectiveTabIndex;
			var walkTree = function(/*DOMNode*/ parent){
				for(var child = parent.firstChild; child; child = child.nextSibling){
					// Skip text elements, hidden elements, and also non-HTML elements (those in custom namespaces) in IE,
					// since show() invokes getAttribute("type"), which crash on VML nodes in IE.
					if(child.nodeType != 1 || (has("ie") <= 9 && child.scopeName !== "HTML") || !shown(child)){
						continue;
					}

					var tabindex = effectiveTabIndex(child);
					if(tabindex >= 0){
						if(tabindex == 0){
							if(!first){
								first = child;
							}
							last = child;
						}else if(tabindex > 0){
							if(!lowest || tabindex < lowestTabindex){
								lowestTabindex = tabindex;
								lowest = child;
							}
							if(!highest || tabindex >= highestTabindex){
								highestTabindex = tabindex;
								highest = child;
							}
						}
						var rn = radioName(child);
						if(domAttr.get(child, "checked") && rn){
							radioSelected[rn] = child;
						}
					}
					if(child.nodeName.toUpperCase() != 'SELECT'){
						walkTree(child);
					}
				}
			};
			if(shown(root)){
				walkTree(root);
			}
			function rs(node){
				// substitute checked radio button for unchecked one, if there is a checked one with the same name.
				return radioSelected[radioName(node)] || node;
			}

			return { first: rs(first), last: rs(last), lowest: rs(lowest), highest: rs(highest) };
		},

		getFirstInTabbingOrder: function(/*String|DOMNode*/ root, /*Document?*/ doc){
			// summary:
			//		Finds the descendant of the specified root node
			//		that is first in the tabbing order
			var elems = a11y._getTabNavigable(dom.byId(root, doc));
			return elems.lowest ? elems.lowest : elems.first; // DomNode
		},

		getLastInTabbingOrder: function(/*String|DOMNode*/ root, /*Document?*/ doc){
			// summary:
			//		Finds the descendant of the specified root node
			//		that is last in the tabbing order
			var elems = a11y._getTabNavigable(dom.byId(root, doc));
			return elems.last ? elems.last : elems.highest; // DomNode
		}
	};

	 1  && lang.mixin(dijit, a11y);

	return a11y;
});

},
'dojo/uacss':function(){
define(["./dom-geometry", "./_base/lang", "./domReady", "./sniff", "./_base/window"],
	function(geometry, lang, domReady, has, baseWindow){

	// module:
	//		dojo/uacss

	/*=====
	return {
		// summary:
		//		Applies pre-set CSS classes to the top-level HTML node, based on:
		//
		//		- browser (ex: dj_ie)
		//		- browser version (ex: dj_ie6)
		//		- box model (ex: dj_contentBox)
		//		- text direction (ex: dijitRtl)
		//
		//		In addition, browser, browser version, and box model are
		//		combined with an RTL flag when browser text is RTL. ex: dj_ie-rtl.
		//
		//		Returns the has() method.
	};
	=====*/

	var
		html = baseWindow.doc.documentElement,
		ie = has("ie"),
		opera = has("opera"),
		maj = Math.floor,
		ff = has("ff"),
		boxModel = geometry.boxModel.replace(/-/,''),

		classes = {
			"dj_quirks": has("quirks"),

			// NOTE: Opera not supported by dijit
			"dj_opera": opera,

			"dj_khtml": has("khtml"),

			"dj_webkit": has("webkit"),
			"dj_safari": has("safari"),
			"dj_chrome": has("chrome"),

			"dj_gecko": has("mozilla"),

			"dj_ios": has("ios"),
			"dj_android": has("android")
		}; // no dojo unsupported browsers

	if(ie){
		classes["dj_ie"] = true;
		classes["dj_ie" + maj(ie)] = true;
		classes["dj_iequirks"] = has("quirks");
	}
	if(ff){
		classes["dj_ff" + maj(ff)] = true;
	}

	classes["dj_" + boxModel] = true;

	// apply browser, browser version, and box model class names
	var classStr = "";
	for(var clz in classes){
		if(classes[clz]){
			classStr += clz + " ";
		}
	}
	html.className = lang.trim(html.className + " " + classStr);

	// If RTL mode, then add dj_rtl flag plus repeat existing classes with -rtl extension.
	// We can't run the code below until the <body> tag has loaded (so we can check for dir=rtl).
	domReady(function(){
		if(!geometry.isBodyLtr()){
			var rtlClassStr = "dj_rtl dijitRtl " + classStr.replace(/ /g, "-rtl ");
			html.className = lang.trim(html.className + " " + rtlClassStr + "dj_rtl dijitRtl " + classStr.replace(/ /g, "-rtl "));
		}
	});
	return has;
});

},
'dijit/hccss':function(){
define(["dojo/dom-class", "dojo/hccss", "dojo/domReady", "dojo/_base/window"], function(domClass, has, domReady, win){

	// module:
	//		dijit/hccss

	/*=====
	return function(){
		// summary:
		//		Test if computer is in high contrast mode, and sets `dijit_a11y` flag on `<body>` if it is.
		//		Deprecated, use ``dojo/hccss`` instead.
	};
	=====*/

	domReady(function(){
		if(has("highcontrast")){
			domClass.add(win.body(), "dijit_a11y");
		}
	});

	return has;
});

},
'dijit/_CssStateMixin':function(){
define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.isDescendant()
	"dojo/dom-class", // domClass.toggle
	"dojo/has",
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/domReady",
	"dojo/touch",
	"dojo/_base/window", // win.body
	"./a11yclick",
	"./registry"
], function(array, declare, dom, domClass, has, lang, on, domReady, touch, win, a11yclick, registry){

	// module:
	//		dijit/_CssStateMixin

	var CssStateMixin = declare("dijit._CssStateMixin", [], {
		// summary:
		//		Mixin for widgets to set CSS classes on the widget DOM nodes depending on hover/mouse press/focus
		//		state changes, and also higher-level state changes such becoming disabled or selected.
		//
		// description:
		//		By mixing this class into your widget, and setting the this.baseClass attribute, it will automatically
		//		maintain CSS classes on the widget root node (this.domNode) depending on hover,
		//		active, focus, etc. state.   Ex: with a baseClass of dijitButton, it will apply the classes
		//		dijitButtonHovered and dijitButtonActive, as the user moves the mouse over the widget and clicks it.
		//
		//		It also sets CSS like dijitButtonDisabled based on widget semantic state.
		//
		//		By setting the cssStateNodes attribute, a widget can also track events on subnodes (like buttons
		//		within the widget).

		/*=====
		 // cssStateNodes: [protected] Object
		 //		Subclasses may define a cssStateNodes property that lists sub-nodes within the widget that
		 //		need CSS classes applied on mouse hover/press and focus.
		 //
		 //		Each entry in this optional hash is a an attach-point name (like "upArrowButton") mapped to a CSS class name
		 //		(like "dijitUpArrowButton"). Example:
		 //	|		{
		 //	|			"upArrowButton": "dijitUpArrowButton",
		 //	|			"downArrowButton": "dijitDownArrowButton"
		 //	|		}
		 //		The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
		 //		is hovered, etc.
		 cssStateNodes: {},
		 =====*/

		// hovering: [readonly] Boolean
		//		True if cursor is over this widget
		hovering: false,

		// active: [readonly] Boolean
		//		True if mouse was pressed while over this widget, and hasn't been released yet
		active: false,

		_applyAttributes: function(){
			// This code would typically be in postCreate(), but putting in _applyAttributes() for
			// performance: so the class changes happen before DOM is inserted into the document.
			// Change back to postCreate() in 2.0.  See #11635.

			this.inherited(arguments);

			// Monitoring changes to disabled, readonly, etc. state, and update CSS class of root node
			array.forEach(["disabled", "readOnly", "checked", "selected", "focused", "state", "hovering", "active", "_opened"], function(attr){
				this.watch(attr, lang.hitch(this, "_setStateClass"));
			}, this);

			// Track hover and active mouse events on widget root node, plus possibly on subnodes
			for(var ap in this.cssStateNodes || {}){
				this._trackMouseState(this[ap], this.cssStateNodes[ap]);
			}
			this._trackMouseState(this.domNode, this.baseClass);

			// Set state initially; there's probably no hover/active/focus state but widget might be
			// disabled/readonly/checked/selected so we want to set CSS classes for those conditions.
			this._setStateClass();
		},

		_cssMouseEvent: function(/*Event*/ event){
			// summary:
			//		Handler for CSS event on this.domNode. Sets hovering and active properties depending on mouse state,
			//		which triggers _setStateClass() to set appropriate CSS classes for this.domNode.

			if(!this.disabled){
				switch(event.type){
					case "mouseover":
					case "MSPointerOver":
					case "pointerover":
						this._set("hovering", true);
						this._set("active", this._mouseDown);
						break;
					case "mouseout":
					case "MSPointerOut":
					case "pointerout":
						this._set("hovering", false);
						this._set("active", false);
						break;
					case "mousedown":
					case "touchstart":
					case "MSPointerDown":
					case "pointerdown":
					case "keydown":
						this._set("active", true);
						break;
					case "mouseup":
					case "dojotouchend":
					case "MSPointerUp":
					case "pointerup":
					case "keyup":
						this._set("active", false);
						break;
				}
			}
		},

		_setStateClass: function(){
			// summary:
			//		Update the visual state of the widget by setting the css classes on this.domNode
			//		(or this.stateNode if defined) by combining this.baseClass with
			//		various suffixes that represent the current widget state(s).
			//
			// description:
			//		In the case where a widget has multiple
			//		states, it sets the class based on all possible
			//		combinations.  For example, an invalid form widget that is being hovered
			//		will be "dijitInput dijitInputInvalid dijitInputHover dijitInputInvalidHover".
			//
			//		The widget may have one or more of the following states, determined
			//		by this.state, this.checked, this.valid, and this.selected:
			//
			//		- Error - ValidationTextBox sets this.state to "Error" if the current input value is invalid
			//		- Incomplete - ValidationTextBox sets this.state to "Incomplete" if the current input value is not finished yet
			//		- Checked - ex: a checkmark or a ToggleButton in a checked state, will have this.checked==true
			//		- Selected - ex: currently selected tab will have this.selected==true
			//
			//		In addition, it may have one or more of the following states,
			//		based on this.disabled and flags set in _onMouse (this.active, this.hovering) and from focus manager (this.focused):
			//
			//		- Disabled	- if the widget is disabled
			//		- Active		- if the mouse (or space/enter key?) is being pressed down
			//		- Focused		- if the widget has focus
			//		- Hover		- if the mouse is over the widget

			// Compute new set of classes
			var newStateClasses = this.baseClass.split(" ");

			function multiply(modifier){
				newStateClasses = newStateClasses.concat(array.map(newStateClasses, function(c){
					return c + modifier;
				}), "dijit" + modifier);
			}

			if(!this.isLeftToRight()){
				// For RTL mode we need to set an addition class like dijitTextBoxRtl.
				multiply("Rtl");
			}

			var checkedState = this.checked == "mixed" ? "Mixed" : (this.checked ? "Checked" : "");
			if(this.checked){
				multiply(checkedState);
			}
			if(this.state){
				multiply(this.state);
			}
			if(this.selected){
				multiply("Selected");
			}
			if(this._opened){
				multiply("Opened");
			}

			if(this.disabled){
				multiply("Disabled");
			}else if(this.readOnly){
				multiply("ReadOnly");
			}else{
				if(this.active){
					multiply("Active");
				}else if(this.hovering){
					multiply("Hover");
				}
			}

			if(this.focused){
				multiply("Focused");
			}

			// Remove old state classes and add new ones.
			// For performance concerns we only write into domNode.className once.
			var tn = this.stateNode || this.domNode,
				classHash = {};	// set of all classes (state and otherwise) for node

			array.forEach(tn.className.split(" "), function(c){
				classHash[c] = true;
			});

			if("_stateClasses" in this){
				array.forEach(this._stateClasses, function(c){
					delete classHash[c];
				});
			}

			array.forEach(newStateClasses, function(c){
				classHash[c] = true;
			});

			var newClasses = [];
			for(var c in classHash){
				newClasses.push(c);
			}
			tn.className = newClasses.join(" ");

			this._stateClasses = newStateClasses;
		},

		_subnodeCssMouseEvent: function(node, clazz, evt){
			// summary:
			//		Handler for hover/active mouse event on widget's subnode
			if(this.disabled || this.readOnly){
				return;
			}

			function hover(isHovering){
				domClass.toggle(node, clazz + "Hover", isHovering);
			}

			function active(isActive){
				domClass.toggle(node, clazz + "Active", isActive);
			}

			function focused(isFocused){
				domClass.toggle(node, clazz + "Focused", isFocused);
			}

			switch(evt.type){
				case "mouseover":
				case "MSPointerOver":
				case "pointerover":
					hover(true);
					break;
				case "mouseout":
				case "MSPointerOut":
				case "pointerout":
					hover(false);
					active(false);
					break;
				case "mousedown":
				case "touchstart":
				case "MSPointerDown":
				case "pointerdown":
				case "keydown":
					active(true);
					break;
				case "mouseup":
				case "MSPointerUp":
				case "pointerup":
				case "dojotouchend":
				case "keyup":
					active(false);
					break;
				case "focus":
				case "focusin":
					focused(true);
					break;
				case "blur":
				case "focusout":
					focused(false);
					break;
			}
		},

		_trackMouseState: function(/*DomNode*/ node, /*String*/ clazz){
			// summary:
			//		Track mouse/focus events on specified node and set CSS class on that node to indicate
			//		current state.   Usually not called directly, but via cssStateNodes attribute.
			// description:
			//		Given class=foo, will set the following CSS class on the node
			//
			//		- fooActive: if the user is currently pressing down the mouse button while over the node
			//		- fooHover: if the user is hovering the mouse over the node, but not pressing down a button
			//		- fooFocus: if the node is focused
			//
			//		Note that it won't set any classes if the widget is disabled.
			// node: DomNode
			//		Should be a sub-node of the widget, not the top node (this.domNode), since the top node
			//		is handled specially and automatically just by mixing in this class.
			// clazz: String
			//		CSS class name (ex: dijitSliderUpArrow)

			// Flag for listener code below to call this._cssMouseEvent() or this._subnodeCssMouseEvent()
			// when node is hovered/active
			node._cssState = clazz;
		}
	});

	domReady(function(){
		// Document level listener to catch hover etc. events on widget root nodes and subnodes.
		// Note that when the mouse is moved quickly, a single onmouseenter event could signal that multiple widgets
		// have been hovered or unhovered (try test_Accordion.html)

		function pointerHandler(evt, target, relatedTarget){
			// Handler for mouseover, mouseout, a11yclick.press and a11click.release events

			// Poor man's event propagation.  Don't propagate event to ancestors of evt.relatedTarget,
			// to avoid processing mouseout events moving from a widget's domNode to a descendant node;
			// such events shouldn't be interpreted as a mouseleave on the widget.
			if(relatedTarget && dom.isDescendant(relatedTarget, target)){
				return;
			}

			for(var node = target; node && node != relatedTarget; node = node.parentNode){
				// Process any nodes with _cssState property.   They are generally widget root nodes,
				// but could also be sub-nodes within a widget
				if(node._cssState){
					var widget = registry.getEnclosingWidget(node);
					if(widget){
						if(node == widget.domNode){
							// event on the widget's root node
							widget._cssMouseEvent(evt);
						}else{
							// event on widget's sub-node
							widget._subnodeCssMouseEvent(node, node._cssState, evt);
						}
					}
				}
			}
		}

		var body = win.body(), activeNode;

		// Handle pointer related events (i.e. mouse or touch)
		on(body, touch.over, function(evt){
			// Using touch.over rather than mouseover mainly to ignore phantom mouse events on iOS.
			pointerHandler(evt, evt.target, evt.relatedTarget);
		});
		on(body, touch.out, function(evt){
			// Using touch.out rather than mouseout mainly to ignore phantom mouse events on iOS.
			pointerHandler(evt, evt.target, evt.relatedTarget);
		});
		on(body, a11yclick.press, function(evt){
			// Save the a11yclick.press target to reference when the a11yclick.release comes.
			activeNode = evt.target;
			pointerHandler(evt, activeNode)
		});
		on(body, a11yclick.release, function(evt){
			// The release event could come on a separate node than the press event, if for example user slid finger.
			// Reference activeNode to reset the state of the node that got state set in the a11yclick.press handler.
			pointerHandler(evt, activeNode);
			activeNode = null;
		});

		// Track focus events on widget sub-nodes that have been registered via _trackMouseState().
		// However, don't track focus events on the widget root nodes, because focus is tracked via the
		// focus manager (and it's not really tracking focus, but rather tracking that focus is on one of the widget's
		// nodes or a subwidget's node or a popup node, etc.)
		// Remove for 2.0 (if focus CSS needed, just use :focus pseudo-selector).
		on(body, "focusin, focusout", function(evt){
			var node = evt.target;
			if(node._cssState && !node.getAttribute("widgetId")){
				var widget = registry.getEnclosingWidget(node);
				if(widget){
					widget._subnodeCssMouseEvent(node, node._cssState, evt);
				}
			}
		});
	});

	return CssStateMixin;
});

},
'dijit/_TemplatedMixin':function(){
define([
	"dojo/cache",	// dojo.cache
	"dojo/_base/declare", // declare
	"dojo/dom-construct", // domConstruct.destroy, domConstruct.toDom
	"dojo/_base/lang", // lang.getObject
	"dojo/on",
	"dojo/sniff", // has("ie")
	"dojo/string", // string.substitute string.trim
	"./_AttachMixin"
], function(cache, declare, domConstruct, lang, on, has, string, _AttachMixin){

	// module:
	//		dijit/_TemplatedMixin

	var _TemplatedMixin = declare("dijit._TemplatedMixin", _AttachMixin, {
		// summary:
		//		Mixin for widgets that are instantiated from a template

		// templateString: [protected] String
		//		A string that represents the widget template.
		//		Use in conjunction with dojo.cache() to load from a file.
		templateString: null,

		// templatePath: [protected deprecated] String
		//		Path to template (HTML file) for this widget relative to dojo.baseUrl.
		//		Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
		templatePath: null,

		// skipNodeCache: [protected] Boolean
		//		If using a cached widget template nodes poses issues for a
		//		particular widget class, it can set this property to ensure
		//		that its template is always re-built from a string
		_skipNodeCache: false,

/*=====
		// _rendered: Boolean
		//		Not normally use, but this flag can be set by the app if the server has already rendered the template,
		//		i.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to
		//		just function like _AttachMixin.
		_rendered: false,
=====*/

		// Set _AttachMixin.searchContainerNode to true for back-compat for widgets that have data-dojo-attach-point's
		// and events inside this.containerNode.   Remove for 2.0.
		searchContainerNode: true,

		_stringRepl: function(tmpl){
			// summary:
			//		Does substitution of ${foo} type properties in template string
			// tags:
			//		private
			var className = this.declaredClass, _this = this;
			// Cache contains a string because we need to do property replacement
			// do the property replacement
			return string.substitute(tmpl, this, function(value, key){
				if(key.charAt(0) == '!'){ value = lang.getObject(key.substr(1), false, _this); }
				if(typeof value == "undefined"){ throw new Error(className+" template:"+key); } // a debugging aide
				if(value == null){ return ""; }

				// Substitution keys beginning with ! will skip the transform step,
				// in case a user wishes to insert unescaped markup, e.g. ${!foo}
				return key.charAt(0) == "!" ? value : this._escapeValue("" + value);
			}, this);
		},

		_escapeValue: function(/*String*/ val){
			// summary:
			//		Escape a value to be inserted into the template, either into an attribute value
			//		(ex: foo="${bar}") or as inner text of an element (ex: <span>${foo}</span>)

			// Safer substitution, see heading "Attribute values" in
			// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
			// and also https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet#RULE_.231_-_HTML_Escape_Before_Inserting_Untrusted_Data_into_HTML_Element_Content
			return val.replace(/["'<>&]/g, function(val){
				return {
					"&": "&amp;",
					"<": "&lt;",
					">": "&gt;",
					"\"": "&quot;",
					"'": "&#x27;"
				}[val];
			});
		},

		buildRendering: function(){
			// summary:
			//		Construct the UI for this widget from a template, setting this.domNode.
			// tags:
			//		protected

			if(!this._rendered){
				if(!this.templateString){
					this.templateString = cache(this.templatePath, {sanitize: true});
				}

				// Lookup cached version of template, and download to cache if it
				// isn't there already.  Returns either a DomNode or a string, depending on
				// whether or not the template contains ${foo} replacement parameters.
				var cached = _TemplatedMixin.getCachedTemplate(this.templateString, this._skipNodeCache, this.ownerDocument);

				var node;
				if(lang.isString(cached)){
					node = domConstruct.toDom(this._stringRepl(cached), this.ownerDocument);
					if(node.nodeType != 1){
						// Flag common problems such as templates with multiple top level nodes (nodeType == 11)
						throw new Error("Invalid template: " + cached);
					}
				}else{
					// if it's a node, all we have to do is clone it
					node = cached.cloneNode(true);
				}

				this.domNode = node;
			}

			// Call down to _WidgetBase.buildRendering() to get base classes assigned
			// TODO: change the baseClass assignment to _setBaseClassAttr
			this.inherited(arguments);

			if(!this._rendered){
				this._fillContent(this.srcNodeRef);
			}

			this._rendered = true;
		},

		_fillContent: function(/*DomNode*/ source){
			// summary:
			//		Relocate source contents to templated container node.
			//		this.containerNode must be able to receive children, or exceptions will be thrown.
			// tags:
			//		protected
			var dest = this.containerNode;
			if(source && dest){
				while(source.hasChildNodes()){
					dest.appendChild(source.firstChild);
				}
			}
		}

	});

	// key is templateString; object is either string or DOM tree
	_TemplatedMixin._templateCache = {};

	_TemplatedMixin.getCachedTemplate = function(templateString, alwaysUseString, doc){
		// summary:
		//		Static method to get a template based on the templatePath or
		//		templateString key
		// templateString: String
		//		The template
		// alwaysUseString: Boolean
		//		Don't cache the DOM tree for this template, even if it doesn't have any variables
		// doc: Document?
		//		The target document.   Defaults to document global if unspecified.
		// returns: Mixed
		//		Either string (if there are ${} variables that need to be replaced) or just
		//		a DOM tree (if the node can be cloned directly)

		// is it already cached?
		var tmplts = _TemplatedMixin._templateCache;
		var key = templateString;
		var cached = tmplts[key];
		if(cached){
			try{
				// if the cached value is an innerHTML string (no ownerDocument) or a DOM tree created within the
				// current document, then use the current cached value
				if(!cached.ownerDocument || cached.ownerDocument == (doc || document)){
					// string or node of the same document
					return cached;
				}
			}catch(e){ /* squelch */ } // IE can throw an exception if cached.ownerDocument was reloaded
			domConstruct.destroy(cached);
		}

		templateString = string.trim(templateString);

		if(alwaysUseString || templateString.match(/\$\{([^\}]+)\}/g)){
			// there are variables in the template so all we can do is cache the string
			return (tmplts[key] = templateString); //String
		}else{
			// there are no variables in the template so we can cache the DOM tree
			var node = domConstruct.toDom(templateString, doc);
			if(node.nodeType != 1){
				throw new Error("Invalid template: " + templateString);
			}
			return (tmplts[key] = node); //Node
		}
	};

	if(has("ie")){
		on(window, "unload", function(){
			var cache = _TemplatedMixin._templateCache;
			for(var key in cache){
				var value = cache[key];
				if(typeof value == "object"){ // value is either a string or a DOM node template
					domConstruct.destroy(value);
				}
				delete cache[key];
			}
		});
	}

	return _TemplatedMixin;
});

},
'dojo/cache':function(){
define(["./_base/kernel", "./text"], function(dojo){
	// module:
	//		dojo/cache

	// dojo.cache is defined in dojo/text
	return dojo.cache;
});

},
'dijit/_AttachMixin':function(){
define([
	"require",
	"dojo/_base/array", // array.forEach
	"dojo/_base/connect",	// remove for 2.0
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.getObject
	"dojo/mouse",
	"dojo/on",
	"dojo/touch",
	"./_WidgetBase"
], function(require, array, connect, declare, lang, mouse, on, touch, _WidgetBase){

	// module:
	//		dijit/_AttachMixin

	// Map from string name like "mouseenter" to synthetic event like mouse.enter
	var synthEvents = lang.delegate(touch, {
		"mouseenter": mouse.enter,
		"mouseleave": mouse.leave,
		"keypress": connect._keypress	// remove for 2.0
	});

	// To be lightweight, _AttachMixin doesn't require() dijit/a11yclick.
	// If the subclass has a template using "ondijitclick", it must load dijit/a11yclick itself.
	// In that case, the a11yclick variable below will get set to point to that synthetic event.
	var a11yclick;

	var _AttachMixin = declare("dijit._AttachMixin", null, {
		// summary:
		//		Mixin for widgets to attach to dom nodes and setup events via
		//		convenient data-dojo-attach-point and data-dojo-attach-event DOM attributes.
		//
		//		Superclass of _TemplatedMixin, and can also be used standalone when templates are pre-rendered on the
		//		server.
		//
		//		Does not [yet] handle widgets like ContentPane with this.containerNode set.   It should skip
		//		scanning for data-dojo-attach-point and data-dojo-attach-event inside this.containerNode, but it
		//		doesn't.

/*=====
		// _attachPoints: [private] String[]
		//		List of widget attribute names associated with data-dojo-attach-point=... in the
		//		template, ex: ["containerNode", "labelNode"]
		_attachPoints: [],

		// _attachEvents: [private] Handle[]
		//		List of connections associated with data-dojo-attach-event=... in the
		//		template
		_attachEvents: [],

		// attachScope: [public] Object
		//		Object to which attach points and events will be scoped.  Defaults
		//		to 'this'.
		attachScope: undefined,

		// searchContainerNode: [protected] Boolean
		//		Search descendants of this.containerNode for data-dojo-attach-point and data-dojo-attach-event.
		//		Should generally be left false (the default value) both for performance and to avoid failures when
		//		this.containerNode holds other _AttachMixin instances with their own attach points and events.
 		searchContainerNode: false,
 =====*/

		constructor: function(/*===== params, srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree.

			this._attachPoints = [];
			this._attachEvents = [];
		},


		buildRendering: function(){
			// summary:
			//		Attach to DOM nodes marked with special attributes.
			// tags:
			//		protected

			this.inherited(arguments);

			// recurse through the node, looking for, and attaching to, our
			// attachment points and events, which should be defined on the template node.
			this._attachTemplateNodes(this.domNode);

			this._beforeFillContent();		// hook for _WidgetsInTemplateMixin
		},

		_beforeFillContent: function(){
		},

		_attachTemplateNodes: function(rootNode){
			// summary:
			//		Iterate through the dom nodes and attach functions and nodes accordingly.
			// description:
			//		Map widget properties and functions to the handlers specified in
			//		the dom node and it's descendants. This function iterates over all
			//		nodes and looks for these properties:
			//
			//		- dojoAttachPoint/data-dojo-attach-point
			//		- dojoAttachEvent/data-dojo-attach-event
			// rootNode: DomNode
			//		The node to search for properties. All descendants will be searched.
			// tags:
			//		private

			// DFS to process all nodes except those inside of this.containerNode
			var node = rootNode;
			while(true){
				if(node.nodeType == 1 && (this._processTemplateNode(node, function(n,p){ return n.getAttribute(p); },
						this._attach) || this.searchContainerNode) && node.firstChild){
					node = node.firstChild;
				}else{
					if(node == rootNode){ return; }
					while(!node.nextSibling){
						node = node.parentNode;
						if(node == rootNode){ return; }
					}
					node = node.nextSibling;
				}
			}
		},

		_processTemplateNode: function(/*DOMNode|Widget*/ baseNode, getAttrFunc, attachFunc){
			// summary:
			//		Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.
			//		Returns true if caller should process baseNode's children too.

			var ret = true;

			// Process data-dojo-attach-point
			var _attachScope = this.attachScope || this,
				attachPoint = getAttrFunc(baseNode, "dojoAttachPoint") || getAttrFunc(baseNode, "data-dojo-attach-point");
			if(attachPoint){
				var point, points = attachPoint.split(/\s*,\s*/);
				while((point = points.shift())){
					if(lang.isArray(_attachScope[point])){
						_attachScope[point].push(baseNode);
					}else{
						_attachScope[point] = baseNode;
					}
					ret = (point != "containerNode");
					this._attachPoints.push(point);
				}
			}

			// Process data-dojo-attach-event
			var attachEvent = getAttrFunc(baseNode, "dojoAttachEvent") || getAttrFunc(baseNode, "data-dojo-attach-event");
			if(attachEvent){
				// NOTE: we want to support attributes that have the form
				// "domEvent: nativeEvent; ..."
				var event, events = attachEvent.split(/\s*,\s*/);
				var trim = lang.trim;
				while((event = events.shift())){
					if(event){
						var thisFunc = null;
						if(event.indexOf(":") != -1){
							// oh, if only JS had tuple assignment
							var funcNameArr = event.split(":");
							event = trim(funcNameArr[0]);
							thisFunc = trim(funcNameArr[1]);
						}else{
							event = trim(event);
						}
						if(!thisFunc){
							thisFunc = event;
						}

						this._attachEvents.push(attachFunc(baseNode, event, lang.hitch(_attachScope, thisFunc)));
					}
				}
			}

			return ret;
		},

		_attach: function(node, type, func){
			// summary:
			//		Roughly corresponding to dojo/on, this is the default function for processing a
			//		data-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.
			// node: DOMNode
			//		The node to setup a listener on.
			// type: String
			//		Event name like "click".
			// getAttrFunc: Function
			//		Function to get the specified property for a given DomNode/Widget.
			// attachFunc: Function?
			//		Attaches an event handler from the specified node/widget to specified function.

			// Map special type names like "mouseenter" to synthetic events.
			// Subclasses are responsible to require() dijit/a11yclick if they want to use it.
			type = type.replace(/^on/, "").toLowerCase();
			if(type == "dijitclick"){
				type = a11yclick || (a11yclick = require("./a11yclick"));
			}else{
				type = synthEvents[type] || type;
			}

			return on(node, type, func);
		},

		_detachTemplateNodes: function() {
			// summary:
			//		Detach and clean up the attachments made in _attachtempalteNodes.

			// Delete all attach points to prevent IE6 memory leaks.
			var _attachScope = this.attachScope || this;
			array.forEach(this._attachPoints, function(point){
				delete _attachScope[point];
			});
			this._attachPoints = [];

			// And same for event handlers
			array.forEach(this._attachEvents, function(handle){ handle.remove(); });
			this._attachEvents = [];
		},

		destroyRendering: function(){
			this._detachTemplateNodes();
			this.inherited(arguments);
		}
	});

	// These arguments can be specified for widgets which are used in templates.
	// Since any widget can be specified as sub widgets in template, mix it
	// into the base widget class.  (This is a hack, but it's effective.).
	// Remove for 2.0.   Also, hide from API doc parser.
	lang.extend(_WidgetBase, /*===== {} || =====*/ {
		dojoAttachEvent: "",
		dojoAttachPoint: ""
	});
	
	return _AttachMixin;
});

},
'dijit/form/_FormWidgetMixin':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-style", // domStyle.get
	"dojo/_base/lang", // lang.hitch lang.isArray
	"dojo/mouse", // mouse.isLeft
	"dojo/on",
	"dojo/sniff", // has("webkit")
	"dojo/window", // winUtils.scrollIntoView
	"../a11y"    // a11y.hasDefaultTabStop
], function(array, declare, domAttr, domStyle, lang, mouse, on, has, winUtils, a11y){

	// module:
	//		dijit/form/_FormWidgetMixin

	return declare("dijit.form._FormWidgetMixin", null, {
		// summary:
		//		Mixin for widgets corresponding to native HTML elements such as `<checkbox>` or `<button>`,
		//		which can be children of a `<form>` node or a `dijit/form/Form` widget.
		//
		// description:
		//		Represents a single HTML element.
		//		All these widgets should have these attributes just like native HTML input elements.
		//		You can set them during widget construction or afterwards, via `dijit/_WidgetBase.set()`.
		//
		//		They also share some common methods.

		// name: [const] String
		//		Name used when submitting form; same as "name" attribute or plain HTML elements
		name: "",

		// alt: String
		//		Corresponds to the native HTML `<input>` element's attribute.
		alt: "",

		// value: String
		//		Corresponds to the native HTML `<input>` element's attribute.
		value: "",

		// type: [const] String
		//		Corresponds to the native HTML `<input>` element's attribute.
		type: "text",

		// type: String
		//		Apply aria-label in markup to the widget's focusNode
		"aria-label": "focusNode",

		// tabIndex: String
		//		Order fields are traversed when user hits the tab key
		tabIndex: "0",
		_setTabIndexAttr: "focusNode", // force copy even when tabIndex default value, needed since Button is <span>

		// disabled: Boolean
		//		Should this widget respond to user input?
		//		In markup, this is specified as "disabled='disabled'", or just "disabled".
		disabled: false,

		// intermediateChanges: Boolean
		//		Fires onChange for each value change or only on demand
		intermediateChanges: false,

		// scrollOnFocus: Boolean
		//		On focus, should this widget scroll into view?
		scrollOnFocus: true,

		// Override _WidgetBase mapping id to this.domNode, needs to be on focusNode so <label> etc.
		// works with screen reader
		_setIdAttr: "focusNode",

		_setDisabledAttr: function(/*Boolean*/ value){
			this._set("disabled", value);
			domAttr.set(this.focusNode, 'disabled', value);
			if(this.valueNode){
				domAttr.set(this.valueNode, 'disabled', value);
			}
			this.focusNode.setAttribute("aria-disabled", value ? "true" : "false");

			if(value){
				// reset these, because after the domNode is disabled, we can no longer receive
				// mouse related events, see #4200
				this._set("hovering", false);
				this._set("active", false);

				// clear tab stop(s) on this widget's focusable node(s)  (ComboBox has two focusable nodes)
				var attachPointNames = "tabIndex" in this.attributeMap ? this.attributeMap.tabIndex :
					("_setTabIndexAttr" in this) ? this._setTabIndexAttr : "focusNode";
				array.forEach(lang.isArray(attachPointNames) ? attachPointNames : [attachPointNames], function(attachPointName){
					var node = this[attachPointName];
					// complex code because tabIndex=-1 on a <div> doesn't work on FF
					if(has("webkit") || a11y.hasDefaultTabStop(node)){    // see #11064 about webkit bug
						node.setAttribute('tabIndex', "-1");
					}else{
						node.removeAttribute('tabIndex');
					}
				}, this);
			}else{
				if(this.tabIndex != ""){
					this.set('tabIndex', this.tabIndex);
				}
			}
		},

		_onFocus: function(/*String*/ by){
			// If user clicks on the widget, even if the mouse is released outside of it,
			// this widget's focusNode should get focus (to mimic native browser behavior).
			// Browsers often need help to make sure the focus via mouse actually gets to the focusNode.
			// TODO: consider removing all of this for 2.0 or sooner, see #16622 etc.
			if(by == "mouse" && this.isFocusable()){
				// IE exhibits strange scrolling behavior when refocusing a node so only do it when !focused.
				var focusHandle = this.own(on(this.focusNode, "focus", function(){
					mouseUpHandle.remove();
					focusHandle.remove();
				}))[0];
				// Set a global event to handle mouseup, so it fires properly
				// even if the cursor leaves this.domNode before the mouse up event.
				var event = has("pointer-events") ? "pointerup" : has("MSPointer") ? "MSPointerUp" :
					has("touch-events") ? "touchend, mouseup" :		// seems like overkill but see #16622, #16725
					"mouseup";
				var mouseUpHandle = this.own(on(this.ownerDocumentBody, event, lang.hitch(this, function(evt){
					mouseUpHandle.remove();
					focusHandle.remove();
					// if here, then the mousedown did not focus the focusNode as the default action
					if(this.focused){
						if(evt.type == "touchend"){
							this.defer("focus"); // native focus hasn't occurred yet
						}else{
							this.focus(); // native focus already occurred on mousedown
						}
					}
				})))[0];
			}
			if(this.scrollOnFocus){
				this.defer(function(){
					winUtils.scrollIntoView(this.domNode);
				}); // without defer, the input caret position can change on mouse click
			}
			this.inherited(arguments);
		},

		isFocusable: function(){
			// summary:
			//		Tells if this widget is focusable or not.  Used internally by dijit.
			// tags:
			//		protected
			return !this.disabled && this.focusNode && (domStyle.get(this.domNode, "display") != "none");
		},

		focus: function(){
			// summary:
			//		Put focus on this widget
			if(!this.disabled && this.focusNode.focus){
				try{
					this.focusNode.focus();
				}catch(e){
				}
				/*squelch errors from hidden nodes*/
			}
		},

		compare: function(/*anything*/ val1, /*anything*/ val2){
			// summary:
			//		Compare 2 values (as returned by get('value') for this widget).
			// tags:
			//		protected
			if(typeof val1 == "number" && typeof val2 == "number"){
				return (isNaN(val1) && isNaN(val2)) ? 0 : val1 - val2;
			}else if(val1 > val2){
				return 1;
			}else if(val1 < val2){
				return -1;
			}else{
				return 0;
			}
		},

		onChange: function(/*===== newValue =====*/){
			// summary:
			//		Callback when this widget's value is changed.
			// tags:
			//		callback
		},

		// _onChangeActive: [private] Boolean
		//		Indicates that changes to the value should call onChange() callback.
		//		This is false during widget initialization, to avoid calling onChange()
		//		when the initial value is set.
		_onChangeActive: false,

		_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
			// summary:
			//		Called when the value of the widget is set.  Calls onChange() if appropriate
			// newValue:
			//		the new value
			// priorityChange:
			//		For a slider, for example, dragging the slider is priorityChange==false,
			//		but on mouse up, it's priorityChange==true.  If intermediateChanges==false,
			//		onChange is only called form priorityChange=true events.
			// tags:
			//		private
			if(this._lastValueReported == undefined && (priorityChange === null || !this._onChangeActive)){
				// this block executes not for a change, but during initialization,
				// and is used to store away the original value (or for ToggleButton, the original checked state)
				this._resetValue = this._lastValueReported = newValue;
			}
			this._pendingOnChange = this._pendingOnChange
				|| (typeof newValue != typeof this._lastValueReported)
				|| (this.compare(newValue, this._lastValueReported) != 0);
			if((this.intermediateChanges || priorityChange || priorityChange === undefined) && this._pendingOnChange){
				this._lastValueReported = newValue;
				this._pendingOnChange = false;
				if(this._onChangeActive){
					if(this._onChangeHandle){
						this._onChangeHandle.remove();
					}
					// defer allows hidden value processing to run and
					// also the onChange handler can safely adjust focus, etc
					this._onChangeHandle = this.defer(
						function(){
							this._onChangeHandle = null;
							this.onChange(newValue);
						}); // try to collapse multiple onChange's fired faster than can be processed
				}
			}
		},

		create: function(){
			// Overrides _Widget.create()
			this.inherited(arguments);
			this._onChangeActive = true;
		},

		destroy: function(){
			if(this._onChangeHandle){ // destroy called before last onChange has fired
				this._onChangeHandle.remove();
				this.onChange(this._lastValueReported);
			}
			this.inherited(arguments);
		}
	});
});

},
'dijit/form/_ButtonMixin':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"dojo/has",
	"../registry"        // registry.byNode
], function(declare, dom, has, registry){

	// module:
	//		dijit/form/_ButtonMixin

	var ButtonMixin = declare("dijit.form._ButtonMixin" + (has("dojo-bidi") ? "_NoBidi" : ""), null, {
		// summary:
		//		A mixin to add a thin standard API wrapper to a normal HTML button
		// description:
		//		A label should always be specified (through innerHTML) or the label attribute.
		//
		//		Attach points:
		//
		//		- focusNode (required): this node receives focus
		//		- valueNode (optional): this node's value gets submitted with FORM elements
		//		- containerNode (optional): this node gets the innerHTML assignment for label
		// example:
		// |	<button data-dojo-type="dijit/form/Button" onClick="...">Hello world</button>
		// example:
		// |	var button1 = new Button({label: "hello world", onClick: foo});
		// |	dojo.body().appendChild(button1.domNode);

		// label: HTML String
		//		Content to display in button.
		label: "",

		// type: [const] String
		//		Type of button (submit, reset, button, checkbox, radio)
		type: "button",

		__onClick: function(/*Event*/ e){
			// summary:
			//		Internal function to divert the real click onto the hidden INPUT that has a native default action associated with it
			// type:
			//		private
			e.stopPropagation();
			e.preventDefault();
			if(!this.disabled){
				// cannot use on.emit since button default actions won't occur
				this.valueNode.click(e);
			}
			return false;
		},

		_onClick: function(/*Event*/ e){
			// summary:
			//		Internal function to handle click actions
			if(this.disabled){
				e.stopPropagation();
				e.preventDefault();
				return false;
			}
			if(this.onClick(e) === false){
				e.preventDefault();
			}
			var cancelled = e.defaultPrevented;

			// Signal Form/Dialog to submit/close.  For 2.0, consider removing this code and instead making the Form/Dialog
			// listen for bubbled click events where evt.target.type == "submit" && !evt.defaultPrevented.
			if(!cancelled && this.type == "submit" && !(this.valueNode || this.focusNode).form){
				for(var node = this.domNode; node.parentNode; node = node.parentNode){
					var widget = registry.byNode(node);
					if(widget && typeof widget._onSubmit == "function"){
						widget._onSubmit(e);
						e.preventDefault(); // action has already occurred
						cancelled = true;
						break;
					}
				}
			}

			return !cancelled;
		},

		postCreate: function(){
			this.inherited(arguments);
			dom.setSelectable(this.focusNode, false);
		},

		onClick: function(/*Event*/ /*===== e =====*/){
			// summary:
			//		Callback for when button is clicked.
			//		If type="submit", return true to perform submit, or false to cancel it.
			// type:
			//		callback
			return true;		// Boolean
		},

		_setLabelAttr: function(/*String*/ content){
			// summary:
			//		Hook for set('label', ...) to work.
			// description:
			//		Set the label (text) of the button; takes an HTML string.
			this._set("label", content);
			var labelNode = this.containerNode || this.focusNode;
			labelNode.innerHTML = content;
		}
	});

	if(has("dojo-bidi")){
		ButtonMixin = declare("dijit.form._ButtonMixin", ButtonMixin, {
			_setLabelAttr: function(){
				this.inherited(arguments);
				var labelNode = this.containerNode || this.focusNode;
				this.applyTextDir(labelNode);
			}
		});
	}

	return ButtonMixin;
});

},
'dijit/Dialog':function(){
define([
	"require",
	"dojo/_base/array", // array.forEach array.indexOf array.map
	"dojo/aspect",
	"dojo/_base/declare", // declare
	"dojo/Deferred", // Deferred
	"dojo/dom", // dom.isDescendant
	"dojo/dom-class", // domClass.add domClass.contains
	"dojo/dom-geometry", // domGeometry.position
	"dojo/dom-style", // domStyle.set
	"dojo/_base/fx", // fx.fadeIn fx.fadeOut
	"dojo/i18n", // i18n.getLocalization
	"dojo/keys",
	"dojo/_base/lang", // lang.mixin lang.hitch
	"dojo/on",
	"dojo/ready",
	"dojo/sniff", // has("ie") has("opera") has("dijit-legacy-requires")
	"dojo/window", // winUtils.getBox, winUtils.get
	"dojo/dnd/Moveable", // Moveable
	"dojo/dnd/TimedMoveable", // TimedMoveable
	"./focus",
	"./_base/manager", // manager.defaultDuration
	"./_Widget",
	"./_TemplatedMixin",
	"./_CssStateMixin",
	"./form/_FormMixin",
	"./_DialogMixin",
	"./DialogUnderlay",
	"./layout/ContentPane",
	"./layout/utils",
	"dojo/text!./templates/Dialog.html",
	"./a11yclick",	// template uses ondijitclick
	"dojo/i18n!./nls/common"
], function(require, array, aspect, declare, Deferred,
			dom, domClass, domGeometry, domStyle, fx, i18n, keys, lang, on, ready, has, winUtils,
			Moveable, TimedMoveable, focus, manager, _Widget, _TemplatedMixin, _CssStateMixin, _FormMixin, _DialogMixin,
			DialogUnderlay, ContentPane, utils, template){

	// module:
	//		dijit/Dialog

	var resolvedDeferred = new Deferred();
	resolvedDeferred.resolve(true);

	var _DialogBase = declare("dijit._DialogBase" + (has("dojo-bidi") ? "_NoBidi" : ""), [_TemplatedMixin, _FormMixin, _DialogMixin, _CssStateMixin], {
		templateString: template,

		baseClass: "dijitDialog",

		cssStateNodes: {
			closeButtonNode: "dijitDialogCloseIcon"
		},

		// Map widget attributes to DOMNode attributes.
		_setTitleAttr: { node: "titleNode", type: "innerHTML" },

		// open: [readonly] Boolean
		//		True if Dialog is currently displayed on screen.
		open: false,

		// duration: Integer
		//		The time in milliseconds it takes the dialog to fade in and out
		duration: manager.defaultDuration,

		// refocus: Boolean
		//		A Toggle to modify the default focus behavior of a Dialog, which
		//		is to re-focus the element which had focus before being opened.
		//		False will disable refocusing. Default: true
		refocus: true,

		// autofocus: Boolean
		//		A Toggle to modify the default focus behavior of a Dialog, which
		//		is to focus on the first dialog element after opening the dialog.
		//		False will disable autofocusing. Default: true
		autofocus: true,

		// _firstFocusItem: [private readonly] DomNode
		//		The pointer to the first focusable node in the dialog.
		//		Set by `dijit/_DialogMixin._getFocusItems()`.
		_firstFocusItem: null,

		// _lastFocusItem: [private readonly] DomNode
		//		The pointer to which node has focus prior to our dialog.
		//		Set by `dijit/_DialogMixin._getFocusItems()`.
		_lastFocusItem: null,

		// draggable: Boolean
		//		Toggles the movable aspect of the Dialog. If true, Dialog
		//		can be dragged by it's title. If false it will remain centered
		//		in the viewport.
		draggable: true,
		_setDraggableAttr: function(/*Boolean*/ val){
			// Avoid _WidgetBase behavior of copying draggable attribute to this.domNode,
			// as that prevents text select on modern browsers (#14452)
			this._set("draggable", val);
		},

		// maxRatio: Number
		//		Maximum size to allow the dialog to expand to, relative to viewport size
		maxRatio: 0.9,

		// closable: Boolean
		//		Dialog show [x] icon to close itself, and ESC key will close the dialog.
		closable: true,
		_setClosableAttr: function(val){
			this.closeButtonNode.style.display = val ? "" : "none";
			this._set("closable", val);
		},

		postMixInProperties: function(){
			var _nlsResources = i18n.getLocalization("dijit", "common");
			lang.mixin(this, _nlsResources);
			this.inherited(arguments);
		},

		postCreate: function(){
			domStyle.set(this.domNode, {
				display: "none",
				position: "absolute"
			});
			this.ownerDocumentBody.appendChild(this.domNode);

			this.inherited(arguments);

			aspect.after(this, "onExecute", lang.hitch(this, "hide"), true);
			aspect.after(this, "onCancel", lang.hitch(this, "hide"), true);

			this._modalconnects = [];
		},

		onLoad: function(){
			// summary:
			//		Called when data has been loaded from an href.
			//		Unlike most other callbacks, this function can be connected to (via `dojo.connect`)
			//		but should *not* be overridden.
			// tags:
			//		callback

			// when href is specified we need to reposition the dialog after the data is loaded
			// and find the focusable elements
			this.resize();
			this._position();

			if(this.autofocus && DialogLevelManager.isTop(this)){
				this._getFocusItems();
				focus.focus(this._firstFocusItem);
			}

			this.inherited(arguments);
		},

		focus: function(){
			this._getFocusItems();
			focus.focus(this._firstFocusItem);
		},

		_endDrag: function(){
			// summary:
			//		Called after dragging the Dialog. Saves the position of the dialog in the viewport,
			//		and also adjust position to be fully within the viewport, so user doesn't lose access to handle
			var nodePosition = domGeometry.position(this.domNode),
				viewport = winUtils.getBox(this.ownerDocument);
			nodePosition.y = Math.min(Math.max(nodePosition.y, 0), (viewport.h - nodePosition.h));
			nodePosition.x = Math.min(Math.max(nodePosition.x, 0), (viewport.w - nodePosition.w));
			this._relativePosition = nodePosition;
			this._position();
		},

		_setup: function(){
			// summary:
			//		Stuff we need to do before showing the Dialog for the first
			//		time (but we defer it until right beforehand, for
			//		performance reasons).
			// tags:
			//		private

			var node = this.domNode;

			if(this.titleBar && this.draggable){
				this._moveable = new ((has("ie") == 6) ? TimedMoveable // prevent overload, see #5285
					: Moveable)(node, { handle: this.titleBar });
				aspect.after(this._moveable, "onMoveStop", lang.hitch(this, "_endDrag"), true);
			}else{
				domClass.add(node, "dijitDialogFixed");
			}

			this.underlayAttrs = {
				dialogId: this.id,
				"class": array.map(this["class"].split(/\s/),function(s){
					return s + "_underlay";
				}).join(" "),
				_onKeyDown: lang.hitch(this, "_onKey"),
				ownerDocument: this.ownerDocument
			};
		},

		_size: function(){
			// TODO: remove for 2.0
			this.resize();
		},

		_position: function(){
			// summary:
			//		Position the dialog in the viewport.  If no relative offset
			//		in the viewport has been determined (by dragging, for instance),
			//		center the dialog.  Otherwise, use the Dialog's stored relative offset,
			//		adjusted by the viewport's scroll.
			if(!domClass.contains(this.ownerDocumentBody, "dojoMove")){    // don't do anything if called during auto-scroll
				var node = this.domNode,
					viewport = winUtils.getBox(this.ownerDocument),
					p = this._relativePosition,
					bb = p ? null : domGeometry.position(node),
					l = Math.floor(viewport.l + (p ? p.x : (viewport.w - bb.w) / 2)),
					t = Math.floor(viewport.t + (p ? p.y : (viewport.h - bb.h) / 2))
					;
				domStyle.set(node, {
					left: l + "px",
					top: t + "px"
				});
			}
		},

		_onKey: function(/*Event*/ evt){
			// summary:
			//		Handles the keyboard events for accessibility reasons
			// tags:
			//		private

			if(evt.keyCode == keys.TAB){
				this._getFocusItems();
				var node = evt.target;
				if(this._firstFocusItem == this._lastFocusItem){
					// don't move focus anywhere, but don't allow browser to move focus off of dialog either
					evt.stopPropagation();
					evt.preventDefault();
				}else if(node == this._firstFocusItem && evt.shiftKey){
					// if we are shift-tabbing from first focusable item in dialog, send focus to last item
					focus.focus(this._lastFocusItem);
					evt.stopPropagation();
					evt.preventDefault();
				}else if(node == this._lastFocusItem && !evt.shiftKey){
					// if we are tabbing from last focusable item in dialog, send focus to first item
					focus.focus(this._firstFocusItem);
					evt.stopPropagation();
					evt.preventDefault();
				}
			}else if(this.closable && evt.keyCode == keys.ESCAPE){
				this.onCancel();
				evt.stopPropagation();
				evt.preventDefault();
			}
		},

		show: function(){
			// summary:
			//		Display the dialog
			// returns: dojo/promise/Promise
			//		Promise object that resolves when the display animation is complete

			if(this.open){
				return resolvedDeferred.promise;
			}

			if(!this._started){
				this.startup();
			}

			// first time we show the dialog, there's some initialization stuff to do
			if(!this._alreadyInitialized){
				this._setup();
				this._alreadyInitialized = true;
			}

			if(this._fadeOutDeferred){
				// There's a hide() operation in progress, so cancel it, but still call DialogLevelManager.hide()
				// as though the hide() completed, in preparation for the DialogLevelManager.show() call below.
				this._fadeOutDeferred.cancel();
				DialogLevelManager.hide(this);
			}

			// Recenter Dialog if user scrolls browser.  Connecting to document doesn't work on IE, need to use window.
			// Be sure that event object doesn't get passed to resize() method, because it's expecting an optional
			// {w: ..., h:...} arg.
			var win = winUtils.get(this.ownerDocument);
			this._modalconnects.push(on(win, "scroll", lang.hitch(this, "resize", null)));

			this._modalconnects.push(on(this.domNode, "keydown", lang.hitch(this, "_onKey")));

			domStyle.set(this.domNode, {
				opacity: 0,
				display: ""
			});

			this._set("open", true);
			this._onShow(); // lazy load trigger

			this.resize();
			this._position();

			// fade-in Animation object, setup below
			var fadeIn;

			this._fadeInDeferred = new Deferred(lang.hitch(this, function(){
				fadeIn.stop();
				delete this._fadeInDeferred;
			}));

			// If delay is 0, code below will delete this._fadeInDeferred instantly, so grab promise while we can.
			var promise = this._fadeInDeferred.promise;

			fadeIn = fx.fadeIn({
				node: this.domNode,
				duration: this.duration,
				beforeBegin: lang.hitch(this, function(){
					DialogLevelManager.show(this, this.underlayAttrs);
				}),
				onEnd: lang.hitch(this, function(){
					if(this.autofocus && DialogLevelManager.isTop(this)){
						// find focusable items each time dialog is shown since if dialog contains a widget the
						// first focusable items can change
						this._getFocusItems();
						focus.focus(this._firstFocusItem);
					}
					this._fadeInDeferred.resolve(true);
					delete this._fadeInDeferred;
				})
			}).play();

			return promise;
		},

		hide: function(){
			// summary:
			//		Hide the dialog
			// returns: dojo/promise/Promise
			//		Promise object that resolves when the display animation is complete

			// If we haven't been initialized yet then we aren't showing and we can just return.
			// Likewise if we are already hidden, or are currently fading out.
			if(!this._alreadyInitialized || !this.open){
				return resolvedDeferred.promise;
			}
			if(this._fadeInDeferred){
				this._fadeInDeferred.cancel();
			}

			// fade-in Animation object, setup below
			var fadeOut;

			this._fadeOutDeferred = new Deferred(lang.hitch(this, function(){
				fadeOut.stop();
				delete this._fadeOutDeferred;
			}));

			// fire onHide when the promise resolves.
			this._fadeOutDeferred.then(lang.hitch(this, 'onHide'));

			// If delay is 0, code below will delete this._fadeOutDeferred instantly, so grab promise while we can.
			var promise = this._fadeOutDeferred.promise;

			fadeOut = fx.fadeOut({
				node: this.domNode,
				duration: this.duration,
				onEnd: lang.hitch(this, function(){
					this.domNode.style.display = "none";
					DialogLevelManager.hide(this);
					this._fadeOutDeferred.resolve(true);
					delete this._fadeOutDeferred;
				})
			}).play();

			if(this._scrollConnected){
				this._scrollConnected = false;
			}
			var h;
			while(h = this._modalconnects.pop()){
				h.remove();
			}

			if(this._relativePosition){
				delete this._relativePosition;
			}
			this._set("open", false);

			return promise;
		},

		resize: function(dim){
			// summary:
			//		Called with no argument when viewport scrolled or viewport size changed.  Adjusts Dialog as
			//		necessary to keep it visible.
			//
			//		Can also be called with an argument (by dojox/layout/ResizeHandle etc.) to explicitly set the
			//		size of the dialog.
			// dim: Object?
			//		Optional dimension object like {w: 200, h: 300}

			if(this.domNode.style.display != "none"){

				this._checkIfSingleChild();

				if(!dim){
					if(this._shrunk){
						// If we earlier shrunk the dialog to fit in the viewport, reset it to its natural size
						if(this._singleChild){
							if(typeof this._singleChildOriginalStyle != "undefined"){
								this._singleChild.domNode.style.cssText = this._singleChildOriginalStyle;
								delete this._singleChildOriginalStyle;
							}
						}
						array.forEach([this.domNode, this.containerNode, this.titleBar], function(node){
							domStyle.set(node, {
								position: "static",
								width: "auto",
								height: "auto"
							});
						});
						this.domNode.style.position = "absolute";
					}

					// If necessary, shrink Dialog to fit in viewport and have some space around it
					// to indicate that it's a popup.  This will also compensate for possible scrollbars on viewport.
					var viewport = winUtils.getBox(this.ownerDocument);
					viewport.w *= this.maxRatio;
					viewport.h *= this.maxRatio;

					var bb = domGeometry.position(this.domNode);
					if(bb.w >= viewport.w || bb.h >= viewport.h){
						dim = {
							w: Math.min(bb.w, viewport.w),
							h: Math.min(bb.h, viewport.h)
						};
						this._shrunk = true;
					}else{
						this._shrunk = false;
					}
				}

				// Code to run if user has requested an explicit size, or the shrinking code above set an implicit size
				if(dim){
					// Set this.domNode to specified size
					domGeometry.setMarginBox(this.domNode, dim);

					// And then size this.containerNode
					var contentDim = utils.marginBox2contentBox(this.domNode, dim),
						centerSize = {domNode: this.containerNode, region: "center"};
					utils.layoutChildren(this.domNode, contentDim,
						[ {domNode: this.titleBar, region: "top"}, centerSize ]);

					// And then if this.containerNode has a single layout widget child, size it too.
					// Otherwise, make this.containerNode show a scrollbar if it's overflowing.
					if(this._singleChild){
						var cb = utils.marginBox2contentBox(this.containerNode, centerSize);
						// note: if containerNode has padding singleChildSize will have l and t set,
						// but don't pass them to resize() or it will doubly-offset the child
						this._singleChild.resize({w: cb.w, h: cb.h});
						// TODO: save original size for restoring it on another show()?
					}else{
						this.containerNode.style.overflow = "auto";
						this._layoutChildren();		// send resize() event to all child widgets
					}
				}else{
					this._layoutChildren();		// send resize() event to all child widgets
				}

				if(!has("touch") && !dim){
					// If the user has scrolled the viewport then reposition the Dialog.  But don't do it for touch
					// devices, because it will counteract when a keyboard pops up and then the browser auto-scrolls
					// the focused node into view.
					this._position();
				}
			}
		},

		_layoutChildren: function(){
			// Override _ContentPaneResizeMixin._layoutChildren because even when there's just a single layout child
			// widget, sometimes we don't want to size it explicitly (i.e. to pass a dim argument to resize())

			array.forEach(this.getChildren(), function(widget){
				if(widget.resize){
					widget.resize();
				}
			});
		},

		destroy: function(){
			if(this._fadeInDeferred){
				this._fadeInDeferred.cancel();
			}
			if(this._fadeOutDeferred){
				this._fadeOutDeferred.cancel();
			}
			if(this._moveable){
				this._moveable.destroy();
			}
			var h;
			while(h = this._modalconnects.pop()){
				h.remove();
			}

			DialogLevelManager.hide(this);

			this.inherited(arguments);
		}
	});

	if(has("dojo-bidi")){
		_DialogBase = declare("dijit._DialogBase", _DialogBase, {
			_setTitleAttr: function(/*String*/ title){
				this._set("title", title);
				this.titleNode.innerHTML = title;
				this.applyTextDir(this.titleNode);
			},

			_setTextDirAttr: function(textDir){
				if(this._created && this.textDir != textDir){
					this._set("textDir", textDir);
					this.set("title", this.title);
				}
			}
		});
	}

	var Dialog = declare("dijit.Dialog", [ContentPane, _DialogBase], {
		// summary:
		//		A modal dialog Widget.
		// description:
		//		Pops up a modal dialog window, blocking access to the screen
		//		and also graying out the screen Dialog is extended from
		//		ContentPane so it supports all the same parameters (href, etc.).
		// example:
		// |	<div data-dojo-type="dijit/Dialog" data-dojo-props="href: 'test.html'"></div>
		// example:
		// |	var foo = new Dialog({ title: "test dialog", content: "test content" });
		// |	foo.placeAt(win.body());
		// |	foo.startup();
	});
	Dialog._DialogBase = _DialogBase;	// for monkey patching and dojox/widget/DialogSimple

	var DialogLevelManager = Dialog._DialogLevelManager = {
		// summary:
		//		Controls the various active "levels" on the page, starting with the
		//		stuff initially visible on the page (at z-index 0), and then having an entry for
		//		each Dialog shown.

		_beginZIndex: 950,

		show: function(/*dijit/_WidgetBase*/ dialog, /*Object*/ underlayAttrs){
			// summary:
			//		Call right before fade-in animation for new dialog.
			//		Saves current focus, displays/adjusts underlay for new dialog,
			//		and sets the z-index of the dialog itself.
			//
			//		New dialog will be displayed on top of all currently displayed dialogs.
			//
			//		Caller is responsible for setting focus in new dialog after the fade-in
			//		animation completes.

			// Save current focus
			ds[ds.length - 1].focus = focus.curNode;

			// Set z-index a bit above previous dialog
			var zIndex = ds[ds.length - 1].dialog ? ds[ds.length - 1].zIndex + 2 : Dialog._DialogLevelManager._beginZIndex;
			domStyle.set(dialog.domNode, 'zIndex', zIndex);

			// Display the underlay, or if already displayed then adjust for this new dialog
			DialogUnderlay.show(underlayAttrs, zIndex - 1);

			ds.push({dialog: dialog, underlayAttrs: underlayAttrs, zIndex: zIndex});
		},

		hide: function(/*dijit/_WidgetBase*/ dialog){
			// summary:
			//		Called when the specified dialog is hidden/destroyed, after the fade-out
			//		animation ends, in order to reset page focus, fix the underlay, etc.
			//		If the specified dialog isn't open then does nothing.
			//
			//		Caller is responsible for either setting display:none on the dialog domNode,
			//		or calling dijit/popup.hide(), or removing it from the page DOM.

			if(ds[ds.length - 1].dialog == dialog){
				// Removing the top (or only) dialog in the stack, return focus
				// to previous dialog

				ds.pop();

				var pd = ds[ds.length - 1];	// the new active dialog (or the base page itself)

				// Adjust underlay
				if(ds.length == 1){
					// Returning to original page.  Hide the underlay.
					DialogUnderlay.hide();
				}else{
					// Popping back to previous dialog, adjust underlay.
					DialogUnderlay.show(pd.underlayAttrs, pd.zIndex - 1);
				}

				// Adjust focus.
				// TODO: regardless of setting of dialog.refocus, if the exeucte() method set focus somewhere,
				// don't shift focus back to button.  Note that execute() runs at the start of the fade-out but
				// this code runs later, at the end of the fade-out.  Menu has code like this.
				if(dialog.refocus){
					// If we are returning control to a previous dialog but for some reason
					// that dialog didn't have a focused field, set focus to first focusable item.
					// This situation could happen if two dialogs appeared at nearly the same time,
					// since a dialog doesn't set it's focus until the fade-in is finished.
					var focus = pd.focus;
					if(pd.dialog && (!focus || !dom.isDescendant(focus, pd.dialog.domNode))){
						pd.dialog._getFocusItems();
						focus = pd.dialog._firstFocusItem;
					}

					if(focus){
						// Refocus the button that spawned the Dialog.   This will fail in corner cases including
						// page unload on IE, because the dijit/form/Button that launched the Dialog may get destroyed
						// before this code runs.  (#15058)
						try{
							focus.focus();
						}catch(e){
						}
					}
				}
			}else{
				// Removing a dialog out of order (#9944, #10705).
				// Don't need to mess with underlay or z-index or anything.
				var idx = array.indexOf(array.map(ds, function(elem){
					return elem.dialog;
				}), dialog);
				if(idx != -1){
					ds.splice(idx, 1);
				}
			}
		},

		isTop: function(/*dijit/_WidgetBase*/ dialog){
			// summary:
			//		Returns true if specified Dialog is the top in the task
			return ds[ds.length - 1].dialog == dialog;
		}
	};

	// Stack representing the various active "levels" on the page, starting with the
	// stuff initially visible on the page (at z-index 0), and then having an entry for
	// each Dialog shown.
	// Each element in stack has form {
	//		dialog: dialogWidget,
	//		focus: returnFromGetFocus(),
	//		underlayAttrs: attributes to set on underlay (when this widget is active)
	// }
	var ds = Dialog._dialogStack = [
		{dialog: null, focus: null, underlayAttrs: null}    // entry for stuff at z-index: 0
	];

	// If focus was accidentally removed from the dialog, such as if the user clicked a blank
	// area of the screen, or clicked the browser's address bar and then tabbed into the page,
	// then refocus.   Won't do anything if focus was removed because the Dialog was closed, or
	// because a new Dialog popped up on top of the old one, or when focus moves to popups
	focus.watch("curNode", function(attr, oldNode, node){
 		// Note: if no dialogs, ds.length==1 but ds[ds.length-1].dialog is null
		var topDialog = ds[ds.length - 1].dialog;

		// If a node was focused, and there's a Dialog currently showing, and not in the process of fading out...
		// Ignore focus events on other document though because it's likely an Editor inside of the Dialog.
		if(node && topDialog && !topDialog._fadeOutDeferred && node.ownerDocument == topDialog.ownerDocument){
			// If the node that was focused is inside the dialog or in a popup, even a context menu that isn't
			// technically a descendant of the the dialog, don't do anything.
			do{
				if(node == topDialog.domNode || domClass.contains(node, "dijitPopup")){ return; }
			}while(node = node.parentNode);

			// Otherwise, return focus to the dialog.  Use a delay to avoid confusing dijit/focus code's
			// own tracking of focus.
			topDialog.focus();
		}
	});

	// Back compat w/1.6, remove for 2.0
	if(has("dijit-legacy-requires")){
		ready(0, function(){
			var requires = ["dijit/TooltipDialog"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	return Dialog;
});

},
'dijit/_base/manager':function(){
define([
	"dojo/_base/array",
	"dojo/_base/config", // defaultDuration
	"dojo/_base/lang",
	"../registry",
	"../main"	// for setting exports to dijit namespace
], function(array, config, lang, registry, dijit){

	// module:
	//		dijit/_base/manager

	var exports = {
		// summary:
		//		Deprecated.  Shim to methods on registry, plus a few other declarations.
		//		New code should access dijit/registry directly when possible.
	};

	array.forEach(["byId", "getUniqueId", "findWidgets", "_destroyAll", "byNode", "getEnclosingWidget"], function(name){
		exports[name] = registry[name];
	});

	 lang.mixin(exports, {
		 // defaultDuration: Integer
		 //		The default fx.animation speed (in ms) to use for all Dijit
		 //		transitional fx.animations, unless otherwise specified
		 //		on a per-instance basis. Defaults to 200, overrided by
		 //		`djConfig.defaultDuration`
		 defaultDuration: config["defaultDuration"] || 200
	 });

	lang.mixin(dijit, exports);

	/*===== return exports; =====*/
	return dijit;	// for back compat :-(
});

},
'dijit/form/_FormMixin':function(){
define([
	"dojo/_base/array", // array.every array.filter array.forEach array.indexOf array.map
	"dojo/_base/declare", // declare
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.hitch lang.isArray
	"dojo/on",
	"dojo/window" // winUtils.scrollIntoView
], function(array, declare, kernel, lang, on, winUtils){

	// module:
	//		dijit/form/_FormMixin

	return declare("dijit.form._FormMixin", null, {
		// summary:
		//		Mixin for containers of form widgets (i.e. widgets that represent a single value
		//		and can be children of a `<form>` node or `dijit/form/Form` widget)
		// description:
		//		Can extract all the form widgets
		//		values and combine them into a single javascript object, or alternately
		//		take such an object and set the values for all the contained
		//		form widgets

	/*=====
		// value: Object
		//		Name/value hash for each child widget with a name and value.
		//		Child widgets without names are not part of the hash.
		//
		//		If there are multiple child widgets w/the same name, value is an array,
		//		unless they are radio buttons in which case value is a scalar (since only
		//		one radio button can be checked at a time).
		//
		//		If a child widget's name is a dot separated list (like a.b.c.d), it's a nested structure.
		//
		//		Example:
		//	|	{ name: "John Smith", interests: ["sports", "movies"] }
	=====*/

		// state: [readonly] String
		//		Will be "Error" if one or more of the child widgets has an invalid value,
		//		"Incomplete" if not all of the required child widgets are filled in.  Otherwise, "",
		//		which indicates that the form is ready to be submitted.
		state: "",

		// TODO:
		//	* Repeater
		//	* better handling for arrays.  Often form elements have names with [] like
		//	* people[3].sex (for a list of people [{name: Bill, sex: M}, ...])


		_getDescendantFormWidgets: function(/*dijit/_WidgetBase[]?*/ children){
			// summary:
			//		Returns all form widget descendants, searching through non-form child widgets like BorderContainer
			var res = [];
			array.forEach(children || this.getChildren(), function(child){
				if("value" in child){
					res.push(child);
				}else{
					res = res.concat(this._getDescendantFormWidgets(child.getChildren()));
				}
			}, this);
			return res;
		},

		reset: function(){
			array.forEach(this._getDescendantFormWidgets(), function(widget){
				if(widget.reset){
					widget.reset();
				}
			});
		},

		validate: function(){
			// summary:
			//		returns if the form is valid - same as isValid - but
			//		provides a few additional (ui-specific) features:
			//
			//		1. it will highlight any sub-widgets that are not valid
			//		2. it will call focus() on the first invalid sub-widget
			var didFocus = false;
			return array.every(array.map(this._getDescendantFormWidgets(), function(widget){
				// Need to set this so that "required" widgets get their
				// state set.
				widget._hasBeenBlurred = true;
				var valid = widget.disabled || !widget.validate || widget.validate();
				if(!valid && !didFocus){
					// Set focus of the first non-valid widget
					winUtils.scrollIntoView(widget.containerNode || widget.domNode);
					widget.focus();
					didFocus = true;
				}
				return valid;
			}), function(item){ return item; });
		},

		setValues: function(val){
			kernel.deprecated(this.declaredClass+"::setValues() is deprecated. Use set('value', val) instead.", "", "2.0");
			return this.set('value', val);
		},
		_setValueAttr: function(/*Object*/ obj){
			// summary:
			//		Fill in form values from according to an Object (in the format returned by get('value'))

			// generate map from name --> [list of widgets with that name]
			var map = { };
			array.forEach(this._getDescendantFormWidgets(), function(widget){
				if(!widget.name){ return; }
				var entry = map[widget.name] || (map[widget.name] = [] );
				entry.push(widget);
			});

			for(var name in map){
				if(!map.hasOwnProperty(name)){
					continue;
				}
				var widgets = map[name],						// array of widgets w/this name
					values = lang.getObject(name, false, obj);	// list of values for those widgets

				if(values === undefined){
					continue;
				}
				values = [].concat(values);
				if(typeof widgets[0].checked == 'boolean'){
					// for checkbox/radio, values is a list of which widgets should be checked
					array.forEach(widgets, function(w){
						w.set('value', array.indexOf(values, w._get('value')) != -1);
					});
				}else if(widgets[0].multiple){
					// it takes an array (e.g. multi-select)
					widgets[0].set('value', values);
				}else{
					// otherwise, values is a list of values to be assigned sequentially to each widget
					array.forEach(widgets, function(w, i){
						w.set('value', values[i]);
					});
				}
			}

			/***
			 *	TODO: code for plain input boxes (this shouldn't run for inputs that are part of widgets)

			array.forEach(this.containerNode.elements, function(element){
				if(element.name == ''){return};	// like "continue"
				var namePath = element.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var p=namePath[j - 1];
					// repeater support block
					var nameA=p.split("[");
					if(nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if

						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
						myObj=myObj[nameA[0]][nameIndex];
						continue;
					} // repeater support ends

					if(typeof(myObj[p]) == "undefined"){
						myObj=undefined;
						break;
					};
					myObj=myObj[p];
				}

				if(typeof(myObj) == "undefined"){
					return;		// like "continue"
				}
				if(typeof(myObj[name]) == "undefined" && this.ignoreNullValues){
					return;		// like "continue"
				}

				// TODO: widget values (just call set('value', ...) on the widget)

				// TODO: maybe should call dojo.getNodeProp() instead
				switch(element.type){
					case "checkbox":
						element.checked = (name in myObj) &&
							array.some(myObj[name], function(val){ return val == element.value; });
						break;
					case "radio":
						element.checked = (name in myObj) && myObj[name] == element.value;
						break;
					case "select-multiple":
						element.selectedIndex=-1;
						array.forEach(element.options, function(option){
							option.selected = array.some(myObj[name], function(val){ return option.value == val; });
						});
						break;
					case "select-one":
						element.selectedIndex="0";
						array.forEach(element.options, function(option){
							option.selected = option.value == myObj[name];
						});
						break;
					case "hidden":
					case "text":
					case "textarea":
					case "password":
						element.value = myObj[name] || "";
						break;
				}
			});
			*/

			// Note: no need to call this._set("value", ...) as the child updates will trigger onChange events
			// which I am monitoring.
		},

		getValues: function(){
			kernel.deprecated(this.declaredClass+"::getValues() is deprecated. Use get('value') instead.", "", "2.0");
			return this.get('value');
		},
		_getValueAttr: function(){
			// summary:
			//		Returns Object representing form values.   See description of `value` for details.
			// description:

			// The value is updated into this.value every time a child has an onChange event,
			// so in the common case this function could just return this.value.   However,
			// that wouldn't work when:
			//
			// 1. User presses return key to submit a form.  That doesn't fire an onchange event,
			// and even if it did it would come too late due to the defer(...) in _handleOnChange()
			//
			// 2. app for some reason calls this.get("value") while the user is typing into a
			// form field.   Not sure if that case needs to be supported or not.

			// get widget values
			var obj = { };
			array.forEach(this._getDescendantFormWidgets(), function(widget){
				var name = widget.name;
				if(!name || widget.disabled){ return; }

				// Single value widget (checkbox, radio, or plain <input> type widget)
				var value = widget.get('value');

				// Store widget's value(s) as a scalar, except for checkboxes which are automatically arrays
				if(typeof widget.checked == 'boolean'){
					if(/Radio/.test(widget.declaredClass)){
						// radio button
						if(value !== false){
							lang.setObject(name, value, obj);
						}else{
							// give radio widgets a default of null
							value = lang.getObject(name, false, obj);
							if(value === undefined){
								lang.setObject(name, null, obj);
							}
						}
					}else{
						// checkbox/toggle button
						var ary=lang.getObject(name, false, obj);
						if(!ary){
							ary=[];
							lang.setObject(name, ary, obj);
						}
						if(value !== false){
							ary.push(value);
						}
					}
				}else{
					var prev=lang.getObject(name, false, obj);
					if(typeof prev != "undefined"){
						if(lang.isArray(prev)){
							prev.push(value);
						}else{
							lang.setObject(name, [prev, value], obj);
						}
					}else{
						// unique name
						lang.setObject(name, value, obj);
					}
				}
			});

			/***
			 * code for plain input boxes (see also domForm.formToObject, can we use that instead of this code?
			 * but it doesn't understand [] notation, presumably)
			var obj = { };
			array.forEach(this.containerNode.elements, function(elm){
				if(!elm.name)	{
					return;		// like "continue"
				}
				var namePath = elm.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var nameIndex = null;
					var p=namePath[j - 1];
					var nameA=p.split("[");
					if(nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if
						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
					}else if(typeof(myObj[nameA[0]]) == "undefined"){
						myObj[nameA[0]] = { }
					} // if

					if(nameA.length == 1){
						myObj=myObj[nameA[0]];
					}else{
						myObj=myObj[nameA[0]][nameIndex];
					} // if
				} // for

				if((elm.type != "select-multiple" && elm.type != "checkbox" && elm.type != "radio") || (elm.type == "radio" && elm.checked)){
					if(name == name.split("[")[0]){
						myObj[name]=elm.value;
					}else{
						// can not set value when there is no name
					}
				}else if(elm.type == "checkbox" && elm.checked){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					myObj[name].push(elm.value);
				}else if(elm.type == "select-multiple"){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					for(var jdx=0,len3=elm.options.length; jdx<len3; ++jdx){
						if(elm.options[jdx].selected){
							myObj[name].push(elm.options[jdx].value);
						}
					}
				} // if
				name=undefined;
			}); // forEach
			***/
			return obj;
		},

		isValid: function(){
			// summary:
			//		Returns true if all of the widgets are valid.
			//		Deprecated, will be removed in 2.0.  Use get("state") instead.

			return this.state == "";
		},

		onValidStateChange: function(/*Boolean*/ /*===== isValid =====*/){
			// summary:
			//		Stub function to connect to if you want to do something
			//		(like disable/enable a submit button) when the valid
			//		state changes on the form as a whole.
			//
			//		Deprecated.  Will be removed in 2.0.  Use watch("state", ...) instead.
		},

		_getState: function(){
			// summary:
			//		Compute what this.state should be based on state of children
			var states = array.map(this._descendants, function(w){
				return w.get("state") || "";
			});

			return array.indexOf(states, "Error") >= 0 ? "Error" :
				array.indexOf(states, "Incomplete") >= 0 ? "Incomplete" : "";
		},

		disconnectChildren: function(){
			// summary:
			//		Deprecated method.   Applications no longer need to call this.   Remove for 2.0.
		},

		connectChildren: function(/*Boolean*/ inStartup){
			// summary:
			//		You can call this function directly, ex. in the event that you
			//		programmatically add a widget to the form *after* the form has been
			//		initialized.

			// TODO: rename for 2.0

			this._descendants = this._getDescendantFormWidgets();

			// To get notifications from children they need to be started.   Children didn't used to need to be started,
			// so for back-compat, start them here
			array.forEach(this._descendants, function(child){
				if(!child._started){ child.startup(); }
			});

			if(!inStartup){
				this._onChildChange();
			}
		},

		_onChildChange: function(/*String*/ attr){
			// summary:
			//		Called when child's value or disabled state changes

			// The unit tests expect state update to be synchronous, so update it immediately.
			if(!attr || attr == "state" || attr == "disabled"){
				this._set("state", this._getState());
			}

			// Use defer() to collapse value changes in multiple children into a single
			// update to my value.   Multiple updates will occur on:
			//	1. Form.set()
			//	2. Form.reset()
			//	3. user selecting a radio button (which will de-select another radio button,
			//		 causing two onChange events)
			if(!attr || attr == "value" || attr == "disabled" || attr == "checked"){
				if(this._onChangeDelayTimer){
					this._onChangeDelayTimer.remove();
				}
				this._onChangeDelayTimer = this.defer(function(){
					delete this._onChangeDelayTimer;
					this._set("value", this.get("value"));
				}, 10);
			}
		},

		startup: function(){
			this.inherited(arguments);

			// Set initial this.value and this.state.   Don't emit watch() notifications.
			this._descendants = this._getDescendantFormWidgets();
			this.value = this.get("value");
			this.state = this._getState();

			// Initialize value and valid/invalid state tracking.
			var self = this;
			this.own(
				on(
					this.containerNode,
					"attrmodified-state, attrmodified-disabled, attrmodified-value, attrmodified-checked",
					function(evt){
						if(evt.target == self.domNode){
							return;	// ignore events that I fire on myself because my children changed
						}
						self._onChildChange(evt.type.replace("attrmodified-", ""));
					}
				)
			);

			// Make state change call onValidStateChange(), will be removed in 2.0
			this.watch("state", function(attr, oldVal, newVal){ this.onValidStateChange(newVal == ""); });
		},

		destroy: function(){
			this.inherited(arguments);
		}

	});
});

},
'dijit/_DialogMixin':function(){
define([
	"dojo/_base/declare", // declare
	"./a11y"	// _getTabNavigable
], function(declare, a11y){

	// module:
	//		dijit/_DialogMixin

	return declare("dijit._DialogMixin", null, {
		// summary:
		//		This provides functions useful to Dialog and TooltipDialog

		// actionBarTemplate: String
		//		HTML snippet to show the action bar (gray bar with OK/cancel buttons).
		//		Blank by default, but used by ConfirmDialog/ConfirmTooltipDialog subclasses.
		actionBarTemplate: "",

		execute: function(/*Object*/ /*===== formContents =====*/){
			// summary:
			//		Callback when the user hits the submit button.
			//		Override this method to handle Dialog execution.
			// description:
			//		After the user has pressed the submit button, the Dialog
			//		first calls onExecute() to notify the container to hide the
			//		dialog and restore focus to wherever it used to be.
			//
			//		*Then* this method is called.
			// type:
			//		callback
		},

		onCancel: function(){
			// summary:
			//		Called when user has pressed the Dialog's cancel button, to notify container.
			// description:
			//		Developer shouldn't override or connect to this method;
			//		it's a private communication device between the TooltipDialog
			//		and the thing that opened it (ex: `dijit/form/DropDownButton`)
			// type:
			//		protected
		},

		onExecute: function(){
			// summary:
			//		Called when user has pressed the dialog's OK button, to notify container.
			// description:
			//		Developer shouldn't override or connect to this method;
			//		it's a private communication device between the TooltipDialog
			//		and the thing that opened it (ex: `dijit/form/DropDownButton`)
			// type:
			//		protected
		},

		_onSubmit: function(){
			// summary:
			//		Callback when user hits submit button
			// type:
			//		protected
			this.onExecute();	// notify container that we are about to execute
			this.execute(this.get('value'));
		},

		_getFocusItems: function(){
			// summary:
			//		Finds focusable items in dialog,
			//		and sets this._firstFocusItem and this._lastFocusItem
			// tags:
			//		protected

			var elems = a11y._getTabNavigable(this.containerNode);
			this._firstFocusItem = elems.lowest || elems.first || this.closeButtonNode || this.domNode;
			this._lastFocusItem = elems.last || elems.highest || this._firstFocusItem;
		}
	});
});

},
'dijit/DialogUnderlay':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.hitch
	"dojo/aspect", // aspect.after
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/on",
	"dojo/window", // winUtils.getBox, winUtils.get
	"./_Widget",
	"./_TemplatedMixin",
	"./BackgroundIframe",
	"./Viewport",
	"./main" // for back-compat, exporting dijit._underlay (remove in 2.0)
], function(declare, lang, aspect, domAttr, domStyle, on,
			winUtils, _Widget, _TemplatedMixin, BackgroundIframe, Viewport, dijit){

	// module:
	//		dijit/DialogUnderlay

	var DialogUnderlay = declare("dijit.DialogUnderlay", [_Widget, _TemplatedMixin], {
		// summary:
		//		A component used to block input behind a `dijit/Dialog`.
		//
		//		Normally this class should not be instantiated directly, but rather shown and hidden via
		//		DialogUnderlay.show() and DialogUnderlay.hide().  And usually the module is not accessed directly
		//		at all, since the underlay is shown and hidden by Dialog.DialogLevelManager.
		//
		//		The underlay itself can be styled based on and id:
		//	|	#myDialog_underlay { background-color:red; }
		//
		//		In the case of `dijit.Dialog`, this id is based on the id of the Dialog,
		//		suffixed with _underlay.

		// Template has two divs; outer div is used for fade-in/fade-out, and also to hold background iframe.
		// Inner div has opacity specified in CSS file.
		templateString: "<div class='dijitDialogUnderlayWrapper'><div class='dijitDialogUnderlay' tabIndex='-1' data-dojo-attach-point='node'></div></div>",

		// Parameters on creation or updatable later

		// dialogId: String
		//		Id of the dialog.... DialogUnderlay's id is based on this id
		dialogId: "",

		// class: String
		//		This class name is used on the DialogUnderlay node, in addition to dijitDialogUnderlay
		"class": "",

		// This will get overwritten as soon as show() is call, but leave an empty array in case hide() or destroy()
		// is called first.   The array is shared between instances but that's OK because we never write into it.
		_modalConnects: [],

		_setDialogIdAttr: function(id){
			domAttr.set(this.node, "id", id + "_underlay");
			this._set("dialogId", id);
		},

		_setClassAttr: function(clazz){
			this.node.className = "dijitDialogUnderlay " + clazz;
			this._set("class", clazz);
		},

		postCreate: function(){
			// Append the underlay to the body
			this.ownerDocumentBody.appendChild(this.domNode);

			this.own(on(this.domNode, "keydown", lang.hitch(this, "_onKeyDown")));

			this.inherited(arguments);
		},

		layout: function(){
			// summary:
			//		Sets the background to the size of the viewport
			//
			// description:
			//		Sets the background to the size of the viewport (rather than the size
			//		of the document) since we need to cover the whole browser window, even
			//		if the document is only a few lines long.
			// tags:
			//		private

			var is = this.node.style,
				os = this.domNode.style;

			// hide the background temporarily, so that the background itself isn't
			// causing scrollbars to appear (might happen when user shrinks browser
			// window and then we are called to resize)
			os.display = "none";

			// then resize and show
			var viewport = winUtils.getBox(this.ownerDocument);
			os.top = viewport.t + "px";
			os.left = viewport.l + "px";
			is.width = viewport.w + "px";
			is.height = viewport.h + "px";
			os.display = "block";
		},

		show: function(){
			// summary:
			//		Show the dialog underlay
			this.domNode.style.display = "block";
			this.open = true;
			this.layout();
			this.bgIframe = new BackgroundIframe(this.domNode);

			var win = winUtils.get(this.ownerDocument);
			this._modalConnects = [
				Viewport.on("resize", lang.hitch(this, "layout")),
				on(win, "scroll", lang.hitch(this, "layout"))
			];

		},

		hide: function(){
			// summary:
			//		Hides the dialog underlay

			this.bgIframe.destroy();
			delete this.bgIframe;
			this.domNode.style.display = "none";
			while(this._modalConnects.length){ (this._modalConnects.pop()).remove(); }
			this.open = false;
		},

		destroy: function(){
			while(this._modalConnects.length){ (this._modalConnects.pop()).remove(); }
			this.inherited(arguments);
		},

		_onKeyDown: function(){
			// summary:
			//		Extension point so Dialog can monitor keyboard events on the underlay.
		}
	});

	DialogUnderlay.show = function(/*Object*/ attrs, /*Number*/ zIndex){
		// summary:
		//		Display the underlay with the given attributes set.  If the underlay is already displayed,
		//		then adjust it's attributes as specified.
		// attrs:
		//		The parameters to create DialogUnderlay with.
		// zIndex:
		//		zIndex of the underlay

		var underlay = DialogUnderlay._singleton;
		if(!underlay || underlay._destroyed){
			underlay = dijit._underlay = DialogUnderlay._singleton = new DialogUnderlay(attrs);
		}else{
			if(attrs){ underlay.set(attrs); }
		}
		domStyle.set(underlay.domNode, 'zIndex', zIndex);
		if(!underlay.open){
			underlay.show();
		}
	};

	DialogUnderlay.hide = function(){
		// summary:
		//		Hide the underlay.

		// Guard code in case the underlay widget has already been destroyed
		// because we are being called during page unload (when all widgets are destroyed)
		var underlay = DialogUnderlay._singleton;
		if(underlay && !underlay._destroyed){
			underlay.hide();
		}
	};

	return DialogUnderlay;
});

},
'dijit/BackgroundIframe':function(){
define([
	"require",			// require.toUrl
	"./main",	// to export dijit.BackgroundIframe
	"dojo/_base/config",
	"dojo/dom-construct", // domConstruct.create
	"dojo/dom-style", // domStyle.set
	"dojo/_base/lang", // lang.extend lang.hitch
	"dojo/on",
	"dojo/sniff" // has("ie"), has("trident"), has("quirks")
], function(require, dijit, config, domConstruct, domStyle, lang, on, has){

	// module:
	//		dijit/BackgroundIFrame

	// Flag for whether to create background iframe behind popups like Menus and Dialog.
	// A background iframe is useful to prevent problems with popups appearing behind applets/pdf files,
	// and is also useful on older versions of IE (IE6 and IE7) to prevent the "bleed through select" problem.
	// By default, it's enabled for IE6-10, excluding Windows Phone 8,
	// and it's also enabled for IE11 on Windows 7 and Windows 2008 Server.
	// TODO: For 2.0, make this false by default.  Also, possibly move definition to has.js so that this module can be
	// conditionally required via  dojo/has!bgIfame?dijit/BackgroundIframe
	has.add("config-bgIframe",
		(has("ie") && !/IEMobile\/10\.0/.test(navigator.userAgent)) || // No iframe on WP8, to match 1.9 behavior
		(has("trident") && /Windows NT 6.[01]/.test(navigator.userAgent)));

	var _frames = new function(){
		// summary:
		//		cache of iframes

		var queue = [];

		this.pop = function(){
			var iframe;
			if(queue.length){
				iframe = queue.pop();
				iframe.style.display="";
			}else{
				// transparency needed for DialogUnderlay and for tooltips on IE (to see screen near connector)
				if(has("ie") < 9){
					var burl = config["dojoBlankHtmlUrl"] || require.toUrl("dojo/resources/blank.html") || "javascript:\"\"";
					var html="<iframe src='" + burl + "' role='presentation'"
						+ " style='position: absolute; left: 0px; top: 0px;"
						+ "z-index: -1; filter:Alpha(Opacity=\"0\");'>";
					iframe = document.createElement(html);
				}else{
					iframe = domConstruct.create("iframe");
					iframe.src = 'javascript:""';
					iframe.className = "dijitBackgroundIframe";
					iframe.setAttribute("role", "presentation");
					domStyle.set(iframe, "opacity", 0.1);
				}
				iframe.tabIndex = -1; // Magic to prevent iframe from getting focus on tab keypress - as style didn't work.
			}
			return iframe;
		};

		this.push = function(iframe){
			iframe.style.display="none";
			queue.push(iframe);
		}
	}();


	dijit.BackgroundIframe = function(/*DomNode*/ node){
		// summary:
		//		For IE/FF z-index shenanigans. id attribute is required.
		//
		// description:
		//		new dijit.BackgroundIframe(node).
		//
		//		Makes a background iframe as a child of node, that fills
		//		area (and position) of node

		if(!node.id){ throw new Error("no id"); }
		if(has("config-bgIframe")){
			var iframe = (this.iframe = _frames.pop());
			node.appendChild(iframe);
			if(has("ie")<7 || has("quirks")){
				this.resize(node);
				this._conn = on(node, 'resize', lang.hitch(this, "resize", node));
			}else{
				domStyle.set(iframe, {
					width: '100%',
					height: '100%'
				});
			}
		}
	};

	lang.extend(dijit.BackgroundIframe, {
		resize: function(node){
			// summary:
			//		Resize the iframe so it's the same size as node.
			//		Needed on IE6 and IE/quirks because height:100% doesn't work right.
			if(this.iframe){
				domStyle.set(this.iframe, {
					width: node.offsetWidth + 'px',
					height: node.offsetHeight + 'px'
				});
			}
		},
		destroy: function(){
			// summary:
			//		destroy the iframe
			if(this._conn){
				this._conn.remove();
				this._conn = null;
			}
			if(this.iframe){
				this.iframe.parentNode.removeChild(this.iframe);
				_frames.push(this.iframe);
				delete this.iframe;
			}
		}
	});

	return dijit.BackgroundIframe;
});

},
'dijit/Viewport':function(){
define([
	"dojo/Evented",
	"dojo/on",
	"dojo/domReady",
	"dojo/sniff",	// has("ie"), has("ios")
	"dojo/window" // getBox()
], function(Evented, on, domReady, has, winUtils){

	// module:
	//		dijit/Viewport

	/*=====
	return {
		// summary:
		//		Utility singleton to watch for viewport resizes, avoiding duplicate notifications
		//		which can lead to infinite loops.
		// description:
		//		Usage: Viewport.on("resize", myCallback).
		//
		//		myCallback() is called without arguments in case it's _WidgetBase.resize(),
		//		which would interpret the argument as the size to make the widget.
	};
	=====*/

	var Viewport = new Evented();

	var focusedNode;

	domReady(function(){
		var oldBox = winUtils.getBox();
		Viewport._rlh = on(window, "resize", function(){
			var newBox = winUtils.getBox();
			if(oldBox.h == newBox.h && oldBox.w == newBox.w){ return; }
			oldBox = newBox;
			Viewport.emit("resize");
		});

		// Also catch zoom changes on IE8, since they don't naturally generate resize events
		if(has("ie") == 8){
			var deviceXDPI = screen.deviceXDPI;
			setInterval(function(){
				if(screen.deviceXDPI != deviceXDPI){
					deviceXDPI = screen.deviceXDPI;
					Viewport.emit("resize");
				}
			}, 500);
		}

		// On iOS, keep track of the focused node so we can guess when the keyboard is/isn't being displayed.
		if(has("ios")){
			on(document, "focusin", function(evt){
				focusedNode = evt.target;
			});
			on(document, "focusout", function(evt){
				focusedNode = null;
			});
		}
	});

	Viewport.getEffectiveBox = function(/*Document*/ doc){
		// summary:
		//		Get the size of the viewport, or on mobile devices, the part of the viewport not obscured by the
		//		virtual keyboard.

		var box = winUtils.getBox(doc);

		// Account for iOS virtual keyboard, if it's being shown.  Unfortunately no direct way to check or measure.
		var tag = focusedNode && focusedNode.tagName && focusedNode.tagName.toLowerCase();
		if(has("ios") && focusedNode && !focusedNode.readOnly && (tag == "textarea" || (tag == "input" &&
			/^(color|email|number|password|search|tel|text|url)$/.test(focusedNode.type)))){

			// Box represents the size of the viewport.  Some of the viewport is likely covered by the keyboard.
			// Estimate height of visible viewport assuming viewport goes to bottom of screen, but is covered by keyboard.
			box.h *= (orientation == 0 || orientation == 180 ? 0.66 : 0.40);

			// Above measurement will be inaccurate if viewport was scrolled up so far that it ends before the bottom
			// of the screen.   In this case, keyboard isn't covering as much of the viewport as we thought.
			// We know the visible size is at least the distance from the top of the viewport to the focused node.
			var rect = focusedNode.getBoundingClientRect();
			box.h = Math.max(box.h, rect.top + rect.height);
		}

		return box;
	};

	return Viewport;
});

},
'dijit/layout/ContentPane':function(){
define([
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.mixin lang.delegate lang.hitch lang.isFunction lang.isObject
	"../_Widget",
	"../_Container",
	"./_ContentPaneResizeMixin",
	"dojo/string", // string.substitute
	"dojo/html", // html._ContentSetter
	"dojo/i18n!../nls/loading",
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/_base/Deferred", // Deferred
	"dojo/dom", // dom.byId
	"dojo/dom-attr", // domAttr.attr
	"dojo/dom-construct", // empty()
	"dojo/_base/xhr", // xhr.get
	"dojo/i18n", // i18n.getLocalization
	"dojo/when"
], function(kernel, lang, _Widget, _Container, _ContentPaneResizeMixin, string, html, nlsLoading, array, declare,
			Deferred, dom, domAttr, domConstruct, xhr, i18n, when){

	// module:
	//		dijit/layout/ContentPane

	return declare("dijit.layout.ContentPane", [_Widget, _Container, _ContentPaneResizeMixin], {
		// summary:
		//		A widget containing an HTML fragment, specified inline
		//		or by uri.  Fragment may include widgets.
		//
		// description:
		//		This widget embeds a document fragment in the page, specified
		//		either by uri, javascript generated markup or DOM reference.
		//		Any widgets within this content are instantiated and managed,
		//		but laid out according to the HTML structure.  Unlike IFRAME,
		//		ContentPane embeds a document fragment as would be found
		//		inside the BODY tag of a full HTML document.  It should not
		//		contain the HTML, HEAD, or BODY tags.
		//		For more advanced functionality with scripts and
		//		stylesheets, see dojox/layout/ContentPane.  This widget may be
		//		used stand alone or as a base class for other widgets.
		//		ContentPane is useful as a child of other layout containers
		//		such as BorderContainer or TabContainer, but note that those
		//		widgets can contain any widget as a child.
		//
		// example:
		//		Some quick samples:
		//		To change the innerHTML:
		// |		cp.set('content', '<b>new content</b>')`
		//		Or you can send it a NodeList:
		// |		cp.set('content', dojo.query('div [class=selected]', userSelection))
		//		To do an ajax update:
		// |		cp.set('href', url)

		// href: String
		//		The href of the content that displays now.
		//		Set this at construction if you want to load data externally when the
		//		pane is shown.  (Set preload=true to load it immediately.)
		//		Changing href after creation doesn't have any effect; Use set('href', ...);
		href: "",

		// content: String|DomNode|NodeList|dijit/_Widget
		//		The innerHTML of the ContentPane.
		//		Note that the initialization parameter / argument to set("content", ...)
		//		can be a String, DomNode, Nodelist, or _Widget.
		content: "",

		// extractContent: Boolean
		//		Extract visible content from inside of `<body> .... </body>`.
		//		I.e., strip `<html>` and `<head>` (and it's contents) from the href
		extractContent: false,

		// parseOnLoad: Boolean
		//		Parse content and create the widgets, if any.
		parseOnLoad: true,

		// parserScope: String
		//		Flag passed to parser.  Root for attribute names to search for.   If scopeName is dojo,
		//		will search for data-dojo-type (or dojoType).  For backwards compatibility
		//		reasons defaults to dojo._scopeName (which is "dojo" except when
		//		multi-version support is used, when it will be something like dojo16, dojo20, etc.)
		parserScope: kernel._scopeName,

		// preventCache: Boolean
		//		Prevent caching of data from href's by appending a timestamp to the href.
		preventCache: false,

		// preload: Boolean
		//		Force load of data on initialization even if pane is hidden.
		preload: false,

		// refreshOnShow: Boolean
		//		Refresh (re-download) content when pane goes from hidden to shown
		refreshOnShow: false,

		// loadingMessage: String
		//		Message that shows while downloading
		loadingMessage: "<span class='dijitContentPaneLoading'><span class='dijitInline dijitIconLoading'></span>${loadingState}</span>",

		// errorMessage: String
		//		Message that shows if an error occurs
		errorMessage: "<span class='dijitContentPaneError'><span class='dijitInline dijitIconError'></span>${errorState}</span>",

		// isLoaded: [readonly] Boolean
		//		True if the ContentPane has data in it, either specified
		//		during initialization (via href or inline content), or set
		//		via set('content', ...) / set('href', ...)
		//
		//		False if it doesn't have any content, or if ContentPane is
		//		still in the process of downloading href.
		isLoaded: false,

		baseClass: "dijitContentPane",

		/*======
		 // ioMethod: dojo/_base/xhr.get|dojo._base/xhr.post
		 //		Function that should grab the content specified via href.
		 ioMethod: dojo.xhrGet,
		 ======*/

		// ioArgs: Object
		//		Parameters to pass to xhrGet() request, for example:
		// |	<div data-dojo-type="dijit/layout/ContentPane" data-dojo-props="href: './bar', ioArgs: {timeout: 500}">
		ioArgs: {},

		// onLoadDeferred: [readonly] dojo.Deferred
		//		This is the `dojo.Deferred` returned by set('href', ...) and refresh().
		//		Calling onLoadDeferred.then() registers your
		//		callback to be called only once, when the prior set('href', ...) call or
		//		the initial href parameter to the constructor finishes loading.
		//
		//		This is different than an onLoad() handler which gets called any time any href
		//		or content is loaded.
		onLoadDeferred: null,

		// Cancel _WidgetBase's _setTitleAttr because we don't want the title attribute (used to specify
		// tab labels) to be copied to ContentPane.domNode... otherwise a tooltip shows up over the
		// entire pane.
		_setTitleAttr: null,

		// Flag to parser that I'll parse my contents, so it shouldn't.
		stopParser: true,

		// template: [private] Boolean
		//		Flag from the parser that this ContentPane is inside a template
		//		so the contents are pre-parsed.
		// TODO: this declaration can be commented out in 2.0
		template: false,

		markupFactory: function(params, node, ctor){
			var self = new ctor(params, node);

			// If a parse has started but is waiting for modules to load, then return a Promise for when the parser
			// finishes.  Don't return a promise though for the case when content hasn't started loading because the
			// ContentPane is hidden and it has an href (ex: hidden pane of a TabContainer).   In that case we consider
			// that initialization has already finished.
			return !self.href && self._contentSetter && self._contentSetter.parseDeferred && !self._contentSetter.parseDeferred.isFulfilled() ?
				self._contentSetter.parseDeferred.then(function(){
					return self;
				}) : self;
		},

		create: function(params, srcNodeRef){
			// Convert a srcNodeRef argument into a content parameter, so that the original contents are
			// processed in the same way as contents set via set("content", ...), calling the parser etc.
			// Avoid modifying original params object since that breaks NodeList instantiation, see #11906.
			if((!params || !params.template) && srcNodeRef && !("href" in params) && !("content" in params)){
				srcNodeRef = dom.byId(srcNodeRef);
				var df = srcNodeRef.ownerDocument.createDocumentFragment();
				while(srcNodeRef.firstChild){
					df.appendChild(srcNodeRef.firstChild);
				}
				params = lang.delegate(params, {content: df});
			}
			this.inherited(arguments, [params, srcNodeRef]);
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			var messages = i18n.getLocalization("dijit", "loading", this.lang);
			this.loadingMessage = string.substitute(this.loadingMessage, messages);
			this.errorMessage = string.substitute(this.errorMessage, messages);
		},

		buildRendering: function(){
			this.inherited(arguments);

			// Since we have no template we need to set this.containerNode ourselves, to make getChildren() work.
			// For subclasses of ContentPane that do have a template, does nothing.
			if(!this.containerNode){
				this.containerNode = this.domNode;
			}

			// remove the title attribute so it doesn't show up when hovering
			// over a node  (TODO: remove in 2.0, no longer needed after #11490)
			this.domNode.removeAttribute("title");
		},

		startup: function(){
			// summary:
			//		Call startup() on all children including non _Widget ones like dojo/dnd/Source objects

			// This starts all the widgets
			this.inherited(arguments);

			// And this catches stuff like dojo/dnd/Source
			if(this._contentSetter){
				array.forEach(this._contentSetter.parseResults, function(obj){
					if(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){
						obj.startup();
						obj._started = true;
					}
				}, this);
			}
		},

		_startChildren: function(){
			// summary:
			//		Called when content is loaded.   Calls startup on each child widget.   Similar to ContentPane.startup()
			//		itself, but avoids marking the ContentPane itself as "restarted" (see #15581).

			// This starts all the widgets
			array.forEach(this.getChildren(), function(obj){
				if(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){
					obj.startup();
					obj._started = true;
				}
			});

			// And this catches stuff like dojo/dnd/Source
			if(this._contentSetter){
				array.forEach(this._contentSetter.parseResults, function(obj){
					if(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){
						obj.startup();
						obj._started = true;
					}
				}, this);
			}
		},

		setHref: function(/*String|Uri*/ href){
			// summary:
			//		Deprecated.   Use set('href', ...) instead.
			kernel.deprecated("dijit.layout.ContentPane.setHref() is deprecated. Use set('href', ...) instead.", "", "2.0");
			return this.set("href", href);
		},
		_setHrefAttr: function(/*String|Uri*/ href){
			// summary:
			//		Hook so set("href", ...) works.
			// description:
			//		Reset the (external defined) content of this pane and replace with new url
			//		Note: It delays the download until widget is shown if preload is false.
			// href:
			//		url to the page you want to get, must be within the same domain as your mainpage

			// Cancel any in-flight requests (a set('href', ...) will cancel any in-flight set('href', ...))
			this.cancel();

			this.onLoadDeferred = new Deferred(lang.hitch(this, "cancel"));
			this.onLoadDeferred.then(lang.hitch(this, "onLoad"));

			this._set("href", href);

			// _setHrefAttr() is called during creation and by the user, after creation.
			// Assuming preload == false, only in the second case do we actually load the URL;
			// otherwise it's done in startup(), and only if this widget is shown.
			if(this.preload || (this._created && this._isShown())){
				this._load();
			}else{
				// Set flag to indicate that href needs to be loaded the next time the
				// ContentPane is made visible
				this._hrefChanged = true;
			}

			return this.onLoadDeferred;		// Deferred
		},

		setContent: function(/*String|DomNode|Nodelist*/data){
			// summary:
			//		Deprecated.   Use set('content', ...) instead.
			kernel.deprecated("dijit.layout.ContentPane.setContent() is deprecated.  Use set('content', ...) instead.", "", "2.0");
			this.set("content", data);
		},
		_setContentAttr: function(/*String|DomNode|Nodelist*/data){
			// summary:
			//		Hook to make set("content", ...) work.
			//		Replaces old content with data content, include style classes from old content
			// data:
			//		the new Content may be String, DomNode or NodeList
			//
			//		if data is a NodeList (or an array of nodes) nodes are copied
			//		so you can import nodes from another document implicitly

			// clear href so we can't run refresh and clear content
			// refresh should only work if we downloaded the content
			this._set("href", "");

			// Cancel any in-flight requests (a set('content', ...) will cancel any in-flight set('href', ...))
			this.cancel();

			// Even though user is just setting content directly, still need to define an onLoadDeferred
			// because the _onLoadHandler() handler is still getting called from setContent()
			this.onLoadDeferred = new Deferred(lang.hitch(this, "cancel"));
			if(this._created){
				// For back-compat reasons, call onLoad() for set('content', ...)
				// calls but not for content specified in srcNodeRef (ie: <div data-dojo-type=ContentPane>...</div>)
				// or as initialization parameter (ie: new ContentPane({content: ...})
				this.onLoadDeferred.then(lang.hitch(this, "onLoad"));
			}

			this._setContent(data || "");

			this._isDownloaded = false; // mark that content is from a set('content') not a set('href')

			return this.onLoadDeferred;	// Deferred
		},
		_getContentAttr: function(){
			// summary:
			//		Hook to make get("content") work
			return this.containerNode.innerHTML;
		},

		cancel: function(){
			// summary:
			//		Cancels an in-flight download of content
			if(this._xhrDfd && (this._xhrDfd.fired == -1)){
				this._xhrDfd.cancel();
			}
			delete this._xhrDfd; // garbage collect

			this.onLoadDeferred = null;
		},

		destroy: function(){
			this.cancel();
			this.inherited(arguments);
		},

		destroyRecursive: function(/*Boolean*/ preserveDom){
			// summary:
			//		Destroy the ContentPane and its contents

			// if we have multiple controllers destroying us, bail after the first
			if(this._beingDestroyed){
				return;
			}
			this.inherited(arguments);
		},

		_onShow: function(){
			// summary:
			//		Called when the ContentPane is made visible
			// description:
			//		For a plain ContentPane, this is called on initialization, from startup().
			//		If the ContentPane is a hidden pane of a TabContainer etc., then it's
			//		called whenever the pane is made visible.
			//
			//		Does necessary processing, including href download and layout/resize of
			//		child widget(s)

			this.inherited(arguments);

			if(this.href){
				if(!this._xhrDfd && // if there's an href that isn't already being loaded
					(!this.isLoaded || this._hrefChanged || this.refreshOnShow)
					){
					return this.refresh();	// If child has an href, promise that fires when the load is complete
				}
			}
		},

		refresh: function(){
			// summary:
			//		[Re]download contents of href and display
			// description:
			//		1. cancels any currently in-flight requests
			//		2. posts "loading..." message
			//		3. sends XHR to download new data

			// Cancel possible prior in-flight request
			this.cancel();

			this.onLoadDeferred = new Deferred(lang.hitch(this, "cancel"));
			this.onLoadDeferred.then(lang.hitch(this, "onLoad"));
			this._load();
			return this.onLoadDeferred;		// If child has an href, promise that fires when refresh is complete
		},

		_load: function(){
			// summary:
			//		Load/reload the href specified in this.href

			// display loading message
			this._setContent(this.onDownloadStart(), true);

			var self = this;
			var getArgs = {
				preventCache: (this.preventCache || this.refreshOnShow),
				url: this.href,
				handleAs: "text"
			};
			if(lang.isObject(this.ioArgs)){
				lang.mixin(getArgs, this.ioArgs);
			}

			var hand = (this._xhrDfd = (this.ioMethod || xhr.get)(getArgs)),
				returnedHtml;

			hand.then(
				function(html){
					returnedHtml = html;
					try{
						self._isDownloaded = true;
						return self._setContent(html, false);
					}catch(err){
						self._onError('Content', err); // onContentError
					}
				},
				function(err){
					if(!hand.canceled){
						// show error message in the pane
						self._onError('Download', err); // onDownloadError
					}
					delete self._xhrDfd;
					return err;
				}
			).then(function(){
					self.onDownloadEnd();
					delete self._xhrDfd;
					return returnedHtml;
				});

			// Remove flag saying that a load is needed
			delete this._hrefChanged;
		},

		_onLoadHandler: function(data){
			// summary:
			//		This is called whenever new content is being loaded
			this._set("isLoaded", true);
			try{
				this.onLoadDeferred.resolve(data);
			}catch(e){
				console.error('Error ' + this.widgetId + ' running custom onLoad code: ' + e.message);
			}
		},

		_onUnloadHandler: function(){
			// summary:
			//		This is called whenever the content is being unloaded
			this._set("isLoaded", false);
			try{
				this.onUnload();
			}catch(e){
				console.error('Error ' + this.widgetId + ' running custom onUnload code: ' + e.message);
			}
		},

		destroyDescendants: function(/*Boolean*/ preserveDom){
			// summary:
			//		Destroy all the widgets inside the ContentPane and empty containerNode

			// Make sure we call onUnload (but only when the ContentPane has real content)
			if(this.isLoaded){
				this._onUnloadHandler();
			}

			// Even if this.isLoaded == false there might still be a "Loading..." message
			// to erase, so continue...

			// For historical reasons we need to delete all widgets under this.containerNode,
			// even ones that the user has created manually.
			var setter = this._contentSetter;
			array.forEach(this.getChildren(), function(widget){
				if(widget.destroyRecursive){
					// All widgets will hit this branch
					widget.destroyRecursive(preserveDom);
				}else if(widget.destroy){
					// Things like dojo/dnd/Source have destroy(), not destroyRecursive()
					widget.destroy(preserveDom);
				}
				widget._destroyed = true;
			});
			if(setter){
				// Most of the widgets in setter.parseResults have already been destroyed, but
				// things like Menu that have been moved to <body> haven't yet
				array.forEach(setter.parseResults, function(widget){
					if(!widget._destroyed){
						if(widget.destroyRecursive){
							// All widgets will hit this branch
							widget.destroyRecursive(preserveDom);
						}else if(widget.destroy){
							// Things like dojo/dnd/Source have destroy(), not destroyRecursive()
							widget.destroy(preserveDom);
						}
						widget._destroyed = true;
					}
				});
				delete setter.parseResults;
			}

			// And then clear away all the DOM nodes
			if(!preserveDom){
				domConstruct.empty(this.containerNode);
			}

			// Delete any state information we have about current contents
			delete this._singleChild;
		},

		_setContent: function(/*String|DocumentFragment*/ cont, /*Boolean*/ isFakeContent){
			// summary:
			//		Insert the content into the container node
			// returns:
			//		Returns a Deferred promise that is resolved when the content is parsed.

			// first get rid of child widgets
			this.destroyDescendants();

			// html.set will take care of the rest of the details
			// we provide an override for the error handling to ensure the widget gets the errors
			// configure the setter instance with only the relevant widget instance properties
			// NOTE: unless we hook into attr, or provide property setters for each property,
			// we need to re-configure the ContentSetter with each use
			var setter = this._contentSetter;
			if(!(setter && setter instanceof html._ContentSetter)){
				setter = this._contentSetter = new html._ContentSetter({
					node: this.containerNode,
					_onError: lang.hitch(this, this._onError),
					onContentError: lang.hitch(this, function(e){
						// fires if a domfault occurs when we are appending this.errorMessage
						// like for instance if domNode is a UL and we try append a DIV
						var errMess = this.onContentError(e);
						try{
							this.containerNode.innerHTML = errMess;
						}catch(e){
							console.error('Fatal ' + this.id + ' could not change content due to ' + e.message, e);
						}
					})/*,
					 _onError */
				});
			}

			var setterParams = lang.mixin({
				cleanContent: this.cleanContent,
				extractContent: this.extractContent,
				parseContent: !cont.domNode && this.parseOnLoad,
				parserScope: this.parserScope,
				startup: false,
				dir: this.dir,
				lang: this.lang,
				textDir: this.textDir
			}, this._contentSetterParams || {});

			var p = setter.set((lang.isObject(cont) && cont.domNode) ? cont.domNode : cont, setterParams);

			// dojox/layout/html/_base::_ContentSetter.set() returns a Promise that indicates when everything is completed.
			// dojo/html::_ContentSetter.set() currently returns the DOMNode, but that will be changed for 2.0.
			// So, if set() returns a promise then use it, otherwise fallback to waiting on setter.parseDeferred
			var self = this;
			return when(p && p.then ? p : setter.parseDeferred, function(){
				// setter params must be pulled afresh from the ContentPane each time
				delete self._contentSetterParams;

				if(!isFakeContent){
					if(self._started){
						// Startup each top level child widget (and they will start their children, recursively)
						self._startChildren();

						// Call resize() on each of my child layout widgets,
						// or resize() on my single child layout widget...
						// either now (if I'm currently visible) or when I become visible
						self._scheduleLayout();
					}
					self._onLoadHandler(cont);
				}
			});
		},

		_onError: function(type, err, consoleText){
			this.onLoadDeferred.reject(err);

			// shows user the string that is returned by on[type]Error
			// override on[type]Error and return your own string to customize
			var errText = this['on' + type + 'Error'].call(this, err);
			if(consoleText){
				console.error(consoleText, err);
			}else if(errText){// a empty string won't change current content
				this._setContent(errText, true);
			}
		},

		// EVENT's, should be overide-able
		onLoad: function(/*===== data =====*/){
			// summary:
			//		Event hook, is called after everything is loaded and widgetified
			// tags:
			//		callback
		},

		onUnload: function(){
			// summary:
			//		Event hook, is called before old content is cleared
			// tags:
			//		callback
		},

		onDownloadStart: function(){
			// summary:
			//		Called before download starts.
			// description:
			//		The string returned by this function will be the html
			//		that tells the user we are loading something.
			//		Override with your own function if you want to change text.
			// tags:
			//		extension
			return this.loadingMessage;
		},

		onContentError: function(/*Error*/ /*===== error =====*/){
			// summary:
			//		Called on DOM faults, require faults etc. in content.
			//
			//		In order to display an error message in the pane, return
			//		the error message from this method, as an HTML string.
			//
			//		By default (if this method is not overriden), it returns
			//		nothing, so the error message is just printed to the console.
			// tags:
			//		extension
		},

		onDownloadError: function(/*Error*/ /*===== error =====*/){
			// summary:
			//		Called when download error occurs.
			//
			//		In order to display an error message in the pane, return
			//		the error message from this method, as an HTML string.
			//
			//		Default behavior (if this method is not overriden) is to display
			//		the error message inside the pane.
			// tags:
			//		extension
			return this.errorMessage;
		},

		onDownloadEnd: function(){
			// summary:
			//		Called when download is finished.
			// tags:
			//		callback
		}
	});
});

},
'dijit/_Container':function(){
define([
	"dojo/_base/array", // array.forEach array.indexOf
	"dojo/_base/declare", // declare
	"dojo/dom-construct", // domConstruct.place
	"dojo/_base/kernel" // kernel.deprecated
], function(array, declare, domConstruct, kernel){

	// module:
	//		dijit/_Container

	return declare("dijit._Container", null, {
		// summary:
		//		Mixin for widgets that contain HTML and/or a set of widget children.

		buildRendering: function(){
			this.inherited(arguments);
			if(!this.containerNode){
				// All widgets with descendants must set containerNode.
				// NB: this code doesn't quite work right because for TabContainer it runs before
				// _TemplatedMixin::buildRendering(), and thus
				// sets this.containerNode to this.domNode, later to be overridden by the assignment in the template.
				this.containerNode = this.domNode;
			}
		},

		addChild: function(/*dijit/_WidgetBase*/ widget, /*int?*/ insertIndex){
			// summary:
			//		Makes the given widget a child of this widget.
			// description:
			//		Inserts specified child widget's dom node as a child of this widget's
			//		container node, and possibly does other processing (such as layout).

			// I want to just call domConstruct.place(widget.domNode, this.containerNode, insertIndex), but the counting
			// is thrown off by text nodes and comment nodes that show up when constructed by markup.
			// In the future consider stripping those nodes on construction, either in the parser or this widget code.
			var refNode = this.containerNode;
			if(insertIndex > 0){
				// Old-school way to get nth child; dojo.query would be easier but _Container was weened from dojo.query
				// in #10087 to minimize download size.   Not sure if that's still and issue with new smaller dojo/query.
				refNode = refNode.firstChild;
				while(insertIndex > 0 && refNode !== null){
					if(refNode.nodeType == 1){ insertIndex--; }
					refNode = refNode.nextSibling;
				}
				if(refNode){
					insertIndex = "before";
				}else{
					// to support addChild(child, n-1) where there are n children (should add child at end)
					refNode = this.containerNode;
					insertIndex = "last";
				}
			}

			domConstruct.place(widget.domNode, refNode, insertIndex);

			// If I've been started but the child widget hasn't been started,
			// start it now.  Make sure to do this after widget has been
			// inserted into the DOM tree, so it can see that it's being controlled by me,
			// so it doesn't try to size itself.
			if(this._started && !widget._started){
				widget.startup();
			}
		},

		removeChild: function(/*Widget|int*/ widget){
			// summary:
			//		Removes the passed widget instance from this widget but does
			//		not destroy it.  You can also pass in an integer indicating
			//		the index within the container to remove (ie, removeChild(5) removes the sixth widget).

			if(typeof widget == "number"){
				widget = this.getChildren()[widget];
			}

			if(widget){
				var node = widget.domNode;
				if(node && node.parentNode){
					node.parentNode.removeChild(node); // detach but don't destroy
				}
			}
		},

		hasChildren: function(){
			// summary:
			//		Returns true if widget has child widgets, i.e. if this.containerNode contains widgets.
			return this.getChildren().length > 0;	// Boolean
		},

		_getSiblingOfChild: function(/*dijit/_WidgetBase*/ child, /*int*/ dir){
			// summary:
			//		Get the next or previous widget sibling of child
			// dir:
			//		if 1, get the next sibling
			//		if -1, get the previous sibling
			// tags:
			//		private
			kernel.deprecated(this.declaredClass+"::_getSiblingOfChild() is deprecated. Use _KeyNavMixin::_getNext() instead.", "", "2.0");
			var children = this.getChildren(),
				idx = array.indexOf(children, child);	// int
			return children[idx + dir];
		},

		getIndexOfChild: function(/*dijit/_WidgetBase*/ child){
			// summary:
			//		Gets the index of the child in this container or -1 if not found
			return array.indexOf(this.getChildren(), child);	// int
		}
	});
});

},
'dijit/layout/_ContentPaneResizeMixin':function(){
define([
	"dojo/_base/array", // array.filter array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.contains domClass.toggle
	"dojo/dom-geometry", // domGeometry.contentBox domGeometry.marginBox
	"dojo/dom-style",
	"dojo/_base/lang", // lang.mixin
	"dojo/query", // query
	"../registry", // registry.byId
	"../Viewport",
	"./utils" // marginBox2contextBox
], function(array, declare, domClass, domGeometry, domStyle, lang, query,
			registry, Viewport, layoutUtils){

	// module:
	//		dijit/layout/_ContentPaneResizeMixin

	return declare("dijit.layout._ContentPaneResizeMixin", null, {
		// summary:
		//		Resize() functionality of ContentPane.   If there's a single layout widget
		//		child then it will call resize() with the same dimensions as the ContentPane.
		//		Otherwise just calls resize on each child.
		//
		//		Also implements basic startup() functionality, where starting the parent
		//		will start the children

		// doLayout: Boolean
		//		- false - don't adjust size of children
		//		- true - if there is a single visible child widget, set it's size to however big the ContentPane is
		doLayout: true,

		// isLayoutContainer: [protected] Boolean
		//		Indicates that this widget will call resize() on it's child widgets
		//		when they become visible.
		isLayoutContainer: true,

		startup: function(){
			// summary:
			//		See `dijit/layout/_LayoutWidget.startup()` for description.
			//		Although ContentPane doesn't extend _LayoutWidget, it does implement
			//		the same API.

			if(this._started){
				return;
			}

			var parent = this.getParent();
			this._childOfLayoutWidget = parent && parent.isLayoutContainer;

			// I need to call resize() on my child/children (when I become visible), unless
			// I'm the child of a layout widget in which case my parent will call resize() on me and I'll do it then.
			this._needLayout = !this._childOfLayoutWidget;

			this.inherited(arguments);

			if(this._isShown()){
				this._onShow();
			}

			if(!this._childOfLayoutWidget){
				// Since my parent isn't a layout container, and my style *may be* width=height=100%
				// or something similar (either set directly or via a CSS class),
				// monitor when viewport size changes so that I can re-layout.
				// This is more for subclasses of ContentPane than ContentPane itself, although it
				// could be useful for a ContentPane if it has a single child widget inheriting ContentPane's size.
				this.own(Viewport.on("resize", lang.hitch(this, "resize")));
			}
		},

		_checkIfSingleChild: function(){
			// summary:
			//		Test if we have exactly one visible widget as a child,
			//		and if so assume that we are a container for that widget,
			//		and should propagate startup() and resize() calls to it.
			//		Skips over things like data stores since they aren't visible.

			if(!this.doLayout){ return; }

			var candidateWidgets = [],
				otherVisibleNodes = false;

			query("> *", this.containerNode).some(function(node){
				var widget = registry.byNode(node);
				if(widget && widget.resize){
					candidateWidgets.push(widget);
				}else if(!/script|link|style/i.test(node.nodeName) && node.offsetHeight){
					otherVisibleNodes = true;
				}
			});

			this._singleChild = candidateWidgets.length == 1 && !otherVisibleNodes ?
				candidateWidgets[0] : null;

			// So we can set overflow: hidden to avoid a safari bug w/scrollbars showing up (#9449)
			domClass.toggle(this.containerNode, this.baseClass + "SingleChild", !!this._singleChild);
		},

		resize: function(changeSize, resultSize){
			// summary:
			//		See `dijit/layout/_LayoutWidget.resize()` for description.
			//		Although ContentPane doesn't extend _LayoutWidget, it does implement
			//		the same API.

			this._resizeCalled = true;

			this._scheduleLayout(changeSize, resultSize);
		},

		_scheduleLayout: function(changeSize, resultSize){
			// summary:
			//		Resize myself, and call resize() on each of my child layout widgets, either now
			//		(if I'm currently visible) or when I become visible
			if(this._isShown()){
				this._layout(changeSize, resultSize);
			}else{
				this._needLayout = true;
				this._changeSize = changeSize;
				this._resultSize = resultSize;
			}
		},

		_layout: function(changeSize, resultSize){
			// summary:
			//		Resize myself according to optional changeSize/resultSize parameters, like a layout widget.
			//		Also, since I am an isLayoutContainer widget, each of my children expects me to
			//		call resize() or layout() on it.
			//
			//		Should be called on initialization and also whenever we get new content
			//		(from an href, or from set('content', ...))... but deferred until
			//		the ContentPane is visible

			delete this._needLayout;

			// For the TabContainer --> BorderContainer --> ContentPane case, _onShow() is
			// never called directly, so resize() is our trigger to do the initial href download (see [20099]).
			// However, don't load href for closed TitlePanes.
			if(!this._wasShown && this.open !== false){
				this._onShow();
			}

			// Set margin box size, unless it wasn't specified, in which case use current size.
			if(changeSize){
				domGeometry.setMarginBox(this.domNode, changeSize);
			}

			// Compute content box size of containerNode in case we [later] need to size our single child.
			var cn = this.containerNode;
			if(cn === this.domNode){
				// If changeSize or resultSize was passed to this method and this.containerNode ==
				// this.domNode then we can compute the content-box size without querying the node,
				// which is more reliable (similar to LayoutWidget.resize) (see for example #9449).
				var mb = resultSize || {};
				lang.mixin(mb, changeSize || {}); // changeSize overrides resultSize
				if(!("h" in mb) || !("w" in mb)){
					mb = lang.mixin(domGeometry.getMarginBox(cn), mb); // just use domGeometry.setMarginBox() to fill in missing values
				}
				this._contentBox = layoutUtils.marginBox2contentBox(cn, mb);
			}else{
				this._contentBox = domGeometry.getContentBox(cn);
			}

			this._layoutChildren();
		},

		_layoutChildren: function(){
			// Call _checkIfSingleChild() again in case app has manually mucked w/the content
			// of the ContentPane (rather than changing it through the set("content", ...) API.
			this._checkIfSingleChild();

			if(this._singleChild && this._singleChild.resize){
				var cb = this._contentBox || domGeometry.getContentBox(this.containerNode);

				// note: if widget has padding this._contentBox will have l and t set,
				// but don't pass them to resize() or it will doubly-offset the child
				this._singleChild.resize({w: cb.w, h: cb.h});
			}else{
				// All my child widgets are independently sized (rather than matching my size),
				// but I still need to call resize() on each child to make it layout.
				var children = this.getChildren(),
					widget,
					i = 0;
				while(widget = children[i++]){
					if(widget.resize){
						widget.resize();
					}
				}
			}
		},

		_isShown: function(){
			// summary:
			//		Returns true if the content is currently shown.
			// description:
			//		If I am a child of a layout widget then it actually returns true if I've ever been visible,
			//		not whether I'm currently visible, since that's much faster than tracing up the DOM/widget
			//		tree every call, and at least solves the performance problem on page load by deferring loading
			//		hidden ContentPanes until they are first shown

			if(this._childOfLayoutWidget){
				// If we are TitlePane, etc - we return that only *IF* we've been resized
				if(this._resizeCalled && "open" in this){
					return this.open;
				}
				return this._resizeCalled;
			}else if("open" in this){
				return this.open;		// for TitlePane, etc.
			}else{
				var node = this.domNode, parent = this.domNode.parentNode;
				return (node.style.display != 'none') && (node.style.visibility != 'hidden') && !domClass.contains(node, "dijitHidden") &&
					parent && parent.style && (parent.style.display != 'none');
			}
		},

		_onShow: function(){
			// summary:
			//		Called when the ContentPane is made visible
			// description:
			//		For a plain ContentPane, this is called on initialization, from startup().
			//		If the ContentPane is a hidden pane of a TabContainer etc., then it's
			//		called whenever the pane is made visible.
			//
			//		Does layout/resize of child widget(s)

			// Need to keep track of whether ContentPane has been shown (which is different than
			// whether or not it's currently visible).
			this._wasShown = true;

			if(this._needLayout){
				// If a layout has been scheduled for when we become visible, do it now
				this._layout(this._changeSize, this._resultSize);
			}

			this.inherited(arguments);
		}
	});
});

},
'dijit/layout/utils':function(){
define([
	"dojo/_base/array", // array.filter array.forEach
	"dojo/dom-class", // domClass.add domClass.remove
	"dojo/dom-geometry", // domGeometry.marginBox
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/_base/lang" // lang.mixin, lang.setObject
], function(array, domClass, domGeometry, domStyle, lang){

	// module:
	//		dijit/layout/utils

	function capitalize(word){
		return word.substring(0,1).toUpperCase() + word.substring(1);
	}

	function size(widget, dim){
		// size the child
		var newSize = widget.resize ? widget.resize(dim) : domGeometry.setMarginBox(widget.domNode, dim);

		// record child's size
		if(newSize){
			// if the child returned it's new size then use that
			lang.mixin(widget, newSize);
		}else{
			// otherwise, call getMarginBox(), but favor our own numbers when we have them.
			// the browser lies sometimes
			lang.mixin(widget, domGeometry.getMarginBox(widget.domNode));
			lang.mixin(widget, dim);
		}
	}

	var utils = {
		// summary:
		//		Utility functions for doing layout

		marginBox2contentBox: function(/*DomNode*/ node, /*Object*/ mb){
			// summary:
			//		Given the margin-box size of a node, return its content box size.
			//		Functions like domGeometry.contentBox() but is more reliable since it doesn't have
			//		to wait for the browser to compute sizes.
			var cs = domStyle.getComputedStyle(node);
			var me = domGeometry.getMarginExtents(node, cs);
			var pb = domGeometry.getPadBorderExtents(node, cs);
			return {
				l: domStyle.toPixelValue(node, cs.paddingLeft),
				t: domStyle.toPixelValue(node, cs.paddingTop),
				w: mb.w - (me.w + pb.w),
				h: mb.h - (me.h + pb.h)
			};
		},


		layoutChildren: function(/*DomNode*/ container, /*Object*/ dim, /*Widget[]*/ children,
				/*String?*/ changedRegionId, /*Number?*/ changedRegionSize){
			// summary:
			//		Layout a bunch of child dom nodes within a parent dom node
			// container:
			//		parent node
			// dim:
			//		{l, t, w, h} object specifying dimensions of container into which to place children
			// children:
			//		An array of Widgets or at least objects containing:
			//
			//		- domNode: pointer to DOM node to position
			//		- region or layoutAlign: position to place DOM node
			//		- resize(): (optional) method to set size of node
			//		- id: (optional) Id of widgets, referenced from resize object, below.
			//
			//		The widgets in this array should be ordered according to how they should be laid out
			//		(each element will be processed in order, and take up as much remaining space as needed),
			//		with the center widget last.
			// changedRegionId:
			//		If specified, the slider for the region with the specified id has been dragged, and thus
			//		the region's height or width should be adjusted according to changedRegionSize
			// changedRegionSize:
			//		See changedRegionId.

			// copy dim because we are going to modify it
			dim = lang.mixin({}, dim);

			domClass.add(container, "dijitLayoutContainer");

			// Move "client" elements to the end of the array for layout.  a11y dictates that the author
			// needs to be able to put them in the document in tab-order, but this algorithm requires that
			// client be last.    TODO: remove for 2.0, all dijit client code already sends children as last item.
			children = array.filter(children, function(item){ return item.region != "center" && item.layoutAlign != "client"; })
				.concat(array.filter(children, function(item){ return item.region == "center" || item.layoutAlign == "client"; }));

			// set positions/sizes
			array.forEach(children, function(child){
				var elm = child.domNode,
					pos = (child.region || child.layoutAlign);
				if(!pos){
					throw new Error("No region setting for " + child.id)
				}

				// set elem to upper left corner of unused space; may move it later
				var elmStyle = elm.style;
				elmStyle.left = dim.l+"px";
				elmStyle.top = dim.t+"px";
				elmStyle.position = "absolute";

				domClass.add(elm, "dijitAlign" + capitalize(pos));

				// Size adjustments to make to this child widget
				var sizeSetting = {};

				// Check for optional size adjustment due to splitter drag (height adjustment for top/bottom align
				// panes and width adjustment for left/right align panes.
				if(changedRegionId && changedRegionId == child.id){
					sizeSetting[child.region == "top" || child.region == "bottom" ? "h" : "w"] = changedRegionSize;
				}

				if(pos == "leading"){
					pos = child.isLeftToRight() ? "left" : "right";
				}
				if(pos == "trailing"){
					pos = child.isLeftToRight() ? "right" : "left";
				}

				// set size && adjust record of remaining space.
				// note that setting the width of a <div> may affect its height.
				if(pos == "top" || pos == "bottom"){
					sizeSetting.w = dim.w;
					size(child, sizeSetting);
					dim.h -= child.h;
					if(pos == "top"){
						dim.t += child.h;
					}else{
						elmStyle.top = dim.t + dim.h + "px";
					}
				}else if(pos == "left" || pos == "right"){
					sizeSetting.h = dim.h;
					size(child, sizeSetting);
					dim.w -= child.w;
					if(pos == "left"){
						dim.l += child.w;
					}else{
						elmStyle.left = dim.l + dim.w + "px";
					}
				}else if(pos == "client" || pos == "center"){
					size(child, dim);
				}
			});
		}
	};

	lang.setObject("dijit.layout.utils", utils);	// remove for 2.0

	return utils;
});

},
'dijit/ProgressBar':function(){
define([
	"require", // require.toUrl
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.toggle
	"dojo/_base/lang", // lang.mixin
	"dojo/number", // number.format
	"./_Widget",
	"./_TemplatedMixin",
	"dojo/text!./templates/ProgressBar.html"
], function(require, declare, domClass, lang, number, _Widget, _TemplatedMixin, template){

	// module:
	//		dijit/ProgressBar

	return declare("dijit.ProgressBar", [_Widget, _TemplatedMixin], {
		// summary:
		//		A progress indication widget, showing the amount completed
		//		(often the percentage completed) of a task.

		// progress: [const] String (Percentage or Number)
		//		Number or percentage indicating amount of task completed.
		//		Deprecated.   Use "value" instead.
		progress: "0",

		// value: String (Percentage or Number)
		//		Number or percentage indicating amount of task completed.
		//		With "%": percentage value, 0% <= progress <= 100%, or
		//		without "%": absolute value, 0 <= progress <= maximum.
		//		Infinity means that the progress bar is indeterminate.
		value: "",

		// maximum: [const] Float
		//		Max sample number
		maximum: 100,

		// places: [const] Number
		//		Number of places to show in values; 0 by default
		places: 0,

		// indeterminate: [const] Boolean
		//		If false: show progress value (number or percentage).
		//		If true: show that a process is underway but that the amount completed is unknown.
		//		Deprecated.   Use "value" instead.
		indeterminate: false,

		// label: String?
		//		HTML label on progress bar.   Defaults to percentage for determinate progress bar and
		//		blank for indeterminate progress bar.
		label: "",

		// name: String
		//		this is the field name (for a form) if set. This needs to be set if you want to use
		//		this widget in a dijit/form/Form widget (such as dijit/Dialog)
		name: '',

		templateString: template,

		// _indeterminateHighContrastImagePath: [private] URL
		//		URL to image to use for indeterminate progress bar when display is in high contrast mode
		_indeterminateHighContrastImagePath: require.toUrl("./themes/a11y/indeterminate_progress.gif"),

		postMixInProperties: function(){
			this.inherited(arguments);

			// Back-compat for when constructor specifies indeterminate or progress, rather than value.   Remove for 2.0.
			if(!(this.params && "value" in this.params)){
				this.value = this.indeterminate ? Infinity : this.progress;
			}
		},

		buildRendering: function(){
			this.inherited(arguments);
			this.indeterminateHighContrastImage.setAttribute("src",
				this._indeterminateHighContrastImagePath.toString());
			this.update();
		},

		_setDirAttr: function(val){
			// Normally _CssStateMixin takes care of this, but we aren't extending it
			var rtl = val.toLowerCase() == "rtl";
			domClass.toggle(this.domNode, "dijitProgressBarRtl", rtl);
			domClass.toggle(this.domNode, "dijitProgressBarIndeterminateRtl", this.indeterminate && rtl);
			this.inherited(arguments);
		},

		update: function(/*Object?*/attributes){
			// summary:
			//		Internal method to change attributes of ProgressBar, similar to set(hash).  Users should call
			//		set("value", ...) rather than calling this method directly.
			// attributes:
			//		May provide progress and/or maximum properties on this parameter;
			//		see attribute specs for details.
			// example:
			//	|	myProgressBar.update({'indeterminate': true});
			//	|	myProgressBar.update({'progress': 80});
			//	|	myProgressBar.update({'indeterminate': true, label:"Loading ..." })
			// tags:
			//		private

			// TODO: deprecate this method and use set() instead

			lang.mixin(this, attributes || {});
			var tip = this.internalProgress, ap = this.domNode;
			var percent = 1;
			if(this.indeterminate){
				ap.removeAttribute("aria-valuenow");
			}else{
				if(String(this.progress).indexOf("%") != -1){
					percent = Math.min(parseFloat(this.progress) / 100, 1);
					this.progress = percent * this.maximum;
				}else{
					this.progress = Math.min(this.progress, this.maximum);
					percent = this.maximum ? this.progress / this.maximum : 0;
				}
				ap.setAttribute("aria-valuenow", this.progress);
			}

			// Even indeterminate ProgressBars should have these attributes
			ap.setAttribute("aria-labelledby", this.labelNode.id);
			ap.setAttribute("aria-valuemin", 0);
			ap.setAttribute("aria-valuemax", this.maximum);

			this.labelNode.innerHTML = this.report(percent);

			domClass.toggle(this.domNode, "dijitProgressBarIndeterminate", this.indeterminate);
			domClass.toggle(this.domNode, "dijitProgressBarIndeterminateRtl", this.indeterminate && !this.isLeftToRight());

			tip.style.width = (percent * 100) + "%";
			this.onChange();
		},

		_setValueAttr: function(v){
			this._set("value", v);
			if(v == Infinity){
				this.update({indeterminate: true});
			}else{
				this.update({indeterminate: false, progress: v});
			}
		},

		_setLabelAttr: function(label){
			this._set("label", label);
			this.update();
		},

		_setIndeterminateAttr: function(indeterminate){
			// Deprecated, use set("value", ...) instead
			this._set("indeterminate", indeterminate);
			this.update();
		},

		report: function(/*float*/percent){
			// summary:
			//		Generates HTML message to show inside progress bar (normally indicating amount of task completed).
			//		May be overridden.
			// tags:
			//		extension

			return this.label ? this.label :
				(this.indeterminate ? "&#160;" : number.format(percent, { type: "percent", places: this.places, locale: this.lang }));
		},

		onChange: function(){
			// summary:
			//		Callback fired when progress updates.
			// tags:
			//		extension
		}
	});
});

},
'dijit/form/TextBox':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-construct", // domConstruct.create
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/sniff", // has("ie") has("mozilla")
	"./_FormValueWidget",
	"./_TextBoxMixin",
	"dojo/text!./templates/TextBox.html",
	"../main"	// to export dijit._setSelectionRange, remove in 2.0
], function(declare, domConstruct, domStyle, kernel, lang, on, has,
			_FormValueWidget, _TextBoxMixin, template, dijit){

	// module:
	//		dijit/form/TextBox

	var TextBox = declare("dijit.form.TextBox" + (has("dojo-bidi") ? "_NoBidi" : ""), [_FormValueWidget, _TextBoxMixin], {
		// summary:
		//		A base class for textbox form inputs

		templateString: template,
		_singleNodeTemplate: '<input class="dijit dijitReset dijitLeft dijitInputField" data-dojo-attach-point="textbox,focusNode" autocomplete="off" type="${type}" ${!nameAttrSetting} />',

		_buttonInputDisabled: has("ie") ? "disabled" : "", // allows IE to disallow focus, but Firefox cannot be disabled for mousedown events

		baseClass: "dijitTextBox",

		postMixInProperties: function(){
			var type = this.type.toLowerCase();
			if(this.templateString && this.templateString.toLowerCase() == "input" || ((type == "hidden" || type == "file") && this.templateString == this.constructor.prototype.templateString)){
				this.templateString = this._singleNodeTemplate;
			}
			this.inherited(arguments);
		},

		postCreate: function(){
			this.inherited(arguments);

			if(has("ie") < 9){
				// IE INPUT tag fontFamily has to be set directly using STYLE
				// the defer gives IE a chance to render the TextBox and to deal with font inheritance
				this.defer(function(){
					try{
						var s = domStyle.getComputedStyle(this.domNode); // can throw an exception if widget is immediately destroyed
						if(s){
							var ff = s.fontFamily;
							if(ff){
								var inputs = this.domNode.getElementsByTagName("INPUT");
								if(inputs){
									for(var i=0; i < inputs.length; i++){
										inputs[i].style.fontFamily = ff;
									}
								}
							}
						}
					}catch(e){/*when used in a Dialog, and this is called before the dialog is
					 shown, s.fontFamily would trigger "Invalid Argument" error.*/}
				});
			}
		},

		_setPlaceHolderAttr: function(v){
			this._set("placeHolder", v);
			if(!this._phspan){
				this._attachPoints.push('_phspan');
				this._phspan = domConstruct.create('span', {
					// dijitInputField class gives placeHolder same padding as the input field
					// parent node already has dijitInputField class but it doesn't affect this <span>
					// since it's position: absolute.
					className: 'dijitPlaceHolder dijitInputField'
				}, this.textbox, 'after');
				this.own(
					on(this._phspan, "mousedown", function(evt){ evt.preventDefault(); }),
					on(this._phspan, "touchend, pointerup, MSPointerUp", lang.hitch(this, function(){
						// If the user clicks placeholder rather than the <input>, need programmatic focus.  Normally this
						// is done in _FormWidgetMixin._onFocus() but after [30663] it's done on a delay, which is ineffective.
						this.focus();
					}))
				);
			}
			this._phspan.innerHTML="";
			this._phspan.appendChild(this._phspan.ownerDocument.createTextNode(v));
			this._updatePlaceHolder();
		},

		_onInput: function(/*Event*/ evt){
			// summary:
			//		Called AFTER the input event has happened
			//		See if the placeHolder text should be removed or added while editing.
			this.inherited(arguments);
			this._updatePlaceHolder();
		},

		_updatePlaceHolder: function(){
			if(this._phspan){
				this._phspan.style.display = (this.placeHolder && !this.textbox.value) ? "" : "none";
			}
		},

		_setValueAttr: function(value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			this.inherited(arguments);
			this._updatePlaceHolder();
		},

		getDisplayedValue: function(){
			// summary:
			//		Deprecated.  Use get('displayedValue') instead.
			// tags:
			//		deprecated
			kernel.deprecated(this.declaredClass+"::getDisplayedValue() is deprecated. Use get('displayedValue') instead.", "", "2.0");
			return this.get('displayedValue');
		},

		setDisplayedValue: function(/*String*/ value){
			// summary:
			//		Deprecated.  Use set('displayedValue', ...) instead.
			// tags:
			//		deprecated
			kernel.deprecated(this.declaredClass+"::setDisplayedValue() is deprecated. Use set('displayedValue', ...) instead.", "", "2.0");
			this.set('displayedValue', value);
		},

		_onBlur: function(e){
			if(this.disabled){ return; }
			this.inherited(arguments);
			this._updatePlaceHolder();

			if(has("mozilla")){
				if(this.selectOnClick){
					// clear selection so that the next mouse click doesn't reselect
					this.textbox.selectionStart = this.textbox.selectionEnd = undefined;
				}
			}
		},

		_onFocus: function(/*String*/ by){
			if(this.disabled || this.readOnly){ return; }
			this.inherited(arguments);
			this._updatePlaceHolder();
		}
	});

	if(has("ie") < 9){
		TextBox.prototype._isTextSelected = function(){
			var range = this.ownerDocument.selection.createRange();
			var parent = range.parentElement();
			return parent == this.textbox && range.text.length > 0;
		};

		// Overrides definition of _setSelectionRange from _TextBoxMixin (TODO: move to _TextBoxMixin.js?)
		dijit._setSelectionRange = _TextBoxMixin._setSelectionRange = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
			if(element.createTextRange){
				var r = element.createTextRange();
				r.collapse(true);
				r.moveStart("character", -99999); // move to 0
				r.moveStart("character", start); // delta from 0 is the correct position
				r.moveEnd("character", stop-start);
				r.select();
			}
		}
	}

	if(has("dojo-bidi")){
		TextBox = declare("dijit.form.TextBox", TextBox, {
			_setPlaceHolderAttr: function(v){
				this.inherited(arguments);
				this.applyTextDir(this._phspan);
			}
		});
	}

	return TextBox;
});

},
'dijit/form/_FormValueWidget':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/sniff", // has("ie")
	"./_FormWidget",
	"./_FormValueMixin"
], function(declare, has, _FormWidget, _FormValueMixin){

	// module:
	//		dijit/form/_FormValueWidget

	return declare("dijit.form._FormValueWidget", [_FormWidget, _FormValueMixin], {
		// summary:
		//		Base class for widgets corresponding to native HTML elements such as `<input>` or `<select>`
		//		that have user changeable values.
		// description:
		//		Each _FormValueWidget represents a single input value, and has a (possibly hidden) `<input>` element,
		//		to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
		//		works as expected.

		// Don't attempt to mixin the 'type', 'name' attributes here programatically -- they must be declared
		// directly in the template as read by the parser in order to function. IE is known to specifically
		// require the 'name' attribute at element creation time.  See #8484, #8660.

		_layoutHackIE7: function(){
			// summary:
			//		Work around table sizing bugs on IE7 by forcing redraw

			if(has("ie") == 7){ // fix IE7 layout bug when the widget is scrolled out of sight
				var domNode = this.domNode;
				var parent = domNode.parentNode;
				var pingNode = domNode.firstChild || domNode; // target node most unlikely to have a custom filter
				var origFilter = pingNode.style.filter; // save custom filter, most likely nothing
				var _this = this;
				while(parent && parent.clientHeight == 0){ // search for parents that haven't rendered yet
					(function ping(){
						var disconnectHandle = _this.connect(parent, "onscroll",
							function(){
								_this.disconnect(disconnectHandle); // only call once
								pingNode.style.filter = (new Date()).getMilliseconds(); // set to anything that's unique
								_this.defer(function(){
									pingNode.style.filter = origFilter;
								}); // restore custom filter, if any
							}
						);
					})();
					parent = parent.parentNode;
				}
			}
		}
	});
});

},
'dijit/form/_FormValueMixin':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/keys", // keys.ESCAPE
	"dojo/_base/lang",
	"dojo/on",
	"./_FormWidgetMixin"
], function(declare, domAttr, keys, lang, on, _FormWidgetMixin){

	// module:
	//		dijit/form/_FormValueMixin

	return declare("dijit.form._FormValueMixin", _FormWidgetMixin, {
		// summary:
		//		Mixin for widgets corresponding to native HTML elements such as `<input>` or `<select>`
		//		that have user changeable values.
		// description:
		//		Each _FormValueMixin represents a single input value, and has a (possibly hidden) `<input>` element,
		//		to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
		//		works as expected.

		// readOnly: Boolean
		//		Should this widget respond to user input?
		//		In markup, this is specified as "readOnly".
		//		Similar to disabled except readOnly form values are submitted.
		readOnly: false,

		_setReadOnlyAttr: function(/*Boolean*/ value){
			domAttr.set(this.focusNode, 'readOnly', value);
			this._set("readOnly", value);
		},

		postCreate: function(){
			this.inherited(arguments);

			// Update our reset value if it hasn't yet been set (because this.set()
			// is only called when there *is* a value)
			if(this._resetValue === undefined){
				this._lastValueReported = this._resetValue = this.value;
			}
		},

		_setValueAttr: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so set('value', value) works.
			// description:
			//		Sets the value of the widget.
			//		If the value has changed, then fire onChange event, unless priorityChange
			//		is specified as null (or false?)
			this._handleOnChange(newValue, priorityChange);
		},

		_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
			// summary:
			//		Called when the value of the widget has changed.  Saves the new value in this.value,
			//		and calls onChange() if appropriate.   See _FormWidget._handleOnChange() for details.
			this._set("value", newValue);
			this.inherited(arguments);
		},

		undo: function(){
			// summary:
			//		Restore the value to the last value passed to onChange
			this._setValueAttr(this._lastValueReported, false);
		},

		reset: function(){
			// summary:
			//		Reset the widget's value to what it was at initialization time
			this._hasBeenBlurred = false;
			this._setValueAttr(this._resetValue, true);
		}
	});
});

},
'dijit/form/_TextBoxMixin':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.byId
	"dojo/has",
	"dojo/keys", // keys.ALT keys.CAPS_LOCK keys.CTRL keys.META keys.SHIFT
	"dojo/_base/lang", // lang.mixin
	"dojo/on", // on
	"../main"    // for exporting dijit._setSelectionRange, dijit.selectInputText
], function(array, declare, dom, has, keys, lang, on, dijit){

	// module:
	//		dijit/form/_TextBoxMixin

	var _TextBoxMixin = declare("dijit.form._TextBoxMixin" + (has("dojo-bidi") ? "_NoBidi" : ""), null, {
		// summary:
		//		A mixin for textbox form input widgets

		// trim: Boolean
		//		Removes leading and trailing whitespace if true.  Default is false.
		trim: false,

		// uppercase: Boolean
		//		Converts all characters to uppercase if true.  Default is false.
		uppercase: false,

		// lowercase: Boolean
		//		Converts all characters to lowercase if true.  Default is false.
		lowercase: false,

		// propercase: Boolean
		//		Converts the first character of each word to uppercase if true.
		propercase: false,

		// maxLength: String
		//		HTML INPUT tag maxLength declaration.
		maxLength: "",

		// selectOnClick: [const] Boolean
		//		If true, all text will be selected when focused with mouse
		selectOnClick: false,

		// placeHolder: String
		//		Defines a hint to help users fill out the input field (as defined in HTML 5).
		//		This should only contain plain text (no html markup).
		placeHolder: "",

		_getValueAttr: function(){
			// summary:
			//		Hook so get('value') works as we like.
			// description:
			//		For `dijit/form/TextBox` this basically returns the value of the `<input>`.
			//
			//		For `dijit/form/MappedTextBox` subclasses, which have both
			//		a "displayed value" and a separate "submit value",
			//		This treats the "displayed value" as the master value, computing the
			//		submit value from it via this.parse().
			return this.parse(this.get('displayedValue'), this.constraints);
		},

		_setValueAttr: function(value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			// summary:
			//		Hook so set('value', ...) works.
			//
			// description:
			//		Sets the value of the widget to "value" which can be of
			//		any type as determined by the widget.
			//
			// value:
			//		The visual element value is also set to a corresponding,
			//		but not necessarily the same, value.
			//
			// formattedValue:
			//		If specified, used to set the visual element value,
			//		otherwise a computed visual value is used.
			//
			// priorityChange:
			//		If true, an onChange event is fired immediately instead of
			//		waiting for the next blur event.

			var filteredValue;
			if(value !== undefined){
				// TODO: this is calling filter() on both the display value and the actual value.
				// I added a comment to the filter() definition about this, but it should be changed.
				filteredValue = this.filter(value);
				if(typeof formattedValue != "string"){
					if(filteredValue !== null && ((typeof filteredValue != "number") || !isNaN(filteredValue))){
						formattedValue = this.filter(this.format(filteredValue, this.constraints));
					}else{
						formattedValue = '';
					}
					// Ensure the filtered value does not change after being formatted. See track #17955.
					//
					// This check is only applied when the formatted value is not specified by the caller in order to allow the 
					// behavior to be overriden. This is needed whenever value synonyms cannot be determined using parse/compare. For
					// example, dijit/form/FilteringSelect determines the formatted value asynchronously and applies it using a 
					// callback to this method.
					//
					// TODO: Should developers be warned that they broke the round trip on format?
					if (this.compare(filteredValue, this.filter(this.parse(formattedValue, this.constraints))) != 0){
						formattedValue = null;
					}
				}
			}
			if(formattedValue != null /* and !undefined */ && ((typeof formattedValue) != "number" || !isNaN(formattedValue)) && this.textbox.value != formattedValue){
				this.textbox.value = formattedValue;
				this._set("displayedValue", this.get("displayedValue"));
			}

			this.inherited(arguments, [filteredValue, priorityChange]);
		},

		// displayedValue: String
		//		For subclasses like ComboBox where the displayed value
		//		(ex: Kentucky) and the serialized value (ex: KY) are different,
		//		this represents the displayed value.
		//
		//		Setting 'displayedValue' through set('displayedValue', ...)
		//		updates 'value', and vice-versa.  Otherwise 'value' is updated
		//		from 'displayedValue' periodically, like onBlur etc.
		//
		//		TODO: move declaration to MappedTextBox?
		//		Problem is that ComboBox references displayedValue,
		//		for benefit of FilteringSelect.
		displayedValue: "",

		_getDisplayedValueAttr: function(){
			// summary:
			//		Hook so get('displayedValue') works.
			// description:
			//		Returns the displayed value (what the user sees on the screen),
			//		after filtering (ie, trimming spaces etc.).
			//
			//		For some subclasses of TextBox (like ComboBox), the displayed value
			//		is different from the serialized value that's actually
			//		sent to the server (see `dijit/form/ValidationTextBox.serialize()`)

			// TODO: maybe we should update this.displayedValue on every keystroke so that we don't need
			// this method
			// TODO: this isn't really the displayed value when the user is typing
			return this.filter(this.textbox.value);
		},

		_setDisplayedValueAttr: function(/*String*/ value){
			// summary:
			//		Hook so set('displayedValue', ...) works.
			// description:
			//		Sets the value of the visual element to the string "value".
			//		The widget value is also set to a corresponding,
			//		but not necessarily the same, value.

			if(value == null /* or undefined */){
				value = ''
			}
			else if(typeof value != "string"){
				value = String(value)
			}

			this.textbox.value = value;

			// sets the serialized value to something corresponding to specified displayedValue
			// (if possible), and also updates the textbox.value, for example converting "123"
			// to "123.00"
			this._setValueAttr(this.get('value'), undefined);

			this._set("displayedValue", this.get('displayedValue'));
		},

		format: function(value /*=====, constraints =====*/){
			// summary:
			//		Replaceable function to convert a value to a properly formatted string.
			// value: String
			// constraints: Object
			// tags:
			//		protected extension
			return value == null /* or undefined */ ? "" : (value.toString ? value.toString() : value);
		},

		parse: function(value /*=====, constraints =====*/){
			// summary:
			//		Replaceable function to convert a formatted string to a value
			// value: String
			// constraints: Object
			// tags:
			//		protected extension

			return value;	// String
		},

		_refreshState: function(){
			// summary:
			//		After the user types some characters, etc., this method is
			//		called to check the field for validity etc.  The base method
			//		in `dijit/form/TextBox` does nothing, but subclasses override.
			// tags:
			//		protected
		},

		 onInput: function(/*===== event =====*/){
			 // summary:
			 //		Connect to this function to receive notifications of various user data-input events.
			 //		Return false to cancel the event and prevent it from being processed.
			 // event:
			 //		keydown | keypress | cut | paste | input
			 // tags:
			 //		callback
		 },

		__skipInputEvent: false,
		_onInput: function(/*Event*/ evt){
			// summary:
			//		Called AFTER the input event has happened

			this._processInput(evt);

			if(this.intermediateChanges){
				// allow the key to post to the widget input box
				this.defer(function(){
					this._handleOnChange(this.get('value'), false);
				});
			}
		},

		_processInput: function(/*Event*/ evt){
			// summary:
			//		Default action handler for user input events

			this._refreshState();

			// In case someone is watch()'ing for changes to displayedValue
			this._set("displayedValue", this.get("displayedValue"));
		},

		postCreate: function(){
			// setting the value here is needed since value="" in the template causes "undefined"
			// and setting in the DOM (instead of the JS object) helps with form reset actions
			this.textbox.setAttribute("value", this.textbox.value); // DOM and JS values should be the same

			this.inherited(arguments);

			// normalize input events to reduce spurious event processing
			//	onkeydown: do not forward modifier keys
			//		       set charOrCode to numeric keycode
			//	onkeypress: do not forward numeric charOrCode keys (already sent through onkeydown)
			//	onpaste & oncut: set charOrCode to 229 (IME)
			//	oninput: if primary event not already processed, set charOrCode to 229 (IME), else do not forward
			function handleEvent(e){
				var charOrCode;
				if(e.type == "keydown"){
					charOrCode = e.keyCode;
					switch(charOrCode){ // ignore state keys
						case keys.SHIFT:
						case keys.ALT:
						case keys.CTRL:
						case keys.META:
						case keys.CAPS_LOCK:
						case keys.NUM_LOCK:
						case keys.SCROLL_LOCK:
							return;
					}
					if(!e.ctrlKey && !e.metaKey && !e.altKey){ // no modifiers
						switch(charOrCode){ // ignore location keys
							case keys.NUMPAD_0:
							case keys.NUMPAD_1:
							case keys.NUMPAD_2:
							case keys.NUMPAD_3:
							case keys.NUMPAD_4:
							case keys.NUMPAD_5:
							case keys.NUMPAD_6:
							case keys.NUMPAD_7:
							case keys.NUMPAD_8:
							case keys.NUMPAD_9:
							case keys.NUMPAD_MULTIPLY:
							case keys.NUMPAD_PLUS:
							case keys.NUMPAD_ENTER:
							case keys.NUMPAD_MINUS:
							case keys.NUMPAD_PERIOD:
							case keys.NUMPAD_DIVIDE:
								return;
						}
						if((charOrCode >= 65 && charOrCode <= 90) || (charOrCode >= 48 && charOrCode <= 57) || charOrCode == keys.SPACE){
							return; // keypress will handle simple non-modified printable keys
						}
						var named = false;
						for(var i in keys){
							if(keys[i] === e.keyCode){
								named = true;
								break;
							}
						}
						if(!named){
							return;
						} // only allow named ones through
					}
				}
				charOrCode = e.charCode >= 32 ? String.fromCharCode(e.charCode) : e.charCode;
				if(!charOrCode){
					charOrCode = (e.keyCode >= 65 && e.keyCode <= 90) || (e.keyCode >= 48 && e.keyCode <= 57) || e.keyCode == keys.SPACE ? String.fromCharCode(e.keyCode) : e.keyCode;
				}
				if(!charOrCode){
					charOrCode = 229; // IME
				}
				if(e.type == "keypress"){
					if(typeof charOrCode != "string"){
						return;
					}
					if((charOrCode >= 'a' && charOrCode <= 'z') || (charOrCode >= 'A' && charOrCode <= 'Z') || (charOrCode >= '0' && charOrCode <= '9') || (charOrCode === ' ')){
						if(e.ctrlKey || e.metaKey || e.altKey){
							return;
						} // can only be stopped reliably in keydown
					}
				}
				if(e.type == "input"){
					if(this.__skipInputEvent){ // duplicate event
						this.__skipInputEvent = false;
						return;
					}
				}else{
					this.__skipInputEvent = true;
				}
				// create fake event to set charOrCode and to know if preventDefault() was called
				var faux = { faux: true }, attr;
				for(attr in e){
					if(!/^(layer[XY]|returnValue|keyLocation)$/.test(attr)){ // prevent WebKit warnings
						var v = e[attr];
						if(typeof v != "function" && typeof v != "undefined"){
							faux[attr] = v;
						}
					}
				}
				lang.mixin(faux, {
					charOrCode: charOrCode,
					_wasConsumed: false,
					preventDefault: function(){
						faux._wasConsumed = true;
						e.preventDefault();
					},
					stopPropagation: function(){
						e.stopPropagation();
					}
				});
				// give web page author a chance to consume the event
				//console.log(faux.type + ', charOrCode = (' + (typeof charOrCode) + ') ' + charOrCode + ', ctrl ' + !!faux.ctrlKey + ', alt ' + !!faux.altKey + ', meta ' + !!faux.metaKey + ', shift ' + !!faux.shiftKey);
				if(this.onInput(faux) === false){ // return false means stop
					faux.preventDefault();
					faux.stopPropagation();
				}
				if(faux._wasConsumed){
					return;
				} // if preventDefault was called
				this.defer(function(){
					this._onInput(faux);
				}); // widget notification after key has posted
			}
			this.own(
				on(this.textbox, "keydown, keypress, paste, cut, input, compositionend", lang.hitch(this, handleEvent)),

				// Allow keypress to bubble to this.domNode, so that TextBox.on("keypress", ...) works,
				// but prevent it from further propagating, so that typing into a TextBox inside a Toolbar doesn't
				// trigger the Toolbar's letter key navigation.
				on(this.domNode, "keypress", function(e){ e.stopPropagation(); })
			);
		},

		_blankValue: '', // if the textbox is blank, what value should be reported
		filter: function(val){
			// summary:
			//		Auto-corrections (such as trimming) that are applied to textbox
			//		value on blur or form submit.
			// description:
			//		For MappedTextBox subclasses, this is called twice
			//
			//		- once with the display value
			//		- once the value as set/returned by set('value', ...)
			//
			//		and get('value'), ex: a Number for NumberTextBox.
			//
			//		In the latter case it does corrections like converting null to NaN.  In
			//		the former case the NumberTextBox.filter() method calls this.inherited()
			//		to execute standard trimming code in TextBox.filter().
			//
			//		TODO: break this into two methods in 2.0
			//
			// tags:
			//		protected extension
			if(val === null){
				return this._blankValue;
			}
			if(typeof val != "string"){
				return val;
			}
			if(this.trim){
				val = lang.trim(val);
			}
			if(this.uppercase){
				val = val.toUpperCase();
			}
			if(this.lowercase){
				val = val.toLowerCase();
			}
			if(this.propercase){
				val = val.replace(/[^\s]+/g, function(word){
					return word.substring(0, 1).toUpperCase() + word.substring(1);
				});
			}
			return val;
		},

		_setBlurValue: function(){
			// Format the displayed value, for example (for NumberTextBox) convert 1.4 to 1.400,
			// or (for CurrencyTextBox) 2.50 to $2.50

			this._setValueAttr(this.get('value'), true);
		},

		_onBlur: function(e){
			if(this.disabled){
				return;
			}
			this._setBlurValue();
			this.inherited(arguments);
		},

		_isTextSelected: function(){
			return this.textbox.selectionStart != this.textbox.selectionEnd;
		},

		_onFocus: function(/*String*/ by){
			if(this.disabled || this.readOnly){
				return;
			}

			// Select all text on focus via click if nothing already selected.
			// Since mouse-up will clear the selection, need to defer selection until after mouse-up.
			// Don't do anything on focus by tabbing into the widget since there's no associated mouse-up event.
			if(this.selectOnClick && by == "mouse"){
				// Use on.once() to only select all text on first click only; otherwise users would have no way to clear
				// the selection.
				this._selectOnClickHandle = on.once(this.domNode, "mouseup, touchend", lang.hitch(this, function(evt){
					// Check if the user selected some text manually (mouse-down, mouse-move, mouse-up)
					// and if not, then select all the text
					if(!this._isTextSelected()){
						_TextBoxMixin.selectInputText(this.textbox);
					}
				}));
				this.own(this._selectOnClickHandle);

				// in case the mouseup never comes
				this.defer(function(){
					if(this._selectOnClickHandle){
						this._selectOnClickHandle.remove();
						this._selectOnClickHandle = null;
					}
				}, 500); // if mouseup not received soon, then treat it as some gesture
			}
			// call this.inherited() before refreshState(), since this.inherited() will possibly scroll the viewport
			// (to scroll the TextBox into view), which will affect how _refreshState() positions the tooltip
			this.inherited(arguments);

			this._refreshState();
		},

		reset: function(){
			// Overrides `dijit/_FormWidget/reset()`.
			// Additionally resets the displayed textbox value to ''
			this.textbox.value = '';
			this.inherited(arguments);
		}
	});

	if(has("dojo-bidi")){
		_TextBoxMixin = declare("dijit.form._TextBoxMixin", _TextBoxMixin, {
			_setValueAttr: function(){
				this.inherited(arguments);
				this.applyTextDir(this.focusNode);
			},
			_setDisplayedValueAttr: function(){
				this.inherited(arguments);
				this.applyTextDir(this.focusNode);
			},
			_onInput: function(){
				this.applyTextDir(this.focusNode);
				this.inherited(arguments);
			}
		});
	}

	_TextBoxMixin._setSelectionRange = dijit._setSelectionRange = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
		if(element.setSelectionRange){
			element.setSelectionRange(start, stop);
		}
	};

	_TextBoxMixin.selectInputText = dijit.selectInputText = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
		// summary:
		//		Select text in the input element argument, from start (default 0), to stop (default end).

		// TODO: use functions in _editor/selection.js?
		element = dom.byId(element);
		if(isNaN(start)){
			start = 0;
		}
		if(isNaN(stop)){
			stop = element.value ? element.value.length : 0;
		}
		try{
			element.focus();
			_TextBoxMixin._setSelectionRange(element, start, stop);
		}catch(e){ /* squelch random errors (esp. on IE) from unexpected focus changes or DOM nodes being hidden */
		}
	};

	return _TextBoxMixin;
});

},
'dijit/form/ValidationTextBox':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang",
	"dojo/i18n", // i18n.getLocalization
	"./TextBox",
	"../Tooltip",
	"dojo/text!./templates/ValidationTextBox.html",
	"dojo/i18n!./nls/validate"
], function(declare, kernel, lang, i18n, TextBox, Tooltip, template){

	// module:
	//		dijit/form/ValidationTextBox


	/*=====
	var __Constraints = {
		// locale: String
		//		locale used for validation, picks up value from this widget's lang attribute
		// _flags_: anything
		//		various flags passed to pattern function
	};
	=====*/

	var ValidationTextBox;
	return ValidationTextBox = declare("dijit.form.ValidationTextBox", TextBox, {
		// summary:
		//		Base class for textbox widgets with the ability to validate content of various types and provide user feedback.

		templateString: template,

		// required: Boolean
		//		User is required to enter data into this field.
		required: false,

		// promptMessage: String
		//		If defined, display this hint string immediately on focus to the textbox, if empty.
		//		Also displays if the textbox value is Incomplete (not yet valid but will be with additional input).
		//		Think of this like a tooltip that tells the user what to do, not an error message
		//		that tells the user what they've done wrong.
		//
		//		Message disappears when user starts typing.
		promptMessage: "",

		// invalidMessage: String
		//		The message to display if value is invalid.
		//		The translated string value is read from the message file by default.
		//		Set to "" to use the promptMessage instead.
		invalidMessage: "$_unset_$",

		// missingMessage: String
		//		The message to display if value is empty and the field is required.
		//		The translated string value is read from the message file by default.
		//		Set to "" to use the invalidMessage instead.
		missingMessage: "$_unset_$",

		// message: String
		//		Currently error/prompt message.
		//		When using the default tooltip implementation, this will only be
		//		displayed when the field is focused.
		message: "",

		// constraints: __Constraints
		//		user-defined object needed to pass parameters to the validator functions
		constraints: {},

		// pattern: [extension protected] String|Function(constraints) returning a string.
		//		This defines the regular expression used to validate the input.
		//		Do not add leading ^ or $ characters since the widget adds these.
		//		A function may be used to generate a valid pattern when dependent on constraints or other runtime factors.
		//		set('pattern', String|Function).
		pattern: ".*",

		// regExp: Deprecated [extension protected] String.  Use "pattern" instead.
		regExp: "",

		regExpGen: function(/*__Constraints*/ /*===== constraints =====*/){
			// summary:
			//		Deprecated.  Use set('pattern', Function) instead.
		},

		// state: [readonly] String
		//		Shows current state (ie, validation result) of input (""=Normal, Incomplete, or Error)
		state: "",

		// tooltipPosition: String[]
		//		See description of `dijit/Tooltip.defaultPosition` for details on this parameter.
		tooltipPosition: [],

		_deprecateRegExp: function(attr, value){
			if(value != ValidationTextBox.prototype[attr]){
				kernel.deprecated("ValidationTextBox id="+this.id+", set('" + attr + "', ...) is deprecated.  Use set('pattern', ...) instead.", "", "2.0");
				this.set('pattern', value);
			}
		},
		_setRegExpGenAttr: function(/*Function*/ newFcn){
			this._deprecateRegExp("regExpGen", newFcn);
			this._set("regExpGen", this._computeRegexp); // backward compat with this.regExpGen(this.constraints)
		},
		_setRegExpAttr: function(/*String*/ value){
			this._deprecateRegExp("regExp", value);
		},

		_setValueAttr: function(){
			// summary:
			//		Hook so set('value', ...) works.
			this.inherited(arguments);
			this._refreshState();
		},

		validator: function(/*anything*/ value, /*__Constraints*/ constraints){
			// summary:
			//		Overridable function used to validate the text input against the regular expression.
			// tags:
			//		protected
			return (new RegExp("^(?:" + this._computeRegexp(constraints) + ")"+(this.required?"":"?")+"$")).test(value) &&
				(!this.required || !this._isEmpty(value)) &&
				(this._isEmpty(value) || this.parse(value, constraints) !== undefined); // Boolean
		},

		_isValidSubset: function(){
			// summary:
			//		Returns true if the value is either already valid or could be made valid by appending characters.
			//		This is used for validation while the user [may be] still typing.
			return this.textbox.value.search(this._partialre) == 0;
		},

		isValid: function(/*Boolean*/ /*===== isFocused =====*/){
			// summary:
			//		Tests if value is valid.
			//		Can override with your own routine in a subclass.
			// tags:
			//		protected
			return this.validator(this.textbox.value, this.get('constraints'));
		},

		_isEmpty: function(value){
			// summary:
			//		Checks for whitespace
			return (this.trim ? /^\s*$/ : /^$/).test(value); // Boolean
		},

		getErrorMessage: function(/*Boolean*/ /*===== isFocused =====*/){
			// summary:
			//		Return an error message to show if appropriate
			// tags:
			//		protected
			var invalid = this.invalidMessage == "$_unset_$" ? this.messages.invalidMessage :
				!this.invalidMessage ? this.promptMessage : this.invalidMessage;
			var missing = this.missingMessage == "$_unset_$" ? this.messages.missingMessage :
				!this.missingMessage ? invalid : this.missingMessage;
			return (this.required && this._isEmpty(this.textbox.value)) ? missing : invalid; // String
		},

		getPromptMessage: function(/*Boolean*/ /*===== isFocused =====*/){
			// summary:
			//		Return a hint message to show when widget is first focused
			// tags:
			//		protected
			return this.promptMessage; // String
		},

		_maskValidSubsetError: true,
		validate: function(/*Boolean*/ isFocused){
			// summary:
			//		Called by oninit, onblur, and onkeypress.
			// description:
			//		Show missing or invalid messages if appropriate, and highlight textbox field.
			// tags:
			//		protected
			var message = "";
			var isValid = this.disabled || this.isValid(isFocused);
			if(isValid){ this._maskValidSubsetError = true; }
			var isEmpty = this._isEmpty(this.textbox.value);
			var isValidSubset = !isValid && isFocused && this._isValidSubset();
			this._set("state", isValid ? "" : (((((!this._hasBeenBlurred || isFocused) && isEmpty) || isValidSubset) && (this._maskValidSubsetError || (isValidSubset && !this._hasBeenBlurred && isFocused))) ? "Incomplete" : "Error"));
			this.focusNode.setAttribute("aria-invalid", this.state == "Error" ? "true" : "false");

			if(this.state == "Error"){
				this._maskValidSubsetError = isFocused && isValidSubset; // we want the error to show up after a blur and refocus
				message = this.getErrorMessage(isFocused);
			}else if(this.state == "Incomplete"){
				message = this.getPromptMessage(isFocused); // show the prompt whenever the value is not yet complete
				this._maskValidSubsetError = !this._hasBeenBlurred || isFocused; // no Incomplete warnings while focused
			}else if(isEmpty){
				message = this.getPromptMessage(isFocused); // show the prompt whenever there's no error and no text
			}
			this.set("message", message);

			return isValid;
		},

		displayMessage: function(/*String*/ message){
			// summary:
			//		Overridable method to display validation errors/hints.
			//		By default uses a tooltip.
			// tags:
			//		extension
			if(message && this.focused){
				Tooltip.show(message, this.domNode, this.tooltipPosition, !this.isLeftToRight());
			}else{
				Tooltip.hide(this.domNode);
			}
		},

		_refreshState: function(){
			// Overrides TextBox._refreshState()
			if(this._created){ // should instead be this._started but that would require all programmatic ValidationTextBox instantiations to call startup()
				this.validate(this.focused);
			}
			this.inherited(arguments);
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		constructor: function(params /*===== , srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree.

			this.constraints = lang.clone(this.constraints);
			this.baseClass += ' dijitValidationTextBox';
		},

		startup: function(){
			this.inherited(arguments);
			this._refreshState(); // after all _set* methods have run
		},

		_setConstraintsAttr: function(/*__Constraints*/ constraints){
			if(!constraints.locale && this.lang){
				constraints.locale = this.lang;
			}
			this._set("constraints", constraints);
			this._refreshState();
		},

		_setPatternAttr: function(/*String|Function*/ pattern){
			this._set("pattern", pattern); // don't set on INPUT to avoid native HTML5 validation
			this._refreshState();
		},

		_computeRegexp: function(/*__Constraints*/ constraints){
			// summary:
			//		Hook to get the current regExp and to compute the partial validation RE.

			var p = this.pattern;
			if(typeof p == "function"){
				p = p.call(this, constraints);
			}
			if(p != this._lastRegExp){
				var partialre = "";
				this._lastRegExp = p;
				// parse the regexp and produce a new regexp that matches valid subsets
				// if the regexp is .* then there's no use in matching subsets since everything is valid
				if(p != ".*"){
					p.replace(/\\.|\[\]|\[.*?[^\\]{1}\]|\{.*?\}|\(\?[=:!]|./g,
					function(re){
						switch(re.charAt(0)){
							case '{':
							case '+':
							case '?':
							case '*':
							case '^':
							case '$':
							case '|':
							case '(':
								partialre += re;
								break;
							case ")":
								partialre += "|$)";
								break;
							 default:
								partialre += "(?:"+re+"|$)";
								break;
						}
					});
				}
				try{ // this is needed for now since the above regexp parsing needs more test verification
					"".search(partialre);
				}catch(e){ // should never be here unless the original RE is bad or the parsing is bad
					partialre = this.pattern;
					console.warn('RegExp error in ' + this.declaredClass + ': ' + this.pattern);
				} // should never be here unless the original RE is bad or the parsing is bad
				this._partialre = "^(?:" + partialre + ")$";
			}
			return p;
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			this.messages = i18n.getLocalization("dijit.form", "validate", this.lang);
			this._setConstraintsAttr(this.constraints); // this needs to happen now (and later) due to codependency on _set*Attr calls attachPoints
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			this.inherited(arguments);	// call FormValueWidget._setDisabledAttr()
			this._refreshState();
		},

		_setRequiredAttr: function(/*Boolean*/ value){
			this._set("required", value);
			this.focusNode.setAttribute("aria-required", value);
			this._refreshState();
		},

		_setMessageAttr: function(/*String*/ message){
			this._set("message", message);
			this.displayMessage(message);
		},

		reset:function(){
			// Overrides dijit/form/TextBox.reset() by also
			// hiding errors about partial matches
			this._maskValidSubsetError = true;
			this.inherited(arguments);
		},

		_onBlur: function(){
			// the message still exists but for back-compat, and to erase the tooltip
			// (if the message is being displayed as a tooltip), call displayMessage('')
			this.displayMessage('');

			this.inherited(arguments);
		},

		destroy: function(){
			Tooltip.hide(this.domNode);	// in case tooltip show when ValidationTextBox (or enclosing Dialog) destroyed
			this.inherited(arguments);
		}
	});
});

},
'dijit/Tooltip':function(){
define([
	"dojo/_base/array", // array.forEach array.indexOf array.map
	"dojo/_base/declare", // declare
	"dojo/_base/fx", // fx.fadeIn fx.fadeOut
	"dojo/dom", // dom.byId
	"dojo/dom-class", // domClass.add
	"dojo/dom-geometry", // domGeometry.position
	"dojo/dom-style", // domStyle.set, domStyle.get
	"dojo/_base/lang", // lang.hitch lang.isArrayLike
	"dojo/mouse",
	"dojo/on",
	"dojo/sniff", // has("ie"), has("trident")
	"./_base/manager",	// manager.defaultDuration
	"./place",
	"./_Widget",
	"./_TemplatedMixin",
	"./BackgroundIframe",
	"dojo/text!./templates/Tooltip.html",
	"./main"		// sets dijit.showTooltip etc. for back-compat
], function(array, declare, fx, dom, domClass, domGeometry, domStyle, lang, mouse, on, has,
			manager, place, _Widget, _TemplatedMixin, BackgroundIframe, template, dijit){

	// module:
	//		dijit/Tooltip


	// TODO: Tooltip should really share more positioning code with TooltipDialog, like:
	//		- the orient() method
	//		- the connector positioning code in show()
	//		- the dijitTooltip[Dialog] class
	//
	// The problem is that Tooltip's implementation supplies it's own <iframe> and interacts directly
	// with dijit/place, rather than going through dijit/popup like TooltipDialog and other popups (ex: Menu).

	var MasterTooltip = declare("dijit._MasterTooltip", [_Widget, _TemplatedMixin], {
		// summary:
		//		Internal widget that holds the actual tooltip markup,
		//		which occurs once per page.
		//		Called by Tooltip widgets which are just containers to hold
		//		the markup
		// tags:
		//		protected

		// duration: Integer
		//		Milliseconds to fade in/fade out
		duration: manager.defaultDuration,

		templateString: template,

		postCreate: function(){
			this.ownerDocumentBody.appendChild(this.domNode);

			this.bgIframe = new BackgroundIframe(this.domNode);

			// Setup fade-in and fade-out functions.
			this.fadeIn = fx.fadeIn({ node: this.domNode, duration: this.duration, onEnd: lang.hitch(this, "_onShow") });
			this.fadeOut = fx.fadeOut({ node: this.domNode, duration: this.duration, onEnd: lang.hitch(this, "_onHide") });
		},

		show: function(innerHTML, aroundNode, position, rtl, textDir, onMouseEnter, onMouseLeave){
			// summary:
			//		Display tooltip w/specified contents to right of specified node
			//		(To left if there's no space on the right, or if rtl == true)
			// innerHTML: String
			//		Contents of the tooltip
			// aroundNode: DomNode|dijit/place.__Rectangle
			//		Specifies that tooltip should be next to this node / area
			// position: String[]?
			//		List of positions to try to position tooltip (ex: ["right", "above"])
			// rtl: Boolean?
			//		Corresponds to `WidgetBase.dir` attribute, where false means "ltr" and true
			//		means "rtl"; specifies GUI direction, not text direction.
			// textDir: String?
			//		Corresponds to `WidgetBase.textdir` attribute; specifies direction of text.
			// onMouseEnter: Function?
			//		Callback function for mouse enter on tooltip
			// onMouseLeave: Function?
			//		Callback function for mouse leave on tooltip

			if(this.aroundNode && this.aroundNode === aroundNode && this.containerNode.innerHTML == innerHTML){
				return;
			}

			if(this.fadeOut.status() == "playing"){
				// previous tooltip is being hidden; wait until the hide completes then show new one
				this._onDeck=arguments;
				return;
			}
			this.containerNode.innerHTML=innerHTML;

			if(textDir){
				this.set("textDir", textDir);
			}

			this.containerNode.align = rtl? "right" : "left"; //fix the text alignment

			var pos = place.around(this.domNode, aroundNode,
				position && position.length ? position : Tooltip.defaultPosition, !rtl, lang.hitch(this, "orient"));

			// Position the tooltip connector for middle alignment.
			// This could not have been done in orient() since the tooltip wasn't positioned at that time.
			var aroundNodeCoords = pos.aroundNodePos;
			if(pos.corner.charAt(0) == 'M' && pos.aroundCorner.charAt(0) == 'M'){
				this.connectorNode.style.top = aroundNodeCoords.y + ((aroundNodeCoords.h - this.connectorNode.offsetHeight) >> 1) - pos.y + "px";
				this.connectorNode.style.left = "";
			}else if(pos.corner.charAt(1) == 'M' && pos.aroundCorner.charAt(1) == 'M'){
				this.connectorNode.style.left = aroundNodeCoords.x + ((aroundNodeCoords.w - this.connectorNode.offsetWidth) >> 1) - pos.x + "px";
			}else{
				// Not *-centered, but just above/below/after/before
				this.connectorNode.style.left = "";
				this.connectorNode.style.top = "";
			}

			// show it
			domStyle.set(this.domNode, "opacity", 0);
			this.fadeIn.play();
			this.isShowingNow = true;
			this.aroundNode = aroundNode;

			this.onMouseEnter = onMouseEnter || noop;
			this.onMouseLeave = onMouseLeave || noop;
		},

		orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ tooltipCorner, /*Object*/ spaceAvailable, /*Object*/ aroundNodeCoords){
			// summary:
			//		Private function to set CSS for tooltip node based on which position it's in.
			//		This is called by the dijit popup code.   It will also reduce the tooltip's
			//		width to whatever width is available
			// tags:
			//		protected

			this.connectorNode.style.top = ""; //reset to default

			var heightAvailable = spaceAvailable.h,
				widthAvailable = spaceAvailable.w;

			node.className = "dijitTooltip " +
				{
					"MR-ML": "dijitTooltipRight",
					"ML-MR": "dijitTooltipLeft",
					"TM-BM": "dijitTooltipAbove",
					"BM-TM": "dijitTooltipBelow",
					"BL-TL": "dijitTooltipBelow dijitTooltipABLeft",
					"TL-BL": "dijitTooltipAbove dijitTooltipABLeft",
					"BR-TR": "dijitTooltipBelow dijitTooltipABRight",
					"TR-BR": "dijitTooltipAbove dijitTooltipABRight",
					"BR-BL": "dijitTooltipRight",
					"BL-BR": "dijitTooltipLeft"
				}[aroundCorner + "-" + tooltipCorner];

			// reset width; it may have been set by orient() on a previous tooltip show()
			this.domNode.style.width = "auto";

			// Reduce tooltip's width to the amount of width available, so that it doesn't overflow screen.
			// Note that sometimes widthAvailable is negative, but we guard against setting style.width to a
			// negative number since that causes an exception on IE.
			var size = domGeometry.position(this.domNode);
			if(has("ie") || has("trident")){
				// workaround strange IE bug where setting width to offsetWidth causes words to wrap
				size.w += 2;
			}

			var width = Math.min((Math.max(widthAvailable,1)), size.w);

			domGeometry.setMarginBox(this.domNode, {w: width});

			// Reposition the tooltip connector.
			if(tooltipCorner.charAt(0) == 'B' && aroundCorner.charAt(0) == 'B'){
				var bb = domGeometry.position(node);
				var tooltipConnectorHeight = this.connectorNode.offsetHeight;
				if(bb.h > heightAvailable){
					// The tooltip starts at the top of the page and will extend past the aroundNode
					var aroundNodePlacement = heightAvailable - ((aroundNodeCoords.h + tooltipConnectorHeight) >> 1);
					this.connectorNode.style.top = aroundNodePlacement + "px";
					this.connectorNode.style.bottom = "";
				}else{
					// Align center of connector with center of aroundNode, except don't let bottom
					// of connector extend below bottom of tooltip content, or top of connector
					// extend past top of tooltip content
					this.connectorNode.style.bottom = Math.min(
						Math.max(aroundNodeCoords.h/2 - tooltipConnectorHeight/2, 0),
						bb.h - tooltipConnectorHeight) + "px";
					this.connectorNode.style.top = "";
				}
			}else{
				// reset the tooltip back to the defaults
				this.connectorNode.style.top = "";
				this.connectorNode.style.bottom = "";
			}

			return Math.max(0, size.w - widthAvailable);
		},

		_onShow: function(){
			// summary:
			//		Called at end of fade-in operation
			// tags:
			//		protected
			if(has("ie")){
				// the arrow won't show up on a node w/an opacity filter
				this.domNode.style.filter="";
			}
		},

		hide: function(aroundNode){
			// summary:
			//		Hide the tooltip

			if(this._onDeck && this._onDeck[1] == aroundNode){
				// this hide request is for a show() that hasn't even started yet;
				// just cancel the pending show()
				this._onDeck=null;
			}else if(this.aroundNode === aroundNode){
				// this hide request is for the currently displayed tooltip
				this.fadeIn.stop();
				this.isShowingNow = false;
				this.aroundNode = null;
				this.fadeOut.play();
			}else{
				// just ignore the call, it's for a tooltip that has already been erased
			}

			this.onMouseEnter = this.onMouseLeave = noop;
		},

		_onHide: function(){
			// summary:
			//		Called at end of fade-out operation
			// tags:
			//		protected

			this.domNode.style.cssText="";	// to position offscreen again
			this.containerNode.innerHTML="";
			if(this._onDeck){
				// a show request has been queued up; do it now
				this.show.apply(this, this._onDeck);
				this._onDeck=null;
			}
		}
	});

	if(has("dojo-bidi")){
		MasterTooltip.extend({
			_setAutoTextDir: function(/*Object*/node){
				// summary:
				//		Resolve "auto" text direction for children nodes
				// tags:
				//		private

				this.applyTextDir(node);
				array.forEach(node.children, function(child){ this._setAutoTextDir(child); }, this);
			},

			_setTextDirAttr: function(/*String*/ textDir){
				// summary:
				//		Setter for textDir.
				// description:
				//		Users shouldn't call this function; they should be calling
				//		set('textDir', value)
				// tags:
				//		private

				this._set("textDir", textDir);

				if (textDir == "auto"){
					this._setAutoTextDir(this.containerNode);
				}else{
					this.containerNode.dir = this.textDir;
				}
			}
		});
	}

	dijit.showTooltip = function(innerHTML, aroundNode, position, rtl, textDir, onMouseEnter, onMouseLeave){
		// summary:
		//		Static method to display tooltip w/specified contents in specified position.
		//		See description of dijit/Tooltip.defaultPosition for details on position parameter.
		//		If position is not specified then dijit/Tooltip.defaultPosition is used.
		// innerHTML: String
		//		Contents of the tooltip
		// aroundNode: place.__Rectangle
		//		Specifies that tooltip should be next to this node / area
		// position: String[]?
		//		List of positions to try to position tooltip (ex: ["right", "above"])
		// rtl: Boolean?
		//		Corresponds to `WidgetBase.dir` attribute, where false means "ltr" and true
		//		means "rtl"; specifies GUI direction, not text direction.
		// textDir: String?
		//		Corresponds to `WidgetBase.textdir` attribute; specifies direction of text.
		// onMouseEnter: Function?
		//		Callback function for mouse over on tooltip
		// onMouseLeave: Function?
		//		Callback function for mouse leave on tooltip

		// After/before don't work, but for back-compat convert them to the working after-centered, before-centered.
		// Possibly remove this in 2.0.   Alternately, get before/after to work.
		if(position){
			position = array.map(position, function(val){
				return {after: "after-centered", before: "before-centered"}[val] || val;
			});
		}

		if(!Tooltip._masterTT){ dijit._masterTT = Tooltip._masterTT = new MasterTooltip(); }
		return Tooltip._masterTT.show(innerHTML, aroundNode, position, rtl, textDir, onMouseEnter, onMouseLeave);
	};

	dijit.hideTooltip = function(aroundNode){
		// summary:
		//		Static method to hide the tooltip displayed via showTooltip()
		return Tooltip._masterTT && Tooltip._masterTT.hide(aroundNode);
	};

	// Possible states for a tooltip, see Tooltip.state property for definitions
	var DORMANT = "DORMANT",
		SHOW_TIMER = "SHOW TIMER",
		SHOWING = "SHOWING",
		HIDE_TIMER = "HIDE TIMER";

	function noop(){}

	var Tooltip = declare("dijit.Tooltip", _Widget, {
		// summary:
		//		Pops up a tooltip (a help message) when you hover over a node.
		//		Also provides static show() and hide() methods that can be used without instantiating a dijit/Tooltip.

		// label: String
		//		HTML to display in the tooltip.
		//		Specified as innerHTML when creating the widget from markup.
		label: "",

		// showDelay: Integer
		//		Number of milliseconds to wait after hovering over/focusing on the object, before
		//		the tooltip is displayed.
		showDelay: 400,

		// hideDelay: Integer
		//		Number of milliseconds to wait after unhovering the object, before
		//		the tooltip is hidden.  Note that blurring an object hides the tooltip immediately.
		hideDelay: 400,

		// connectId: String|String[]|DomNode|DomNode[]
		//		Id of domNode(s) to attach the tooltip to.
		//		When user hovers over specified dom node(s), the tooltip will appear.
		connectId: [],

		// position: String[]
		//		See description of `dijit/Tooltip.defaultPosition` for details on position parameter.
		position: [],

		// selector: String?
		//		CSS expression to apply this Tooltip to descendants of connectIds, rather than to
		//		the nodes specified by connectIds themselves.    Useful for applying a Tooltip to
		//		a range of rows in a table, tree, etc.   Use in conjunction with getContent() parameter.
		//		Ex: connectId: myTable, selector: "tr", getContent: function(node){ return ...; }
		//
		//		The application must require() an appropriate level of dojo/query to handle the selector.
		selector: "",

		// TODO: in 2.0 remove support for multiple connectIds.   selector gives the same effect.
		// So, change connectId to a "", remove addTarget()/removeTarget(), etc.

		_setConnectIdAttr: function(/*String|String[]|DomNode|DomNode[]*/ newId){
			// summary:
			//		Connect to specified node(s)

			// Remove connections to old nodes (if there are any)
			array.forEach(this._connections || [], function(nested){
				array.forEach(nested, function(handle){ handle.remove(); });
			}, this);

			// Make array of id's to connect to, excluding entries for nodes that don't exist yet, see startup()
			this._connectIds = array.filter(lang.isArrayLike(newId) ? newId : (newId ? [newId] : []),
					function(id){ return dom.byId(id, this.ownerDocument); }, this);

			// Make connections
			this._connections = array.map(this._connectIds, function(id){
				var node = dom.byId(id, this.ownerDocument),
					selector = this.selector,
					delegatedEvent = selector ?
						function(eventType){ return on.selector(selector, eventType); } :
						function(eventType){ return eventType; },
					self = this;
				return [
					on(node, delegatedEvent(mouse.enter), function(){
						self._onHover(this);
					}),
					on(node, delegatedEvent("focusin"), function(){
						self._onHover(this);
					}),
					on(node, delegatedEvent(mouse.leave), lang.hitch(self, "_onUnHover")),
					on(node, delegatedEvent("focusout"), lang.hitch(self, "set", "state", DORMANT))
				];
			}, this);

			this._set("connectId", newId);
		},

		addTarget: function(/*OomNode|String*/ node){
			// summary:
			//		Attach tooltip to specified node if it's not already connected

			// TODO: remove in 2.0 and just use set("connectId", ...) interface

			var id = node.id || node;
			if(array.indexOf(this._connectIds, id) == -1){
				this.set("connectId", this._connectIds.concat(id));
			}
		},

		removeTarget: function(/*DomNode|String*/ node){
			// summary:
			//		Detach tooltip from specified node

			// TODO: remove in 2.0 and just use set("connectId", ...) interface

			var id = node.id || node,	// map from DOMNode back to plain id string
				idx = array.indexOf(this._connectIds, id);
			if(idx >= 0){
				// remove id (modifies original this._connectIds but that's OK in this case)
				this._connectIds.splice(idx, 1);
				this.set("connectId", this._connectIds);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);
			domClass.add(this.domNode,"dijitTooltipData");
		},

		startup: function(){
			this.inherited(arguments);

			// If this tooltip was created in a template, or for some other reason the specified connectId[s]
			// didn't exist during the widget's initialization, then connect now.
			var ids = this.connectId;
			array.forEach(lang.isArrayLike(ids) ? ids : [ids], this.addTarget, this);
		},

		getContent: function(/*DomNode*/ node){
			// summary:
			//		User overridable function that return the text to display in the tooltip.
			// tags:
			//		extension
			return this.label || this.domNode.innerHTML;
		},

		// state: [private readonly] String
		//		One of:
		//
		//		- DORMANT: tooltip not SHOWING
		//		- SHOW TIMER: tooltip not SHOWING but timer set to show it
		//		- SHOWING: tooltip displayed
		//		- HIDE TIMER: tooltip displayed, but timer set to hide it
		state: DORMANT,
		_setStateAttr: function(val){
			if(this.state == val ||
				(val == SHOW_TIMER && this.state == SHOWING) ||
				(val == HIDE_TIMER && this.state == DORMANT)){
				return;
			}

			if(this._hideTimer){
				this._hideTimer.remove();
				delete this._hideTimer;
			}
			if(this._showTimer){
				this._showTimer.remove();
				delete this._showTimer;
			}

			switch(val){
				case DORMANT:
					if(this._connectNode){
						Tooltip.hide(this._connectNode);
						delete this._connectNode;
						this.onHide();
					}
					break;
				case SHOW_TIMER:	 // set timer to show tooltip
					// should only get here from a DORMANT state, i.e. tooltip can't be already SHOWING
					if(this.state != SHOWING){
						this._showTimer = this.defer(function(){ this.set("state", SHOWING); }, this.showDelay);
					}
					break;
				case SHOWING:		// show tooltip and clear timers
					var content = this.getContent(this._connectNode);
					if(!content){
						this.set("state", DORMANT);
						return;
					}

					// Show tooltip and setup callbacks for mouseenter/mouseleave of tooltip itself
					Tooltip.show(content, this._connectNode, this.position, !this.isLeftToRight(), this.textDir,
						lang.hitch(this, "set", "state", SHOWING), lang.hitch(this, "set", "state", HIDE_TIMER));

					this.onShow(this._connectNode, this.position);
					break;
				case HIDE_TIMER:	// set timer set to hide tooltip
					this._hideTimer = this.defer(function(){ this.set("state", DORMANT); }, this.hideDelay);
					break;
			}

			this._set("state", val);
		},

		_onHover: function(/*DomNode*/ target){
			// summary:
			//		Despite the name of this method, it actually handles both hover and focus
			//		events on the target node, setting a timer to show the tooltip.
			// tags:
			//		private

			if(this._connectNode && target != this._connectNode){
				// Tooltip is displaying for another node
				this.set("state", DORMANT);
			}
			this._connectNode = target;		// _connectNode means "tooltip currently displayed for this node"

			this.set("state", SHOW_TIMER);	// no-op if show-timer already set, or if already showing
		},

		_onUnHover: function(/*DomNode*/ target){
			// summary:
			//		Handles mouseleave event on the target node, hiding the tooltip.
			// tags:
			//		private

			this.set("state", HIDE_TIMER);		// no-op if already dormant, or if hide-timer already set
		},

		// open() and close() aren't used anymore, except from the _BidiSupport/misc/Tooltip test.
		// Should probably remove for 2.0, but leaving for now.
		open: function(/*DomNode*/ target){
			// summary:
			//		Display the tooltip; usually not called directly.
			// tags:
			//		private

			this.set("state", DORMANT);
			this._connectNode = target;		// _connectNode means "tooltip currently displayed for this node"
			this.set("state", SHOWING);
		},

		close: function(){
			// summary:
			//		Hide the tooltip or cancel timer for show of tooltip
			// tags:
			//		private

			this.set("state", DORMANT);
		},

		onShow: function(/*===== target, position =====*/){
			// summary:
			//		Called when the tooltip is shown
			// tags:
			//		callback
		},

		onHide: function(){
			// summary:
			//		Called when the tooltip is hidden
			// tags:
			//		callback
		},

		destroy: function(){
			this.set("state", DORMANT);

			// Remove connections manually since they aren't registered to be removed by _WidgetBase
			array.forEach(this._connections || [], function(nested){
				array.forEach(nested, function(handle){ handle.remove(); });
			}, this);

			this.inherited(arguments);
		}
	});

	Tooltip._MasterTooltip = MasterTooltip;		// for monkey patching
	Tooltip.show = dijit.showTooltip;		// export function through module return value
	Tooltip.hide = dijit.hideTooltip;		// export function through module return value

	Tooltip.defaultPosition = ["after-centered", "before-centered"];

	/*=====
	lang.mixin(Tooltip, {
		 // defaultPosition: String[]
		 //		This variable controls the position of tooltips, if the position is not specified to
		 //		the Tooltip widget or *TextBox widget itself.  It's an array of strings with the values
		 //		possible for `dijit/place.around()`.   The recommended values are:
		 //
		 //		- before-centered: centers tooltip to the left of the anchor node/widget, or to the right
		 //		  in the case of RTL scripts like Hebrew and Arabic
		 //		- after-centered: centers tooltip to the right of the anchor node/widget, or to the left
		 //		  in the case of RTL scripts like Hebrew and Arabic
		 //		- above-centered: tooltip is centered above anchor node
		 //		- below-centered: tooltip is centered above anchor node
		 //
		 //		The list is positions is tried, in order, until a position is found where the tooltip fits
		 //		within the viewport.
		 //
		 //		Be careful setting this parameter.  A value of "above-centered" may work fine until the user scrolls
		 //		the screen so that there's no room above the target node.   Nodes with drop downs, like
		 //		DropDownButton or FilteringSelect, are especially problematic, in that you need to be sure
		 //		that the drop down and tooltip don't overlap, even when the viewport is scrolled so that there
		 //		is only room below (or above) the target node, but not both.
	 });
	=====*/
	return Tooltip;
});

},
'dijit/place':function(){
define([
	"dojo/_base/array", // array.forEach array.map array.some
	"dojo/dom-geometry", // domGeometry.position
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/window", // win.body
	"./Viewport", // getEffectiveBox
	"./main"	// dijit (defining dijit.place to match API doc)
], function(array, domGeometry, domStyle, kernel, win, Viewport, dijit){

	// module:
	//		dijit/place


	function _place(/*DomNode*/ node, choices, layoutNode, aroundNodeCoords){
		// summary:
		//		Given a list of spots to put node, put it at the first spot where it fits,
		//		of if it doesn't fit anywhere then the place with the least overflow
		// choices: Array
		//		Array of elements like: {corner: 'TL', pos: {x: 10, y: 20} }
		//		Above example says to put the top-left corner of the node at (10,20)
		// layoutNode: Function(node, aroundNodeCorner, nodeCorner, size)
		//		for things like tooltip, they are displayed differently (and have different dimensions)
		//		based on their orientation relative to the parent.	 This adjusts the popup based on orientation.
		//		It also passes in the available size for the popup, which is useful for tooltips to
		//		tell them that their width is limited to a certain amount.	 layoutNode() may return a value expressing
		//		how much the popup had to be modified to fit into the available space.	 This is used to determine
		//		what the best placement is.
		// aroundNodeCoords: Object
		//		Size of aroundNode, ex: {w: 200, h: 50}

		// get {x: 10, y: 10, w: 100, h:100} type obj representing position of
		// viewport over document
		var view = Viewport.getEffectiveBox(node.ownerDocument);

		// This won't work if the node is inside a <div style="position: relative">,
		// so reattach it to <body>.	 (Otherwise, the positioning will be wrong
		// and also it might get cutoff.)
		if(!node.parentNode || String(node.parentNode.tagName).toLowerCase() != "body"){
			win.body(node.ownerDocument).appendChild(node);
		}

		var best = null;
		array.some(choices, function(choice){
			var corner = choice.corner;
			var pos = choice.pos;
			var overflow = 0;

			// calculate amount of space available given specified position of node
			var spaceAvailable = {
				w: {
					'L': view.l + view.w - pos.x,
					'R': pos.x - view.l,
					'M': view.w
				}[corner.charAt(1)],
				h: {
					'T': view.t + view.h - pos.y,
					'B': pos.y - view.t,
					'M': view.h
				}[corner.charAt(0)]
			};

			// Clear left/right position settings set earlier so they don't interfere with calculations,
			// specifically when layoutNode() (a.k.a. Tooltip.orient()) measures natural width of Tooltip
			var s = node.style;
			s.left = s.right = "auto";

			// configure node to be displayed in given position relative to button
			// (need to do this in order to get an accurate size for the node, because
			// a tooltip's size changes based on position, due to triangle)
			if(layoutNode){
				var res = layoutNode(node, choice.aroundCorner, corner, spaceAvailable, aroundNodeCoords);
				overflow = typeof res == "undefined" ? 0 : res;
			}

			// get node's size
			var style = node.style;
			var oldDisplay = style.display;
			var oldVis = style.visibility;
			if(style.display == "none"){
				style.visibility = "hidden";
				style.display = "";
			}
			var bb = domGeometry.position(node);
			style.display = oldDisplay;
			style.visibility = oldVis;

			// coordinates and size of node with specified corner placed at pos,
			// and clipped by viewport
			var
				startXpos = {
					'L': pos.x,
					'R': pos.x - bb.w,
					'M': Math.max(view.l, Math.min(view.l + view.w, pos.x + (bb.w >> 1)) - bb.w) // M orientation is more flexible
				}[corner.charAt(1)],
				startYpos = {
					'T': pos.y,
					'B': pos.y - bb.h,
					'M': Math.max(view.t, Math.min(view.t + view.h, pos.y + (bb.h >> 1)) - bb.h)
				}[corner.charAt(0)],
				startX = Math.max(view.l, startXpos),
				startY = Math.max(view.t, startYpos),
				endX = Math.min(view.l + view.w, startXpos + bb.w),
				endY = Math.min(view.t + view.h, startYpos + bb.h),
				width = endX - startX,
				height = endY - startY;

			overflow += (bb.w - width) + (bb.h - height);

			if(best == null || overflow < best.overflow){
				best = {
					corner: corner,
					aroundCorner: choice.aroundCorner,
					x: startX,
					y: startY,
					w: width,
					h: height,
					overflow: overflow,
					spaceAvailable: spaceAvailable
				};
			}

			return !overflow;
		});

		// In case the best position is not the last one we checked, need to call
		// layoutNode() again.
		if(best.overflow && layoutNode){
			layoutNode(node, best.aroundCorner, best.corner, best.spaceAvailable, aroundNodeCoords);
		}

		// And then position the node.  Do this last, after the layoutNode() above
		// has sized the node, due to browser quirks when the viewport is scrolled
		// (specifically that a Tooltip will shrink to fit as though the window was
		// scrolled to the left).

		var top = best.y,
			side = best.x,
			body = win.body(node.ownerDocument);

		if(/relative|absolute/.test(domStyle.get(body, "position"))){
			// compensate for margin on <body>, see #16148
			top -= domStyle.get(body, "marginTop");
			side -= domStyle.get(body, "marginLeft");
		}

		var s = node.style;
		s.top = top + "px";
		s.left = side + "px";
		s.right = "auto";	// needed for FF or else tooltip goes to far left

		return best;
	}

	var reverse = {
		// Map from corner to kitty-corner
		"TL": "BR",
		"TR": "BL",
		"BL": "TR",
		"BR": "TL"
	};

	var place = {
		// summary:
		//		Code to place a DOMNode relative to another DOMNode.
		//		Load using require(["dijit/place"], function(place){ ... }).

		at: function(node, pos, corners, padding, layoutNode){
			// summary:
			//		Positions node kitty-corner to the rectangle centered at (pos.x, pos.y) with width and height of
			//		padding.x * 2 and padding.y * 2, or zero if padding not specified.  Picks first corner in corners[]
			//		where node is fully visible, or the corner where it's most visible.
			//
			//		Node is assumed to be absolutely or relatively positioned.
			// node: DOMNode
			//		The node to position
			// pos: dijit/place.__Position
			//		Object like {x: 10, y: 20}
			// corners: String[]
			//		Array of Strings representing order to try corners of the node in, like ["TR", "BL"].
			//		Possible values are:
			//
			//		- "BL" - bottom left
			//		- "BR" - bottom right
			//		- "TL" - top left
			//		- "TR" - top right
			// padding: dijit/place.__Position?
			//		Optional param to set padding, to put some buffer around the element you want to position.
			//		Defaults to zero.
			// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
			//		For things like tooltip, they are displayed differently (and have different dimensions)
			//		based on their orientation relative to the parent.  This adjusts the popup based on orientation.
			// example:
			//		Try to place node's top right corner at (10,20).
			//		If that makes node go (partially) off screen, then try placing
			//		bottom left corner at (10,20).
			//	|	place(node, {x: 10, y: 20}, ["TR", "BL"])
			var choices = array.map(corners, function(corner){
				var c = {
					corner: corner,
					aroundCorner: reverse[corner],	// so TooltipDialog.orient() gets aroundCorner argument set
					pos: {x: pos.x,y: pos.y}
				};
				if(padding){
					c.pos.x += corner.charAt(1) == 'L' ? padding.x : -padding.x;
					c.pos.y += corner.charAt(0) == 'T' ? padding.y : -padding.y;
				}
				return c;
			});

			return _place(node, choices, layoutNode);
		},

		around: function(
			/*DomNode*/		node,
			/*DomNode|dijit/place.__Rectangle*/ anchor,
			/*String[]*/	positions,
			/*Boolean*/		leftToRight,
			/*Function?*/	layoutNode){

			// summary:
			//		Position node adjacent or kitty-corner to anchor
			//		such that it's fully visible in viewport.
			// description:
			//		Place node such that corner of node touches a corner of
			//		aroundNode, and that node is fully visible.
			// anchor:
			//		Either a DOMNode or a rectangle (object with x, y, width, height).
			// positions:
			//		Ordered list of positions to try matching up.
			//
			//		- before: places drop down to the left of the anchor node/widget, or to the right in the case
			//			of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down
			//			with the top of the anchor, or the bottom of the drop down with bottom of the anchor.
			//		- after: places drop down to the right of the anchor node/widget, or to the left in the case
			//			of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down
			//			with the top of the anchor, or the bottom of the drop down with bottom of the anchor.
			//		- before-centered: centers drop down to the left of the anchor node/widget, or to the right
			//			in the case of RTL scripts like Hebrew and Arabic
			//		- after-centered: centers drop down to the right of the anchor node/widget, or to the left
			//			in the case of RTL scripts like Hebrew and Arabic
			//		- above-centered: drop down is centered above anchor node
			//		- above: drop down goes above anchor node, left sides aligned
			//		- above-alt: drop down goes above anchor node, right sides aligned
			//		- below-centered: drop down is centered above anchor node
			//		- below: drop down goes below anchor node
			//		- below-alt: drop down goes below anchor node, right sides aligned
			// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
			//		For things like tooltip, they are displayed differently (and have different dimensions)
			//		based on their orientation relative to the parent.	 This adjusts the popup based on orientation.
			// leftToRight:
			//		True if widget is LTR, false if widget is RTL.   Affects the behavior of "above" and "below"
			//		positions slightly.
			// example:
			//	|	placeAroundNode(node, aroundNode, {'BL':'TL', 'TR':'BR'});
			//		This will try to position node such that node's top-left corner is at the same position
			//		as the bottom left corner of the aroundNode (ie, put node below
			//		aroundNode, with left edges aligned).	If that fails it will try to put
			//		the bottom-right corner of node where the top right corner of aroundNode is
			//		(ie, put node above aroundNode, with right edges aligned)
			//

			// If around is a DOMNode (or DOMNode id), convert to coordinates.
			var aroundNodePos;
			if(typeof anchor == "string" || "offsetWidth" in anchor || "ownerSVGElement" in anchor){
				aroundNodePos = domGeometry.position(anchor, true);

				// For above and below dropdowns, subtract width of border so that popup and aroundNode borders
				// overlap, preventing a double-border effect.  Unfortunately, difficult to measure the border
				// width of either anchor or popup because in both cases the border may be on an inner node.
				if(/^(above|below)/.test(positions[0])){
					var anchorBorder = domGeometry.getBorderExtents(anchor),
						anchorChildBorder = anchor.firstChild ? domGeometry.getBorderExtents(anchor.firstChild) : {t:0,l:0,b:0,r:0},
						nodeBorder =  domGeometry.getBorderExtents(node),
						nodeChildBorder = node.firstChild ? domGeometry.getBorderExtents(node.firstChild) : {t:0,l:0,b:0,r:0};
					aroundNodePos.y += Math.min(anchorBorder.t + anchorChildBorder.t, nodeBorder.t + nodeChildBorder.t);
					aroundNodePos.h -=  Math.min(anchorBorder.t + anchorChildBorder.t, nodeBorder.t+ nodeChildBorder.t) +
						Math.min(anchorBorder.b + anchorChildBorder.b, nodeBorder.b + nodeChildBorder.b);
				}
			}else{
				aroundNodePos = anchor;
			}

			// Compute position and size of visible part of anchor (it may be partially hidden by ancestor nodes w/scrollbars)
			if(anchor.parentNode){
				// ignore nodes between position:relative and position:absolute
				var sawPosAbsolute = domStyle.getComputedStyle(anchor).position == "absolute";
				var parent = anchor.parentNode;
				while(parent && parent.nodeType == 1 && parent.nodeName != "BODY"){  //ignoring the body will help performance
					var parentPos = domGeometry.position(parent, true),
						pcs = domStyle.getComputedStyle(parent);
					if(/relative|absolute/.test(pcs.position)){
						sawPosAbsolute = false;
					}
					if(!sawPosAbsolute && /hidden|auto|scroll/.test(pcs.overflow)){
						var bottomYCoord = Math.min(aroundNodePos.y + aroundNodePos.h, parentPos.y + parentPos.h);
						var rightXCoord = Math.min(aroundNodePos.x + aroundNodePos.w, parentPos.x + parentPos.w);
						aroundNodePos.x = Math.max(aroundNodePos.x, parentPos.x);
						aroundNodePos.y = Math.max(aroundNodePos.y, parentPos.y);
						aroundNodePos.h = bottomYCoord - aroundNodePos.y;
						aroundNodePos.w = rightXCoord - aroundNodePos.x;
					}
					if(pcs.position == "absolute"){
						sawPosAbsolute = true;
					}
					parent = parent.parentNode;
				}
			}			

			var x = aroundNodePos.x,
				y = aroundNodePos.y,
				width = "w" in aroundNodePos ? aroundNodePos.w : (aroundNodePos.w = aroundNodePos.width),
				height = "h" in aroundNodePos ? aroundNodePos.h : (kernel.deprecated("place.around: dijit/place.__Rectangle: { x:"+x+", y:"+y+", height:"+aroundNodePos.height+", width:"+width+" } has been deprecated.  Please use { x:"+x+", y:"+y+", h:"+aroundNodePos.height+", w:"+width+" }", "", "2.0"), aroundNodePos.h = aroundNodePos.height);

			// Convert positions arguments into choices argument for _place()
			var choices = [];
			function push(aroundCorner, corner){
				choices.push({
					aroundCorner: aroundCorner,
					corner: corner,
					pos: {
						x: {
							'L': x,
							'R': x + width,
							'M': x + (width >> 1)
						}[aroundCorner.charAt(1)],
						y: {
							'T': y,
							'B': y + height,
							'M': y + (height >> 1)
						}[aroundCorner.charAt(0)]
					}
				})
			}
			array.forEach(positions, function(pos){
				var ltr =  leftToRight;
				switch(pos){
					case "above-centered":
						push("TM", "BM");
						break;
					case "below-centered":
						push("BM", "TM");
						break;
					case "after-centered":
						ltr = !ltr;
						// fall through
					case "before-centered":
						push(ltr ? "ML" : "MR", ltr ? "MR" : "ML");
						break;
					case "after":
						ltr = !ltr;
						// fall through
					case "before":
						push(ltr ? "TL" : "TR", ltr ? "TR" : "TL");
						push(ltr ? "BL" : "BR", ltr ? "BR" : "BL");
						break;
					case "below-alt":
						ltr = !ltr;
						// fall through
					case "below":
						// first try to align left borders, next try to align right borders (or reverse for RTL mode)
						push(ltr ? "BL" : "BR", ltr ? "TL" : "TR");
						push(ltr ? "BR" : "BL", ltr ? "TR" : "TL");
						break;
					case "above-alt":
						ltr = !ltr;
						// fall through
					case "above":
						// first try to align left borders, next try to align right borders (or reverse for RTL mode)
						push(ltr ? "TL" : "TR", ltr ? "BL" : "BR");
						push(ltr ? "TR" : "TL", ltr ? "BR" : "BL");
						break;
					default:
						// To assist dijit/_base/place, accept arguments of type {aroundCorner: "BL", corner: "TL"}.
						// Not meant to be used directly.  Remove for 2.0.
						push(pos.aroundCorner, pos.corner);
				}
			});

			var position = _place(node, choices, layoutNode, {w: width, h: height});
			position.aroundNodePos = aroundNodePos;

			return position;
		}
	};

	/*=====
	place.__Position = {
		// x: Integer
		//		horizontal coordinate in pixels, relative to document body
		// y: Integer
		//		vertical coordinate in pixels, relative to document body
	};
	place.__Rectangle = {
		// x: Integer
		//		horizontal offset in pixels, relative to document body
		// y: Integer
		//		vertical offset in pixels, relative to document body
		// w: Integer
		//		width in pixels.   Can also be specified as "width" for backwards-compatibility.
		// h: Integer
		//		height in pixels.   Can also be specified as "height" for backwards-compatibility.
	};
	=====*/

	return dijit.place = place;	// setting dijit.place for back-compat, remove for 2.0
});

},
'Sage/Utility/ErrorHandler':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
        'Sage/Utility',
        'Sage/UI/Dialogs',
        'dojo/io-query',
        'dojo/string',
        'dojo/_base/array', 
        'dojo/i18n!./nls/ErrorHandler'
],
//TODO: Localization
// ReSharper disable InconsistentNaming
    function (Utility, Dialogs, ioQuery, dString, array, resources) {
        // ReSharper restore InconsistentNaming
        Sage.namespace('Utility.ErrorHandler');
        dojo.mixin(Sage.Utility.ErrorHandler, {
            _debugEndRequest: false, // Set to true for development only.
            _configuration: {
                isDebug: false /* See base.master for isDebug setting. */,
                preemption: {
                    enabled: true,
                    allowAuthRedirect: true,
                    handledStatusCodes: "577,578,579,580,581,582,584",
                    showPreemptedErrorMsg: false,
                    showInternalServerErrorMsg: false,
                    showUnhandledMessagingServiceExceptionMsg: true
                },
                authenticationRedirectUrl: null,
                showExtendedValidationException: false,
                showExtendedRoleAccessDeniedException: false
            },
            _doRedirect: function (location) {
                var service = Sage.Services.getService("ClientBindingManagerService");
                if (service) {
                    service.clearDirtyStatus();
                }
                window.location = location;
            },
            _fmtSlxErrorId: function (slxErrorId) {
                if (Sage.Utility.isStringWithLength(slxErrorId)) {
                    if (this._configuration.isDebug) {
                        return dString.substitute("\r\n\r\nSaleslogix Error Id: <a href=\"SLXErrorLookupService.asmx/GetEventLogError?slxErrorId=${0}\" target=\"_blank\">${0}</a>",
                            [slxErrorId]);
                    } else {
                        return dString.substitute("\r\n\r\nSaleslogix Error Id: ${0}", [slxErrorId]);
                    }
                }
                return "";
            },
            _fmtStackTrace: function (stackTrace) {
                if (this._configuration.isDebug && Sage.Utility.isStringWithLength(stackTrace)) {
                    var stack = Sage.Utility.htmlEncode(stackTrace).replace(/(\r\n)/g, "&#13;&#10;").trim();
                    return dString.substitute("\r\n\r\nStack trace:\r\n<textarea id=\"StackTrace\" cols=\"20\" name=\"StackTrace\" readonly=\"readonly\" rows=\"1\" style=\"width: 100%; height: 200px; font-family: 'Courier New', Courier, monospace; font-size: small; background-color: #F2F2F2; color: #444444; 1px: ; opacity: 0.8; -moz-box-sizing: border-box; box-sizing: border-box;\" unselectable=\"off\" wrap=\"off\">${0}</textarea>", [stack]);
                }
                return "";
            },
            _mixinConfig: function () {
                if (window.errorHandlerConfig && typeof window.errorHandlerConfig === "object") {
                    dojo.mixin(this._configuration, window.errorHandlerConfig);
                }
            },
            _preemptError: function (xhr, o) {
                try {
                    var oHttpInfo = this.getHttpStatusInfo(xhr, o);
                    if (this._configuration.isDebug && typeof console !== "undefined") {
                        console.debug("Sage.Utility.ErrorHandler._preemptError: xhr=%o; o=%o; oHttpInfo=%o", xhr, o, oHttpInfo);
                    }
                    if (!(oHttpInfo && typeof oHttpInfo === "object" && oHttpInfo.hasOwnProperty("sdataError"))) {
                        return false;
                    }
                    var fnGetHeaderValue = function (response, header) {
                        if (response && typeof response === "object" && typeof xhr.getResponseHeader !== "undefined" && header && dojo.isString(header)) {
                            var sUrl = response.getResponseHeader(header);
                            if (sUrl && Sage.Utility.isStringWithLength(sUrl)) {
                                return sUrl;
                            }
                        }
                        return null;
                    };
                    var fnGetExceptionRedirect = function (response) {
                        return fnGetHeaderValue(response, "Sage-SalesLogix-Exception-Redirect");
                    };
                    var fnGetSalesLogixErrorId = function (response) {
                        return fnGetHeaderValue(response, "Sage-SalesLogix-Error-Id");
                    };
                    var self = this;
                    var fnRedirect = function (url) {
                        if (typeof console !== "undefined") {
                            console.debug("Redirecting to %o", url);
                        }
                        self._doRedirect(url);
                    };
                    var sRedirect;

                    // First, check to see if we have an SData Diagnoses that was sent via the UnhandledMessagingServiceException handler.
                    if ((this.isSDataExceptionDiagnoses(oHttpInfo.sdataError.applicationCode) && (oHttpInfo.status == 500) &&
                        this._configuration.preemption.showUnhandledMessagingServiceExceptionMsg)) {
                        this.showStatusInfoError(oHttpInfo);
                        return true;
                    }

                    switch (oHttpInfo.status) {
                        case 401:
                            // 401: Unauthorized
                            if (typeof console !== "undefined") {
                                console.error("Unauthorized (401): %o", oHttpInfo.url);
                            }
                            if (this.isConfiguredToHandle(oHttpInfo.status)) {
                                this.showStatusInfoError(oHttpInfo);
                                return true;
                            }
                            return false;
                        case 403:
                            // 403: Forbidden (used in many HttpHanders when IAuthenticationProvider::IsAuthenticated returns false). 
                            // NOTE: Only redirect if the HTTP response was coming from the current client.
                            if (typeof console !== "undefined") {
                                console.error("Forbidden (403): %o", oHttpInfo.url);
                            }
                            if (this.isConfiguredToHandle(oHttpInfo.status)) {
                                this.showStatusInfoError(oHttpInfo);
                                return true;
                            }
                            return false;
                        case 404:
                            // 404: Not Found 
                            if (typeof console !== "undefined") {
                                console.error("Not Found (404): %o", oHttpInfo.url);
                            }
                            if (this.isConfiguredToHandle(oHttpInfo.status)) {
                                this.showStatusInfoError(oHttpInfo);
                                return true;
                            }
                            return false;
                        case 408:
                            // 408: Request Timeout (this type of error is not handled anywhere else).
                            if (typeof console !== "undefined") {
                                console.error("Request Timeout: %o", oHttpInfo.url);
                            }
                            if (this.isConfiguredToHandle(oHttpInfo.status)) {
                                this.showStatusInfoError(oHttpInfo);
                                return true;
                            }
                            return false;
                        case 500:
                            if (typeof console !== "undefined") {
                                console.error("Internal Server Error (500) - HTTP Info: %o", oHttpInfo);
                            }
                            if ((this.isSDataExceptionDiagnoses(oHttpInfo.sdataError.applicationCode) &&
                            this._configuration.preemption.showUnhandledMessagingServiceExceptionMsg) ||
                                this._configuration.preemption.showInternalServerErrorMsg) {
                                this.showStatusInfoError(oHttpInfo);
                                return true;
                            }
                            return false;
                        case 575:
                            // AuthTokenNullException
                            if (typeof console !== "undefined") {
                                console.error("AuthTokenNullException (575) - Saleslogix Error Id: %o; HTTP Info: %o", fnGetSalesLogixErrorId(xhr), oHttpInfo);
                            }
                            if (this._configuration.preemption.allowAuthRedirect) {
                                sRedirect = fnGetExceptionRedirect(xhr);
                                if (sRedirect !== null) {
                                    fnRedirect(sRedirect);
                                    return true;
                                }
                            }
                            return false;
                        case 576:
                            // BaseException (i.e. Exception.GetBaseException())                    
                            if (typeof console !== "undefined") {
                                console.error("BaseException (576) - Saleslogix Error Id: %o; HTTP Info: %o", fnGetSalesLogixErrorId(xhr), oHttpInfo);
                            }
                            if (this._configuration.preemption.showPreemptedErrorMsg) {
                                this.showStatusInfoError(oHttpInfo);
                                return true;
                            }
                            return false;
                        case 577:
                            // RoleAccessDeniedException
                            if (typeof console !== "undefined") {
                                console.error("RoleAccessDeniedException (577) - Saleslogix Error Id: %o; HTTP Info: %o", fnGetSalesLogixErrorId(xhr), oHttpInfo);
                            }
                            if (this.isConfiguredToHandle(oHttpInfo.status)) {
                                this.showStatusInfoError(oHttpInfo);
                                return true;
                            }
                            return false;
                        case 578:
                            // ValidationException
                            if (typeof console !== "undefined") {
                                console.error("ValidationException (578) - Saleslogix Error Id: %o; HTTP Info: %o", fnGetSalesLogixErrorId(xhr), oHttpInfo);
                            }
                            if (this.isConfiguredToHandle(oHttpInfo.status)) {
                                this.showStatusInfoError(oHttpInfo);
                                return true;
                            }
                            return false;
                        case 579:
                            // UserObservableException
                            if (typeof console !== "undefined") {
                                console.error("UserObservableException (579) - Saleslogix Error Id: %o; HTTP Info: %o", fnGetSalesLogixErrorId(xhr), oHttpInfo);
                            }
                            if (this.isConfiguredToHandle(oHttpInfo.status)) {
                                this.showStatusInfoError(oHttpInfo);
                                return true;
                            }
                            return false;
                        case 580:
                            // HttpRequestValidationException
                            if (typeof console !== "undefined") {
                                console.error("HttpRequestValidationException (580) - Saleslogix Error Id: %o; HTTP Info: %o", fnGetSalesLogixErrorId(xhr), oHttpInfo);
                            }
                            if (this.isConfiguredToHandle(oHttpInfo.status)) {
                                this.showStatusInfoError(oHttpInfo);
                                return true;
                            }
                            return false;
                        case 581:
                            // StringOrBinaryDataWouldBeTruncatedException (OleDbException)
                            if (typeof console !== "undefined") {
                                console.error("StringOrBinaryDataWouldBeTruncatedException (581) - Saleslogix Error Id: %o; HTTP Info: %o", fnGetSalesLogixErrorId(xhr), oHttpInfo);
                            }
                            if (this.isConfiguredToHandle(oHttpInfo.status)) {
                                this.showStatusInfoError(oHttpInfo);
                                return true;
                            }
                            return false;
                        case 582:
                            // AccessException
                            if (typeof console !== "undefined") {
                                console.error("AccessException (582) - Saleslogix Error Id: %o; HTTP Info: %o", fnGetSalesLogixErrorId(xhr), oHttpInfo);
                            }
                            if (this.isConfiguredToHandle(oHttpInfo.status)) {
                                this.showStatusInfoError(oHttpInfo);
                                return true;
                            }
                            return false;
                        case 584:
                            // ProjectsValidationException
                            if (typeof console !== "undefined") {
                                console.error("ProjectsValidationException (584) - Saleslogix Error Id: %o; HTTP Info: %o", fnGetSalesLogixErrorId(xhr), oHttpInfo);
                            }
                            if (this.isConfiguredToHandle(oHttpInfo.status)) {
                                this.showStatusInfoError(oHttpInfo);
                                return true;
                            }
                            return false;
                        default:
                            if (typeof console !== "undefined") {
                                console.debug("%o (%o) - HTTP Info: %o", oHttpInfo.statusText, oHttpInfo.status, oHttpInfo);
                            }
                            if (this.isConfiguredToHandle(oHttpInfo.status)) {
                                this.showStatusInfoError(oHttpInfo);
                                return true;
                            }
                            return false;
                    }
                } catch (e) {
                    if (typeof console !== "undefined") {
                        console.warn("Error in _preemptError(): %o", e);
                    }
                    return false;
                }
            },
            init: function () {
                this._mixinConfig();
                if (this._configuration.preemption.enabled) {

                    if (typeof console !== 'undefined') {
                        console.debug('init preemption');
                    }

                    // Note: Native calls to XMLHttpRequest cannot be preempted (e.g. new XMLHttpRequest()).
                    // You can add a call to ErrorHelper.handleHttpError() in the error handler of the XMLHttpRequest object.
                    // The recommendation is to use either Sage.SData.Client.* or the dojo.xhr* methods.

                    // Handle dojo XMLHTTPRequest errors
                    if (window.dojoConfig && window.dojoConfig.ioPublish && typeof window.dojoConfig.ioPublish === "boolean" && window.dojoConfig.ioPublish === true) {
                        dojo.subscribe("/dojo/io/error", function (dfd, response) {
                            if (dfd && typeof dfd === "object" && typeof dfd.ioArgs === "object") {
                                if ((Sage.Utility.ErrorHandler._hasErrorHandler(dfd.ioArgs.url) === false) || (dfd.ioArgs.xhr.status === 575)) {
                                    Sage.Utility.ErrorHandler._preemptError(dfd.ioArgs.xhr, { url: dfd.ioArgs.url });
                                }
                            }
                            return response;
                        });
                    } else {
                        (function () {
                            var oldRequest = dojo.xhr;
                            // ReSharper disable UnusedParameter
                            dojo.xhr = function (/*String*/method, /*dojo.__XhrArgs*/args, /*Boolean?*/hasBody) {
                                // ReSharper restore UnusedParameter
                                return oldRequest.apply(dojo, arguments).addErrback(function (err) {
                                    if (err && typeof err === "object" && (err instanceof Error) && typeof err.xhr === "object") {
                                        var sUrl = (args && args.url) ? args.url || "" : "";
                                        if ((Sage.Utility.ErrorHandler._hasErrorHandler(sUrl) === false) || (err.xhr.status === 575)) {
                                            Sage.Utility.ErrorHandler._preemptError(err.xhr, { url: sUrl });
                                        }
                                    }
                                    return err;
                                });
                            };
                        })();
                    }

                    // Handle Sage.SData.Client.Ajax XMLHTTPRequest errors
                    (function () {
                        var oldRequest = Sage.SData.Client.Ajax.request;
                        Sage.SData.Client.Ajax.request = function (o) {
                            dojo.mixin(o, {
                                // The .__failure property stores the original .failure callback, if any.
                                __failure: null,
                                // The .__failureHandler function defines the callback that is called for any AJAX failure. If the original
                                // request included a .failure callback the original .failure callback is called unless there was an
                                // unhandled server-side exception (i.e. 5xx) redirected to here from App_Code\Global.cs that requires
                                // either a redirection to Login.aspx or other special error handling.
                                __failureHandler: function (response, opt) {
                                    var referenceError = false;
                                    if (opt.__failure && typeof opt.__failure === "function") {
                                        try {
                                            opt.__failure.call(opt.scope || this, response, opt);
                                        } catch (e) {
                                            if (typeof console !== "undefined") {
                                                console.error("There was an error calling the original failure() handler: %o", e);
                                            }
                                            if (e instanceof ReferenceError) {
                                                referenceError = true;
                                                console.warn("The call to Sage.Utility.ErrorHandler.handleHttpError() may be invalid. Check your spelling and make sure there is a valid Sage/Utility reference or that the fully qualified name is used when calling handleHttpError().");
                                            }
                                        }
                                    }
                                    var sUrl = opt.url;
                                    if ((Sage.Utility.ErrorHandler._hasErrorHandler(sUrl) === false) || (response.status === 575)) {
                                        if (referenceError) {
                                            Sage.Utility.ErrorHandler.handleHttpError(response, opt);
                                        } else {
                                            Sage.Utility.ErrorHandler._preemptError(response, opt);
                                        }
                                    }
                                    return response;
                                }
                            });
                            if (typeof o.failure === "function") {
                                o.__failure = o.failure;
                            }
                            o.failure = o.__failureHandler;
                            return oldRequest.apply(this, arguments);
                        };
                    })();

                    // Handle $ajax XMLHTTPRequest errors
                    // Note: See also dojo.jq (jQuery compatibility layer) and its ajaxError handling.
                    if (typeof $ === 'function') {
                        $(function () {
                            // http://api.jquery.com/ajaxError/
                            // ReSharper disable UnusedParameter
                            jQuery(this).ajaxError(function (event, jqXhr, ajaxSettings, thrownError) {
                                // ReSharper restore UnusedParameter
                                var sUrl = (typeof ajaxSettings === "object") ? (ajaxSettings.url || "") : "";
                                var options = { url: sUrl };
                                if ((Sage.Utility.ErrorHandler._hasErrorHandler(sUrl) === false) || (jqXhr.status === 575)) {
                                    Sage.Utility.ErrorHandler._preemptError(jqXhr, options);
                                }
                            });
                        });
                    }
                }
            },
            _getInternalHttpStatus: function (statusInfo) {
                if (statusInfo && typeof statusInfo === "object" && statusInfo.hasOwnProperty("status") && (isNaN(statusInfo.status) === false)) {
                    if (typeof statusInfo.sdataError === "object" &&
                        this.isSDataExceptionDiagnoses(statusInfo.sdataError.applicationCode) &&
                            typeof statusInfo.sdataError.appInfo === "object" && typeof statusInfo.sdataError.appInfo.exceptionKind === "string") {

                        switch (statusInfo.sdataError.appInfo.exceptionKind) {
                            case "AuthTokenNullException":
                                return 575;
                            case "BaseException":
                                if (Number(statusInfo.status) == 500) {
                                    return 576;
                                }
                                else {
                                    return Number(statusInfo.status);
                                }
                                break;
                            case "RoleAccessDeniedException":
                                return 577;
                            case "ValidationException":
                                return 578;
                            case "UserObservableException":
                                return 579;
                            case "HttpRequestValidationException":
                                return 580;
                            case "StringOrBinaryDataWouldBeTruncatedException":
                                return 581;
                            case "AccessException":
                                return 582;
                            case "ProjectsValidationException":
                                return 584;
                            default:
                                return Number(statusInfo.status);
                        }
                    } else {
                        return Number(statusInfo.status);
                    }
                }
                return -1;
            },
            _getStatusInfoOptions: function (opt) {
                var options = {
                    "message": "",
                    "url": ""
                };
                if (opt && dojo.isObject(opt)) {
                    dojo.mixin(options, opt);
                }
                return options;
            },
            _handleAsDojoXhrHttpError: function (error, ioargs, opt) {
                var options = this._getStatusInfoOptions(opt);
                var sError = "";
                if (error && dojo.isObject(error)) {
                    sError = error.message || error.result || "";
                }
                if (sError !== "" && options.message !== "")
                    options.message = options.message + " " + sError;
                else
                    options.message = sError;
                var xhr = (ioargs && dojo.isObject(ioargs) && ioargs.xhr && dojo.isObject(ioargs.xhr)) ? ioargs.xhr : null;
                if (options.url === "" && xhr !== null && dojo.isString(ioargs.url))
                    options.url = ioargs.url;
                this._handleAsHttpError(xhr, null, options);
            },
            _handleAsHttpError: function (xhr, sdata, options) {
                var oStatusInfo = this.getHttpStatusInfo(xhr, sdata);
                if (oStatusInfo !== null)
                    this.showStatusInfoError(oStatusInfo, options);
                else {
                    var sMessage = (options && dojo.isObject(options) && Sage.Utility.isStringWithLength(options.message)) ? options.message : resources.HttpError;
					Dialogs.showError(sMessage);
                }
            },
            _hasErrorHandler: function (url) {
                var hasErrorHandler = 'HASERRORHANDLER'; //DNL
                if (url && dojo.isString(url) && url.toUpperCase().indexOf(hasErrorHandler) != -1) {
                    var query = url.substring(url.indexOf('?') + 1, url.length);
                    if (query !== '') {
                        var queryObject = ioQuery.queryToObject(query.toUpperCase());
                        if (queryObject && dojo.isObject(queryObject)) {
                            return queryObject[hasErrorHandler] === 'TRUE';
                        }
                    }
                }
                return false;
            },
            handleEndRequestError: function (args) {
                // IMPORTANT: This method is called from the callback Sage.Utility.hideRequestIndicator which is
                //            setup via Sys.WebForms.PageRequestManager.getInstance().add_endRequest(). The args
                //            may or may [not] represent an error.

                if (this._debugEndRequest && typeof console !== 'undefined') {
                    console.debug('handleEndRequestError: args=%o', args);
                }

                if (args && typeof args === 'object' && typeof args.get_error === 'function' && args.get_error() !== null) {

                    try {

                        function cleanMessage(msg) {
                            if (msg && dojo.isString(msg)) {
                                // See C:\Program Files (x86)\Microsoft ASP.NET\ASP.NET 2.0 AJAX Extensions\v1.0.61025
                                // \MicrosoftAjaxLibrary\System.Web.Extensions\1.0.61025.0\MicrosoftAjaxWebForms.debug.js
                                return msg
                                    .replace('Sys.WebForms.PageRequestManagerServerErrorException: ', '')
                                    .replace('Sys.WebForms.PageRequestManagerParserErrorException: ', '')
                                    .replace('Sys.WebForms.PageRequestManagerTimeoutException: ', '');
                            }
                            return msg;
                        }

                        switch (args.get_error().name) {
                            case 'Sys.WebForms.PageRequestManagerTimeoutException':
                            case 'Sys.WebForms.PageRequestManagerParserErrorException':
                                Dialogs.showError(cleanMessage(args.get_error().message));
                                args.set_errorHandled(true);
                                return;
                        }

                        var message = cleanMessage(args.get_error().message);
                        var httpStatusCode = args.get_error().httpStatusCode;
                        if (message === '${AjaxLoginRedirect}' || message === '${LoginRedirect}' || httpStatusCode == 401 || httpStatusCode == 575) {
                            if (this._configuration.preemption.allowAuthRedirect) {
                                var redirectUrl = this._configuration.authenticationRedirectUrl || 'Login.aspx';
                                if (typeof console !== 'undefined') {
                                    console.debug('handleEndRequestError: ' + message + ' - Redirecting to ' + redirectUrl);
                                }
                                args.set_errorHandled(true);
                                this._doRedirect(redirectUrl);
                                return;
                            }
                        }

                        // Handle Sys.WebForms.PageRequestManagerServerErrorException
                        var hasResponse = args.get_response() !== null;
                        // Is it possible there can be a timeout event if the get_error().name is not
                        // Sys.WebForms.PageRequestManagerTimeoutException?
                        var timedout = hasResponse ? args.get_response().get_timedOut() : false;
                        var aborted = hasResponse ? args.get_response().get_aborted() : false;
                        var statusCode = hasResponse ? args.get_response().get_statusCode() : -1;
                        var responseAvaiable = hasResponse ? args.get_response().get_responseAvailable() : false;

                        if (this._debugEndRequest && typeof console !== 'undefined') {
                            console.debug('hasResponse: %o', hasResponse);
                            console.debug('statusCode: %o', statusCode);
                            console.debug('responseAvaiable: %o', responseAvaiable);
                            console.debug('name: %o', args.get_error().name);
                            console.debug('timedout: %o', timedout);
                            console.debug('aborted: %o', aborted);
                        }

                        // HTTP request was interrupted or aborted
                        if (statusCode === 0 || aborted) {
                            args.set_errorHandled(true);
                            return;
                        }

                        var hasXhr = responseAvaiable ?
                            (args.get_response().hasOwnProperty('_xmlHttpRequest') && args.get_response()._xmlHttpRequest !== null)
                            : false;

                        if (this._debugEndRequest && typeof console !== 'undefined') {
                            console.debug('hasXhr: %o', hasXhr);
                        }

                        if (hasXhr || timedout) {

                            var xhr = args.get_response()._xmlHttpRequest;
                            if (this._debugEndRequest && typeof console !== 'undefined') {
                                console.debug('xhr: %o', xhr);
                            }

                            if (statusCode == 200 || timedout) {
                                // NOTE: If the statusCode is 200 it means the Exception was handled by the
                                //       ScriptManager.AsyncPostBackError error handler. The AsyncPostBackError
                                //       handler does not appear to handle the System.Web.HttpRequestValidationException
                                //       exception type, so that type bubbles to the server and then we'll get the
                                //       Saleslogix JSON Error Response with a statusCode of 580. The reason for this 
                                //       appears to be that the HttpRequestValidationException is raised in the
                                //       HttpRequest object, which means the AsyncPostBackError error handler is 
                                //       never reached; however, EndRequest is still called, but with the XHR that
                                //       contains the Saleslogix JSON Error Response and statusCode.
                                if (this._debugEndRequest && typeof console !== 'undefined') {
                                    console.debug('message [1]: %o', cleanMessage(args.get_error().message));
                                }
                                Dialogs.showError(cleanMessage(args.get_error().message));
                                args.set_errorHandled(true);
                                return;
                            }

                            // Is the ErrorHandler configured to handle the statusCode?
                            // Note: isConfiguredToHandle() also takes into consideration whether or not preemption is enabled.
                            var canBeHandled = this.isConfiguredToHandle(statusCode, xhr);

                            if (this._debugEndRequest && typeof console !== 'undefined') {
                                console.debug('canBeHandled: %o', canBeHandled);
                            }

                            // Handle HTTP responses other than those with a statusCode of 200 (e.g. 580).

                            // If preemption is enabled and the status code is set up to be handled by preemption, then call
                            // _preemptError(); otherwise, call handleHttpError().               
                            if (canBeHandled) {
                                if (this._debugEndRequest && typeof console !== 'undefined') {
                                    console.debug('calling this._preemptError(xhr)');
                                }
                                this._preemptError(xhr);
                            } else {
                                if (this._debugEndRequest && typeof console !== 'undefined') {
                                    console.debug('this.handleHttpError(xhr)');
                                }
                                this.handleHttpError(xhr);
                            }
                            args.set_errorHandled(true);
                            return;
                        }

                        if (this._debugEndRequest && typeof console !== 'undefined') {
                            console.debug('message [2]: %o', cleanMessage(args.get_error().message));
                        }

                        // Failsafe
                        Dialogs.showError(cleanMessage(args.get_error().message));
                        args.set_errorHandled(true);

                    } catch (e) {
                        if (typeof console !== 'undefined') {
                            console.error('There was an error in handleEndRequestError(): %o', e);
                        }
                    }
                } else {
                    if (this._debugEndRequest && typeof console !== 'undefined') {
                        console.debug('No error in handleEndRequestError to handle');
                    }
                }
            },
            handleHttpError: function (arg1, arg2, options) {
                var bFirstArgIsXhr = (arg1 && dojo.isObject(arg1) && typeof arg1.getResponseHeader !== "undefined");
                if (bFirstArgIsXhr)
                    this._handleAsHttpError(arg1, arg2, options);
                else
                    this._handleAsDojoXhrHttpError(arg1, arg2, options);
            },
            getInterceptedError: function (responseText, isJson) {
                if (!Sage.Utility.isStringWithLength(responseText)) {
                    return null;
                }
                if (Sage.Utility.isTrue(isJson)) {
                    var obj = dojo.fromJson(responseText);
                    if (obj && typeof obj === "object") {
                        return obj;
                    }
                } else {
                    return { "text": responseText };
                }
                return null;
            },
            getSDataDiagnosis: function (responseText, isXml) {
                if (!Sage.Utility.isStringWithLength(responseText)) {
                    return null;
                }
                var obj;
                if (Sage.Utility.isTrue(isXml)) {
                    var xml = new XML.ObjTree();
                    obj = xml.parseXML(responseText);
                    if (obj && typeof obj === "object" && obj.hasOwnProperty("sdata:diagnoses")) {
                        obj = obj["sdata:diagnoses"]["sdata:diagnosis"];
                        if (!obj || typeof obj !== "object") {
                            return null;
                        }
                        var fnGetProp = function (prop) {
                            var value = obj.hasOwnProperty(prop) ? obj[prop] : "";
                            // "value" could be an object with a property named -xsi:nil which represents an empty nullable string.
                            // Make sure we have a string.
                            if (value && dojo.isString(value)) {
                                if (prop === "stackTrace") {
                                    if (!this._configuration.isDebug) {
                                        return "";
                                    }
                                }
                                return value;
                            }
                            return "";
                        };
                        return {
                            "severity": fnGetProp("sdata:severity"),
                            "sdataCode": fnGetProp("sdata:sdataCode"),
                            "applicationCode": fnGetProp("sdata:applicationCode"),
                            "message": fnGetProp("sdata:message"),
                            "stackTrace": fnGetProp("sdata:stackTrace"),
                            "payloadPath": fnGetProp("sdata:payloadPath")
                        };
                    }
                } else {
                    obj = dojo.fromJson(responseText);
                    if (obj && dojo.isArray(obj) && obj.length > 0 && typeof obj[0] === "object" && obj[0].hasOwnProperty("sdataCode")) {
                        return obj[0];
                    }
                }
                return null;
            },
            getHttpStatusInfo: function (xhr, sdata) {
                var bIsXhr = (xhr && dojo.isObject(xhr) && typeof xhr.getResponseHeader !== "undefined");
                if (!bIsXhr) {
                    return null;
                }
                var iStatus = this.safeGetPropValue(xhr, "status", -1);
                var sStatusText = this.safeGetPropValue(xhr, "statusText", "Unknown HTTP status. Possible timeout.");
                var oStatusInfo = {
                    "message": dString.substitute("HTTP status: ${0} (${1}).", [sStatusText, iStatus]),
                    "status": iStatus,
                    "statusText": sStatusText,
                    "url": (sdata && dojo.isObject(sdata) && dojo.isString(sdata.url)) ? sdata.url : "",
                    "sdataError": {}
                };
                if (xhr.readyState !== 4) {
                    return oStatusInfo;
                }
                var sContentType = xhr.getResponseHeader("Content-Type");
                if (dojo.isString(sContentType)) {
                    var self = this;
                    switch (iStatus) {
                        case 576:
                            // Exception.GetBaseException()
                        case 577:
                            // RoleAccessDeniedException
                        case 578:
                            // ValidationException
                        case 579:
                            // UserObservableException
                        case 580:
                            // HttpRequestValidationException
                        case 581:
                            // StringOrBinaryDataWouldBeTruncatedException (OleDbException)
                        case 582:
                            // AccessException
                            var oErrorInfo;
                            var fnGetErrorInfo = function (isJson) {
                                var sResponseText = self.safeGetPropValue(xhr, "responseText", "");
                                return self.getInterceptedError(sResponseText, isJson);
                            };
                            if (sContentType.indexOf("application/json") !== -1) {
                                oErrorInfo = fnGetErrorInfo(true);
                            } else if (sContentType.indexOf("text/plain") !== -1) {
                                oErrorInfo = fnGetErrorInfo(false);
                                if (oErrorInfo && typeof oErrorInfo === "object" && oErrorInfo.hasOwnProperty("text")) {
                                    if (iStatus === 576) {
                                        oStatusInfo.message += "\r\n\r\n" + oErrorInfo.text;
                                    } else {
                                        oStatusInfo.message = oErrorInfo.text;
                                    }
                                    return oStatusInfo;
                                }
                            } else {
                                return oStatusInfo;
                            }
                            if (oErrorInfo && typeof oErrorInfo === "object" && oErrorInfo.hasOwnProperty("slxErrorId")) {
                                oStatusInfo.errorInfo = oErrorInfo;
                            }
                            break;
                        default:
                            var oDiagnosis;
                            var fnGetDiagnosis = function (isXml) {
                                var sResponseText = self.safeGetPropValue(xhr, "responseText", "");
                                return self.getSDataDiagnosis(sResponseText, isXml);
                            };
                            if (sContentType.indexOf("application/json") !== -1) {
                                oDiagnosis = fnGetDiagnosis(false);
                            } else if (sContentType.indexOf("application/xml") !== -1) {
                                oDiagnosis = fnGetDiagnosis(true);
                            } else {
                                return oStatusInfo;
                            }
                            if (oDiagnosis && typeof oDiagnosis === "object" && oDiagnosis.hasOwnProperty("sdataCode")) {
                                var sdataError = {
                                    "severity": "",
                                    "sdataCode": "",
                                    "applicationCode": "",
                                    "message": "",
                                    "stackTrace": "",
                                    "payloadPath": "",
                                    fmtError: function () {
                                        var arrProp = [];
                                        for (var prop in this) {
                                            // "message" and "stackTrace" are handled separately, so exclude them.
                                            if (prop == "message" || prop == "stackTrace" || prop == "fmtError")
                                                continue;
                                            var value = this[prop];
                                            if (dojo.isString(value) && value !== "")
                                                arrProp.push(dString.substitute("${0}=${1}", [prop.toString(), value]));
                                        }
                                        return (arrProp.length > 0) ? arrProp.join("; ") : "";
                                    }
                                };

                                oStatusInfo.sdataError = sdataError;
                                dojo.mixin(oStatusInfo.sdataError, oDiagnosis);

                                if (oStatusInfo.sdataError.applicationCode && this.isSDataExceptionDiagnoses(oStatusInfo.sdataError.applicationCode)) {
                                    var fnGetInfo = function () {
                                        var obj = {};
                                        var arrAppData = oStatusInfo.sdataError.applicationCode.split("; ");
                                        array.forEach(arrAppData, function (item) {
                                            if (item && dojo.isString(item) && item.indexOf("=") !== -1) {
                                                var arrItem = item.split("=");
                                                var name = arrItem[0].trim();
                                                var value = arrItem[1].trim();
                                                obj[name] = value;
                                            }
                                        });
                                        return obj;
                                    };
                                    oStatusInfo.sdataError.appInfo = fnGetInfo();
                                    if (oStatusInfo.sdataError.appInfo.hasOwnProperty("code") && oStatusInfo.sdataError.appInfo.source) {
                                        oStatusInfo.sdataError.applicationCode = oStatusInfo.sdataError.appInfo.code + "|" +
                                        oStatusInfo.sdataError.appInfo.source;
                                    } else {
                                        oStatusInfo.sdataError.applicationCode = oStatusInfo.sdataError.appInfo.source;
                                    }
                                    if (oStatusInfo.sdataError.appInfo.source) {
                                        delete oStatusInfo.sdataError.appInfo.source;
                                    }
                                }

                                var sSeverity = "UNKNOWN";
                                if (Sage.Utility.isStringWithLength(oStatusInfo.sdataError.severity)) {
                                    sSeverity = oStatusInfo.sdataError.severity.toUpperCase();
                                }
                                var oDescriptionMap = {
                                    "INFO": "Informational message",
                                    "WARNING": "Warning message",
                                    "TRANSIENT": "Transient error",
                                    "ERROR": "Operation failed",
                                    "FATAL": "Severe error",
                                    "UNKNOWN": "Unknown"
                                };
                                var sDescription = oDescriptionMap[sSeverity] || oDescriptionMap["UNKNOWN"];
                                var sMessage = oStatusInfo.sdataError.message;
                                if (dojo.isString(sMessage)) {
                                    if (sMessage.trim().match("." + "$") != ".") {
                                        sMessage += ".";
                                    }
                                }
                                if (this._configuration.isDebug) {
                                    oStatusInfo.message = dString.substitute(
                                    "The following SData diagnosis occurred: Description=${0}. Message=${1} HTTP status: ${2} (${3}).",
                                    [sDescription, sMessage, oStatusInfo.statusText, oStatusInfo.status]);
                                } else {
                                    var internalStatus = this._getInternalHttpStatus(oStatusInfo);
                                    var showHttpStatus = true;
                                    switch (internalStatus) {
                                        // RoleAccessDeniedException                                                                                      
                                        case 577:
                                            if (!this._configuration.showExtendedRoleAccessDeniedException) {
                                                showHttpStatus = false;
                                            }
                                            break;
                                            // ValidationException                                                                                      
                                        case 578:
                                            if (!this._configuration.showExtendedValidationException) {
                                                showHttpStatus = false;
                                            }
                                            break;
                                            // AccessException                                                                                     
                                        case 582:
                                            // ProjectsValidationException
                                        case 584:
                                            showHttpStatus = false;
                                            break;
                                    }
                                    if (showHttpStatus) {
                                        oStatusInfo.message = dString.substitute("${0} HTTP status: ${1} (${2}).",
                                        [sMessage, oStatusInfo.statusText, oStatusInfo.status]);
                                    } else {
                                        oStatusInfo.message = sMessage;
                                    }
                                }
                            }
                            break;
                    }
                }
                return oStatusInfo;
            },
            isConfiguredToHandle: function (statusCode, xhr) {
                var result = false;
                if (this._configuration.preemption.enabled === false) return false;
                if (statusCode && isNaN(statusCode) === false) {
                    switch (Number(statusCode)) {
                        case 500:
                            if (this._configuration.preemption.showInternalServerErrorMsg) {
                                return true;
                            }
                            if (this._configuration.preemption.showUnhandledMessagingServiceExceptionMsg) {
                                var statusInfo = this.getHttpStatusInfo(xhr);
                                if (!(statusInfo && typeof statusInfo === "object" && statusInfo.hasOwnProperty("sdataError"))) {
                                    return false;
                                }
                                return this.isSDataExceptionDiagnoses(statusInfo.sdataError.applicationCode);
                            }
                            break;
                        case 575:
                            return this._configuration.preemption.allowAuthRedirect;
                        case 576:
                            return this._configuration.preemption.showPreemptedErrorMsg;
                        default:
                            if (this._configuration.preemption.handledStatusCodes !== '') {
                                var arrStatusCodes = this._configuration.preemption.handledStatusCodes.split(',');
                                array.some(arrStatusCodes, function (sc) {
                                    if (sc == statusCode) {
                                        result = true;
                                        return true;
                                    } else {
                                        return false;
                                    }
                                });
                            }
                            break;
                    }
                }
                return result;
            },
            isSDataExceptionDiagnoses: function (applicationCode) {
                if (applicationCode && typeof applicationCode === "string" && applicationCode.indexOf("SDataExceptionDiagnoses") != -1) {
                    return true;
                }
                return false;
            },
            preemptError: function (xhr, o) {
                this._preemptError(xhr, o);
            },
            safeGetPropValue: function (obj, prop, defaultValue) {
                /* This function was created to address an issue where reading from a valid XmlHttpRequest object
                * raises an exception if the XmlHttpRequest object represents an HTTP session that has timed out
                * or when the xhr.readyState is != 4. Some of the problematic properties include xhr.status,
                * xhr.statusText, xhr.getResponseHeader() and xhr.responseText. Not all browsers have the same behavior.
                * http://msdn.microsoft.com/en-us/library/windows/desktop/ms753800(v=vs.85).aspx
                * 'In MSXML 3.0 and later, reading the status property after loading has commenced but has not
                * yet completed (for example, at the LOADED or INTERACTIVE state) returns the following error:
                * "The data necessary to complete this operation is not yet available."' */
                try {
                    return obj[prop];
                } catch (e) {
                    return defaultValue;
                }
            },
            showStatusInfoError: function (statusInfo, opt) {
                var options = this._getStatusInfoOptions(opt);
                var sMessage = options.message;

                var sPlainTextStackTrace = "";
                var sStackTraceWithTextArea = "";

                var sPlainSlxErrorIdMsg = "";
                var sSlxErrorIdMsgWithLink = "";

                // The internalStatus should [not] be used for display purposes. The Sage.Integration.Server sends
                // an HTTP status of 500 for all of its errors. The _getInternalHttpStatus() function translates
                // the statusInfo.sdataError.appInfo.exceptionKind into the exception kind that should be handled (e.g. 576, 577, etc.).
                var internalStatus = this._getInternalHttpStatus(statusInfo);

                if ((internalStatus == 575) && this._configuration.preemption.allowAuthRedirect) {
                    var location = this._configuration.authenticationRedirectUrl || 'Login.aspx';
                    this._doRedirect(location);
                    return;
                }

                if (statusInfo && dojo.isObject(statusInfo) && dojo.isString(statusInfo.message)) {

                    sMessage += (sMessage === "") ? statusInfo.message : " " + statusInfo.message;

                    switch (internalStatus) {
                        case 575:
                            // AuthTokenNullException
                        case 576:
                            // BaseException
                        case 577:
                            // RoleAccessDeniedException
                        case 578:
                            // ValidationException
                        case 579:
                            // UserObservableException
                        case 580:
                            // HttpRequestValidationException
                        case 581:
                            // StringOrBinaryDataWouldBeTruncatedException (OleDbException)
                        case 582:
                            // AccessException
                            sMessage = Sage.Utility.htmlEncode(statusInfo.message);
                            if (typeof statusInfo.errorInfo === "object") {
                                sMessage = Sage.Utility.htmlEncode(statusInfo.errorInfo.message);
                            }
                            switch (internalStatus) {
                                case 577:
                                    if (!this._configuration.showExtendedRoleAccessDeniedException) {
                                        Dialogs.showError(sMessage);
                                        return;
                                    }
                                    break;
                                case 578:
                                    if (!this._configuration.showExtendedValidationException) {
                                        Dialogs.showError(sMessage);
                                        return;
                                    }
                                    break;
                                case 579:
                                    break;
                                case 576:
                                case 580:
                                case 581:
                                    if (statusInfo.status != 500) {
                                        sMessage += dString.substitute(" HTTP status: ${info.statusText} (${info.status}).", { info: statusInfo });
                                    }
                                    break;
                                case 582:
                                    Dialogs.showError(sMessage);
                                    return;
                            }
                            break;
                    }

                    if (typeof statusInfo.sdataError === "object" && typeof statusInfo.sdataError.appInfo === "object") {
                        sPlainSlxErrorIdMsg = dString.substitute("\r\n\r\nSaleslogix Error Id: ${0}", [statusInfo.sdataError.appInfo.slxErrorId]);
                        sSlxErrorIdMsgWithLink = this._fmtSlxErrorId(statusInfo.sdataError.appInfo.slxErrorId);
                        sMessage += sSlxErrorIdMsgWithLink;
                    }
                    if (typeof statusInfo.errorInfo === "undefined") {
                        var sUrl = null;
                        if (Sage.Utility.isStringWithLength(statusInfo.url)) {
                            if (sMessage.indexOf(decodeURIComponent(statusInfo.url)) == -1) {
                                sUrl = decodeURIComponent(statusInfo.url);
                            }
                        } else if (Sage.Utility.isStringWithLength(options.url)) {
                            if (sMessage.indexOf(decodeURIComponent(options.url)) == -1) {
                                sUrl = decodeURIComponent(options.url);
                            }
                        }
                        if (sUrl !== null) {
                            sMessage += dString.substitute("\r\n\r\nURL: ${0}", [sUrl]);
                        }
                    }
                    if (this._configuration.isDebug) {
                        // Are we dealing with an SData error object?
                        if (typeof statusInfo.sdataError === "object") {
                            if (dojo.isFunction(statusInfo.sdataError.fmtError)) {
                                sMessage += dString.substitute("\r\n\r\nExtended SData diagnosis information: ${0}.", [statusInfo.sdataError.fmtError()]);
                            }
                            if (typeof statusInfo.sdataError.appInfo === "object") {
                                sMessage += dString.substitute("\r\n\r\nException type: ${info.exceptionType}\r\n\r\nSource: ${info.exceptionSource}",
                                    { info: statusInfo.sdataError.appInfo });
                            }
                            if (statusInfo.sdataError.stackTrace) {
                                sPlainTextStackTrace = statusInfo.sdataError.stackTrace;
                                sStackTraceWithTextArea = this._fmtStackTrace(statusInfo.sdataError.stackTrace);
                                sMessage += sStackTraceWithTextArea;
                            }
                        }
                    }
                    var mail = { subject: "Infor Exception Details" };
                    // Are we dealing with an ErrorInfo object?
                    if (typeof statusInfo.errorInfo === "object") {
                        sPlainSlxErrorIdMsg = dString.substitute("\r\n\r\nInfor Error Id: ${0}", [statusInfo.errorInfo.slxErrorId]);
                        sSlxErrorIdMsgWithLink = this._fmtSlxErrorId(statusInfo.errorInfo.slxErrorId);
                        sMessage += sSlxErrorIdMsgWithLink;
                        sMessage += dString.substitute("\r\n\r\nURL: ${info.request.url}", { info: statusInfo.errorInfo });
                        if (this._configuration.isDebug) {
                            if (statusInfo.errorInfo.stackTrace) {
                                sPlainTextStackTrace = statusInfo.errorInfo.stackTrace;
                                sStackTraceWithTextArea = this._fmtStackTrace(statusInfo.errorInfo.stackTrace);
                                statusInfo.errorInfo.__stackTrace = sStackTraceWithTextArea;
                                sMessage += dString.substitute("\r\n\r\nException type: ${info.type}\r\n\r\nSource: ${info.source}${info.__stackTrace}\r\n\r\nTarget site: ${info.targetSite}", { info: statusInfo.errorInfo });
                            }
                        }
                        mail.subject = dString.substitute("Infor Exception Details (Infor Error Id: ${0})", [statusInfo.errorInfo.slxErrorId]);
                    }
                    var slxErrorId = statusInfo.errorInfo.slxErrorId;
                    mail.subject = encodeURIComponent(mail.subject);
                    if (sPlainTextStackTrace !== "") {
                        sPlainTextStackTrace = dString.substitute("\r\n\r\nStack trace:\r\n${0}", [sPlainTextStackTrace]);
                    }
                    mail.toAddress = "";
                    var officeProfile = this.getOfficeProfile();
                    if (officeProfile.UseEmailLink) {
                        mail.toAddress = officeProfile.EmailAddress;
                        mail.message = this.getShortMailContent(slxErrorId);
                    }
                    else {
                        mail.message = encodeURIComponent(Sage.Utility.htmlDecode(sMessage
                           .replace(sStackTraceWithTextArea, sPlainTextStackTrace)
                           .replace(sSlxErrorIdMsgWithLink, sPlainSlxErrorIdMsg)));
                    }                   
                    mail.linkCaption = "Mail details of this exception to your administrator";
                    sMessage += dString.substitute("\r\n\r\n<a href=\"mailto:${info.toAddress}?subject=${info.subject}&amp;body=${info.message}\">${info.linkCaption}</a>", { info: mail });
                }
                if (sMessage === "") {
                    sMessage = "There was an unknown error.";
                }
                sMessage = sMessage.replace(/(\r\n)/g, "<br />");
                Dialogs.showError(sMessage);
            },
            getOfficeProfile: function () {
                var officeProfile = {};
                var service = Sage.Utility.getSDataService('dynamic');
                var request = new Sage.SData.Client.SDataSingleResourceRequest(service);
                request.setResourceKind('officeProfiles');
                request.read({
                    async: false,
                    success: function (result) {
                        officeProfile = result;
                    },
                    failure: function (err) {
                        Sage.UI.Dialogs.showError(err);
                    }
                   
                });
                return officeProfile;
            },
            getShortMailContent: function (slxErrorId)
            {
                var sMessage = '';
                var newLine = "\r\n";
                var dblNewLine = "\r\n\r\n";
                var protocal = window.location.protocol;
                var hostname = window.location.hostname.replace('localhost', '127.0.0.1');
                var port = '';
                if(window.location.port) {
                    port = ":" + window.location.port;
                }
                var pathArray = window.location.pathname.split('/');
                var portalName = '/';
                if (pathArray[1] !== 'SLXErrorLookupService.asmx') {
                    portalName = portalName + pathArray[1];
                }
                var user='';
                var clientContextSvc = Sage.Services.getService('ClientContextService');
                if (clientContextSvc) {
                    if (clientContextSvc.containsKey('userID')) {
                        var userId = clientContextSvc.getValue('userID');
                        user = Sage.Utility.getUserName(userId);
                    }
                }
                var time = new Date().toISOString().split('.')[0];
                sMessage = dString.substitute(newLine + resources.EmailContentL1);
                sMessage += dString.substitute(dblNewLine + resources.EmailContentL2, [user, time]);
                sMessage += dString.substitute(dblNewLine + resources.EmailContentL3);
                var eventViewerLink = dString.substitute(dblNewLine + "${0}//${1}${2}${3}/SLXErrorLookupService.asmx/GetEventLogError?slxErrorId=${4}",
                    [protocal, hostname, port, portalName, slxErrorId]);
                sMessage += eventViewerLink;
                return encodeURIComponent(sMessage);
            }
        });

        Sage.Utility.ErrorHandler.init();

        return Sage.Utility.ErrorHandler;
    }
);

},
'dojox/validate/regexp':function(){
define(["dojo/_base/lang", "dojo/regexp", "dojox/main"], 
  function(lang, regexp, dojox){

var dxregexp = lang.getObject("validate.regexp", true, dojox);
dxregexp = dojox.validate.regexp = {
	
	ipAddress: function(flags){
		// summary:
		//		Builds a RE that matches an IP Address
		// description:
		//		Supports 5 formats for IPv4: dotted decimal, dotted hex, dotted octal, decimal and hexadecimal.
		//		Supports 2 formats for Ipv6.
		// flags: Object?
		//		All flags are boolean with default = true.
		//
		//		- flags.allowDottedDecimal  Example, 207.142.131.235.  No zero padding.
		//		- flags.allowDottedHex  Example, 0x18.0x11.0x9b.0x28.  Case insensitive.  Zero padding allowed.
		//		- flags.allowDottedOctal  Example, 0030.0021.0233.0050.  Zero padding allowed.
		//		- flags.allowDecimal  Example, 3482223595.  A decimal number between 0-4294967295.
		//		- flags.allowHex  Example, 0xCF8E83EB.  Hexadecimal number between 0x0-0xFFFFFFFF.
		//		  Case insensitive.  Zero padding allowed.
		//		- flags.allowIPv6   IPv6 address written as eight groups of four hexadecimal digits.
		
		//	FIXME: ipv6 can be written multiple ways IIRC
		//		- flags.allowHybrid   IPv6 address written as six groups of four hexadecimal digits
		//		-   followed by the usual 4 dotted decimal digit notation of IPv4. x:x:x:x:x:x:d.d.d.d

		// assign default values to missing parameters
		flags = (typeof flags == "object") ? flags : {};
		if(typeof flags.allowDottedDecimal != "boolean"){ flags.allowDottedDecimal = true; }
		if(typeof flags.allowDottedHex != "boolean"){ flags.allowDottedHex = true; }
		if(typeof flags.allowDottedOctal != "boolean"){ flags.allowDottedOctal = true; }
		if(typeof flags.allowDecimal != "boolean"){ flags.allowDecimal = true; }
		if(typeof flags.allowHex != "boolean"){ flags.allowHex = true; }
		if(typeof flags.allowIPv6 != "boolean"){ flags.allowIPv6 = true; }
		if(typeof flags.allowHybrid != "boolean"){ flags.allowHybrid = true; }

		// decimal-dotted IP address RE.
		var dottedDecimalRE =
			// Each number is between 0-255.  Zero padding is not allowed.
			"((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";

		// dotted hex IP address RE.  Each number is between 0x0-0xff.  Zero padding is allowed, e.g. 0x00.
		var dottedHexRE = "(0[xX]0*[\\da-fA-F]?[\\da-fA-F]\\.){3}0[xX]0*[\\da-fA-F]?[\\da-fA-F]";

		// dotted octal IP address RE.  Each number is between 0000-0377.
		// Zero padding is allowed, but each number must have at least 4 characters.
		var dottedOctalRE = "(0+[0-3][0-7][0-7]\\.){3}0+[0-3][0-7][0-7]";

		// decimal IP address RE.  A decimal number between 0-4294967295.
		var decimalRE =  "(0|[1-9]\\d{0,8}|[1-3]\\d{9}|4[01]\\d{8}|42[0-8]\\d{7}|429[0-3]\\d{6}|" +
			"4294[0-8]\\d{5}|42949[0-5]\\d{4}|429496[0-6]\\d{3}|4294967[01]\\d{2}|42949672[0-8]\\d|429496729[0-5])";

		// hexadecimal IP address RE.
		// A hexadecimal number between 0x0-0xFFFFFFFF. Case insensitive.  Zero padding is allowed.
		var hexRE = "0[xX]0*[\\da-fA-F]{1,8}";

		// IPv6 address RE.
		// The format is written as eight groups of four hexadecimal digits, x:x:x:x:x:x:x:x,
		// where x is between 0000-ffff. Zero padding is optional. Case insensitive.
		var ipv6RE = "([\\da-fA-F]{1,4}\\:){7}[\\da-fA-F]{1,4}";

		// IPv6/IPv4 Hybrid address RE.
		// The format is written as six groups of four hexadecimal digits,
		// followed by the 4 dotted decimal IPv4 format. x:x:x:x:x:x:d.d.d.d
		var hybridRE = "([\\da-fA-F]{1,4}\\:){6}" +
			"((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";

		// Build IP Address RE
		var a = [];
		if(flags.allowDottedDecimal){ a.push(dottedDecimalRE); }
		if(flags.allowDottedHex){ a.push(dottedHexRE); }
		if(flags.allowDottedOctal){ a.push(dottedOctalRE); }
		if(flags.allowDecimal){ a.push(decimalRE); }
		if(flags.allowHex){ a.push(hexRE); }
		if(flags.allowIPv6){ a.push(ipv6RE); }
		if(flags.allowHybrid){ a.push(hybridRE); }

		var ipAddressRE = "";
		if(a.length > 0){
			ipAddressRE = "(" + a.join("|") + ")";
		}
		return ipAddressRE; // String
	},

	host: function(flags){
		// summary:
		//		Builds a RE that matches a host
		// description:
		//		A host is a named host (A-z0-9_- but not starting with -), a domain name or an IP address, possibly followed by a port number.
		// flags: Object?
		//		- flags.allowNamed Allow a named host for local networks. Default is false.
		//		- flags.allowIP  Allow an IP address for hostname.  Default is true.
		//		- flags.allowLocal  Allow the host to be "localhost".  Default is false.
		//		- flags.allowPort  Allow a port number to be present.  Default is true.
		//		- flags in regexp.ipAddress can be applied.

		// assign default values to missing parameters
		flags = (typeof flags == "object") ? flags : {};

		if(typeof flags.allowIP != "boolean"){ flags.allowIP = true; }
		if(typeof flags.allowLocal != "boolean"){ flags.allowLocal = false; }
		if(typeof flags.allowPort != "boolean"){ flags.allowPort = true; }
		if(typeof flags.allowNamed != "boolean"){ flags.allowNamed = false; }

		//TODO: support unicode hostnames?
		// Domain name labels can not end with a dash.
		var domainLabelRE = "(?:[\\da-zA-Z](?:[-\\da-zA-Z]{0,61}[\\da-zA-Z])?)";
		var domainNameRE = "(?:[a-zA-Z](?:[-\\da-zA-Z]{0,6}[\\da-zA-Z])?)"; // restricted version to allow backwards compatibility with allowLocal, allowIP

		// port number RE
		var portRE = flags.allowPort ? "(\\:\\d+)?" : "";

		// build host RE
		var hostNameRE = "((?:" + domainLabelRE + "\\.)+" + domainNameRE + "\\.?)";
		if(flags.allowIP){ hostNameRE += "|" +  dxregexp.ipAddress(flags); }
		if(flags.allowLocal){ hostNameRE += "|localhost"; }
		if(flags.allowNamed){ hostNameRE += "|^[^-][a-zA-Z0-9_-]*"; }
		return "(" + hostNameRE + ")" + portRE; // String

	},

	url: function(flags){
		// summary:
		//		Builds a regular expression that matches a URL
		// flags: Object?
		//		- flags.scheme  Can be true, false, or [true, false].
		//		-   This means: required, not allowed, or match either one.
		//		- flags in regexp.host can be applied.
		//		- flags in regexp.ipAddress can be applied.

		// assign default values to missing parameters
		flags = (typeof flags == "object") ? flags : {};
		if(!("scheme" in flags)){ flags.scheme = [true, false]; }

		// Scheme RE
		var protocolRE = regexp.buildGroupRE(flags.scheme,
			function(q){ if(q){ return "(https?|ftps?)\\://"; } return ""; }
		);

		// Path and query and anchor RE
		var pathRE = "(/(?:[^?#\\s/]+/)*(?:[^?#\\s/]+(?:\\?[^?#\\s/]*)?(?:#[A-Za-z][\\w.:-]*)?)?)?";

		return protocolRE + dxregexp.host(flags) + pathRE;
	},

	emailAddress: function(flags){
		// summary:
		//		Builds a regular expression that matches an email address
		// flags: Object?
		//		- flags.allowCruft  Allow address like `<mailto:foo@yahoo.com>`.  Default is false.
		//		- flags in regexp.host can be applied.
		//		- flags in regexp.ipAddress can be applied.

		// assign default values to missing parameters
		flags = (typeof flags == "object") ? flags : {};
		if (typeof flags.allowCruft != "boolean") { flags.allowCruft = false; }
		flags.allowPort = false; // invalid in email addresses

		// user name RE per rfc5322
		var usernameRE = "([!#-'*+\\-\\/-9=?A-Z^-~]+[.])*[!#-'*+\\-\\/-9=?A-Z^-~]+";

		// build emailAddress RE
		var emailAddressRE = usernameRE + "@" + dxregexp.host(flags);

		// Allow email addresses with cruft
		if ( flags.allowCruft ) {
			emailAddressRE = "<?(mailto\\:)?" + emailAddressRE + ">?";
		}

		return emailAddressRE; // String
	},

	emailAddressList: function(flags){
		// summary:
		//		Builds a regular expression that matches a list of email addresses.
		// flags: Object?
		//		- flags.listSeparator  The character used to separate email addresses.  Default is ";", ",", "\n" or " ".
		//		- flags in regexp.emailAddress can be applied.
		//		- flags in regexp.host can be applied.
		//		- flags in regexp.ipAddress can be applied.

		// assign default values to missing parameters
		flags = (typeof flags == "object") ? flags : {};
		if(typeof flags.listSeparator != "string"){ flags.listSeparator = "\\s;,"; }

		// build a RE for an Email Address List
		var emailAddressRE = dxregexp.emailAddress(flags);
		var emailAddressListRE = "(" + emailAddressRE + "\\s*[" + flags.listSeparator + "]\\s*)*" +
			emailAddressRE + "\\s*[" + flags.listSeparator + "]?\\s*";

		return emailAddressListRE; // String
	},
	
	numberFormat: function(flags){
		// summary:
		//		Builds a regular expression to match any sort of number based format
		// description:
		//		Use this method for phone numbers, social security numbers, zip-codes, etc.
		//		The RE can match one format or one of multiple formats.
		//
		//		Format:
		//
		//		- #        Stands for a digit, 0-9.
		//		- ?        Stands for an optional digit, 0-9 or nothing.
		//		- All other characters must appear literally in the expression.
		//
		// example:
		//		- "(###) ###-####"		-    ->   (510) 542-9742
		//		- "(###) ###-#### x#???" ->   (510) 542-9742 x153
		//		- "###-##-####"		- 		-   ->   506-82-1089		-    i.e. social security number
		//		- "#####-####"		- 		-    ->   98225-1649		- 		- i.e. zip code
		//
		// flags:  Object?
		//		- flags.format  A string or an Array of strings for multiple formats.

		// assign default values to missing parameters
		flags = (typeof flags == "object") ? flags : {};
		if(typeof flags.format == "undefined"){ flags.format = "###-###-####"; }

		// Converts a number format to RE.
		var digitRE = function(format){
			// escape all special characters, except '?'
			return regexp.escapeString(format, "?")
				// Now replace '?' with Regular Expression
				.replace(/\?/g, "\\d?")
				// replace # with Regular Expression
				.replace(/#/g, "\\d")
			;
		};

		// build RE for multiple number formats
		return regexp.buildGroupRE(flags.format, digitRE); //String
	},
	
	ca: {

		postalCode: function(){
			// summary:
			//		String regular Express to match Canadain Postal Codes
			return "([A-Z][0-9][A-Z] [0-9][A-Z][0-9])";
		},

		province: function(){
			// summary:
			//		a regular expression to match Canadian Province Abbreviations
			return "(AB|BC|MB|NB|NL|NS|NT|NU|ON|PE|QC|SK|YT)";
		}

	},
	
	us:{
		state: function(flags){
			// summary:
			//		A regular expression to match US state and territory abbreviations
			// flags: Object?
			//		- flags.allowTerritories  Allow Guam, Puerto Rico, etc.  Default is true.
			//		- flags.allowMilitary  Allow military 'states', e.g. Armed Forces Europe (AE).  Default is true.

			// assign default values to missing parameters
			flags = (typeof flags == "object") ? flags : {};
			if(typeof flags.allowTerritories != "boolean"){ flags.allowTerritories = true; }
			if(typeof flags.allowMilitary != "boolean"){ flags.allowMilitary = true; }

			// state RE
			var statesRE =
				"AL|AK|AZ|AR|CA|CO|CT|DE|DC|FL|GA|HI|ID|IL|IN|IA|KS|KY|LA|ME|MD|MA|MI|MN|MS|MO|MT|" +
				"NE|NV|NH|NJ|NM|NY|NC|ND|OH|OK|OR|PA|RI|SC|SD|TN|TX|UT|VT|VA|WA|WV|WI|WY";

			// territories RE
			var territoriesRE = "AS|FM|GU|MH|MP|PW|PR|VI";

			// military states RE
			var militaryRE = "AA|AE|AP";

			// Build states and territories RE
			if(flags.allowTerritories){ statesRE += "|" + territoriesRE; }
			if(flags.allowMilitary){ statesRE += "|" + militaryRE; }

			return "(" + statesRE + ")"; // String
		}

	}
	
};

return dxregexp;

});

},
'dojox/main':function(){
define(["dojo/_base/kernel"], function(dojo) {
	// module:
	//		dojox/main

	/*=====
	return {
		// summary:
		//		The dojox package main module; dojox package is somewhat unusual in that the main module currently just provides an empty object.
		//		Apps should require modules from the dojox packages directly, rather than loading this module.
	};
	=====*/

	return dojo.dojox;
});
},
'Sage/Data/QBTreeStoreModel':function(){
/*globals Sage, define */
define([
        'dijit/tree/ForestStoreModel',
        'Sage/Data/SDataServiceRegistry',
        'dojo/string',
        'dojo/_base/array',
        'dojo/_base/declare',
        'dojo/_base/lang'
],
function (
    ForestStoreModel,
    SDataServiceRegistry,
    dString,
    array,
    declare,
    lang
    ) {
    return declare("Sage.Data.QBTreeStoreModel", ForestStoreModel, {
        insertedChildren: null,
        constructor: function() {
            this.insertedChildren = [];
        },
        convertDescriptionToFilter: function(parentNode) {
            // Just ensure the descriptor exists, otherwise this is the root node
            if(parentNode.$descriptor) {
                var dataPath = parentNode.$descriptor;
                dataPath = dataPath.replace(this.rootId + ':', '');
                return dataPath;
            }
            return parentNode.id;
        },
        getChildren: function (parentItem, complete_cb, error_cb) {
            this.store.fetch({
                queryArgs: { "_pathFilter": this.convertDescriptionToFilter(parentItem) },
                resourcePredicate: parentItem.root ? undefined : '',
                onComplete: lang.hitch(this, function (data, obj) {
                    var service = SDataServiceRegistry.getSDataService('metadata', false, true, false),
                        request,
                        table,
                        i,
                        temp,
                        fields = [],
                        transforms,
                        makeFn;

                    table = parentItem.id || parentItem.toTable;

                    array.forEach(this.insertedChildren, lang.hitch(this, function (child) {
                        if (child.parentItem === parentItem) {
                            data.push(child);
                        }
                    }));

                    // Array of transform functions to run on the data
                    transforms = [
                        // Invert if needed
                        function (item) {
                            if (item.toTable === table) {
                                item.toTable = item.fromTable;
                                temp = item.toField;
                                item.toField = item.fromField;
                                item.fromTable = table;
                                item.fromField = temp;
                            }
                        },
                        // Add a label property
                        function(item) {
                            var joinTypeChar = item.joinType,
                                joinTypeMap = {
                                    /* <join char> : <label> */
                                    'Left': '[left]',
                                    '>': '[left]',
                                    'Inner': '[inner]',
                                    '=': '[inner]',
                                    'Right': '[right]',
                                    '<': '[right]'
                                },
                                joinType = joinTypeMap[joinTypeChar];

                            if (item.toTable) {
                                item.label = dString.substitute("${2} (${1} -> ${3})${4}", [item.fromTable, item.fromField, item.toTableDisplayName, item.toField, joinType]);
                            }
                        },
                        // Add parent item
                        function (item) {
                            item.parentItem = parentItem;
                        },
                        // Add child property
                        function (item) {
                            item.children = [];
                        },
                        // Add dataPathSegment property
                        function (item) {
                            var joinTypeChar = item.joinType,
                                joinTypeMap = {
                                    'Left': '>',
                                    'Inner': '=',
                                    'Right': '<'
                                },
                                joinType = joinTypeMap[joinTypeChar] || item.joinType;
                            item.dataPathSegment = dString.substitute("${0}${1}${2}.${3}", [item.fromField, joinType, item.toField, item.toTable]);
                        },
                        // Add displayPathSegment (ToTable)
                        function (item) {
                            item.displayPathSegment = dString.substitute("${0}", [item.toTable]);
                        },
                        // Add full dataPath
                        function (item) {
                            var results;

                            function GetDataPath(path, _item) {
                                if (_item.root) {
                                    if (path && path.length > 0) {
                                        if (path.startsWith("!")) {
                                            path = path.substring(1, path.length);
                                        }
                                    }
                                    return _item.id + ":" + path;
                                }

                                return GetDataPath(dString.substitute("!${0}", [_item.dataPathSegment]) + path, _item.parentItem);
                            }

                            results = GetDataPath("!", item);
                            item.dataPath = results;
                            item['$descriptor'] = item['$descriptor'] || results;
                        },
                        // Add full display path
                        function (item) {
                            var results;
                            function GetDisplayPath(path, _item) {
                                if (_item.root) {
                                    return _item.id + path;
                                }
                                
                                return GetDisplayPath(dString.substitute(".${0}${1}", [_item.displayPathSegment, path]), _item.parentItem);
                            }

                            results = GetDisplayPath("", item);
                            item.displayPath = results;
                        }
                    ];

                    // Clojure for our transform loop
                    makeFn = function (item) {
                        return function(func) {
                            func(item);
                        };
                    };
                    
                    for (i = 0; i < data.length; i++) {
                        array.forEach(transforms, lang.hitch(this, makeFn(data[i])));
                    }
                    // Filter out data that includes a relationship that's already in the existing
                    // branch (ACCOUNT -> CONTACT -> ACCOUNT, ACCOUNT -> ADDRESS -> ACCOUNT, etc.)
                    data = array.filter(data, lang.hitch(this, function(item) {
                        var parentItem = item.parentItem;
                        while(!parentItem.root) {
                            if(item.toTable === parentItem.toTable) {
                                return false;
                            }
                            parentItem = parentItem.parentItem;
                        }
                        // check against the root item's id field instead
                        if(item.toTable === parentItem.id) {
                            return false;
                        }
                        return true;
                    }));

                    data.sort(function(a, b) {
                        if(a.toTable < b.toTable) {
                            return -1;
                        }

                        if(a.toTable > b.toTable) {
                            return 1;
                        }

                        return 0;
                    });
                   
                    parentItem.children = data;
                    complete_cb(data, obj);
                }),
                onError: error_cb
            });
        },
        getIdentity: function (item) {
            return item.$descriptor;
        },
        mayHaveChildren: function (item) {
            return item.root || true;
        },
        newItem: function (args, parentNode) {
            var child = {
                "$descriptor": args.fromtable,
                "$etag": "",
                "$httpStatus": 200,
                "fromTable": args.fromtable,
                "fromField": args.fromfield,
                "toTable": args.totable,
                "toTableDisplayName": args.fromtable,
                "toField": args.tofield,
                "cascadeType": args.cascadetype,
                "joinType": args.jointype,
                "parentItem": parentNode.item,
                "children": []
            };
            this.insertedChildren.push(child);
            this.addItemToStore(child, parentNode.item);
        },
        addItemToStore: function (childItem, newParentItem) {
            var store = this.store,
                parentAttr = this.childrenAttrs[0],// name of "children" attr in parent item
                children = store.getValue(newParentItem, parentAttr),
                updated;

            // modify target item's children attribute to include this item
            if(newParentItem){
                if (children) {
                    updated = children.slice(0);
                    updated.push(childItem);
                    store.setValue(newParentItem, parentAttr, updated);
                }
            }
        },
        // Overrides ForestStoreModel to not _requeryTop() since this is only desired when the root
        // is modifiable (which for QueryBuilder it is not). Instead use the TreeStoreModel funciton call
        onSetItem: function (item, attribute, /* Object|Array */ oldValue, /* Object|Array */ newValue) {
            // Just use TreeStoreModel onSetItem function call instead
            if (array.indexOf(this.childrenAttrs, attribute) != -1) {
                // item's children list changed
                this.getChildren(item, lang.hitch(this, function (children) {
                    // See comments in onNewItem() about calling getChildren()
                    this.onChildrenChange(item, children);
                }));
            } else {
                // item's label/icon/etc. changed.
                this.onChange(item);
            }
        }
    });
});
},
'dijit/tree/ForestStoreModel':function(){
define([
	"dojo/_base/array", // array.indexOf array.some
	"dojo/_base/declare", // declare
	"dojo/_base/kernel", // global
	"dojo/_base/lang", // lang.hitch
	"./TreeStoreModel"
], function(array, declare, kernel, lang, TreeStoreModel){

// module:
//		dijit/tree/ForestStoreModel

return declare("dijit.tree.ForestStoreModel", TreeStoreModel, {
	// summary:
	//		Interface between a dijit.Tree and a dojo.data store that doesn't have a root item,
	//		a.k.a. a store that has multiple "top level" items.
	//
	// description:
	//		Use this class to wrap a dojo.data store, making all the items matching the specified query
	//		appear as children of a fabricated "root item".  If no query is specified then all the
	//		items returned by fetch() on the underlying store become children of the root item.
	//		This class allows dijit.Tree to assume a single root item, even if the store doesn't have one.
	//
	//		When using this class the developer must override a number of methods according to their app and
	//		data, including:
	//
	//		- onNewRootItem
	//		- onAddToRoot
	//		- onLeaveRoot
	//		- onNewItem
	//		- onSetItem

	// Parameters to constructor

	// rootId: String
	//		ID of fabricated root item
	rootId: "$root$",

	// rootLabel: String
	//		Label of fabricated root item
	rootLabel: "ROOT",

	// query: String
	//		Specifies the set of children of the root item.
	// example:
	//	|	{type:'continent'}
	query: null,

	// End of parameters to constructor

	constructor: function(params){
		// summary:
		//		Sets up variables, etc.
		// tags:
		//		private

		// Make dummy root item
		this.root = {
			store: this,
			root: true,
			id: params.rootId,
			label: params.rootLabel,
			children: params.rootChildren	// optional param
		};
	},

	// =======================================================================
	// Methods for traversing hierarchy

	mayHaveChildren: function(/*dojo/data/Item*/ item){
		// summary:
		//		Tells if an item has or may have children.  Implementing logic here
		//		avoids showing +/- expando icon for nodes that we know don't have children.
		//		(For efficiency reasons we may not want to check if an element actually
		//		has children until user clicks the expando node)
		// tags:
		//		extension
		return item === this.root || this.inherited(arguments);
	},

	getChildren: function(/*dojo/data/Item*/ parentItem, /*function(items)*/ callback, /*function*/ onError){
		// summary:
		//		Calls onComplete() with array of child items of given parent item, all loaded.
		if(parentItem === this.root){
			if(this.root.children){
				// already loaded, just return
				callback(this.root.children);
			}else{
				this.store.fetch({
					query: this.query,
					onComplete: lang.hitch(this, function(items){
						this.root.children = items;
						callback(items);
					}),
					onError: onError
				});
			}
		}else{
			this.inherited(arguments);
		}
	},

	// =======================================================================
	// Inspecting items

	isItem: function(/* anything */ something){
		return (something === this.root) ? true : this.inherited(arguments);
	},

	fetchItemByIdentity: function(/* object */ keywordArgs){
		if(keywordArgs.identity == this.root.id){
			var scope = keywordArgs.scope || kernel.global;
			if(keywordArgs.onItem){
				keywordArgs.onItem.call(scope, this.root);
			}
		}else{
			this.inherited(arguments);
		}
	},

	getIdentity: function(/* item */ item){
		return (item === this.root) ? this.root.id : this.inherited(arguments);
	},

	getLabel: function(/* item */ item){
		return	(item === this.root) ? this.root.label : this.inherited(arguments);
	},

	// =======================================================================
	// Write interface

	newItem: function(/* dijit/tree/dndSource.__Item */ args, /*Item*/ parent, /*int?*/ insertIndex){
		// summary:
		//		Creates a new item.   See dojo/data/api/Write for details on args.
		//		Used in drag & drop when item from external source dropped onto tree.
		if(parent === this.root){
			this.onNewRootItem(args);
			return this.store.newItem(args);
		}else{
			return this.inherited(arguments);
		}
	},

	onNewRootItem: function(/* dijit/tree/dndSource.__Item */ /*===== args =====*/){
		// summary:
		//		User can override this method to modify a new element that's being
		//		added to the root of the tree, for example to add a flag like root=true
	},

	pasteItem: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Boolean*/ bCopy, /*int?*/ insertIndex){
		// summary:
		//		Move or copy an item from one parent item to another.
		//		Used in drag & drop
		if(oldParentItem === this.root){
			if(!bCopy){
				// It's onLeaveRoot()'s responsibility to modify the item so it no longer matches
				// this.query... thus triggering an onChildrenChange() event to notify the Tree
				// that this element is no longer a child of the root node
				this.onLeaveRoot(childItem);
			}
		}
		this.inherited(arguments, [childItem,
			oldParentItem === this.root ? null : oldParentItem,
			newParentItem === this.root ? null : newParentItem,
			bCopy,
			insertIndex
		]);
		if(newParentItem === this.root){
			// It's onAddToRoot()'s responsibility to modify the item so it matches
			// this.query... thus triggering an onChildrenChange() event to notify the Tree
			// that this element is now a child of the root node
			this.onAddToRoot(childItem);
		}
	},

	// =======================================================================
	// Handling for top level children

	onAddToRoot: function(/* item */ item){
		// summary:
		//		Called when item added to root of tree; user must override this method
		//		to modify the item so that it matches the query for top level items
		// example:
		//	|	store.setValue(item, "root", true);
		// tags:
		//		extension
		console.log(this, ": item ", item, " added to root");
	},

	onLeaveRoot: function(/* item */ item){
		// summary:
		//		Called when item removed from root of tree; user must override this method
		//		to modify the item so it doesn't match the query for top level items
		// example:
		//	|	store.unsetAttribute(item, "root");
		// tags:
		//		extension
		console.log(this, ": item ", item, " removed from root");
	},

	// =======================================================================
	// Events from data store

	_requeryTop: function(){
		// reruns the query for the children of the root node,
		// sending out an onSet notification if those children have changed
		var oldChildren = this.root.children || [];
		this.store.fetch({
			query: this.query,
			onComplete: lang.hitch(this, function(newChildren){
				this.root.children = newChildren;

				// If the list of children or the order of children has changed...
				if(oldChildren.length != newChildren.length ||
					array.some(oldChildren, function(item, idx){ return newChildren[idx] != item;})){
					this.onChildrenChange(this.root, newChildren);
				}
			})
		});
	},

	onNewItem: function(/* dojo/data/api/Item */ item, /* Object */ parentInfo){
		// summary:
		//		Handler for when new items appear in the store.  Developers should override this
		//		method to be more efficient based on their app/data.
		// description:
		//		Note that the default implementation requeries the top level items every time
		//		a new item is created, since any new item could be a top level item (even in
		//		addition to being a child of another item, since items can have multiple parents).
		//
		//		If developers can detect which items are possible top level items (based on the item and the
		//		parentInfo parameters), they should override this method to only call _requeryTop() for top
		//		level items.  Often all top level items have parentInfo==null, but
		//		that will depend on which store you use and what your data is like.
		// tags:
		//		extension
		this._requeryTop();

		this.inherited(arguments);
	},

	onDeleteItem: function(/*Object*/ item){
		// summary:
		//		Handler for delete notifications from underlying store

		// check if this was a child of root, and if so send notification that root's children
		// have changed
		if(array.indexOf(this.root.children, item) != -1){
			this._requeryTop();
		}

		this.inherited(arguments);
	},

	onSetItem: function(/* item */ item,
					/* attribute-name-string */ attribute,
					/* Object|Array */ oldValue,
					/* Object|Array */ newValue){
		// summary:
		//		Updates the tree view according to changes to an item in the data store.
		//		Developers should override this method to be more efficient based on their app/data.
		// description:
		//		Handles updates to an item's children by calling onChildrenChange(), and
		//		other updates to an item by calling onChange().
		//
		//		Also, any change to any item re-executes the query for the tree's top-level items,
		//		since this modified item may have started/stopped matching the query for top level items.
		//
		//		If possible, developers should override this function to only call _requeryTop() when
		//		the change to the item has caused it to stop/start being a top level item in the tree.
		// tags:
		//		extension

		this._requeryTop();
		this.inherited(arguments);
	}

});

});

},
'dijit/tree/TreeStoreModel':function(){
define([
	"dojo/_base/array", // array.filter array.forEach array.indexOf array.some
	"dojo/aspect", // aspect.after
	"dojo/_base/declare", // declare
	"dojo/_base/lang" // lang.hitch
], function(array, aspect, declare, lang){

	// module:
	//		dijit/tree/TreeStoreModel

	return declare("dijit.tree.TreeStoreModel", null, {
		// summary:
		//		Implements dijit/Tree/model connecting to a dojo.data store with a single
		//		root item.  Any methods passed into the constructor will override
		//		the ones defined here.

		// store: dojo/data/api/Read
		//		Underlying store
		store: null,

		// childrenAttrs: String[]
		//		One or more attribute names (attributes in the dojo.data item) that specify that item's children
		childrenAttrs: ["children"],

		// newItemIdAttr: String
		//		Name of attribute in the Object passed to newItem() that specifies the id.
		//
		//		If newItemIdAttr is set then it's used when newItem() is called to see if an
		//		item with the same id already exists, and if so just links to the old item
		//		(so that the old item ends up with two parents).
		//
		//		Setting this to null or "" will make every drop create a new item.
		newItemIdAttr: "id",

		// labelAttr: String
		//		If specified, get label for tree node from this attribute, rather
		//		than by calling store.getLabel()
		labelAttr: "",

		// root: [readonly] dojo/data/Item
		//		Pointer to the root item (read only, not a parameter)
		root: null,

		// query: anything
		//		Specifies datastore query to return the root item for the tree.
		//		Must only return a single item.   Alternately can just pass in pointer
		//		to root item.
		// example:
		//	|	{id:'ROOT'}
		query: null,

		// deferItemLoadingUntilExpand: Boolean
		//		Setting this to true will cause the TreeStoreModel to defer calling loadItem on nodes
		//		until they are expanded. This allows for lazying loading where only one
		//		loadItem (and generally one network call, consequently) per expansion
		//		(rather than one for each child).
		//		This relies on partial loading of the children items; each children item of a
		//		fully loaded item should contain the label and info about having children.
		deferItemLoadingUntilExpand: false,

		constructor: function(/* Object */ args){
			// summary:
			//		Passed the arguments listed above (store, etc)
			// tags:
			//		private

			lang.mixin(this, args);

			this.connects = [];

			var store = this.store;
			if(!store.getFeatures()['dojo.data.api.Identity']){
				throw new Error("dijit.tree.TreeStoreModel: store must support dojo.data.Identity");
			}

			// if the store supports Notification, subscribe to the notification events
			if(store.getFeatures()['dojo.data.api.Notification']){
				this.connects = this.connects.concat([
					aspect.after(store, "onNew", lang.hitch(this, "onNewItem"), true),
					aspect.after(store, "onDelete", lang.hitch(this, "onDeleteItem"), true),
					aspect.after(store, "onSet", lang.hitch(this, "onSetItem"), true)
				]);
			}
		},

		destroy: function(){
			var h;
			while(h = this.connects.pop()){ h.remove(); }
			// TODO: should cancel any in-progress processing of getRoot(), getChildren()
		},

		// =======================================================================
		// Methods for traversing hierarchy

		getRoot: function(onItem, onError){
			// summary:
			//		Calls onItem with the root item for the tree, possibly a fabricated item.
			//		Calls onError on error.
			if(this.root){
				onItem(this.root);
			}else{
				this.store.fetch({
					query: this.query,
					onComplete: lang.hitch(this, function(items){
						if(items.length != 1){
							throw new Error("dijit.tree.TreeStoreModel: root query returned " + items.length +
								" items, but must return exactly one");
						}
						this.root = items[0];
						onItem(this.root);
					}),
					onError: onError
				});
			}
		},

		mayHaveChildren: function(/*dojo/data/Item*/ item){
			// summary:
			//		Tells if an item has or may have children.  Implementing logic here
			//		avoids showing +/- expando icon for nodes that we know don't have children.
			//		(For efficiency reasons we may not want to check if an element actually
			//		has children until user clicks the expando node)
			return array.some(this.childrenAttrs, function(attr){
				return this.store.hasAttribute(item, attr);
			}, this);
		},

		getChildren: function(/*dojo/data/Item*/ parentItem, /*function(items)*/ onComplete, /*function*/ onError){
			// summary:
			//		Calls onComplete() with array of child items of given parent item, all loaded.

			var store = this.store;
			if(!store.isItemLoaded(parentItem)){
				// The parent is not loaded yet, we must be in deferItemLoadingUntilExpand
				// mode, so we will load it and just return the children (without loading each
				// child item)
				var getChildren = lang.hitch(this, arguments.callee);
				store.loadItem({
					item: parentItem,
					onItem: function(parentItem){
						getChildren(parentItem, onComplete, onError);
					},
					onError: onError
				});
				return;
			}
			// get children of specified item
			var childItems = [];
			for(var i=0; i<this.childrenAttrs.length; i++){
				var vals = store.getValues(parentItem, this.childrenAttrs[i]);
				childItems = childItems.concat(vals);
			}

			// count how many items need to be loaded
			var _waitCount = 0;
			if(!this.deferItemLoadingUntilExpand){
				array.forEach(childItems, function(item){ if(!store.isItemLoaded(item)){ _waitCount++; } });
			}

			if(_waitCount == 0){
				// all items are already loaded (or we aren't loading them).  proceed...
				onComplete(childItems);
			}else{
				// still waiting for some or all of the items to load
				array.forEach(childItems, function(item, idx){
					if(!store.isItemLoaded(item)){
						store.loadItem({
							item: item,
							onItem: function(item){
								childItems[idx] = item;
								if(--_waitCount == 0){
									// all nodes have been loaded, send them to the tree
									onComplete(childItems);
								}
							},
							onError: onError
						});
					}
				});
			}
		},

		// =======================================================================
		// Inspecting items

		isItem: function(/* anything */ something){
			return this.store.isItem(something);	// Boolean
		},

		fetchItemByIdentity: function(/* object */ keywordArgs){
			// summary:
			//		Given the identity of an item, this method returns the item that has
			//		that identity through the onItem callback.  Conforming implementations
			//		should return null if there is no item with the given identity.
			//		Implementations of fetchItemByIdentity() may sometimes return an item
			//		from a local cache and may sometimes fetch an item from a remote server.
			// tags:
			//		extension
			this.store.fetchItemByIdentity(keywordArgs);
		},

		getIdentity: function(/* item */ item){
			return this.store.getIdentity(item);	// Object
		},

		getLabel: function(/*dojo/data/Item*/ item){
			// summary:
			//		Get the label for an item
			if(this.labelAttr){
				return this.store.getValue(item,this.labelAttr);	// String
			}else{
				return this.store.getLabel(item);	// String
			}
		},

		// =======================================================================
		// Write interface

		newItem: function(/* dijit/tree/dndSource.__Item */ args, /*dojo/data/api/Item*/ parent, /*int?*/ insertIndex){
			// summary:
			//		Creates a new item.   See `dojo/data/api/Write` for details on args.
			//		Used in drag & drop when item from external source dropped onto tree.
			// description:
			//		Developers will need to override this method if new items get added
			//		to parents with multiple children attributes, in order to define which
			//		children attribute points to the new item.

			var pInfo = {parent: parent, attribute: this.childrenAttrs[0]}, LnewItem;

			if(this.newItemIdAttr && args[this.newItemIdAttr]){
				// Maybe there's already a corresponding item in the store; if so, reuse it.
				this.fetchItemByIdentity({identity: args[this.newItemIdAttr], scope: this, onItem: function(item){
					if(item){
						// There's already a matching item in store, use it
						this.pasteItem(item, null, parent, true, insertIndex);
					}else{
						// Create new item in the tree, based on the drag source.
						LnewItem=this.store.newItem(args, pInfo);
						if(LnewItem && (insertIndex!=undefined)){
							// Move new item to desired position
							this.pasteItem(LnewItem, parent, parent, false, insertIndex);
						}
					}
				}});
			}else{
				// [as far as we know] there is no id so we must assume this is a new item
				LnewItem=this.store.newItem(args, pInfo);
				if(LnewItem && (insertIndex!=undefined)){
					// Move new item to desired position
					this.pasteItem(LnewItem, parent, parent, false, insertIndex);
				}
			}
		},

		pasteItem: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Boolean*/ bCopy, /*int?*/ insertIndex){
			// summary:
			//		Move or copy an item from one parent item to another.
			//		Used in drag & drop
			var store = this.store,
				parentAttr = this.childrenAttrs[0];	// name of "children" attr in parent item

			// remove child from source item, and record the attribute that child occurred in
			if(oldParentItem){
				array.forEach(this.childrenAttrs, function(attr){
					if(store.containsValue(oldParentItem, attr, childItem)){
						if(!bCopy){
							var values = array.filter(store.getValues(oldParentItem, attr), function(x){
								return x != childItem;
							});
							store.setValues(oldParentItem, attr, values);
						}
						parentAttr = attr;
					}
				});
			}

			// modify target item's children attribute to include this item
			if(newParentItem){
				if(typeof insertIndex == "number"){
					// call slice() to avoid modifying the original array, confusing the data store
					var childItems = store.getValues(newParentItem, parentAttr).slice();
					childItems.splice(insertIndex, 0, childItem);
					store.setValues(newParentItem, parentAttr, childItems);
				}else{
					store.setValues(newParentItem, parentAttr,
						store.getValues(newParentItem, parentAttr).concat(childItem));
				}
			}
		},

		// =======================================================================
		// Callbacks

		onChange: function(/*dojo/data/Item*/ /*===== item =====*/){
			// summary:
			//		Callback whenever an item has changed, so that Tree
			//		can update the label, icon, etc.   Note that changes
			//		to an item's children or parent(s) will trigger an
			//		onChildrenChange() so you can ignore those changes here.
			// tags:
			//		callback
		},

		onChildrenChange: function(/*===== parent, newChildrenList =====*/){
			// summary:
			//		Callback to do notifications about new, updated, or deleted items.
			// parent: dojo/data/Item
			// newChildrenList: dojo/data/Item[]
			// tags:
			//		callback
		},

		onDelete: function(/*dojo/data/Item*/ /*===== item =====*/){
			// summary:
			//		Callback when an item has been deleted.
			// description:
			//		Note that there will also be an onChildrenChange() callback for the parent
			//		of this item.
			// tags:
			//		callback
		},

		// =======================================================================
		// Events from data store

		onNewItem: function(/* dojo/data/Item */ item, /* Object */ parentInfo){
			// summary:
			//		Handler for when new items appear in the store, either from a drop operation
			//		or some other way.   Updates the tree view (if necessary).
			// description:
			//		If the new item is a child of an existing item,
			//		calls onChildrenChange() with the new list of children
			//		for that existing item.
			//
			// tags:
			//		extension

			// We only care about the new item if it has a parent that corresponds to a TreeNode
			// we are currently displaying
			if(!parentInfo){
				return;
			}

			// Call onChildrenChange() on parent (ie, existing) item with new list of children
			// In the common case, the new list of children is simply parentInfo.newValue or
			// [ parentInfo.newValue ], although if items in the store has multiple
			// child attributes (see `childrenAttr`), then it's a superset of parentInfo.newValue,
			// so call getChildren() to be sure to get right answer.
			this.getChildren(parentInfo.item, lang.hitch(this, function(children){
				this.onChildrenChange(parentInfo.item, children);
			}));
		},

		onDeleteItem: function(/*Object*/ item){
			// summary:
			//		Handler for delete notifications from underlying store
			this.onDelete(item);
		},

		onSetItem: function(item, attribute /*===== , oldValue, newValue =====*/){
			// summary:
			//		Updates the tree view according to changes in the data store.
			// description:
			//		Handles updates to an item's children by calling onChildrenChange(), and
			//		other updates to an item by calling onChange().
			//
			//		See `onNewItem` for more details on handling updates to an item's children.
			// item: Item
			// attribute: attribute-name-string
			// oldValue: Object|Array
			// newValue: Object|Array
			// tags:
			//		extension

			if(array.indexOf(this.childrenAttrs, attribute) != -1){
				// item's children list changed
				this.getChildren(item, lang.hitch(this, function(children){
					// See comments in onNewItem() about calling getChildren()
					this.onChildrenChange(item, children);
				}));
			}else{
				// item's label/icon/etc. changed.
				this.onChange(item);
			}
		}
	});
});

},
'Sage/Store/SData':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
// Taken from argos-sdk (https://github.com/Sage/argos-sdk/blob/topic-tablet-support/src/Store/SData.js)
define('Sage/Store/SData', [
    'dojo/_base/declare',
    'dojo/_base/lang',
    'dojo/_base/array',
    'dojo/_base/Deferred',
    'dojo/store/util/QueryResults',
    'dojo/string',
    'dojo/json',
    '../Utility'
], function (
    declare,
    lang,
    array,
    Deferred,
    QueryResults,
    string,
    json,
    utility
) {
    return declare('Sage.Store.SData', null, {
        doDateConversion: false,

        /* todo: is this the appropriate name for the expansion scope? */
        scope: null,
        where: null,
        select: null,
        include: null,
        orderBy: null,
        service: null,
        request: null,
        queryName: null,
        queryArgs: null,
        entityName: null,
        contractName: null,
        resourceKind: null,
        resourceProperty: null,
        resourcePredicate: null,
        applicationName: null,
        dataSet: null,
        executeQueryAs: null,
        executeGetAs: null,

        itemsProperty: '$resources',
        idProperty: '$key',
        labelProperty: '$descriptor',
        entityProperty: '$name',
        versionProperty: '$etag',
        dataCache: [],
        /**
         * @constructor
         */
        constructor: function constructor(props) {
            lang.mixin(this, props);
        },
        _createDeleteRequest: function _createDeleteRequest(object, options) {
            var request = utility.expand(this, options.request || this.request);

            var id = options.id || this.getIdentity(object);
            if (request) {
                request = request.clone();
            } else {
                id = id || utility.expand(this.scope || this, options.resourcePredicate || this.resourcePredicate);

                var contractName = utility.expand(this.scope || this, options.contractName || this.contractName);
                var resourceKind = utility.expand(this.scope || this, options.resourceKind || this.resourceKind);
                var resourceProperty = utility.expand(this.scope || this, options.resourceProperty || this.resourceProperty);
                var resourcePredicate;

                if (id) {
                    resourcePredicate = /\s+/.test(id) ? id : string.substitute("'${0}'", [id]);
                }

                if (resourceProperty) {
                    request = new Sage.SData.Client.SDataResourcePropertyRequest(this.service)
                      .setResourceProperty(resourceProperty)
                      .setResourceSelector(resourcePredicate);
                } else {
                    request = new Sage.SData.Client.SDataSingleResourceRequest(this.service)
                      .setResourceSelector(resourcePredicate);
                }

                if (contractName) {
                    request.setContractName(contractName);
                }

                if (resourceKind) {
                    request.setResourceKind(resourceKind);
                }
            }
            return request;
        },
        _createEntryRequest: function _createEntryRequest(identity, getOptions) {
            var request = utility.expand(this, getOptions.request || this.request);
            var id = identity;
            if (request) {
                request = request.clone();
            } else {
                id = id || utility.expand(this.scope || this, getOptions.resourcePredicate || this.resourcePredicate);

                var contractName = utility.expand(this.scope || this, getOptions.contractName || this.contractName);
                var resourceKind = utility.expand(this.scope || this, getOptions.resourceKind || this.resourceKind);
                var dataSet = utility.expand(this.scope || this, getOptions.dataSet || this.dataSet);
                var resourceProperty = utility.expand(this.scope || this, getOptions.resourceProperty || this.resourceProperty);
                var resourcePredicate;

                if (id) {
                    resourcePredicate = /\s+/.test(id) ? id : string.substitute("'${0}'", [id]);
                }

                if (resourceProperty) {
                    request = new Sage.SData.Client.SDataResourcePropertyRequest(this.service)
                      .setResourceProperty(resourceProperty)
                      .setResourceSelector(resourcePredicate);
                } else {
                    request = new Sage.SData.Client.SDataSingleResourceRequest(this.service)
                      .setResourceSelector(resourcePredicate);
                }

                if (contractName) {
                    request.setContractName(contractName);
                }

                if (resourceKind) {
                    request.setResourceKind(resourceKind);
                }

                if (dataSet) {
                    request.setDataSet(dataSet);
                }
            }

            var select = utility.expand(this.scope || this, getOptions.select || this.select);
            var include = utility.expand(this.scope || this, getOptions.include || this.include);

            if (select && select.length > 0) {
                request.setQueryArg('select', select.join(',').replace(/\./g, '/'));
            }

            if (include && include.length > 0) {
                request.setQueryArg('include', include.join(','));
            }

            return request;
        },
        _createFeedRequest: function _createFeedRequest(q, queryOptions) {
            var request = utility.expand(this, queryOptions.request || this.request);
            if (request) {
                request = request.clone();
            } else {
                var queryName = utility.expand(this.scope || this, queryOptions.queryName || this.queryName);
                var contractName = utility.expand(this.scope || this, queryOptions.contractName || this.contractName);
                var resourceKind = utility.expand(this.scope || this, queryOptions.resourceKind || this.resourceKind);
                var resourceProperty = utility.expand(this.scope || this, queryOptions.resourceProperty || this.resourceProperty);
                var resourcePredicate = utility.expand(this.scope || this, queryOptions.resourcePredicate || this.resourcePredicate);
                var applicationName = utility.expand(this.scope || this, queryOptions.applicationName || this.applicationName);
                var dataSet = utility.expand(this.scope || this, queryOptions.dataSet || this.dataSet);
                var queryArgs = utility.expand(this.scope || this, queryOptions.queryArgs || this.queryArgs);
                var operationSDataStore = utility.expand(this.scope || this, queryOptions.operationSDataStore || this.operationSDataStore);
                var operationName = utility.expand(this.scope || this, queryOptions.operationName || this.operationName);

                if (queryName) {
                    request = new Sage.SData.Client.SDataNamedQueryRequest(this.service)
                      .setQueryName(queryName);

                    if (resourcePredicate) {
                        request.getUri().setCollectionPredicate(resourcePredicate);
                    }
                } else if (resourceProperty) {
                    request = new Sage.SData.Client.SDataResourcePropertyRequest(this.service)
                      .setResourceProperty(resourceProperty)
                      .setResourceSelector(resourcePredicate);
                } else if (operationSDataStore === 'Sage.SData.Client.SDataServiceOperationRequest') {
                    request = new Sage.SData.Client.SDataServiceOperationRequest(this.service)
                        .setContractName(contractName)
                        .setOperationName(operationName);
                } else {
                    request = new Sage.SData.Client.SDataResourceCollectionRequest(this.service);
                }

                if (contractName) {
                    request.setContractName(contractName);
                }

                if (resourceKind) {
                    request.setResourceKind(resourceKind);
                }

                if (applicationName) {
                    request.setApplicationName(applicationName);
                }

                if (dataSet) {
                    request.setDataSet(dataSet);
                }

                if (queryArgs) {
                    for (var arg in queryArgs) {
                        if (queryArgs.hasOwnProperty(arg)) {
                            request.setQueryArg(arg, queryArgs[arg]);
                        }
                    }
                }
            }

            var select = utility.expand(this.scope || this, queryOptions.select || this.select);
            var include = utility.expand(this.scope || this, queryOptions.include || this.include);
            var orderBy = utility.expand(this.scope || this, queryOptions.sort || this.orderBy);

            if (select && select.length > 0) {
                request.setQueryArg('select', select.join(',').replace(/\./g, '/'));
            }

            if (include && include.length > 0) {
                request.setQueryArg('include', include.join(','));
            }

            if (orderBy) {
                if (typeof orderBy === 'string') {
                    request.setQueryArg('orderby', orderBy);
                } else if (orderBy.length > 0) {
                    var order = [];
                    array.forEach(orderBy, function forEach(v) {
                        if (v.descending) {
                            this.push(v.attribute + ' desc');
                        } else {
                            this.push(v.attribute);
                        }
                    }, order);

                    request.setQueryArg('orderby', order.join(','));
                }
            }

            var where = utility.expand(this.scope || this, queryOptions.where || this.where);
            var conditions = [];
            if (where) {
                conditions.push(where);
            }

            var query = utility.expand(this.scope || this, q);

            if (query) {
                if (typeof query === "string") {
                    conditions.push(query);
                }
                else {
                    console.warn("SDATA Store: A query object was found, but was not of correct type to include in query conditions.");
                }
            }

            if (conditions.length > 0) {
                request.setQueryArg('where', '(' + conditions.join(') and (') + ')');
            }

            if (typeof queryOptions.start !== 'undefined') {
                request.setQueryArg(Sage.SData.Client.SDataUri.QueryArgNames.StartIndex, queryOptions.start + 1);
            }

            if (typeof queryOptions.count !== 'undefined') {
                request.setQueryArg(Sage.SData.Client.SDataUri.QueryArgNames.Count, queryOptions.count);
            }

            return request;
        },
        _onCancel: function _onCancel(/*deferred*/) { },
        _onRequestFeedSuccess: function _onRequestFeedSuccess(queryDeferred, feed) {
            if (feed) {
                var items = lang.getObject(this.itemsProperty, false, feed);
                var total = typeof feed.$totalResults === 'number' ? feed.$totalResults : -1;

                queryDeferred.total = total;

                // Depracated. Use calling control's onLoadComplete events
                if (this.onComplete) {
                    this.onComplete(items, total);
                }

                this.dataCache = items;
                queryDeferred.resolve(items ? items : []);
            } else {
                var error = new Error('The feed result is invalid.');
                queryDeferred.reject(error);
            }
        },
        _onRequestEntrySuccess: function _onRequestEntrySuccess(deferred, entry) {
            if (entry) {
                deferred.resolve(this.doDateConversion ? this._handleDateConversion(entry) : entry);
            } else {
                var error = new Error('The entry result is invalid.');
                deferred.reject(error);
            }
        },
        _onRequestFailure: function _onRequestFailure(deferred, xhr, xhrOptions) {
            var error = new Error('An error occurred requesting: ' + xhrOptions.url);

            error.xhr = xhr;
            error.status = xhr.status;
            error.aborted = false;
            error.url = xhrOptions.url;

            deferred.reject(error);
        },
        _onRequestAbort: function _onRequestAbort(deferred, xhr, xhrOptions) {
            var error = new Error('An error occurred requesting: ' + xhrOptions.url);

            error.xhr = xhr;
            error.status = 0;
            error.responseText = null;
            error.aborted = true;

            deferred.reject(error);
        },
        _handleDateConversion: function _handleDateConversion(entry) {
            for (var prop in entry) {
                if (utility.Convert.isDateString(entry[prop])) {
                    entry[prop] = utility.Convert.toDateFromString(entry[prop]);
                }
            }

            return entry;
        },
        get: function get(id, getOptions /* sdata only */) {
            var handle = {};
            var deferred = new Deferred();
            var request = this._createEntryRequest(id, getOptions || {});
            var method = this.executeGetAs ? request[this.executeGetAs] : request.read;

            handle.value = method.call(request, {
                success: this._onRequestEntrySuccess.bind(this, deferred),
                failure: this._onRequestFailure.bind(this, deferred),
                aborted: this._onRequestAbort.bind(this, deferred)
            });

            return deferred;
        },
        /**
         * Returns an object's identity using this.idProperty
         * @param {Object} object The object to get the identity from
         * @returns {String|Number}
         */
        getIdentity: function getIdentity(object) {
            return lang.getObject(this.idProperty, false, object);
        },
        /**
         * Returns an object's label using this.labelProperty
         * @param {Object} object The object to get the label from
         * @returns {String}
         */
        getLabel: function getLabel(object) {
            return lang.getObject(this.labelProperty, false, object);
        },
        /**
         * Returns an object's entity using this.entityProperty
         * @param {Object} object The object to get the entity from
         * @returns {String|Object}
         */
        getEntity: function getEntity(object) {
            return lang.getObject(this.entityProperty, false, object);
        },
        /**
         * Returns an object's version using this.versionProperty
         * @param {Object} object The object to get the version from
         * @returns {String}
         */
        getVersion: function getVersion(object) {
            return lang.getObject(this.versionProperty, false, object);
        },
        /**
         * Stores an object.
         * @param {Object} object The object to store.
         * @param {Object} putOptions Additional directives for storing objects.
         * @param {String|Number} putOptions.id
         * @param {String|Object} putOptions.entity
         * @param {String} putOptions.version
         * @param {Boolean} putOptions.overwrite
         * @returns {String|Number}
         */
        put: function put(object, putOptions) {
            putOptions = putOptions || {};

            var id = putOptions.id || this.getIdentity(object);
            var entity = putOptions.entity || this.entityName;
            var version = putOptions.version || this.getVersion(object);
            var atom = !this.service.isJsonEnabled();

            if (id) {
                object.$key = id;
            }

            if (entity && atom) {
                object.$name = entity;
            }

            if (version) {
                object.$etag = version;
            }

            var handle = {};
            var deferred = new Deferred();
            var request = this._createEntryRequest(id, putOptions);
            var method = putOptions.create ? request.create : request.update;

            handle.value = method.call(request, object, {
                success: this._onTransmitEntrySuccess.bind(this, deferred),
                failure: this._onRequestFailure.bind(this, deferred),
                aborted: this._onRequestAbort.bind(this, deferred)
            });

            return deferred;
        },
        _onTransmitEntrySuccess: function _onTransmitEntrySuccess(deferred, entry) {
            deferred.resolve(this.doDateConversion ? this._handleDateConversion(entry) : entry);
        },
        /**
         * Creates an object, throws an error if the object already exists.
         * @param {Object} object The object to store
         * @param {Object} addOptions Additional directives for creating objects
         * @param {Boolean} addOptions.overwrite
         */
        add: function add(object, addOptions) {
            addOptions = addOptions || {};
            addOptions.create = true;
            return this.put(object, addOptions);
        },
        newItem: function (args /*, parentInfo */) {
            var request = new Sage.SData.Client.SDataTemplateResourceRequest(this.service);
            request.setResourceKind(this.resourceKind);
            request.read({
                success: function (entry) {
                    this._entity = entry;
                    if ((args.onComplete) && (typeof args.onComplete === 'function')) {
                        args.onComplete.call(args.scope || this, entry);
                    }
                },
                failure: function (err) {
                    if (args.onError) {
                        args.onError.call(args.scope || this, err);
                    }
                },
                scope: this
            });
        },
        createItem: function (item, scope) {
            var options = {};
            options.scope = scope || this;
            options.scope.store = this;
            var fnSuccess = function (created) {
                if (typeof this.onResponse === 'function') {
                    this.onResponse.call(this, created);
                }
            };
            options.success = fnSuccess;
            this.add(item).then(lang.hitch(this, function () {
                this.dataCache.push(item);
                options.success.call(options.scope, item);
            }));
        },
        deleteItem: function (selectedItems, scope) {
            var batchRequest = new Sage.SData.Client.SDataBatchRequest(this.service);
            batchRequest.setResourceKind(this.resourceKind);
            batchRequest.using(lang.hitch(this, function () {
                for (var i = 0; i < selectedItems.length; i++) {
                    var request = new Sage.SData.Client.SDataSingleResourceRequest(this.service);
                    request.setResourceKind(this.resourceKind);
                    request.setResourceSelector("'" + selectedItems[i].$key + "'");
                    request['delete']({}, { scope: this, ignoreETag: true });
                }
            }));
            batchRequest.commit({
                scope: this,
                ignoreETag: true,
                success: function (entry) {
                    var resources = entry.$resources[0];
                    if (resources.$diagnoses!==undefined) {
                        var diagnoses = resources.$diagnoses[0];
                        if (diagnoses.applicationCode && typeof diagnoses.applicationCode === "string" && diagnoses.applicationCode.indexOf("SDataExceptionDiagnoses") != -1) {
                            if (entry.$resources[0].$httpStatus == 500) {
                                scope.onResponseExceptionMsg = entry.$resources[0].$diagnoses[0].message;
                                
                            }
                        }
                    }
                    
                    var options = {};
                    options.scope = scope || this;
                    var fnSuccess = function () {
                        if (typeof this.onResponse === 'function') {
                            this.onResponse.call(this, options.scope.onResponseExceptionMsg);
                        }
                    };
                    options.success = fnSuccess;
                    options.success.call(options.scope);
                },
                failure: function (err) {
                    console.error(err);
                }
            });
        },
        remove: function (item, options) {
            options = options || {};

            var handle = {};
            var deferred = new Deferred();
            var request = this._createDeleteRequest(item, options);
            var method = request["delete"];

            handle.value = method.call(request, item, {
                success: this._onTransmitEntrySuccess.bind(this, deferred),
                failure: this._onRequestFailure.bind(this, deferred),
                aborted: this._onRequestAbort.bind(this, deferred)
            });

            return deferred;
        },
        /**
         * Queries the store for objects. This does not alter the store, but returns a
         * set of data from the store.
         *
         * @param {String|Object|Function} query The query to use for retrieving objects from the store.
         * @param {Object} queryOptions
         * @returns {dojo.store.api.Store.QueryResults}
         *
         */
        query: function query(q, queryOptions) {
            var handle = {};
            var queryDeferred = new Deferred(this._onCancel.bind(this, handle));
            var request = this._createFeedRequest(q, queryOptions || {});

            queryDeferred.total = -1;

            var options = {
                success: this._onRequestFeedSuccess.bind(this, queryDeferred),
                failure: this._onRequestFailure.bind(this, queryDeferred),
                aborted: this._onRequestAbort.bind(this, queryDeferred),
                httpMethodOverride: queryOptions && queryOptions.httpMethodOverride
            };

            var method = request.read;
            if (this.executeQueryAs) {
                method = request[this.executeQueryAs];
            } else if (request instanceof Sage.SData.Client.SDataResourcePropertyRequest) {
                method = request.readFeed;
            } else if (request instanceof Sage.SData.Client.SDataServiceOperationRequest) {
                method = request.execute;
                handle.value = method.call(request, this.entry, options);
                return QueryResults(queryDeferred); // eslint-disable-line
            }
            handle.value = method.call(request, options);
            return QueryResults(queryDeferred); // eslint-disable-line
        },
        /**
         * Not implemented in this store.
         */
        transaction: function transaction() { },
        /**
         * Not implemented in this store.
         */
        getChildren: function getChildren(/*parent, options*/) { },
        /**
         * Returns any metadata about the object. This may include attribution,
         * cache directives, history, or version information.
         *
         * @param {Object} object The object to return metadata for.
         * @return {Object} Object containing the metadata.
         * @return {String|Number} return.id
         * @return {String} return.label
         * @return {String|Object} return.entity
         * @return {String} return.version
         */
        getMetadata: function getMetadata(object) {
            if (object) {
                return {
                    id: this.getIdentity(object),
                    label: this.getLabel(object),
                    entity: this.getEntity(object),
                    version: this.getVersion(object)
                };
            }

            return null;
        },
        getLabelAttributes: function (item) {
            if (this.labelProperty) {
                return [this.labelProperty]; //array
            }
            return null; //null
        },
        getValue: function (item, attribute, defaultValue) {
            return utility.getValue(item, attribute);
        },
        /***********************************/
        // TODO: Remove all methods listed below after 8.3.
        /***********************************/
        onSuccess: function (context, feed) {
            console.error('store onSuccess function is not guaranteed to exist after 8.3');
        },
        isItem: function (something) {
            console.warn('store isItem function is not guaranteed to exist after 8.3');
            var id = this.getIdentity(something);
            if (id && id !== '') {
                return this.dataCache.hasOwnProperty(id);
            }
            return false;
        },
        isItemLoaded: function (/* anything */something) {
            console.error('store isItemLoaded function is not guaranteed to exist after 8.3');
            return this.isItem(something); //boolean
        },
        loadItem: function (/* object */keywordArgs) {
            console.error('store loadItem function is not guaranteed to exist after 8.3');
            if (!this.isItem(keywordArgs.item)) throw new Error('Unable to load ' + keywordArgs.item);
        },
        getValues: function (item, attributename) {
            console.error('store getValues function is not guaranteed to exist after 8.3');
            if (this.isItem(item) && (typeof attributename === "string")) {
                return (item[attributename] || []).slice(0);
            }
            return [];
        },
        isDirty: function (item) {
            console.error('store isDirty function is not guaranteed to exist after 8.3');
        },
        saveNewEntity: function (entity, success, failure, scope) {
            console.error('store saveNewEntity is deprecated');
            this.add(entity).then(lang.hitch(this, function () {
                success.call(scope, entity);
            }));
        },
        revert: function () {
            console.error('store revert function is not guaranteed to exist after 8.3');
        },
        save: function (scope) {
            console.error('store save function is not guaranteed to exist after 8.3');
        },
        setValue: function (item, attribute, value) {
            console.error('store setValue function is not guaranteed to exist after 8.3');
        },
        setValues: function (item, attribute, values) {
            console.error('store setValues function is not guaranteed to exist after 8.3');
        },
        unsetAttribute: function (item, attribute) {
            console.error('store unsetAttribute function is not guaranteed to exist after 8.3');
        },
        onSet: function (/* item */item,
        /*attribute-name-string*/attribute,
        /*object | array*/oldValue,
        /*object | array*/newValue) {
            console.error('store onSet function is not guaranteed to exist after 8.3');
        },
        onNew: function (newItem) {
        },
        onDelete: function (deletedItem) {
        },
        onDataReset: function () {
        },
        onDataSaved: function () {
        },
        onItemSaved: function (savedItem, parentInfo) {
        },
        onItemNotSaved: function (notSavedItem, error) {
        }
    });
});

},
'Sage/Data/WritableSDataStore':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
        'Sage/Data/BaseSDataStore',
        'Sage/Utility',
        'dojo/_base/declare',
        'dojo/_base/array',
        'dojo/_base/lang'
],
function (BaseSDataStore, Utility, declare, array, lang) {
    var writableSDataStore = declare('Sage.Data.WritableSDataStore', BaseSDataStore, {
        newItemParentReferenceProperty: false,
        constructor: function (o) {
            //dojo.data.api.Identity Implemented on BaseSDataStore...
            //dojo.data.api.Read Implemented on BaseSDataStore...
            this.features['dojo.data.api.Write'] = true;
            this.features['dojo.data.api.Notification'] = true;
            this.dirtyDataCache = { isDirty: false };
            this.singleResourceRequest = null;
            dojo.connect(this, "clearCache", this, this._clearCache);
            this.onComplete = o.onComplete;
        },
        getSingleResourceRequest: function (key) {
            this.verifyService();
            if (this.singleResourceRequest === null) {
                this.singleResourceRequest = new Sage.SData.Client.SDataSingleResourceRequest(this.service);
                this.singleResourceRequest.setResourceKind(this.resourceKind);
                if (this.select && this.select.length > 0) {
                    this.singleResourceRequest.setQueryArg('select', this.select.join(','));
                }
                if (this.include && this.include.length > 0) {
                    this.singleResourceRequest.setQueryArg('include', this.include.join(','));
                }
            }
            if (key) {
                this.singleResourceRequest.setResourceSelector("'" + key + "'");
            }
            return this.singleResourceRequest;
        },
        onSuccess: function (context, feed) {
            //console.log('success: %o, %o', context, feed);
            if (context.onBegin) {
                context.onBegin.call(context.scope || this, feed.$totalResults, context);
            }
            if (this.onComplete) {
                this.onComplete.call(context.scope || this, feed.$resources, context);
            }
            if (context.onComplete) {
                context.onComplete.call(context.scope || this, feed.$resources, context);
            }
            this.addToCache(context, feed);
        },
        _clearCache: function () {
            this.clearDirtyDataCache();
        },
        clearDirtyDataCache: function () {
            for (var key in this.dirtyDataCache) {
                if (key !== 'isDirty') {
                    delete this.dirtyDataCache[key];
                }
            }
            this.dirtyDataCache.isDirty = false;
            //this.dirtyDataCache = { isDirty: false };
        },
        isItem: function (something) {
            var id = this.getIdentity(something);
            if (id && id !== '') {
                return this.dataCache.hasOwnProperty(id);
            }
            return false;
        },
        isItemLoaded: function (/* anything */something) {
            return this.isItem(something); //boolean
        },
        loadItem: function (/* object */keywordArgs) {
            if (!this.isItem(keywordArgs.item)) throw new Error('Unable to load ' + keywordArgs.item);
        },
        getValues: function (item, attributename) {
            if (this.isItem(item) && (typeof attributename === "string")) {
                return (item[attributename] || []).slice(0);
            }
            return [];
        },
        hasAttribute: function (item, attributename) {
            if (this.isItem(item) && (typeof attributename === "string")) {
                return attributename in item;
            }
            return false;
        },
        close: function () {
            this.clearCache();
        },
        //dojo.data.api.Write implementations...
        deleteItem: function (item, scope) {
            var options = {};
            options.scope = scope || this;
            options.ignoreETag = true;
            var request = this.getSingleResourceRequest(this.getIdentity(item));
            if (scope && typeof scope.onResponse === 'function') {
                options.success = scope.onResponse;
                options.aborted = scope.onResponse;
                options.failure = scope.onResponse;
            }
            request['delete'](item, options);
        },
        isDirty: function (item) {
            //item could be null - if so, it means is any item dirty...
            if (item) {
                var id = this.getIdentity(item);
                if (id && id !== '') {
                    return this.dirtyDataCache.hasOwnPropery(id);
                }
            }
            return this.dirtyDataCache.isDirty;
        },
        _checkPageExitWarningMessage: function () {
            var response = true;
            if (this.dirtyDataCache.isDirty) {
                var service = Sage.Services.getService("ClientBindingManagerService");
                response = confirm(service._PageExitWarningMessage);
            }
            return response;
        },
        newItem: function (args /*, parentInfo */) {
            if (!this._checkPageExitWarningMessage()) {
                return;
            }
            var request = this.createTemplateRequest();
            if (request) {
                request.read({
                    success: function (entity) {
                        this._newItemCreated(args, entity);
                        this.onNew(entity);
                    },
                    failure: this.requestTemplateFailure,
                    scope: this
                });
            }
        },
        _newItemCreated: function (options, entity) {
            if (this.newItemParentReferenceProperty) {
                var currentId = Sage.Utility.getCurrentEntityId();
                if (entity.hasOwnProperty(this.newItemParentReferenceProperty) && currentId) {
                    entity[this.newItemParentReferenceProperty] = { '$key': currentId };
                }
            }
            if ((options) && (options.onComplete) && (typeof options.onComplete === 'function')) {
                options.onComplete.call(options.scope || this, entity);
            }
        },
        createTemplateRequest: function () {
            //The entity to create the relationship/New record for, from the selection.        
            var request = new Sage.SData.Client.SDataTemplateResourceRequest(this.service);
            if ((this.resourceKind) && (this.resourceKind !== '')) {
                request.setResourceKind(this.resourceKind);
            }
            return request;
        },
        requestTemplateFailure: function () {
            //alert('Template not received.');
        },
        saveNewEntity: function (entity, success, failure, scope) {
            var request = new Sage.SData.Client.SDataSingleResourceRequest(this.service);
            if (request) {
                if ((this.resourceKind) && (this.resourceKind !== '')) {
                    request.setResourceKind(this.resourceKind);
                }
                request.create(entity, {
                    success: success || function (created) {
                        if (typeof console !== 'undefined') {
                            console.log('created item: ' + created.$key);
                        }
                    },
                    failure: failure || function (response, o) {
                        if (typeof console !== 'undefined') {
                            console.log('Item not created: ' + entity.$key);
                        }
                    },
                    scope: scope || this
                });
            }
        },
        createItem: function (item, scope) {
            var request = new Sage.SData.Client.SDataSingleResourceRequest(this.service);
            if (request) {
                if ((this.resourceKind) && (this.resourceKind !== '')) {
                    request.setResourceKind(this.resourceKind);
                }
                var options = {};
                options.scope = scope || this;
                options.scope.store = this;
                var fnSuccess = function (created) {
                    if (typeof console !== 'undefined') {
                        console.log('createItem() created item with $key of %o', created.$key);
                    }
                    if (typeof this.onResponse === 'function') {
                        this.onResponse.call(this, created);
                    }
                };
                options.success = fnSuccess;
                var fnFailure = function (response, o) {
                    if (typeof this.onResponse === 'function') {
                        this.onResponse.call(this, response, o);
                    }
                    else {
                        if (typeof console !== 'undefined' && response && typeof response !== 'undefined' && response.status) {
                            // Note: item may not have scope here.
                            console.log('createItem() creation failed for an item. Response: status = %o; statusText = %o', response.status, response.statusText);
                        }
                    }
                };
                options.failure = fnFailure;
                options.aborted = fnFailure;
                request.create(item, options);
            }
        },
        revert: function () {
            // return success
            // we don't really need to do much - the grid calls fetch again and gets the data...
            this.clearDirtyDataCache();
            this.onDataReset();
        },
        save: function (scope) {
            var entity, request;
            if (!this.dirtyDataCache.isDirty) {
                if (scope && typeof scope.onComplete === 'function') {
                    scope.onComplete.call(scope);
                }
                return;
            }
            for (var key in this.dirtyDataCache) {
                if (key !== 'isDirty') {
                    entity = this.dirtyDataCache[key];
                    if (this.isItem(entity)) {
                        request = this.getSingleResourceRequest(key);
                        var options = {};
                        options.scope = scope || this;
                        options.scope.store = this;
                        // per the spec, the 'If-Match' header MUST be present for PUT requests.
                        // however, we are breaking with the spec, on the consumer, to allow it to be OPTIONAL so
                        // that the provider can decide if it wishes to break with the spec or not.
                        if (!this.isSecurityManager) {
                            options.ignoreETag = true;
                        }
                        var fnSuccess = function (updated) {
                            //Get the current $etag from the response so we can continue to update the item via sdata.
                            if (this.store.dataCache[updated.$key]) {
                                this.store.dataCache[updated.$key].$etag = updated.$etag;
                            }
                            if (typeof this.onResponse === 'function') {
                                this.onResponse.call(this, updated);
                            }
                        };
                        options.success = fnSuccess;
                        var fnFailure = function (response, o) {
                            //TODO: Update the store's $etag if we get a new one during a failure?
                            if (typeof console !== 'undefined') {
                                if (response && typeof response !== 'undefined' && response.responseText) {
                                    var oResponse = dojo.fromJson(response.responseText);
                                    if (oResponse && typeof oResponse !== 'undefined' && oResponse.$key) {
                                        // entity.$key does not have the correct context here.
                                        console.log('save() item not updated for $key: %o', oResponse.$key);
                                        console.log('save() response $etag: %o', oResponse.$etag);
                                        var obj = this.store.dataCache[oResponse.$key];
                                        if (obj && obj.$etag) {
                                            console.log('save() store $etag: %o', obj.$etag);
                                        }
                                    }
                                }
                            }
                            if (typeof this.onResponse === 'function') {
                                this.onResponse.call(this, response, o);
                            }
                        };
                        options.failure = fnFailure;
                        options.aborted = fnFailure;
                        request.update(entity, options);
                    }
                    delete this.dirtyDataCache[key];
                }
            }
            this.dirtyDataCache.isDirty = false;
            // If scope.onResponse is undefined but scope.onComplete is defined.
            if (scope && typeof scope.onResponse !== 'function' && typeof scope.onComplete === 'function') {
                scope.onComplete.call(scope);
            }
        },
        setValue: function (item, attribute, value) {
            //if (typeof console !== 'undefined') { console.log('setValue - %o %o %o', item, attribute, value) };
            var oldValue = this.getValue(item, attribute, '');
            Utility.setValue(item, attribute, value);
            this.onSet(item, attribute, oldValue, value);
            if (oldValue != value) {
                this.dirtyDataCache[this.getIdentity(item)] = item;
                this.dirtyDataCache.isDirty = true;
            }
            return true;
        },
        setValues: function (item, attribute, values) {
            array.forEach(values, lang.hitch(this, function(val) {
                this.setValue(item, attribute, val);
            }));
        },
        unsetAttribute: function (item, attribute) {
            alert('not implemented - unsetAttribute');
            //delete all values of an attribute on the item...
        },
        //dojo.data.api.Notification
        onSet: function (/* item */item,
        /*attribute-name-string*/attribute,
        /*object | array*/oldValue,
        /*object | array*/newValue) {
            // summary: See dojo.data.api.Notification.onSet()

            // No need to do anything. This method is here just so that the
            // client code can connect observers to it.
        },
        onNew: function (newItem) {
            //nothing to do here - client code connects observers to this
        },
        onDelete: function (deletedItem) {
            //nothing to do here - client code connects observers to this
        },
        onDataReset: function () {
        },
        onDataSaved: function () {
        },
        onItemSaved: function (savedItem, parentInfo) {
        },
        onItemNotSaved: function (notSavedItem, error) {
        }
    });
    return writableSDataStore;
});

},
'Sage/Groups/GroupContextService':function(){
/*globals Sage, dojo, window, define */
define([
        'Sage/Utility',
        'dojo/string',
        'Sage/Data/SDataServiceRegistry',
        'dojo/ready',
        'dojo/_base/lang',
        'dojo/_base/declare',
        'dojo/_base/array'
],
function (
        utility,
        dString,
        sDataServiceRegistry,
        ready,
        lang,
        declare,
        array
    ) {
    var groupContextService = declare('Sage.Groups.GroupContextService', null, {
        _adHocGroupList: null,
        _connects: null,
        _subscribes: null,
        _emptyContext: null,
        _currentRequestHandle: null,
        _isAdHocGroupListRetrieved: false,
        constructor: function () {
            this._connects = [];
            this._subscribes = [];
            this._adHocGroupList = [];
            this._emptyContext = {
                DefaultGroupID: null,
                CurrentGroupID: null,
                CurrentTable: null,
                CurrentName: null,
                CurrentEntity: null,
                CurrentFamily: null
            };

            this._isAdHocGroupListRetrieved = false;
            this._subscribes.push(
                dojo.subscribe(dString.substitute("/ui/filters/default/refresh"), this, this._onDefaultFilterRefresh)
            );

            ready(lang.hitch(this, function () {
                if (!this.isContextRequired()) {
                    var context = utility.getValue(window, 'Sage.Groups._groupContext'),
                        container = utility.getValue(window, 'Sage.UI.DataStore.Filters');
                    if (container) {
                        if (context['AppliedFilterInfo']) {
                            container['default'] = this.createFilterExtendedSet(context['AppliedFilterInfo']);
                        }
                    }
                }

                if (this.isContextRequired()) {
                    this.requestContext();
                }
            }));
        },
        createFilterExtendedSet: function (appliedFilterInfo) {
            var sourceDefinitionSet = appliedFilterInfo['definitionSet'] || [],
                sourceApplied = appliedFilterInfo['applied'] || [],
                resultDefinitionSet = {},
                resultApplied = {},
                sourceItem,
                resultItem,
                i,
                j,
                value;

            for (i = 0; i < sourceDefinitionSet.length; i++) {
                sourceItem = sourceDefinitionSet[i];
                resultItem = {
                    '$key': sourceItem['id'],
                    '$partial': true,
                    'filterName': sourceItem['filterName'],
                    'displayName': sourceItem['displayName'],
                    'propertyName': sourceItem['propertyName'],
                    'propertyDataTypeId': sourceItem['propertyDataTypeId'],
                    'details': {}
                };

                if (sourceItem['filterType'] == 'rangeFilter') {
                    resultItem['details']['rangeFilter'] = {
                        'characters': sourceItem['characters']
                    };
                }
                if (sourceItem['filterType'] == 'lookupFilter') {
                    resultItem['details']['lookupFilter'] = {};
                } else {
                    resultItem['details']['distinctFilter'] = {};
                }

                resultDefinitionSet[sourceItem['id']] = resultItem;
            }

            for (i = 0; i < sourceApplied.length; i++) {
                sourceItem = sourceApplied[i];
                resultItem = {};

                for (j = 0; j < sourceItem['rangeValues'].length; j++) {
                    value = sourceItem['rangeValues'][j];
                    resultItem[value['rangeName']] = lang.mixin({}, value);
                }

                for (j = 0; j < sourceItem['distinctValues'].length; j++) {
                    value = sourceItem['distinctValues'][j];
                    if (typeof value === 'string') {
                        resultItem[value] = value;
                    }
                }
                for (j = 0; j < sourceItem['lookupValues'].length; j++) {
                    var lookuValue = sourceItem['lookupValues'][j];
                    resultItem['value'] = lookuValue;
                }
                resultApplied[sourceItem['id']] = resultItem;
            }

            return {
                'definitionSet': resultDefinitionSet,
                'applied': resultApplied
            };
        },
        destroy: function () {
            array.forEach(this._connects, function (handle) {
                dojo.disconnect(handle);
            });

            this.unsubscribeConnects();

            this.uninitialize();
        },
        unsubscribeConnects: function () {
            array.forEach(this._subscribes, function (handle) {
                dojo.unsubscribe(handle);
            });
        },
        uninitialize: function () {
        },
        isContextRequired: function () {
            var results = !(Sage && Sage.Groups && Sage.Groups._groupContext);
            return results;
        },
        createCompatibleContext: function (context) {
            if (context['currentGroupId'] == 'LOOKUPRESULTS') {
                context['currentName'] = 'Lookup Results';
            }
            var compatibleContext = {
                'AppliedFilterInfo': context['appliedFilterInfo'],
                'ContainsPositionState': context['containsPositionState'],
                'CurrentDisplayName': context['currentDisplayName'],
                'CurrentEntity': context['currentEntity'],
                'CurrentEntityID': context['currentEntityId'],
                'CurrentEntityPosition': context['currentEntityPosition'],
                'CurrentFamily': context['currentFamily'],
                'CurrentGroupCount': context['currentGroupCount'],
                'CurrentGroupID': context['currentGroupId'],
                'CurrentName': context['currentName'],
                'CurrentTable': context['currentTable'],
                'CurrentTableKeyField': context['currentTableKeyField'],
                'DefaultGroupID': context['defaultGroupId'],
                'FirstEntityID': context['firstEntityId'],
                'LastEntityID': context['lastEntityId'],
                'LookupLayoutGroupName': context['lookupLayoutGroupName'],
                'NextEntityID': context['nextEntityId'],
                'PreviousEntityID': context['previousEntityId'],
                'RetrievedOn': context['retrievedOn'],
                'isAdhoc': context['isAdHoc']
            };

            if (!context['appliedFilterInfo']) {
                delete compatibleContext.AppliedFilterInfo;
            }

            return compatibleContext;
        },
        _onDefaultFilterRefresh: function (applied, definitionSet, filterManager) {
            var groupContext = this.getContext(),
                service = sDataServiceRegistry.getSDataService('system'),
                entry = {
                    '$name': 'applyFilterToGroup',
                    'request': {
                        'groupId': groupContext['CurrentGroupID'],
                        'filter': dojo.toJson(filterManager.createValueSet())
                    }
                };
            if ((groupContext['CurrentGroupID'] === null) || (groupContext['CurrentGroupID'] === '')) {
                return;
            }

            var request = new Sage.SData.Client.SDataServiceOperationRequest(service)
                .setOperationName('applyFilterToGroup');

            request.execute(entry, {});
        },
        getContext: function () {
            var context = Sage && Sage.Groups && Sage.Groups._groupContext;
            if (context) {
                return context;
            }

            if (this.isContextRequired()) {
                this.requestContext();
            }

            return this._emptyContext;
        },
        requestContext: function (onComplete) {
            if (this._currentRequestHandle) {
                return;
            }

            var service = sDataServiceRegistry.getSDataService('system'),
                request = new Sage.SData.Client.SDataServiceOperationRequest(service)
                    .setOperationName('getGroupContext');

            this._currentRequestHandle = request.execute({}, {
                success: this._onRequestContextSuccess,
                failure: this._onRequestContextFailure,
                scope: this
            });
        },
        _onRequestContextSuccess: function (entry) {
            var context = entry && entry['response'];
            if (context) this.setContext(this.createCompatibleContext(context));

            this._currentRequestHandle = null;
        },
        _onRequestContextFailure: function (response, o) {
            this._currentRequestHandle = null;
        },
        setContext: function (context) {
            var container = Sage && Sage.Groups;
            if (container && context) {
                lang.mixin(container._groupContext, context);
                this.onContextSet(container._groupContext);
            }
        },
        setCurrentGroup: function (groupId, groupName, lookupCondition) {

            var context = this.getContext();

            if (context && (context['CurrentGroupID'] === groupId)) { //This condition is met when the user clicks on an item on the list view, the system loads the detail view, and setCurrentGroup is invoked. In this case, we are not actually "changing" group.
              if (groupId === 'LOOKUPRESULTS') {
                //If groupId is LOOKUPRESULTS, then if no lookupcondition or if no change in condition then, no need to refresh the list, just return - so that we can avoid double refresh for lookups.
                if ((!lookupCondition) || (context.LookupResultsConditions === lookupCondition)) {
                    return;
                }
                context['currentName'] = 'Lookup Results';
              }

                //NRADDATZ: Needed to add this flag to avoid the Group Changed event being triggered twice the first time the page is loaded.
                //For lookup results though, we still want the group change to trigger, since conditions (and the recordset matching them) probably changed.
                if (groupId !== 'LOOKUPRESULTS') {
                    this.doNotFireGroupChangedEvent = true;
                }
            }

            //assume a groupID is coming in - and that it is an ID (not the name)...
            if (groupId.length === 12 || groupId === 'LOOKUPRESULTS') {
                // todo: handle if a group name and family is passed...
                var service = sDataServiceRegistry.getSDataService('system'),
                    request = new Sage.SData.Client.SDataServiceOperationRequest(service)
                        .setOperationName('setGroupContext'),
                    entry = {
                        request: {
                            'currentGroupId': groupId,
                            'currentName': '',
                            'currentFamily': ''
                        }
                    };

                request.execute(entry, {
                    success: this._onSetContextRequestSuccess,
                    failure: this._onSetContextRequestFailure,
                    scope: this
                });
            }
        },
        _onSetContextRequestSuccess: function (entry) {
            var context = entry && entry['response'],
                compatibleContext = context && this.createCompatibleContext(context);
            if (compatibleContext) this.setContext(compatibleContext);

            //NRADDATZ: Needed to add this flag to avoid the Group Changed event being triggered twice the first time the page is loaded.
            if (!this.doNotFireGroupChangedEvent) {
                this.onCurrentGroupChanged({ current: compatibleContext });
            }
            this.doNotFireGroupChangedEvent = false;
        },
        _onSetContextRequestFailure: function (response, o) {
        },
        onSuccessfulGroupChanged: function (data) {
            var previousContext = this.getContext();
            this.setContext(data);
            this.onCurrentGroupChanged({ current: data, previous: previousContext });
        },
        onCurrentGroupChanged: function (options) {
            // We need to apply the the change before publishing the applied filters Info
            //The filter panel will check and see if the group is the same before appling the filter info.
            dojo.publish('/group/context/changed', [options, this]);
            if (options['current']['AppliedFilterInfo']) {
                // We need to apply the the change before publishing the applied filters Info
                //The filter panel will check and see if the group is the same before appling the filter info.
                this.publishFiltersApplied(options['current']['AppliedFilterInfo']);
            }
        },
        publishFiltersApplied: function (appliedFilterInfo) {
            // When the dom is ready publish that we have applied filters.
            if (appliedFilterInfo) {
                ready(lang.hitch(this, function () {
                    var extendedSet = this.createFilterExtendedSet(appliedFilterInfo),
                        container = utility.getValue(window, 'Sage.UI.DataStore.Filters');
                    container['default'] = extendedSet;
                    dojo.publish('/ui/filters/default/apply', [extendedSet['applied'], extendedSet['definitionSet'], this]);
                }));
            }
        },
        onContextSet: function (context) {
            if (context && context['AppliedFilterInfo']) {
                this.publishFiltersApplied(context['AppliedFilterInfo']);
            }
        },

        //adhoc group list...
        getAdHocGroupList: function (callback, callbackScope) {
            if (this._isAdHocGroupListRetrieved) {
                callback.call(callbackScope || this, this._adHocGroupList);
                return;
            }
            var store = new Sage.Data.BaseSDataStore({
                service: sDataServiceRegistry.getSDataService('system'),
                resourceKind: 'groups',
                include: [],
                select: ['name', 'family', 'isHidden', 'isAdHoc', 'mainTable', 'keyField', 'entityName']
            });

            Sage.Groups._groupContext.CurrentFamily = Sage.Groups._groupContext.CurrentFamily.toUpperCase();

            store.fetch({
                query: dojo.string.substitute("upper(family) eq '${CurrentFamily}' and isAdHoc", Sage.Groups._groupContext),
                count: 1000,
                sort: [{ attribute: 'name' }],
                start: 0,
                onComplete: function (data) {
                    this._adHocGroupList = data;
                    callback.call(callbackScope || this, this._adHocGroupList);
                    this._isAdHocGroupListRetrieved = true;
                },
                scope: this
            });
        }
    });

    Sage.Services.addService("ClientGroupContext", new groupContextService());
    return groupContextService;
});

},
'Sage/Groups/GroupManager':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define, getXMLDoc */
define([
        'Sage/UI/Dialogs',
        'Sage/Utility/Email',
        'dojo/string',
        'Sage/Groups/GroupContextService',
        'dojox/storage/LocalStorageProvider',
        'dojo/_base/array',
        'dojo/_base/lang',
        'dojo/i18n',
        'dojo/i18n!./nls/GroupManager',
        'Sage/Data/SDataServiceRegistry',
        'dojo/_base/xhr',
        'dojo/topic',
        'dojo/aspect',
        'Sage/Utility/Jobs'
],
function (
        dialogs,
        email,
        dString,
        GroupContextService,
        LocalStorageProvider,
        array,
        lang,
        i18n,
        nls,
        sDataServiceRegistry,
        xhr,
        topic,
        aspect,
        jobs
    ) {
    Sage.namespace('Sage.Groups.GroupManager');
    Sage.Groups.GroupManager = {
        CurrentUserID: "",
        SortCol: -1,
        SortDir: "ASC",
        //CurrentMode : "CONTACT", //Contact
        GMUrl: "SLXGroupBuilder.aspx?method=",
        GroupXML: "",
        resources: nls,
        LOCALSTORE_NAMESPACE: 'SageGroups',
        QB_WIDTH: 840,
        QB_HEIGHT: 710,
        GroupAdHocJobRecordLimit: -1,

        GetFromServer: function (url, datatype, onSuccess, onError, sync) {
            var args = {
                url: url,
                sync: sync || false,
                handleAs: datatype || 'text',
                headers: { 'Content-Type': 'application/xml' },
                preventCache: true,
                load: onSuccess,
                error: onError
            };
            return dojo.xhrGet(args);
        },
        ClearLocalStorage: function () {
            var localStore = new LocalStorageProvider();
            localStore.initialize();
            localStore.clear(Sage.Groups.GroupManager.resources.LOCALSTORE_NAMESPACE);
            window.location.reload(true);
        },
        ClearLocalStorageForGroup: function (groupId) {
            var localStore = new LocalStorageProvider();
            localStore.initialize();
            array.forEach(localStore.getNamespaces(), function (item) {
                if (item.indexOf(groupId) > -1) {
                    localStore.clear(item);
                }
            });
            sessionStorage.removeItem('GROUPLAYOUT_' + groupId);
            sessionStorage.removeItem('hidden_filters_' + groupId);
            sessionStorage.removeItem('METADATA_FILTERS_' + groupId);
            window.location.reload(true);
        },
        PostToServer: function (url, data, onSuccess, onError) {
            var args = {
                url: url,
                postData: data,
                handleAs: 'text',
                headers: { 'Content-Type': 'application/xml' },
                load: function (data) {
                    if (typeof onSuccess === 'function') {
                        onSuccess(data);
                    }
                },
                error: function (err) {
                    if (typeof onError === 'function') {
                        onError(err);
                    }
                }
            };
            return dojo.xhrPost(args);
        },
        GetCurrentGroupInfo: function () {
            var clGrpContextSvc = Sage.Services.getService("ClientGroupContext");
            if (clGrpContextSvc) {
                var clGrpContext = clGrpContextSvc.getContext();
                return { "Name": clGrpContext.CurrentName,
                    "Family": clGrpContext.CurrentFamily,
                    "Id": clGrpContext.CurrentGroupID,
                    "isAdhoc": clGrpContext.isAdhoc,
                    "Entity": clGrpContext.CurrentEntity,
                    "tableName": clGrpContext.CurrentTable
                };
            }
            return "";
        },
        CreateGroup: function (mode) {
            if (typeof mode === 'undefined' || mode === '') {
                mode = Sage.Groups.GroupManager.GetCurrentGroupInfo().Family;
            }
            var vUrl = "QueryBuilderMain.aspx?mode=" + mode,
                width = Sage.Groups.GroupManager.QB_WIDTH,
                height = Sage.Groups.GroupManager.QB_HEIGHT;
            window.open(vUrl, "GroupViewer",
                dString.substitute("resizable=yes,centerscreen=yes,width=${width},height=${height},status=no,toolbar=no,scrollbars=yes", { width: width, height: height }));
        },
        DeleteGroup: function(groupID, groupName) {
            if (typeof groupID === 'undefined' || groupID === '') {
                groupID = Sage.Groups.GroupManager.GetCurrentGroupInfo().Id;
            }
            var msg = (groupName) ? dString.substitute(Sage.Groups.GroupManager.resources.ConfirmDeleteFmtMessage, [groupName]) : Sage.Groups.GroupManager.resources.ConfirmDeleteMessage;
            dialogs.raiseQueryDialog('', msg,
                function(result) {
                    if (result === true) {
                        Sage.Groups.GroupManager.GetFromServer(Sage.Groups.GroupManager.GMUrl + 'DeleteGroup&gid=' + groupID,
                            'text',
                            function() {
                                var url = document.location.href.replace("#", "");
                                if (url.indexOf("?") > -1) {
                                    var halves = url.split("?");
                                    url = halves[0];
                                }
                                document.location = url;
                            },
                            function() {
                            }
                        );
                    }
                },
                Sage.Groups.GroupManager.resources.yesCaption,
                Sage.Groups.GroupManager.resources.noCaption);
        },
        EditGroup: function (strGroupId) {
            // show group editor dialog...
            var curGrpInfo = Sage.Groups.GroupManager.GetCurrentGroupInfo();
            if (typeof strGroupId === 'undefined' || strGroupId === '')
                strGroupId = curGrpInfo.Id;

            var url = dString.substitute('QueryBuilderMain.aspx?gid=${groupid}&mode=${md}', { groupid: strGroupId, md: curGrpInfo.Family }),
                width = Sage.Groups.GroupManager.QB_WIDTH,
                height = Sage.Groups.GroupManager.QB_HEIGHT;

            window.open(url, "EditGroup",
            dString.substitute("resizable=yes,centerscreen=yes,width=${width},height=${height},status=no,toolbar=no,scrollbars=yes", { width: width, height: height }));
        },
        CopyGroup: function (strGroupId) {
            // show group editor dialog...
            var curGrpInfo = Sage.Groups.GroupManager.GetCurrentGroupInfo();
            if (typeof strGroupId === 'undefined' || strGroupId === '')
                strGroupId = curGrpInfo.Id;
            var vUrl = ['QueryBuilderMain.aspx?gid=', strGroupId, '&action=copy', '&mode=', curGrpInfo.Family].join(''),
                width = Sage.Groups.GroupManager.QB_WIDTH,
                height = Sage.Groups.GroupManager.QB_HEIGHT;

            window.open(vUrl, "EditGroup",
               dString.substitute("resizable=yes,centerscreen=yes,width=${width},height=${height},status=no,toolbar=no,scrollbars=yes", { width: width, height: height }));
        },
        ListGroupsAsSelect: function (family) {
            var sFamily = family;
            if (!dojo.isString(sFamily) || sFamily.length === 0) {
                sFamily = Sage.Groups.GroupManager.GetCurrentGroupInfo().Family;
                if (!dojo.isString(sFamily) || sFamily.length === 0) {
                    return "";
                }
            }
            var sUrl = Sage.Groups.GroupManager.GMUrl + "GetGroupList&entity=" + sFamily;
            var sResult = "";
            Sage.Groups.GroupManager.GetFromServer(
                sUrl,
                "text",
                function (data) {
                    sResult = data;
                },
                function (err) {
                    if (typeof console !== "undefined") {
                        console.error(err);
                    }
                },
                true);
            var oXmlDoc = getXMLDoc(sResult);
            if (oXmlDoc) {
                var arrGroupInfos = oXmlDoc.getElementsByTagName("GroupInfo");
                if (!arrGroupInfos) {
                    return "";
                }
                var sSelectOption = "";
                for (var i = 0; i < arrGroupInfos.length; i++) {
                    sSelectOption += "<option value = '" + arrGroupInfos[i].getElementsByTagName("GroupID")[0].firstChild.nodeValue + "'>" + arrGroupInfos[i].getElementsByTagName("DisplayName")[0].firstChild.nodeValue + "</option>";
                }
                return sSelectOption;
            }
            return "";
        },
        GetGroupId: function (name) {
            var results = '';
            // Call httpHandler synchronously
            Sage.Groups.GroupManager.GetFromServer(
                Sage.Groups.GroupManager.GMUrl + 'GetGroupId&name=' + encodeURIComponent(name),
                'text',
                function (data) {
                    results = data;
                },
                function (err) {
                    console.error(err);
                },
                true);
            return results;
        },
        HideGroup: function (strGroupId, skipReload) {
            if (typeof strGroupId === 'undefined' || strGroupId === '') {
                strGroupId = Sage.Groups.GroupManager.GetCurrentGroupInfo().Id;
            }

            Sage.Groups.GroupManager.PostToServer(Sage.Groups.GroupManager.GMUrl + 'HideGroup&gid=' + strGroupId, '', lang.hitch(this, Sage.Groups.GroupManager._HideOrShowComplete, skipReload, strGroupId));
        },
        _HideOrShowComplete: function (skipReload, groupId) {
            var service, context, reloadFn, handle;
            if (skipReload) {
                return;
            }

            reloadFn = function () {
                if (handle && handle.remove) {
                    handle.remove();
                }
                var titlePane = dijit.byId('titlePane');
                if (titlePane) {
                    titlePane.resetConfiguration();
                }
            };

            service = Sage.Services.getService("ClientGroupContext");
            context = service && service.getContext();
            handle = aspect.after(service, 'onCurrentGroupChanged', reloadFn);

            if (!Sage.Groups.GroupManager._isDefaultGroup(groupId) && context.CurrentGroupID === groupId) {
                // User has hidden the current group they are on, and it is NOT the default group
                service.setCurrentGroup(context.DefaultGroupID);
            } else if (Sage.Groups.GroupManager._isDefaultGroup(groupId) && context.CurrentGroupID === groupId) {
                // User has hidden the group they are on, and it happens to be the default group that we would normally switch to...
                // Lookup results is good enough??
                service.setCurrentGroup('LOOKUPRESULTS');
            } else {
                // Hide a group other than current, no need to switch here, just reload the tabs
                reloadFn.call();
            }
        },
        _isDefaultGroup: function (groupId) {
            var service, context, results;
            results = false;
            service = Sage.Services.getService("ClientGroupContext");
            if (service) {
                context = service.getContext();
                if (context) {
                    results = context.DefaultGroupID === groupId;
                }
            }
            return results;
        },
        UnHideGroup: function groupmanager_(strGroupId, skipReload) {
            if (typeof strGroupId === 'undefined' || strGroupId === '') {
                strGroupId = Sage.Groups.GroupManager.GetCurrentGroupInfo().Id;
            }
            Sage.Groups.GroupManager.GetFromServer(Sage.Groups.GroupManager.GMUrl + 'UnHideGroup&gid=' + strGroupId, '', lang.hitch(this, Sage.Groups.GroupManager._HideOrShowComplete, skipReload, strGroupId));
        },
        ShowGroups: function (strTableName) {
            if (typeof strTableName === 'undefined' || strTableName === '')
                strTableName = Sage.Groups.GroupManager.GetCurrentGroupInfo().Family;
            var vUrl = 'ShowGroups.aspx?tablename=' + strTableName;
            window.open(vUrl, "ShowGroups", "resizable=yes,centerscreen=yes,width=800,height=646,status=no,toolbar=no,scrollbars=yes");
        },
        CreateAdHocGroup: function (strGroups, strName, strFamily, strLayoutId) {
            //ToDo: should this be depricated or removed?...
            var vUrl = [Sage.Groups.GroupManager.GMUrl, 'CreateAdHocGroup',
                '&name=', encodeURIComponent(strName),
                '&family=', strFamily,
                '&layoutid=', encodeURIComponent(strLayoutId)].join();
            return Sage.Groups.GroupManager.PostToServer(vUrl, strGroups);
        },
        EditAdHocGroupAddMember: function (strGroupId, strItem) {
            //ToDo: should this be depricated or removed?...
            if (typeof strGroupId === 'undefined' || strGroupId === '')
                strGroupId = Sage.Groups.GroupManager.GetCurrentGroupInfo().Id;
            var x = Sage.Groups.GroupManager.GetFromServer(Sage.Groups.GroupManager.GMUrl + 'EditAdHocGroupAddMember&groupid=' + strGroupId + '&entityid=' + strItem);
        },
        EditAdHocGroupDeleteMember: function (strGroupId, strItem) {
            //ToDo: should this be depricated or removed?...
            if (typeof strGroupId === 'undefined' || strGroupId === '')
                strGroupId = Sage.Groups.GroupManager.GetCurrentGroupInfo().Id;
            var x = Sage.Groups.GroupManager.GetFromServer(Sage.Groups.GroupManager.GMUrl + 'EditAdHocGroupDeleteMember&groupid=' + strGroupId + '&entityid=' + strItem);
        },
        SetDefault: function (strGroupId, name, family) {
            Sage.Groups.GroupManager._saveGroupUserOptions(name, family, "DEFAULTGROUP");
        },
        SetLookupLayout: function (strGroupId, name, family) {
            Sage.Groups.GroupManager._saveGroupUserOptions(name, family, "LOOKUPLAYOUTGROUP");
        },
        _saveGroupUserOptions: function (name, family, optionCategory) {
            var groupInfo = Sage.Groups.GroupManager.GetCurrentGroupInfo(),
                currentName = groupInfo.Name,
                tempName = name || currentName,
                tempFamily = family;

            var svc = Sage.Services.getService("UserOptions");
            if (svc) {
                svc.set(family, optionCategory, dString.substitute("${0}:${1}", [tempFamily, tempName]));
            }
        },
        IsAdHoc: function (groupId) {
            alert('not implemented in this object yet...');
        },
        ExportGroup: function (strGroupID, strFileName) {
            dialogs.showInfo(Sage.Groups.GroupManager.resources.exportToExcel);
        },
        ShareGroup: function (strGroupId) {
            // show group editor dialog...
            if (typeof strGroupId === 'undefined' || strGroupId === '')
                strGroupId = Sage.Groups.GroupManager.GetCurrentGroupInfo().Id;
            var vURL = 'ShareGroup.aspx?gid=' + strGroupId;
            window.open(vURL, "ShareGroup", "resizable=yes,centerscreen=yes,width=500,height=450,status=no,toolbar=no,scrollbars=yes");
        },
        GetGroupSQL: function (groupId, useAliases, parts, applyFilters) {
            var sGroupId = groupId;
            if (!dojo.isString(sGroupId) || sGroupId.length === 0) {
                sGroupId = Sage.Groups.GroupManager.GetCurrentGroupInfo().Id;
                if (!dojo.isString(sGroupId) || sGroupId.length === 0) {
                    return "";
                }
            }
            var sUrl = Sage.Groups.GroupManager.GMUrl + "GetGroupSQL&gid=" + sGroupId;
            if (typeof useAliases !== "undefined") {
                if (dojo.isString(useAliases)) {
                    if ((useAliases === "true") || (useAliases === "false")) {
                        sUrl += "&UseAliases=" + useAliases;
                    }
                }
                else {
                    if (typeof useAliases === "boolean") {
                        sUrl += "&UseAliases=" + useAliases.toString();
                    }
                }
            }
            if (dojo.isString(parts) && parts.length > 0) {
                sUrl += "&parts=" + parts;
            }

            if (typeof applyFilters !== "undefined") {
                if (dojo.isString(applyFilters)) {
                    if ((applyFilters === "true") || (applyFilters === "false")) {
                        sUrl += "&ApplyFilters=" + applyFilters;
                    }
                }
                else {
                    if (typeof applyFilters === "boolean") {
                        sUrl += "&ApplyFilters=" + applyFilters.toString();
                    }
                }
            }
            var sResult = "";
            Sage.Groups.GroupManager.GetFromServer(
                sUrl,
                "text",
                function (data) {
                    sResult = data;
                },
                function (err) {
                    if (typeof console !== "undefined") {
                        console.error(err);
                    }
                },
                true);
            return sResult;
        },
        GetGroupSQLFromXML: function (groupXml, onSuccess, onError) {
            Sage.Groups.GroupManager.PostToServer(Sage.Groups.GroupManager.GMUrl + "GetGroupSQL", groupXml, onSuccess, onError);
        },
        GetGroupSQLById: function (groupId, onSuccess, onError) {
            var url = Sage.Groups.GroupManager.GMUrl + "GetGroupSQL&gid=" + groupId;
            Sage.Groups.GroupManager.GetFromServer(url, 'json', onSuccess, onError);
        },
        GetAdHocGroupJobRecordLimit: function () {
            if (!this.GroupAdHocJobRecordLimit || this.GroupAdHocJobRecordLimit < 1) {
                var sUrl = Sage.Groups.GroupManager.GMUrl + "GetAdHocGroupJobRecordLimit";
                var sResult = "";
                Sage.Groups.GroupManager.GetFromServer(sUrl, "text",
                    function (data) {
                        sResult = data;
                    },
                    function (err) {
                        if (typeof console !== "undefined") {
                            console.error(err);
                        }
                    },
                    true);
                this.GroupAdHocJobRecordLimit = sResult;
            }
        },

        saveSelectionsAsNewGroup: function () {
            var selectionInfo = Sage.Utility.getSelectionInfo();
            if (!selectionInfo || selectionInfo.selectionCount === 0) {
                if (selectionInfo.recordCount < 1) {
                    dialogs.showInfo(Sage.Groups.GroupManager.resources.noRecordsInGroup, Sage.Groups.GroupManager.resources.noneSelectedTitle);
                } else {
                    var dialogbody = dString.substitute(Sage.Groups.GroupManager.resources.noneSelectedPromptFmt, [selectionInfo.recordCount]);
                    dialogs.raiseQueryDialog(
                        Sage.Groups.GroupManager.resources.noneSelectedTitle,
                        dialogbody,
                        function (result) {
                            if (result === true) {
                                if (selectionInfo.selectionCount === 0) {
                                    Sage.Groups.GroupManager.saveLookupAsGroup();
                                }
                                Sage.Groups.GroupManager.promptForName('');
                            }
                        },
                        Sage.Groups.GroupManager.resources.yesCaption,
                        Sage.Groups.GroupManager.resources.noCaption);
                }
            } else {
                Sage.Groups.GroupManager.promptForName('');
            }
        },
        promptForName: function (addlMsg, defaultValue) {
            var selectionInfo = Sage.Utility.getSelectionInfo();
            var totalToAdd = (selectionInfo.selectionCount === 0) ? selectionInfo.recordCount : selectionInfo.selectionCount;
            var dialogBody = dString.substitute(Sage.Groups.GroupManager.resources.newGroupNamePrompt, [totalToAdd, addlMsg || '']);
            dialogs.raiseInputDialogExt({
                title: Sage.Groups.GroupManager.resources.newGroupTitle,
                query: dialogBody,
                callbackFn: function (result, name) {
                    if (result === true) {
                        if (name === '') {
                            window.setTimeout(function () { Sage.Groups.GroupManager.promptForName(Sage.Groups.GroupManager.resources.newGroupRePrompt, name); }, 100);
                        } else if (name.match(/[\/\\:\*\?"<\>|\.'\r\n]/) !== null) {
                            window.setTimeout(function () { Sage.Groups.GroupManager.promptForName(Sage.Groups.GroupManager.resources.invalidCharMsg, name); }, 100);
                        } else {
                            Sage.Groups.GroupManager.saveNewGroupPost(name);
                        }
                    }
                },
                yesText: Sage.Groups.GroupManager.resources.okCaption,
                noText: Sage.Groups.GroupManager.resources.cancelCaption,
                defaultValue: defaultValue || '',
                closable: true
            });
        },
        saveNewGroupPost: function (name) {
            var selectionInfo = Sage.Utility.getSelectionInfo(),
                service = sDataServiceRegistry.getSDataService('system'),
                request = new Sage.SData.Client.SDataSingleResourceRequest(service),
                groupContext = Sage.Services.getService("ClientGroupContext").getContext(),
                family = groupContext.CurrentFamily,
                groupId = groupContext.CurrentGroupID,
                entry = {},
                copy = false;

            request.setResourceKind('groups');

            if (selectionInfo.selectionCount === 0 && groupId !== 'LOOKUPRESULTS') {
                copy = true;
            }

            var totalToAdd = (selectionInfo.selectionCount === 0) ? selectionInfo.recordCount : selectionInfo.selectionCount;
            this.GetAdHocGroupJobRecordLimit();
            var recordLimit = this.GroupAdHocJobRecordLimit ? this.GroupAdHocJobRecordLimit : -1;
            if (recordLimit >= 0 && totalToAdd > recordLimit) {
                entry = {
                    family: family,
                    name: name,
                    adHocIds: (selectionInfo.selectionCount === 0) ? null : selectionInfo.selectedIds,
                    groupId: groupId
                };
                this.createAdHocGroupViaJob(entry);
            } else {

                entry = {
                    family: family,
                    name: name,
                    adHocIds: selectionInfo.selectedIds
                };
                request.create(entry, {
                    success: function (entry) {
                        if (copy) {
                            Sage.Groups.GroupManager.copyFromGroup(groupId, entry.$key);
                        } else {
                            Sage.Groups.GroupManager.newGroupCreated();
                        }
                    },
                    failure: function () {
                    },
                    scope: this
                });
            }
        },

        createAdHocGroupViaJob: function (entry) {
            var groupId = entry["groupId"];
            if (groupId === "LOOKUPRESULTS") {
                groupId = this._getDefaultGroupId();
            }

            var parameters = [
                { "name": "SelectedIds", "value": entry["adHocIds"] },
                { "name": "Family", "value": entry["family"] },
                { "name": "EntityName", "value": entry["family"] },
                { "name": "GroupName", "value": entry["name"] },
                { "name": "GroupId", "value": groupId },
                { "name": "AppliedFilters", "value": Sys.Serialization.JavaScriptSerializer.serialize(jobs.getFiltersForJob()) },
                { "name": "LookupConditions", "value": Sys.Serialization.JavaScriptSerializer.serialize(jobs.getLookupConditionsForJob()) }
            ];

            var options = {
                descriptor: dString.substitute(nls.createAdHocGroupJob_Description, [entry["name"]]),
                closable: true,
                title: nls.createAdHocGroupJob_Title,
                key: "Sage.SalesLogix.BusinessRules.Jobs.CreateAdHocGroupJob",
                infoMessage: nls.createAdHocGroupJobProcessingJobMsg,
                parameters: parameters,
                failure: function (result) {
                    console.log(result);
                    dialogs.showError(dString.substitute(Sage.Groups.GroupManager.resources.createAdHocGroupJobError, [result.result ? result.result : '']));
                },
                ensureZeroFilters: true
            };
            jobs.triggerJobAndDisplayProgressDialog(options);
        },

        _getDefaultGroupId: function () {
            var grpContextSvc = Sage.Services.getService('ClientGroupContext');
            if (grpContextSvc) {
                var contextService = grpContextSvc.getContext();
                return contextService.DefaultGroupID;
            }
            return '';
        },

        removeSelectionsFromGroup: function () {
            var selectionInfo = Sage.Utility.getSelectionInfo();
            if (selectionInfo.selectionCount === 0) {
                if (selectionInfo.recordCount < 1) {
                    dialogs.showInfo(Sage.Groups.GroupManager.resources.noRecordsInGroup, Sage.Groups.GroupManager.resources.noneSelectedTitle);
                } else {
                    var dialogBody = dString.substitute(Sage.Groups.GroupManager.resources.noneSelectedRemovePromptFmt, [selectionInfo.recordCount]);
                    dialogs.raiseQueryDialog(Sage.Groups.GroupManager.resources.noneSelectedTitle, dialogBody,
                        function (result) {
                            if (result === true) {
                                Sage.Groups.GroupManager.removeConfirmed();
                            }
                        },
                        Sage.Groups.GroupManager.resources.yesCaption,
                        Sage.Groups.GroupManager.resources.noCaption);
                }
            } else {
                Sage.Groups.GroupManager.removeConfirmed();
            }
        },
        removeConfirmed: function () {
            var selectionInfo = Sage.Utility.getSelectionInfo(),
                groupContext = Sage.Services.getService("ClientGroupContext").getContext(),
                family = groupContext.CurrentFamily,
                name = groupContext.CurrentName,
                groupId = groupContext.CurrentGroupID;

            Sage.Groups.GroupManager.removeIds(groupId, name, family, selectionInfo.selectedIds, function () {
                Sage.Groups.GroupManager.refreshListView();
            }, function (err) {
                console.error(err);
            }, this);
        },
        removeIds: function (groupId, groupName, family, ids, onSuccess, onFailure, scope) {
            var service = sDataServiceRegistry.getSDataService('system'),
                request = new Sage.SData.Client.SDataServiceOperationRequest(service),
                entry,
                onSuccessWrapper,
                idsRemoved = [];

            request.setResourceKind('groups');
            if (ids && ids.length > 0) {
                request.setOperationName('removeAdHocIds');
                idsRemoved = ids;
            } else {
                request.setOperationName('removeAllAdHocIds');
                idsRemoved.push(ids);
            }

            entry = {
                '$name': 'removeAdHocIds',
                request: {
                    groupId: groupId,
                    groupName: groupName,
                    family: family,
                    adHocIds: ids
                }
            };

            onSuccessWrapper = lang.hitch(this, function () {
                topic.publish('/group/adhoc/removed', { 'groupId': groupId, 'groupName': groupName, 'family': family, 'ids': idsRemoved });
                if (onSuccess) {
                    onSuccess.call(arguments);
                }
            });

            request.execute(entry, {
                success: onSuccessWrapper,
                failure: onFailure,
                scope: scope || this
            });
        },
        addSelectionsToGroup: function (groupId) {
            //Handle addition from details view
            var entityId = Sage.Utility.getCurrentEntityId();
            if (entityId !== '') {
                Sage.Groups.GroupManager.postAddToGroup(groupId, { selectedIds: [entityId], selectionCount: 1 });
            } else {
                //Handle additions from list view
                var selectionInfo = Sage.Utility.getSelectionInfo();
                if (selectionInfo.selectionCount === 0) {
                    if (selectionInfo.recordCount < 1) {
                        dialogs.showInfo(Sage.Groups.GroupManager.resources.noRecordsInGroup, Sage.Groups.GroupManager.resources.noneSelectedTitle);
                    } else {
                        var dialogBody = dString.substitute(Sage.Groups.GroupManager.resources.noneSelectedPromptFmt, [selectionInfo.recordCount]);
                        dialogs.raiseQueryDialog(Sage.Groups.GroupManager.resources.noneSelectedTitle, dialogBody,
                            function (result) {
                                if (result === true) {
                                    Sage.Groups.GroupManager.addConfirmed(groupId);
                                }
                            },
                            Sage.Groups.GroupManager.resources.yesCaption,
                            Sage.Groups.GroupManager.resources.noCaption);
                    }
                } else {
                    Sage.Groups.GroupManager.addConfirmed(groupId);
                }
            }
        },
        copyFromGroup: function (fromGroupId, toGroupId) {
            var service = sDataServiceRegistry.getSDataService('system'),
                request = new Sage.SData.Client.SDataServiceOperationRequest(service),
                groupContext = Sage.Services.getService("ClientGroupContext").getContext(),
                family = groupContext.CurrentFamily,
                name = groupContext.CurrentName,
                entry;

            request.setResourceKind('groups');
            request.setOperationName('addAdHocIdsFrom');

            entry = {
                '$name': 'addAdHocIdsFrom',
                request: {
                    groupId: toGroupId,
                    groupName: name,
                    family: family,
                    fromGroupId: fromGroupId
                }
            };

            request.execute(entry, {
                success: function () {
                    var ctxService = Sage.Services.getService('ClientGroupContext');
                    if (ctxService) {
                        var titlePane = dijit.byId('titlePane');
                        if (titlePane) {
                            titlePane.resetConfiguration();
                        }

                        ctxService.setCurrentGroup(toGroupId);
                    }
                },
                failure: function () {
                },
                scope: this
            });
        },
        addConfirmed: function (groupId) {
            var selectionInfo = Sage.Utility.getSelectionInfo();
            Sage.Groups.GroupManager.postAddToGroup(groupId, selectionInfo);
        },
        postAddToGroup: function (groupId, selectionInfo) {
            var service = sDataServiceRegistry.getSDataService('system'),
                request = new Sage.SData.Client.SDataServiceOperationRequest(service),
                groupContext = Sage.Services.getService("ClientGroupContext").getContext(),
                family = groupContext.CurrentFamily,
                fromGroupId = groupContext.CurrentGroupID,
                entry,
                operation = 'addAdHocIds';


            if (selectionInfo.selectionCount === 0) {
                Sage.Groups.GroupManager.copyFromGroup(fromGroupId, groupId);
                return;
            }

            request.setResourceKind('groups');
            request.setOperationName(operation);

            entry = {
                '$name': operation,
                request: {
                    groupId: groupId,
                    family: family,
                    adHocIds: selectionInfo.selectedIds /* adHocIds is ignored if operation is "all" */
                }
            };

            request.execute(entry, {
                success: function () {
                },
                failure: function () {
                },
                scope: this
            });
        },
        saveLookupAsGroup: function (obj, e, msg) {
            if (typeof (msg) === 'undefined') {
                msg = Sage.Groups.GroupManager.resources.groupNameText;
            }
            dialogs.raiseInputDialogExt({
                title: Sage.Groups.GroupManager.resources.saveLookupDlgTitle,
                query: msg,
                callbackFn: function (result, name) {
                    if (result === true) {
                        if (name === '') {
                            window.setTimeout(function () { Sage.Groups.GroupManager.saveLookupAsGroup(Sage.Groups.GroupManager.resources.newGroupRePrompt); }, 100);
                        } else if (name.match(/\'|\"|\/|\\|\*|\:|\?|<|\>/) !== null) {
                            window.setTimeout(function () { Sage.Groups.GroupManager.promptForName(Sage.Groups.GroupManager.resources.invalidCharMsg); }, 100);
                        } else {
                            var postUrl = "slxdata.ashx/slx/crm/-/groups/adhoc?action=SaveLookupAsGroup&name=" + encodeURIComponent(name);
                            xhr.post({
                                url: postUrl,
                                handleAs: 'text',
                                content: {},
                                load: Sage.Groups.GroupManager.newGroupCreated,
                                error: Sage.Groups.GroupManager.handleAjaxError
                            });
                        }
                    }
                },
                yesText: Sage.Groups.GroupManager.resources.okCaption,
                noText: Sage.Groups.GroupManager.resources.cancelCaption,
                defaultValue: '',
                closable: true
            });
        },
        handleAjaxError: function (request) {
            if (typeof request != 'undefined') {
                if (request.responseXML) {
                    var nodes = request.responseXML.getElementsByTagName('sdata:message');
                    if (nodes.length > 0) {
                        dialogs.showError(nodes[0].text || nodes[0].textContent, '');
                    }
                }
                else {
                    dialogs.alert("an unidentified exception has occured");
                }
            }
        },
        newGroupCreated: function () {
            Sage.Link.toListView();
        },
        refreshListView: function () {
            var listpanel = dijit.byId('list');
            if (listpanel) {
                listpanel.refreshList();
            }
        },
        emailSelectionsFromGroup: function () {
            var subject, body, nameOrder, emailField;
            subject = "";
            body = "";
            nameOrder = 0; // 0 = FirstLast; 1 = LastFirst.
            emailField = "Email"; // Valid values are "Email" (for Contact and Lead) and "SecondaryEmail" and "Email3" for Contact.
            // Works only for Contact and Lead groups.
            email.writeEmailToGroupSelection(subject, body, nameOrder, emailField);
        }
    };
    window.groupManager = Sage.Groups.GroupManager; //for backward compatibility
    return window.groupManager;
});
},
'Sage/Utility/Email':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'Sage/Utility',
    'Sage/Data/SDataServiceRegistry',
    'Sage/UI/Dialogs',
    'dojo/parser',
    'dojox/validate/regexp',
    'dojo/i18n!./nls/Email',
    'dojo/has'
],
// ReSharper disable InconsistentNaming
function (Utility, SDataServiceRegistry, Dialogs, parser, regexp, nls, has) {

    Sage.namespace('Utility.Email');
    dojo.mixin(Sage.Utility.Email, {
        resources: nls,
        /* ------------------------------------- writeEmail functionality ----------------------------------  */

        /**
        * writeEmail - generate an email with subject, body and one or more recipients
        * @param {string || object || array [of string] || array [of object]} recipent - if it is a string or array all items are added to the "To"
        *       if it is an object it can have the following properties whose values can be a single string, array of strings, single
        *       object or array of objects: to, cc, bcc
        * @param {string} subject - the subject line of the email
        * @param {string} body - the body of the email can be plain text or html if it is html, use isFormatted
        * @param {bool} isFormatted - if true, the body will be treated as formatted html
        * @param {number} nameOrder - 0 = format name as "John Abbott"; 1 = format name as "Abbott, John"
        */

        /*
        example:
        Sage.Utility.Email.writeEmail(
        {
        to: ['bob@mycompany.com', 'sally@mycompany'],
        cc: 'billy@othercompany.com',
        bcc: 'mom@hotmail.com'
        },
        'This is a good email - read it',
        'Hello all,<br />This is the <b>best</b> email you have ever gotten.<br /><br /> <span style="font-size:26px;font-weight:bold;">Pass it on to all of your contacts or you will have bad luck.</span>',
        true, 1);
        */
        writeEmail: function (recipient, subject, body, isFormatted, nameOrder) {

            if (dojo.isString(recipient) && (recipient.length > 0)) {
                // First, check to see if the recipient string represents a JSON object (such as would be passed when writeEmail is called from code behind).
                // Since we're not expecting JSON every time, there is no need to call JSON.parse for each request.
                if ((recipient.indexOf("{", 0) === 0) && (recipient.lastIndexOf("}") == recipient.length - 1)) {
                    try {
                        var objValue = dojo.fromJson(recipient);
                        if (dojo.isObject(objValue))
                            recipient = objValue;
                    } catch (e) {
                        Dialogs.showError(dojo.substitute(Utility.Email.resources.RecipientInfoError, [e.message]));
                        if (typeof console !== "undefined") {
                            console.error("There was an error attempting to parse the recipient data as JSON: %o", e); //DNL
                            console.error("recipient parameter: %o", recipient); //DNL
                        }
                        return;
                    }
                }
                // Does the string represent an array passed as a string?
                else if ((recipient.indexOf("[", 0) === 0) && (recipient.lastIndexOf("]") === recipient.length - 1)) {
                    recipient = eval(recipient);
                }
            }

            var self = this;

            require(['Sage/MailMerge/Helper', 'Sage/MailMerge/Service'], function (Helper, DesktopService) {

                // 0 = FirstLast (e.g. John Abbott <jabbot@abbott.demo>)
                // 1 = LastFirst (e.g. Abbott, John <jabbot@abbott.demo>) 
                var iNameOrder = 0;
                if (typeof nameOrder !== "undefined") {
                    if (!isNaN(nameOrder)) {
                        if (Number(nameOrder) == 1)
                            iNameOrder = 1;
                    }
                }
                var olBCC = 3, olCC = 2, olTo = 1; // Microsoft Outlook constants. These constants are also used below generically (for any e-mail client).
                var arrProps = ["to", "cc", "bcc"];
                var iRecipientType = 0;
                var sType = (dojo.isArray(recipient)) ? "array" : typeof recipient;
                var bHasRecipient = (sType !== "undefined") && (recipient !== null);

                var oRecipients = {
                    "to": [],
                    "cc": [],
                    "bcc": []
                };

                // Helper function to add the recipient to the correct array (i.e. TO, CC, or BCC).
                var fnAddRecipient = function (type, firstName, lastName, emailAddress) {
                    if (self.isValidEmailAddress(emailAddress || "")) {
                        var fnAddToArray = function (array) {
                            array.push({ "firstName": firstName || "", "lastName": lastName || "", "emailAddress": emailAddress || "" });
                        };
                        switch (type) {
                            case olCC:
                                fnAddToArray(oRecipients.cc);
                                break;
                            case olBCC:
                                fnAddToArray(oRecipients.bcc);
                                break;
                            default:
                                fnAddToArray(oRecipients.to);
                                break;
                        }
                    } else {
                        if (typeof console !== "undefined")
                            console.warn(dojo.string.substitute("Invalid or missing e-mail for ${0} ${1}. E-mail address: ${2}.", [firstName, lastName, emailAddress]));
                    }
                };

                // Parse the recipient parameter and add the corresponding data to the oRecipients object.
                if (bHasRecipient) {
                    var fnAddEmailObj = function (type, email) {
                        if (dojo.isObject(email))
                            fnAddRecipient(type, email.firstName || "", email.lastName || "", email.emailAddress || "");
                    };
                    switch (sType) {
                        case "string":
                            if (recipient !== "")
                                fnAddRecipient(olTo, "", "", recipient);
                            break;
                        case "array":
                            dojo.forEach(recipient, function (email) {
                                if (dojo.isString(email))
                                    fnAddRecipient(olTo, "", "", email);
                                else if (dojo.isObject(email))
                                    fnAddEmailObj(olTo, email);
                            });
                            break;
                        case "object":
                            iRecipientType = 0;
                            dojo.forEach(arrProps, function (prop) {
                                iRecipientType++; // olTo = 1; olCC = 2; olBCC = 3                            
                                if (recipient.hasOwnProperty(prop)) {
                                    switch ((dojo.isArray(recipient[prop])) ? "array" : typeof recipient[prop]) {
                                        case "string":
                                            fnAddRecipient(iRecipientType, "", "", recipient[prop]);
                                            break;
                                        case "array":
                                            dojo.forEach(recipient[prop], function (obj) {
                                                if (dojo.isString(obj))
                                                    fnAddRecipient(iRecipientType, "", "", obj);
                                                else if (dojo.isObject(obj))
                                                    fnAddEmailObj(iRecipientType, obj);
                                            });
                                            break;
                                        case "object":
                                            fnAddEmailObj(iRecipientType, recipient[prop]);
                                            break;
                                    }
                                }
                            });
                            break;
                    }
                }

                // Ensure that the recipient parameter is not used incorrectly after this point; the oRecipients object has the data we want now.
                recipient = undefined;

                // Sort proc used for sorting the recipient arrays.
                var fnCompare = function (obj1, obj2) {
                    var iCompare;
                    switch (iNameOrder) {
                        // LastFirst (e.g. Abbott, John <jabbot@abbott.demo>)                   
                        case 1:
                            iCompare = (obj1.lastName || "").toLocaleUpperCase().localeCompare((obj2.lastName || "").toLocaleUpperCase());
                            if (iCompare === 0)
                                iCompare = (obj1.firstName || "").toLocaleUpperCase().localeCompare((obj2.firstName || "").toLocaleUpperCase());
                            break;
                        // FirstLast (e.g. John Abbott <jabbot@abbott.demo>)                   
                        default:
                            iCompare = (obj1.firstName || "").toLocaleUpperCase().localeCompare((obj2.firstName || "").toLocaleUpperCase());
                            if (iCompare === 0)
                                iCompare = (obj1.lastName || "").toLocaleUpperCase().localeCompare((obj2.lastName || "").toLocaleUpperCase());
                    }
                    return iCompare;
                };

                var sSubject = (dojo.isString(subject)) ? subject : "";

                // Note: body can be plain text or HTML (e.g. <HTML>Hello <B>World</B></HTML>).
                var sBody = (dojo.isString(body)) ? body : "";

                var iRecipientLength = oRecipients.to.length + oRecipients.cc.length + oRecipients.bcc.length;
                bHasRecipient = (iRecipientLength > 0);
                
                // Use SageGears with Desktop Integration if it and Microsoft Outlook are available.
                var oService = Helper.GetDesktopService(false /* Do not show an error if the service cannot be loaded. */);
                if (oService) {
                    if (typeof oService.MailMergeGUI !== "undefined") {
                        // Make sure that at least the 8.x version of SLXMMGUIW.DLL being used.
                        if (typeof oService.MailMergeGUI().OutlookIsAvailable !== "undefined" && oService.MailMergeGUI().OutlookIsAvailable) {
                            // SageGears does not like NULL parameters when it's expecting an IDispatch interface, so create an empty array.
                            var arrRecipients = oService.NewActiveXObject("SLXMMGUIW.MultidimensionalArray");
                            var iColumnCount = 4;
                            arrRecipients.Resize(0, iColumnCount);
                            if (bHasRecipient) {
                                arrRecipients.Resize(iRecipientLength, iColumnCount);
                                iRecipientType = 0;
                                var iRow = 0;
                                dojo.forEach(arrProps, function (prop) {
                                    iRecipientType++; // olTo = 1; olCC = 2; olBCC = 3 
                                    var arrRecipientObjs = oRecipients[prop];
                                    if (dojo.isArray(arrRecipientObjs) && arrRecipientObjs.length > 0) {
                                        arrRecipientObjs.sort(fnCompare);
                                        dojo.forEach(arrRecipientObjs, function (obj) {
                                            arrRecipients.SetValue(iRow, 0, obj.firstName || "");
                                            arrRecipients.SetValue(iRow, 1, obj.lastName || "");
                                            arrRecipients.SetValue(iRow, 2, obj.emailAddress || "");
                                            arrRecipients.SetValue(iRow, 3, iRecipientType);
                                            iRow++;
                                        });
                                    }
                                });
                            }
                            // Use Extended MAPI to access the Outlook recipients and other properties; if we do not do
                            // this there will be a security prompt, depending on Outlook version and heuristics.                            
                            oService.MailMergeGUI().WriteEmailEx(arrRecipients, sSubject, sBody, iNameOrder);
                            return;
                        } else {
                            if (typeof console !== "undefined") {
                                // SLXMMGUIW.DLL is installed, but it's an older version.
                                if (typeof oService.MailMergeGUI().OutlookIsAvailable === "undefined")
                                    console.error("The request to e-mail could not be processed by Desktop Integration. An older version of SLXMMGUIW.DLL appears to be installed."); //DNL
                                else
                                // If Microsoft Outlook is unavailable.
                                    console.warn("The request to e-mail could not be processed by Desktop Integration. Microsoft Outlook is unavailable."); //DNL
                            }
                        }
                    }
                }

                // Format the recipient text as it will appear in the e-mail TO, CC, and BCC fields.
                var fnGetRecipientText = function (firstName, lastName, email) {
                    var sResult = "";
                    var sFirstName = firstName || "";
                    var sLastName = lastName || "";
                    var sEmail = email || "";
                    if (sFirstName !== "" && sLastName !== "") {
                        // iNameOrder: 0 = FirstLast; 1 = LastFirst.
                        switch (iNameOrder) {
                            case 1:
                                sResult = sLastName + ", " + sFirstName;
                                break;
                            default:
                                sResult = sFirstName + " " + sLastName;
                                break;
                        }
                    } else if (sLastName === "" && sFirstName !== "") sResult = sFirstName;
                    else if (sLastName !== "" && sFirstName === "") sResult = sLastName;
                    if (sResult === "") return sEmail;
                    sResult = dojo.string.substitute("${0} <${1}>", [sResult, sEmail]);
                    return sResult;
                };

                // Attempt to use the Outlook object model if Desktop Integration could not be used to send the e-mail.
                if (has('trident') || typeof ActiveXObject !== "undefined") {
                    try {
                        var outlook = new ActiveXObject("Outlook.Application");
                        var message = outlook.CreateItem(0);                        
                        if (sSubject !== "") {
                            message.Subject = sSubject;
                        }                        
                        if (sBody !== "") {
                            if (isFormatted) {
                                message.HTMLBody = sBody;
                            } else {
                                message.Body = sBody;
                            }
                        }                        
                        iRecipientType = 0;
                        dojo.forEach(arrProps, function (prop) {
                            iRecipientType++; // olTo = 1; olCC = 2; olBCC = 3 
                            var arrRecipientObjs = oRecipients[prop];
                            if (dojo.isArray(arrRecipientObjs) && arrRecipientObjs.length > 0) {
                                arrRecipientObjs.sort(fnCompare);
                                dojo.forEach(arrRecipientObjs, function (obj) {
                                    var address = fnGetRecipientText(obj.firstName, obj.lastName, obj.emailAddress);
                                    var recip = message.Recipients.Add(address);
                                    recip.Type = iRecipientType;
                                });
                            }
                        });                        
                        message.Display();
                        return;                        
                    } catch (e) {
                        if (typeof console !== 'undefined') {
                            console.warn('There was an error attempting to generate an e-mail using Microsoft Outlook: ' + e);
                        }
                    }
                }

                // If we get this far it means that Desktop Integration was [not] used to create the e-mail message. We'll use the mailto: protocol instead.
                if (typeof console !== "undefined")
                    console.info("Falling back to the mailto: protocol to create the e-mail message."); //DNL

                /*
                //BEGIN Supporting writeEmail functions
                * Add all strings in parts to str
                * @param {String} str - current value we need to add to
                * @param {Array} parts
                * @param {Number} maxLength
                * @param {String} (optional) separator.  Note the separator is not url encoded.
                * @param {bool} (optional) doEncode.  Defaults to true.  If false, strings won't be url encoded.
                * @param {bool} (optional partialOk.  Defaults to true.  If false, only whole strings from the parts array will be included.
                */
                var addUrlComponents = function (str, parts, maxLength, separator, doEncode, partialOk) {
                    if (typeof parts == "string")
                        parts = [parts];
                    var encode;
                    if (doEncode === false)
                        encode = function (x) { return x; };
                    else
                        encode = function (x) { return encodeURIComponent(x); };
                    for (var i = 0; i < parts.length && str.length < maxLength; i++) {
                        var left = maxLength - str.length;
                        var part = parts[i];
                        if (i > 0 && separator)
                            left--;
                        if (left === 0 || (partialOk === false && left < part.length))
                            continue;
                        part = part.substr(0, left);

                        var ns = encode(part);
                        if (str.length + ns.length > maxLength) {
                            if (partialOk === false)
                                continue;
                            var right = 0;
                            var overflow = ns.length - left;
                            while (overflow > 0) {
                                right++;
                                overflow -= encode(part.charAt(part.length - right)).length;
                            }
                            if (right >= part.length)
                                continue;
                            ns = encode(part.substr(0, part.length - right));
                        }
                        if (i > 0 && separator)
                            str += separator;
                        str += ns;
                    }
                    return str;
                };

                // Get the recipients for each type (i.e. TO, CC, or BCC).
                var fnGetRecipients = function (type) {
                    var arrMailRecipients = [];
                    var arrRecipientsByType;
                    switch (type) {
                        case olCC:
                            arrRecipientsByType = oRecipients.cc;
                            break;
                        case olBCC:
                            arrRecipientsByType = oRecipients.bcc;
                            break;
                        default:
                            arrRecipientsByType = oRecipients.to;
                            break;
                    }
                    if (dojo.isArray(arrRecipientsByType) && arrRecipientsByType.length > 0) {
                        // Sort the recipients
                        arrRecipientsByType.sort(fnCompare);
                        dojo.forEach(arrRecipientsByType, function (obj) {
                            var sMailTo = fnGetRecipientText(obj.firstName || "", obj.lastName || "", obj.emailAddress || "");
                            arrMailRecipients.push(sMailTo);
                        });
                    }
                    return arrMailRecipients;
                };

                //END Supporting writeEmail functions
                var maxRecipLen = (subject || body) ? 1500 : 2040;
                var arrTo = fnGetRecipients(olTo);
                // To:
                var url = addUrlComponents("mailto:", (dojo.isArray(arrTo) ? arrTo : []), maxRecipLen, ";", false, false);
                var bQueryStringInitialized = false;
                var fnAddParameter = function (param) {
                    var sParam = (bQueryStringInitialized) ? "&" : "?";
                    sParam += param + "=";
                    bQueryStringInitialized = true;
                    return sParam;
                };
                // Subject
                if (dojo.isString(subject) && subject !== "") {
                    url += fnAddParameter("subject");
                    url = addUrlComponents(url, subject, 1700);
                }
                // CC:
                var arrCarbonCopy = fnGetRecipients(olCC);
                if (dojo.isArray(arrCarbonCopy) && arrCarbonCopy.length > 0) {
                    url += fnAddParameter("cc");
                    url = addUrlComponents(url, arrCarbonCopy, maxRecipLen, ";", false, false);
                }
                // BCC:
                var arrBlindCopy = fnGetRecipients(olBCC);
                if (dojo.isArray(arrBlindCopy) && arrBlindCopy.length > 0) {
                    url += fnAddParameter("bcc");
                    url = addUrlComponents(url, arrBlindCopy, maxRecipLen, ";", false, false);
                }
                // Body
                if (dojo.isString(body) && body !== "") {
                    url += fnAddParameter("body");
                    url = addUrlComponents(url, body, 2000);
                }
                if (typeof console !== "undefined") {
                    console.debug("mailto: protocol URL length = %o", url.length);
                    console.debug("url: %o", url);
                }
                try {
                    location.href = url;
                } catch (e) {
                    //Component returned failure code: 0x80004005 (NS_ERROR_FAILURE) [nsIDOMLocation.href]
                    Dialogs.showError(dojo.string.substitute(Utility.Email.resources.MailToProtocolError,
                        [url.length, (typeof e.toMessage == "function") ? e.toMessage() : e.message]));
                }
            });
        }, // End writeEmail

        // isWriteEmailToIdsSupported
        isWriteEmailToIdsSupported: function (maintable) {
            if (!dojo.isString(maintable) || maintable === "") {
                if (typeof console !== "undefined")
                    console.error("The maintable argument is invalid in isWriteEmailToIdsSupported(maintable)."); //DNL
            }
            // Currently only Contact or Lead is supported for writeEmailToIds.               
            var sMainTable = (dojo.isString(maintable)) ? maintable.toUpperCase() : "";
            return (sMainTable == "CONTACT" || sMainTable == "LEAD");
        },

        // isValidEmailAddress
        __emailValidationRegEx: null,
        isValidEmailAddress: function (email) {
            if (this.__emailValidationRegEx === null)
                this.__emailValidationRegEx = new RegExp(dojox.validate.regexp.emailAddress());
            if (dojo.isString(email))
                return this.__emailValidationRegEx.test(email);
            return false;
        },

        // writeEmailToIds
        writeEmailToIds: function (arrEntityIds, maintable, subject, body, nameOrder, emailField) {
            if (!this.isWriteEmailToIdsSupported(maintable)) {
                Dialogs.showError(Utility.Email.resources.InvalidContextError);
                return;
            }
            if (!dojo.isArray(arrEntityIds)) {
                Dialogs.showError(Utility.Email.resources.InvalidArgumentError);
                return;
            }

            var self = this;

            require(['Sage/MailMerge/Helper', 'Sage/MailMerge/Service'], function (Helper, DesktopService) {

                console.debug('in it');

                var sMainTable = maintable.toUpperCase();

                // Remove duplicate entity ids.
                var iDuplicateCount = 0;
                arrEntityIds.sort();
                var arrEntityIdsNoDupes = [];
                dojo.forEach(arrEntityIds, function (id) {
                    if (dojo.indexOf(arrEntityIdsNoDupes, id) == -1)
                        arrEntityIdsNoDupes.push(id);
                    else {
                        iDuplicateCount++;
                        if (typeof console !== "undefined")
                            console.info("Filtering out duplicate entity Id: %o", id);
                    }
                });
                arrEntityIds = arrEntityIdsNoDupes;

                // Quote each id for the SData query.
                dojo.forEach(arrEntityIds, function (id, idx) {
                    arrEntityIds[idx] = "'" + id + "'";
                });

                // Determine the number of HTTP SData requests that will be required.
                // NOTE: SData supports a maximum of 100 items for an IN clause.
                var iRequestCount = 1;
                if (arrEntityIds.length > 100) {
                    iRequestCount = Math.floor(arrEntityIds.length / 100);
                    if ((arrEntityIds.length % 100) !== 0)
                        iRequestCount++;
                }

                // 0 = FirstLast; 1 = LastFirst.
                var iNameOrder = 0;
                if (typeof nameOrder !== "undefined") {
                    if (!isNaN(nameOrder)) {
                        if (Number(nameOrder) == 1)
                            iNameOrder = 1;
                    }
                }

                var bIsContactEntity = (sMainTable == "CONTACT");
                var sEmailField = "Email"; //DNL            
                if (dojo.isString(emailField) && emailField !== "" && bIsContactEntity) {
                    var sEmailFieldUpper = emailField.toUpperCase();
                    switch (sEmailFieldUpper) {
                        case "SECONDARYEMAIL":
                            sEmailField = "SecondaryEmail"; //DNL
                            if (typeof console !== "undefined")
                                console.info("Using the Contact.SecondaryEmail field."); //DNL
                            break;
                        case "EMAIL3":
                            sEmailField = "Email3"; //DNL
                            if (typeof console !== "undefined")
                                console.info("Using the Contact.Email3 field."); //DNL
                            break;
                        default:
                            if (sEmailFieldUpper != "EMAIL")
                                if (typeof console !== "undefined")
                                    console.warn("Invalid Contact e-mail field: %o", sEmailField); //DNL
                            if (typeof console !== "undefined")
                                console.log("Using the Contact.Email field."); //DNL
                            break;
                    }
                }

                var iMissingOrInvalidEmailCount = 0; // The number of entities that had an invaild or missing e-mail address.
                var iCannotSolicitCount = 0; // The number of entities that were marked DoNotEmail or DoNotSolicit.
                var iRequest; // The current request.
                var iResponseCount = 0; // The number of successful HTTP responses.

                var oSelectedEntities = { "data": [] }; // Temporary entity store.            
                var fnAddEntityData = function (key, firstName, lastName, emailAddress) {
                    oSelectedEntities.data.push({ "key": key || "", "firstName": firstName || "", "lastName": lastName || "", "emailAddress": emailAddress || "" });
                };

                // Desktop Integration
                var oService = Helper.GetDesktopService(false /* Do not show an error if the service cannot be loaded. */);

                // Process each SData request.
                for (iRequest = 0; iRequest < iRequestCount; iRequest++) {
                    var fnProcessRequest = function () {
                        var iArraySize = 100;
                        if (arrEntityIds.length < 100)
                            iArraySize = arrEntityIds.length;
                        var arrRequestIds = new Array(iArraySize);
                        var iEntityId;
                        for (iEntityId = 0; iEntityId < iArraySize; iEntityId++)
                            arrRequestIds[iEntityId] = arrEntityIds.shift();
                        var sFmtString = (arrRequestIds.length > 1) ? "Id in (${0})" : "Id eq ${0}";
                        var sWhere = dojo.string.substitute(sFmtString, [arrRequestIds.join(",")]);
                        var oSDataService = Sage.Data.SDataServiceRegistry.getSDataService("dynamic");
                        var oSDataRequest = new Sage.SData.Client.SDataResourceCollectionRequest(oSDataService);
                        oSDataRequest.setResourceKind((sMainTable == "LEAD") ? "leads" : "contacts");
                        var sFields = "FirstName,LastName,DoNotSolicit,DoNotEmail," + sEmailField;
                        oSDataRequest.setQueryArg("select", sFields);
                        oSDataRequest.setQueryArg("where", sWhere);
                        oSDataRequest.read({
                            httpMethodOverride: true,
                            success: function (data) {
                                iResponseCount++;
                                var oResources = (typeof data !== "undefined" && data !== null) ? data["$resources"] : null;
                                if (dojo.isArray(oResources) && oResources.length > 0) {
                                    var iEntity;
                                    for (iEntity = 0; iEntity < oResources.length; iEntity++) {
                                        var sEntityId = oResources[iEntity].$key || "";
                                        var sEmailAddress;
                                        switch (sEmailField) {
                                            case "SecondaryEmail":
                                                //DNL
                                                sEmailAddress = oResources[iEntity].SecondaryEmail || "";
                                                break;
                                            case "Email3":
                                                //DNL
                                                sEmailAddress = oResources[iEntity].Email3 || "";
                                                break;
                                            default:
                                                sEmailAddress = oResources[iEntity].Email || "";
                                                break;
                                        }
                                        var sFirstName = oResources[iEntity].FirstName || "";
                                        var sLastName = oResources[iEntity].LastName || "";
                                        var bDoNotEmail = oResources[iEntity].DoNotEmail || false;
                                        var bDoNotSolicit = oResources[iEntity].DoNotSolicit || false;
                                        if (sEmailAddress !== "" && self.isValidEmailAddress(sEmailAddress) && !bDoNotEmail && !bDoNotSolicit)
                                            fnAddEntityData(sEntityId, sFirstName, sLastName, sEmailAddress);
                                        else {
                                            if (bDoNotEmail || bDoNotSolicit) {
                                                iCannotSolicitCount++;
                                                if (typeof console !== "undefined")
                                                    console.warn(dojo.string.substitute("Cannot solicit ${0} ${1} (${2}).", [sFirstName, sLastName, sEntityId]));
                                            } else {
                                                iMissingOrInvalidEmailCount++;
                                                if (typeof console !== "undefined")
                                                    console.warn(dojo.string.substitute("Invalid e-mail for ${0} ${1} (${2}). E-mail address: ${3}.", [sFirstName, sLastName, sEntityId, sEmailAddress]));
                                            }
                                        }
                                    }
                                }
                                // Has the FINAL SData response been processed?
                                if (iResponseCount == iRequestCount) {
                                    var sExclusions = null;
                                    if (iCannotSolicitCount > 0 || iMissingOrInvalidEmailCount > 0 || iDuplicateCount > 0)
                                        sExclusions = dojo.string.substitute(Utility.Email.resources.FilteredOutMsg, [iCannotSolicitCount, iMissingOrInvalidEmailCount, iDuplicateCount]);
                                    var enumRecipientType = {
                                        rtTo: 0,
                                        rtCC: 1,
                                        rtBCC: 2
                                    };
                                    var oRecipients = {
                                        "to": [],
                                        "cc": [],
                                        "bcc": []
                                    };
                                    // Add the recipient to one of the arrays in oRecipients.
                                    var fnAddRecipient = function (type, firstName, lastName, emailAddress) {
                                        var fnAddToArray = function (array) {
                                            array.push({ "firstName": firstName || "", "lastName": lastName || "", "emailAddress": emailAddress || "" });
                                        };
                                        switch (type) {
                                            case enumRecipientType.rtCC:
                                                fnAddToArray(oRecipients.cc);
                                                break;
                                            case enumRecipientType.rtBCC:
                                                fnAddToArray(oRecipients.bcc);
                                                break;
                                            default:
                                                // enumRecipientType.rtTo
                                                fnAddToArray(oRecipients.to);
                                                break;
                                        }
                                    };
                                    var oRecipient;
                                    if (oSelectedEntities.data.length > 1) {
                                        if (iMissingOrInvalidEmailCount > 0)
                                            if (typeof console !== "undefined")
                                                console.warn(dojo.string.substitute("Total number of entities that had an invalid or missing e-mail address: ${0}. These entities have been excluded.", [iMissingOrInvalidEmailCount])); //DNL
                                        if (iCannotSolicitCount > 0)
                                            if (typeof console !== "undefined")
                                                console.warn(dojo.string.substitute("Total number of entities that were marked as DoNotEmail or DoNotSolicit: ${0}. These entities have been excluded.", [iCannotSolicitCount])); //DNL
                                        if (iDuplicateCount > 0)
                                            if (typeof console !== "undefined")
                                                console.info(dojo.string.substitute("Total number of entities excluded because they were duplicates: ${0}.", [iDuplicateCount])); //DNL
                                        var i;
                                        // If Desktop Integration is available we'll prompt the user with the selection dialog.                                    
                                        if (oService) {
                                            var oSelectEmailInfo = new Sage.SelectEmailInfo();
                                            dojo.forEach(oSelectedEntities.data, function (entity) {
                                                oSelectEmailInfo.AddInfo("", "", entity.key, entity.emailAddress, entity.firstName, entity.lastName, "", "", false);
                                            });
                                            var sStatusText = (dojo.isString(sExclusions)) ? sExclusions : "";
                                            // NOTE: The oService.SelectEmailNames() dialog filters out duplicate entity ids and the entities will be sorted.
                                            var oSelectedInfo = oService.SelectEmailNames(oSelectEmailInfo, MaxTo.maxNoMax, sStatusText);
                                            if (oSelectedInfo !== null && oSelectedInfo.Recipients.length > 0) {
                                                for (i = 0; i < oSelectedInfo.Recipients.length; i++) {
                                                    oRecipient = oSelectedInfo.Recipients[i];
                                                    // Note: CASE is different between Desktop Integration and non-Desktop Integration.
                                                    fnAddRecipient(oRecipient.Type, oRecipient.FirstName, oRecipient.LastName, oRecipient.EmailAddress);
                                                }
                                            } else
                                            // The user canceled or did not select any entities.
                                                return;
                                        }
                                        // NON-Desktop Integration. In the future we may create a dojo based dialog.
                                        else {
                                            dojo.forEach(oSelectedEntities.data, function (entity) {
                                                // Note: CASE is different between Desktop Integration and non-Desktop Integration.
                                                fnAddRecipient(enumRecipientType.rtTo, entity.firstName, entity.lastName, entity.emailAddress);
                                            });
                                        }
                                    } else {
                                        if (oSelectedEntities.data.length == 1) {
                                            oRecipient = oSelectedEntities.data[0];
                                            // Note: CASE is different between Desktop Integration and non-Desktop Integration.
                                            fnAddRecipient(enumRecipientType.rtTo, oRecipient.firstName, oRecipient.lastName, oRecipient.emailAddress);
                                        } else {
                                            var sFailureMsg = Utility.Email.resources.AllInvalidEmailError;
                                            if (bIsContactEntity && sEmailField != "Email") //DNL
                                                sFailureMsg += dojo.string.substitute(" " + Utility.Email.resources.EmailFieldQueried, ["Contact." + sEmailField]);
                                            Dialogs.showInfo(sFailureMsg);
                                            return;
                                        }
                                    }
                                    var sSubject = (dojo.isString(subject)) ? subject : "";
                                    // Note: body can be plain text or HTML (e.g. <HTML>Hello <B>World</B></HTML>).                                                   
                                    var sBody = (dojo.isString(body)) ? body : "";
                                    // "<HTML></HTML>"
                                    var bFormatted = (sBody.length > 13) ? (sBody.indexOf("<HTML", sBody.substring(0, 4).toUpperCase()) === 0) : false;
                                    self.writeEmail(oRecipients, sSubject, sBody, bFormatted, iNameOrder);
                                }
                            },
                            failure: function (xhr, sdata) {
                                var options = { message: Utility.Email.resources.EntityInfoError };
                                Utility.ErrorHandler.handleHttpError(xhr, sdata, options);
                            },
                            scope: this
                        });
                    };
                    fnProcessRequest();
                }
            });
        }, // End writeEmailToIds

        // writeEmailToGroupSelection
        writeEmailToGroupSelection: function (subject, body, nameOrder, emailField) {
            if (Utility.getModeId() != "list") {
                Dialogs.showInfo(Utility.Email.resources.CapabilityModeError);
                return;
            }
            var oGroupContext = Sage.Services.getService("ClientGroupContext");
            if (!dojo.isObject(oGroupContext)) return;
            var sMainTable = oGroupContext.getContext().CurrentTable;
            if (!this.isWriteEmailToIdsSupported(sMainTable)) {
                Dialogs.showError(Utility.Email.resources.CapabilityEntityError);
                return;
            }
            var oPanel = dijit.byId("list");
            if (!dojo.isObject(oPanel)) return;
            var oSelectionInfo = oPanel.getSelectionInfo();
            if (!dojo.isObject(oSelectionInfo) || !oSelectionInfo.hasOwnProperty("selectionCount") || oSelectionInfo.selectionCount <= 0) {
                Dialogs.showInfo(Utility.Email.resources.NoRowsSelectedError);
                return;
            }
            var arrEntityIds = new Array(oSelectionInfo.selections.length);
            dojo.forEach(oSelectionInfo.selections, function (item, idx) {
                arrEntityIds[idx] = item.id;
            });
            this.writeEmailToIds(arrEntityIds, sMainTable, subject, body, nameOrder, emailField);
        }
    });

    return Sage.Utility.Email;
});

},
'dojox/storage/LocalStorageProvider':function(){
define([
	"dojo/_base/declare",
	"dojox/storage/Provider",
	"dojox/storage/manager",
	"dojo/_base/array",
	"dojo/_base/lang",
	"dojo/json"
	], function(declare, Provider, storageManager, array, lang, JSON){
	var LocalStorageProvider = declare("dojox.storage.LocalStorageProvider", [Provider], {
		store: null,
		initialize: function(){

			this.store = localStorage;

			this.initialized = true;
			storageManager.loaded();
		},

		isAvailable: function(){ /*Boolean*/
			return typeof localStorage != 'undefined';
		},

		put: function(	/*string*/ key,
						/*object*/ value,
						/*function*/ resultsHandler,
						/*string?*/ namespace){

			// TODO: Use the events as specified in http://dev.w3.org/html5/webstorage/#the-storage-event ?
			//	Currently, the storage event is not reliable around browsers.

			this._assertIsValidKey(key);

			namespace = namespace||this.DEFAULT_NAMESPACE;
			this._assertIsValidNamespace(namespace);

			var fullKey = this.getFullKey(key,namespace);

			// prepending a prefix to a string value
			// will result in that prefix not being
			// usable as a value, so we better use
			// toJson() always.
			value = JSON.stringify(value);

			try { // ua may raise an QUOTA_EXCEEDED_ERR exception
				this.store.setItem(fullKey,value);

				if(resultsHandler){
					resultsHandler(this.SUCCESS, key, null, namespace);
				}
			} catch(e) {
				if(resultsHandler){
					resultsHandler(this.FAILED, key, e.toString(), namespace);
				}
			}
		},

		get: function(/*string*/ key, /*string?*/ namespace){ /*Object*/
			this._assertIsValidKey(key);

			namespace = namespace||this.DEFAULT_NAMESPACE;
			this._assertIsValidNamespace(namespace);

			// get our full key name, which is namespace + key
			key = this.getFullKey(key, namespace);

			return JSON.parse(this.store.getItem(key));
		},

		getKeys: function(/*string?*/ namespace){ /*Array*/
			namespace = namespace||this.DEFAULT_NAMESPACE;
			this._assertIsValidNamespace(namespace);

			namespace = '__'+namespace+'_'

			var keys = [];
			for(var i = 0; i < this.store.length; i++){
				var currentKey = this.store.key(i);
				if(this._beginsWith(currentKey,namespace)){
					currentKey = currentKey.substring(namespace.length);
					keys.push(currentKey);
				}
			}

			return keys;
		},

		clear: function(/*string?*/ namespace){
			// Um, well, the 'specs' in Provider.js say that if
			// no namespace is given, this method should nuke
			// the *complete* storage. As other components might
			// be using localStorage too, this might not be a
			// good idea, so this method won't do it.

			namespace = namespace||this.DEFAULT_NAMESPACE;
			this._assertIsValidNamespace(namespace);

			namespace = '__'+namespace+'_';

			var keys = [];
			for(var i = 0; i < this.store.length; i++){
				if(this._beginsWith(this.store.key(i),namespace)){
					keys.push(this.store.key(i));
				}
			}

			array.forEach(keys, lang.hitch(this.store, "removeItem"));
		},

		remove: function(/*string*/ key, /*string?*/ namespace){
			namespace = namespace||this.DEFAULT_NAMESPACE;
			this._assertIsValidNamespace(namespace);

			this.store.removeItem(this.getFullKey(key, namespace));
		},

		getNamespaces: function(){ /*string[]*/
			// There must be a better way than
			// to execute a regex on *every*
			// item in the store.

			var results = [ this.DEFAULT_NAMESPACE];

			var found = {};
			found[this.DEFAULT_NAMESPACE] = true;
			var tester = /^__([^_]*)_/;

			for(var i = 0; i < this.store.length; i++){
				var currentKey = this.store.key(i);
				if(tester.test(currentKey) == true){
					var currentNS = currentKey.match(tester)[1];
					if(typeof found[currentNS] == "undefined"){
						found[currentNS] = true;
						results.push(currentNS);
					}
				}
			}

			return results;
		},

		isPermanent: function(){ /*Boolean*/
			return true;
		},

		getMaximumSize: function(){ /* mixed */
			return dojox.storage.SIZE_NO_LIMIT;
		},

		hasSettingsUI: function(){ /*Boolean*/
			return false;
		},

		isValidKey: function(/*string*/ keyName){ /*Boolean*/
			if(keyName === null || keyName === undefined){
				return false;
			}

			return /^[0-9A-Za-z_-]*$/.test(keyName);
		},

		isValidNamespace: function(/*string*/ keyName){ /*Boolean*/
			// we *must* prevent namespaces from having
			// underscores - else lookup of namespaces
			// via RegEx (e.g. in getNamespaces ) would
			// return wrong results.
			//
			// The only way around this would be to
			// disallow underscores in keys.

			if(keyName === null || keyName === undefined){
				return false;
			}

			return /^[0-9A-Za-z-]*$/.test(keyName);
		},

		getFullKey: function(key, namespace){
			// checks for valid namespace and
			// key are already performed.
			return "__" + namespace + "_" + key;
		},

		_beginsWith: function(/* string */ haystack, /* string */ needle) {
			if(needle.length > haystack.length) {
				return false;
			}
			return haystack.substring(0,needle.length) === needle;
		},

		_assertIsValidNamespace: function(/* string */ namespace){
			if(this.isValidNamespace(namespace) === false){
				throw new Error("Invalid namespace given: " + namespace);
			}
		},

		_assertIsValidKey: function(/* string */ key){
			if(this.isValidKey(key) === false){
				throw new Error("Invalid key given: " + key);
			}
		}
	});
	storageManager.register("dojox.storage.LocalStorageProvider", new LocalStorageProvider());
	return LocalStorageProvider;
});

},
'dojox/storage/Provider':function(){
define([
	"dojo/_base/array",
	"dojo/_base/declare",
	"dojo/_base/lang"
	], function(array, declare, lang){
	return declare("dojox.storage.Provider", null, {
		// summary: A singleton for working with dojox.storage.
		// description:
		//		dojox.storage exposes the current available storage provider on this
		//		platform. It gives you methods such as dojox.storage.put(),
		//		dojox.storage.get(), etc.
		//
		//		For more details on dojox.storage, see the primary documentation
		//		page at
		//			http://manual.dojotoolkit.org/storage.html
		//
		//		Note for storage provider developers who are creating subclasses-
		//		This is the base class for all storage providers Specific kinds of
		//		Storage Providers should subclass this and implement these methods.
		//		You should avoid initialization in storage provider subclass's
		//		constructor; instead, perform initialization in your initialize()
		//		method.
		constructor: function(){
		},
		
		// SUCCESS: String
		//	Flag that indicates a put() call to a
		//	storage provider was succesful.
		SUCCESS: "success",
		
		// FAILED: String
		//	Flag that indicates a put() call to
		//	a storage provider failed.
		FAILED: "failed",
		
		// PENDING: String
		//	Flag that indicates a put() call to a
		//	storage provider is pending user approval.
		PENDING: "pending",
		
		// SIZE_NOT_AVAILABLE: String
		//	Returned by getMaximumSize() if this storage provider can not determine
		//	the maximum amount of data it can support.
		SIZE_NOT_AVAILABLE: "Size not available",
		
		// SIZE_NO_LIMIT: String
		//	Returned by getMaximumSize() if this storage provider has no theoretical
		//	limit on the amount of data it can store.
		SIZE_NO_LIMIT: "No size limit",

		// DEFAULT_NAMESPACE: String
		//	The namespace for all storage operations. This is useful if several
		//	applications want access to the storage system from the same domain but
		//	want different storage silos.
		DEFAULT_NAMESPACE: "default",
		
		// onHideSettingsUI: Function
		//	If a function is assigned to this property, then when the settings
		//	provider's UI is closed this function is called. Useful, for example,
		//	if the user has just cleared out all storage for this provider using
		//	the settings UI, and you want to update your UI.
		onHideSettingsUI: null,

		initialize: function(){
			// summary:
			//		Allows this storage provider to initialize itself. This is
			//		called after the page has finished loading, so you can not do
			//		document.writes(). Storage Provider subclasses should initialize
			//		themselves inside of here rather than in their function
			//		constructor.
			console.warn("dojox.storage.initialize not implemented");
		},
		
		isAvailable: function(){ /*Boolean*/
			// summary:
			//		Returns whether this storage provider is available on this
			//		platform.
			console.warn("dojox.storage.isAvailable not implemented");
		},

		put: function(	/*string*/ key,
						/*object*/ value,
						/*function*/ resultsHandler,
						/*string?*/ namespace){
			// summary:
			//		Puts a key and value into this storage system.
			// description:
			//		Example-
			//			var resultsHandler = function(status, key, message, namespace){
			//			  alert("status="+status+", key="+key+", message="+message);
			//			};
			//			dojox.storage.put("test", "hello world", resultsHandler);
			//
			//			Arguments:
			//
			//			status - The status of the put operation, given by
			//								dojox.storage.FAILED, dojox.storage.SUCCEEDED, or
			//								dojox.storage.PENDING
			//			key - The key that was used for the put
			//			message - An optional message if there was an error or things failed.
			//			namespace - The namespace of the key. This comes at the end since
			//									it was added later.
			//
			//		Important note: if you are using Dojo Storage in conjunction with
			//		Dojo Offline, then you don't need to provide
			//		a resultsHandler; this is because for Dojo Offline we
			//		use Google Gears to persist data, which has unlimited data
			//		once the user has given permission. If you are using Dojo
			//		Storage apart from Dojo Offline, then under the covers hidden
			//		Flash might be used, which is both asychronous and which might
			//		get denied; in this case you must provide a resultsHandler.
			// key:
			//		A string key to use when retrieving this value in the future.
			// value:
			//		A value to store; this can be any JavaScript type.
			// resultsHandler:
			//		A callback function that will receive three arguments. The
			//		first argument is one of three values: dojox.storage.SUCCESS,
			//		dojox.storage.FAILED, or dojox.storage.PENDING; these values
			//		determine how the put request went. In some storage systems
			//		users can deny a storage request, resulting in a
			//		dojox.storage.FAILED, while in other storage systems a storage
			//		request must wait for user approval, resulting in a
			//		dojox.storage.PENDING status until the request is either
			//		approved or denied, resulting in another call back with
			//		dojox.storage.SUCCESS.
			//		The second argument in the call back is the key name that was being stored.
			//		The third argument in the call back is an optional message that
			//		details possible error messages that might have occurred during
			//		the storage process.
			//	namespace:
			//		Optional string namespace that this value will be placed into;
			//		if left off, the value will be placed into dojox.storage.DEFAULT_NAMESPACE
			
			console.warn("dojox.storage.put not implemented");
		},

		get: function(/*string*/ key, /*string?*/ namespace){ /*Object*/
			// summary:
			//		Gets the value with the given key. Returns null if this key is
			//		not in the storage system.
			// key:
			//		A string key to get the value of.
			//	namespace:
			//		Optional string namespace that this value will be retrieved from;
			//		if left off, the value will be retrieved from dojox.storage.DEFAULT_NAMESPACE
			// return: Returns any JavaScript object type; null if the key is not present
			console.warn("dojox.storage.get not implemented");
		},

		hasKey: function(/*string*/ key, /*string?*/ namespace){
			// summary: Determines whether the storage has the given key.
			return !!this.get(key, namespace); // Boolean
		},

		getKeys: function(/*string?*/ namespace){ /*Array*/
			// summary: Enumerates all of the available keys in this storage system.
			// return: Array of available keys
			console.warn("dojox.storage.getKeys not implemented");
		},
		
		clear: function(/*string?*/ namespace){
			// summary:
			//		Completely clears this storage system of all of it's values and
			//		keys. If 'namespace' is provided just clears the keys in that
			//		namespace.
			console.warn("dojox.storage.clear not implemented");
		},
	  
		remove: function(/*string*/ key, /*string?*/ namespace){
			// summary: Removes the given key from this storage system.
			console.warn("dojox.storage.remove not implemented");
		},
		
		getNamespaces: function(){ /*string[]*/
			console.warn("dojox.storage.getNamespaces not implemented");
		},

		isPermanent: function(){ /*Boolean*/
			// summary:
			//		Returns whether this storage provider's values are persisted
			//		when this platform is shutdown.
			console.warn("dojox.storage.isPermanent not implemented");
		},

		getMaximumSize: function(){ /* mixed */
			// summary: The maximum storage allowed by this provider
			// returns:
			//	Returns the maximum storage size
			//	supported by this provider, in
			//	thousands of bytes (i.e., if it
			//	returns 60 then this means that 60K
			//	of storage is supported).
			//
			//	If this provider can not determine
			//	it's maximum size, then
			//	dojox.storage.SIZE_NOT_AVAILABLE is
			//	returned; if there is no theoretical
			//	limit on the amount of storage
			//	this provider can return, then
			//	dojox.storage.SIZE_NO_LIMIT is
			//	returned
			console.warn("dojox.storage.getMaximumSize not implemented");
		},
			
		putMultiple: function(	/*array*/ keys,
								/*array*/ values,
								/*function*/ resultsHandler,
								/*string?*/ namespace){
			// summary:
			//		Puts multiple keys and values into this storage system.
			// description:
			//		Example-
			//			var resultsHandler = function(status, key, message){
			//			  alert("status="+status+", key="+key+", message="+message);
			//			};
			//			dojox.storage.put(["test"], ["hello world"], resultsHandler);
			//
			//		Important note: if you are using Dojo Storage in conjunction with
			//		Dojo Offline, then you don't need to provide
			//		a resultsHandler; this is because for Dojo Offline we
			//		use Google Gears to persist data, which has unlimited data
			//		once the user has given permission. If you are using Dojo
			//		Storage apart from Dojo Offline, then under the covers hidden
			//		Flash might be used, which is both asychronous and which might
			//		get denied; in this case you must provide a resultsHandler.
			// keys:
			//		An array of string keys to use when retrieving this value in the future,
			//		one per value to be stored
			// values:
			//		An array of values to store; this can be any JavaScript type, though the
			//		performance of plain strings is considerably better
			// resultsHandler:
			//		A callback function that will receive three arguments. The
			//		first argument is one of three values: dojox.storage.SUCCESS,
			//		dojox.storage.FAILED, or dojox.storage.PENDING; these values
			//		determine how the put request went. In some storage systems
			//		users can deny a storage request, resulting in a
			//		dojox.storage.FAILED, while in other storage systems a storage
			//		request must wait for user approval, resulting in a
			//		dojox.storage.PENDING status until the request is either
			//		approved or denied, resulting in another call back with
			//		dojox.storage.SUCCESS.
			//		The second argument in the call back is the key name that was being stored.
			//		The third argument in the call back is an optional message that
			//		details possible error messages that might have occurred during
			//		the storage process.
			//	namespace:
			//		Optional string namespace that this value will be placed into;
			//		if left off, the value will be placed into dojox.storage.DEFAULT_NAMESPACE
			
			for(var i = 0; i < keys.length; i++){
				dojox.storage.put(keys[i], values[i], resultsHandler, namespace);
			}
		},

		getMultiple: function(/*array*/ keys, /*string?*/ namespace){ /*Object*/
			// summary:
			//		Gets the valuse corresponding to each of the given keys.
			//		Returns a null array element for each given key that is
			//		not in the storage system.
			// keys:
			//		An array of string keys to get the value of.
			//	namespace:
			//		Optional string namespace that this value will be retrieved from;
			//		if left off, the value will be retrieved from dojox.storage.DEFAULT_NAMESPACE
			// return: Returns any JavaScript object type; null if the key is not present
			
			var results = [];
			for(var i = 0; i < keys.length; i++){
				results.push(dojox.storage.get(keys[i], namespace));
			}
			
			return results;
		},

		removeMultiple: function(/*array*/ keys, /*string?*/ namespace) {
			// summary: Removes the given keys from this storage system.
			
			for(var i = 0; i < keys.length; i++){
				dojox.storage.remove(keys[i], namespace);
			}
		},
		
		isValidKeyArray: function( keys) {
			if(keys === null || keys === undefined || !lang.isArray(keys)){
				return false;
			}

			//	JAC: This could be optimized by running the key validity test
			//  directly over a joined string
			return !array.some(keys, function(key){
				return !this.isValidKey(key);
			}, this); // Boolean
		},

		hasSettingsUI: function(){ /*Boolean*/
			// summary: Determines whether this provider has a settings UI.
			return false;
		},

		showSettingsUI: function(){
			// summary: If this provider has a settings UI, determined
			// by calling hasSettingsUI(), it is shown.
			console.warn("dojox.storage.showSettingsUI not implemented");
		},

		hideSettingsUI: function(){
			// summary: If this provider has a settings UI, hides it.
			console.warn("dojox.storage.hideSettingsUI not implemented");
		},
		
		isValidKey: function(/*string*/ keyName){ /*Boolean*/
			// summary:
			//		Subclasses can call this to ensure that the key given is valid
			//		in a consistent way across different storage providers. We use
			//		the lowest common denominator for key values allowed: only
			//		letters, numbers, and underscores are allowed. No spaces.
			if(keyName === null || keyName === undefined){
				return false;
			}
				
			return /^[0-9A-Za-z_]*$/.test(keyName);
		},
		
		getResourceList: function(){ /* Array[] */
			// summary:
			//	Returns a list of URLs that this
			//	storage provider might depend on.
			// description:
			//	This method returns a list of URLs that this
			//	storage provider depends on to do its work.
			//	This list is used by the Dojo Offline Toolkit
			//	to cache these resources to ensure the machinery
			//	used by this storage provider is available offline.
			//	What is returned is an array of URLs.
			//  Note that Dojo Offline uses Gears as its native
			//  storage provider, and does not support using other
			//  kinds of storage providers while offline anymore.
			
			return [];
		}
	});
});

},
'dojox/storage/manager':function(){
define([
	"dojo/_base/config",
	"dojo/_base/lang",
	"dojo/_base/array"
	], function (config, lang, array) {
		var manager = new function(){
		// summary: A singleton class in charge of the dojox.storage system
		// description:
		//		Initializes the storage systems and figures out the best available
		//		storage options on this platform.

		// currentProvider: Object
		//	The storage provider that was automagically chosen to do storage
		//	on this platform, such as dojox.storage.FlashStorageProvider.
		this.currentProvider = null;

		// available: Boolean
		//	Whether storage of some kind is available.
		this.available = false;

	  // providers: Array
	  //  Array of all the static provider instances, useful if you want to
	  //  loop through and see what providers have been registered.
	  this.providers = [];

		this._initialized = false;

		this._onLoadListeners = [];

		this.initialize = function(){
			// summary:
			//		Initializes the storage system and autodetects the best storage
			//		provider we can provide on this platform
			this.autodetect();
		};

		this.register = function(/*string*/ name, /*Object*/ instance){
			// summary:
			//		Registers the existence of a new storage provider; used by
			//		subclasses to inform the manager of their existence. The
			//		storage manager will select storage providers based on
			//		their ordering, so the order in which you call this method
			//		matters.
			// name:
			//		The full class name of this provider, such as
			//		"dojox.storage.FlashStorageProvider".
			// instance:
			//		An instance of this provider, which we will use to call
			//		isAvailable() on.

			// keep list of providers as a list so that we can know what order
			// storage providers are preferred; also, store the providers hashed
			// by name in case someone wants to get a provider that uses
			// a particular storage backend
			this.providers.push(instance);
			this.providers[name] = instance;
		};

		this.setProvider = function(storageClass){
			// summary:
			//		Instructs the storageManager to use the given storage class for
			//		all storage requests.
			// description:
			//		Example-
			//			dojox.storage.setProvider(
			//				dojox.storage.IEStorageProvider)

		};

		this.autodetect = function(){
			// summary:
			//		Autodetects the best possible persistent storage provider
			//		available on this platform.

			//console.debug("dojox.storage.manager.autodetect");

			if(this._initialized){ // already finished
				return;
			}

			// a flag to force the storage manager to use a particular
			// storage provider type, such as
			// djConfig = {forceStorageProvider: "dojox.storage.WhatWGStorageProvider"};
			var forceProvider = config["forceStorageProvider"] || false;

			// go through each provider, seeing if it can be used
			var providerToUse;
			//FIXME: use array.some
			for(var i = 0; i < this.providers.length; i++){
				providerToUse = this.providers[i];
				if(forceProvider && forceProvider == providerToUse.declaredClass){
					// still call isAvailable for this provider, since this helps some
					// providers internally figure out if they are available
					// FIXME: This should be refactored since it is non-intuitive
					// that isAvailable() would initialize some state
					providerToUse.isAvailable();
					break;
				}else if(!forceProvider && providerToUse.isAvailable()){
					break;
				}
			}

			if(!providerToUse){ // no provider available
				this._initialized = true;
				this.available = false;
				this.currentProvider = null;
				console.warn("No storage provider found for this platform");
				this.loaded();
				return;
			}

			// create this provider and mix in it's properties
			// so that developers can do dojox.storage.put rather
			// than dojox.storage.currentProvider.put, for example
			this.currentProvider = providerToUse;
			lang.mixin(dojox.storage, this.currentProvider);

			// have the provider initialize itself
			dojox.storage.initialize();

			this._initialized = true;
			this.available = true;
		};

		this.isAvailable = function(){ /*Boolean*/
			// summary: Returns whether any storage options are available.
			return this.available;
		};

		this.addOnLoad = function(func){ /* void */
			// summary:
			//		Adds an onload listener to know when Dojo Offline can be used.
			// description:
			//		Adds a listener to know when Dojo Offline can be used. This
			//		ensures that the Dojo Offline framework is loaded and that the
			//		local dojox.storage system is ready to be used. This method is
			//		useful if you don't want to have a dependency on Dojo Events
			//		when using dojox.storage.
			// func: Function
			//		A function to call when Dojo Offline is ready to go
			this._onLoadListeners.push(func);

			if(this.isInitialized()){
				this._fireLoaded();
			}
		};

		this.removeOnLoad = function(func){ /* void */
			// summary: Removes the given onLoad listener
			for(var i = 0; i < this._onLoadListeners.length; i++){
				if(func == this._onLoadListeners[i]){
					this._onLoadListeners.splice(i, 1);
					break;
				}
			}
		};

		this.isInitialized = function(){ /*Boolean*/
			// summary:
			//		Returns whether the storage system is initialized and ready to
			//		be used.

			// FIXME: This should REALLY not be in here, but it fixes a tricky
			// Flash timing bug.
			// Confirm that this is still needed with the newly refactored Dojo
			// Flash. Used to be for Internet Explorer. -- Brad Neuberg
			if(this.currentProvider != null
				&& this.currentProvider.declaredClass == "dojox.storage.FlashStorageProvider"
				&& dojox.flash.ready == false){
				return false;
			}else{
				return this._initialized;
			}
		};

		this.supportsProvider = function(/*string*/ storageClass){ /* Boolean */
			// summary: Determines if this platform supports the given storage provider.
			// description:
			//		Example-
			//			dojox.storage.manager.supportsProvider(
			//				"dojox.storage.InternetExplorerStorageProvider");

			// construct this class dynamically
			try{
				// dynamically call the given providers class level isAvailable()
				// method
				var provider = eval("new " + storageClass + "()");
				var results = provider.isAvailable();
				if(!results){ return false; }
				return results;
			}catch(e){
				return false;
			}
		};

		this.getProvider = function(){ /* Object */
			// summary: Gets the current provider
			return this.currentProvider;
		};

		this.loaded = function(){
			// summary:
			//		The storage provider should call this method when it is loaded
			//		and ready to be used. Clients who will use the provider will
			//		connect to this method to know when they can use the storage
			//		system. You can either use dojo.connect to connect to this
			//		function, or can use dojox.storage.manager.addOnLoad() to add
			//		a listener that does not depend on the dojo.event package.
			// description:
			//		Example 1-
			//			if(dojox.storage.manager.isInitialized() == false){
			//				dojo.connect(dojox.storage.manager, "loaded", TestStorage, "initialize");
			//			}else{
			//				dojo.connect(dojo, "loaded", TestStorage, "initialize");
			//			}
			//		Example 2-
			//			dojox.storage.manager.addOnLoad(someFunction);


			// FIXME: we should just provide a Deferred for this. That way you
			// don't care when this happens or has happened. Deferreds are in Base
			this._fireLoaded();
		};

		this._fireLoaded = function(){
			//console.debug("dojox.storage.manager._fireLoaded");

			array.forEach(this._onLoadListeners, function(i){
				try{
					i();
				}catch(e){ console.debug(e); }
			});
		};

		this.getResourceList = function(){
			// summary:
			//		Returns a list of whatever resources are necessary for storage
			//		providers to work.
			// description:
			//		This will return all files needed by all storage providers for
			//		this particular environment type. For example, if we are in the
			//		browser environment, then this will return the hidden SWF files
			//		needed by the FlashStorageProvider, even if we don't need them
			//		for the particular browser we are working within. This is meant
			//		to faciliate Dojo Offline, which must retrieve all resources we
			//		need offline into the offline cache -- we retrieve everything
			//		needed, in case another browser that requires different storage
			//		mechanisms hits the local offline cache. For example, if we
			//		were to sync against Dojo Offline on Firefox 2, then we would
			//		not grab the FlashStorageProvider resources needed for Safari.
			var results = [];
			array.forEach(dojox.storage.manager.providers, function(currentProvider){
				results = results.concat(currentProvider.getResourceList());
			});

			return results;
		}
	};
	return manager;
});




},
'Sage/Utility/Jobs':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'Sage/Utility',
    'dojo/date/locale',
    'dojo/string',
    'dojo/_base/declare',
    'dojo/dom',
    'dojo/dom-class',
    'dojo/dom-construct',
    'dojo/_base/connect',
    'Sage/UI/Dialogs',
    'dojo/i18n!./nls/Jobs',
    'dijit/ProgressBar',
    'Sage/UI/Controls/_DialogHelpIconMixin',
    'Sage/Data/SDataServiceRegistry',
    'dojo/_base/lang',
    'dojo/_base/array',
    'dijit/registry',
    'dijit/form/Button',
    'dijit/Dialog'    
],
function (
    utility,
    dateLocale,
    dojoString,
    declare,
    dDom,
    domClass,
    domConstruct,
    connect,
    dialogs,
    nlsStrings,
    dijitProgressBar,
    dialogHelpIconMixin,
    sDataServiceRegistry,
    lang,
    dojoArray,
    dijitReg,
    Button,
    Dialog
) {
    Sage.namespace('Utility.Jobs');
    lang.mixin(Sage.Utility.Jobs, {
        _intervalId: null,
        _triggerId: null,
        _jobService: null,
        _options: null,
        _pollIntervalInSeconds: 5,
        progressDialog: false,
        progressBar: false,
        cancelButton: null,
        /**
        * Triggers a job for immediate execution and displays a progress dialog.
        * @param {Object} options - Options for the function.
        * @param {string} options.key - The id of the job to be executed. Example: 'Sage.SalesLogix.BusinessRules.Jobs.UpdateEntityJob'.
        * @param {Array} [options.parameters] - An array containing parameters to be passed to the Job execution.
        * @param {function} [options.complete] - An optional callback function to be executed on complete.
        * @param {function} [options.failure] - An optional callback function to be executed on failure.
        * @param {boolean} [options.closable=true] - Whether the progress dialog can be closed or not.
        * @param {string} [options.infoMessage] - A message to show to the user in the progress dialog.
        * @param {string} [options.title] - The title of the progress dialog.
        * @param {boolean} [options.showDismissButton=true] - Whether to show the dismiss button when the job completes or not.
        * @param {number} [options.width=400] - The progress dialog width.
        * @param {boolean} [options.indeterminate=false] - Whether to show an indeterminate progress bar or not.
        * @param {number} [options.maximum=100] - Maximum value for the progress bar.
        * @param {boolean} [options.showCompleteNotification=false] - Whether to show a default complete notification on complete. This is displayed as an
        *       information dialog, its usage would typically be used when closing the progress dialog, in which case this message is displayed as a informational
        *       dialog when the job completes. Is redundant when the progress dialog is not closed.
        * @param {boolean} [options.showErrorNotification=true] - Whether to show a default error notification on error.        
        * @param {boolean} [options.ensureZeroFilters] - Forces a check to ensure no filters are applied.
        */
        triggerJobAndDisplayProgressDialog: function (options) {
            this._reset();
            if (!this._validateOptions(options)) {
                return;
            }

            this._options = {
                key: options.key,
                closable: (typeof options.closable === 'boolean') ? options.closable : true,
                infoMessage: (typeof options.infoMessage === 'string') ? options.infoMessage : '',
                title: (typeof options.title === 'string') ? options.title : nlsStrings.defaultProgressDialogTitle,
                showDismissButton: (typeof options.showDismissButton === 'boolean') ? options.showDismissButton : true,
                width: (typeof options.width === 'number') ? options.width : 400,
                indeterminate: (typeof options.indeterminate === 'boolean') ? options.indeterminate : false,
                maximum: (typeof options.maximum === 'number') ? options.maximum : 100,
                showCompleteNotification: (typeof options.showCompleteNotification === 'boolean') ? options.showCompleteNotification : false,
                showErrorNotification: (typeof options.showErrorNotification === 'boolean') ? options.showErrorNotification : true,
                failure: options.failure,
                complete: options.complete,
                ensureZeroFilters: options.ensureZeroFilters === true ? true : false
            };

            var triggerJobOptions = {
                descriptor: options.descriptor,
                key: options.key,
                parameters: options.parameters,
                success: lang.hitch(this, function (result) {
                    this._showProgressDialog(result.response ? result.response.triggerId : result.$key);
                }),
                failure: lang.hitch(this, function (xhr, sdata) {
                    if (this._options.showErrorNotification) {
                        var msg = this._errorMessageHandlingBaseOffRequestStatus(xhr.status, true);
                        if (msg === "") {
                            utility.ErrorHandler.handleHttpError(xhr, sdata);
                        } else {
                            dialogs.showError(msg, this._options.title);
                        }
                    }
                    if (this._options.failure) {
                        var errorMsg = this._getErrorMessage(xhr);
                        this._options.failure(errorMsg);
                    }
                })
            };
            this._jobService = Sage.Services.getService('JobService');
            this._jobService.scheduleJob(triggerJobOptions);
            connect.publish('/job/execution/changed', [this]);
        },
        formatElapsedTime: function (elapsedTime) {
            if (!elapsedTime) {
                elapsedTime = '00:00:00.00000';
            }
            var elapsedTimeArray = elapsedTime.split('.');
            return elapsedTimeArray[0];
        },
        formatJobDescription: function (job) {
            return !job ? '' : job.$descriptor;
        },
        formatDate: function (jsonDate) {
            if (!jsonDate) {
                return '';
            }
            //The substr function takes out the "/Date(" part, and the parseInt function gets the integer and ignores the ")/" at the end. The resulting number is passed into the Date constructor.
            var dateVar = new Date(parseInt(jsonDate.substr(6), 10));
            return dateLocale.format(dateVar, { selector: 'datetime', fullYear: true, locale: Sys.CultureInfo.CurrentCulture.name });
        },
        formatUser: function (user) {
            return user ? user.$descriptor : '';
        },
        formatRepeatCount: function (repeatCount) {
            if (repeatCount === -1) {
                return nlsStrings.repeatIndefinitely;
            }
            return repeatCount;
        },
        formatJobResultGrid: function (rowValue, rowObj) {
            // attempts to sort the results field in a dgrid
            var result = rowValue;
            console.log("formatJobResultLink:  rowValue: %o | rowObj: %o", rowValue, rowObj);
            return !result ? '' : Sage.Utility.Jobs.formatJobResultLink(result, rowObj.trigger);
        },
        formatJobResult: function (item) {
            //if this was a job which wrote to the result property to format the display as a link, i.e. to open an attachment or redirect to an entity page,
            //the result should be in the format of a URI i.e. SlxAttachment\\ID or SlxReport\\ID or EntityRedirect\\Entity\\ID
            var result = item.result;
            return !result ? '' : Sage.Utility.Jobs.formatJobResultLink(result, item.trigger);
        },
        formatJob: function (value) {
            return !value ? '' : Sage.Utility.Jobs.formatJobResultLink(value.result, value.trigger);
        },
        formatJobResultLink: function (result, trigger) {
            if (result && typeof result === 'string') {
                var parts = result.split('://');
                if (parts.length === 1) {
                    return parts[0];
                } else {
                    if (parts.length > 1) {
                        switch (parts[0]) {
                            case "SlxAttachment":
                                return dojoString.substitute('<a href="javascript: Sage.Utility.File.Attachment.getAttachment(\'${1}\');" title="${0}">${0}</a>',
                                    [trigger ? trigger.$descriptor : '', parts[1]]);
                            case "GoToEntity":
                                return dojoString.substitute('<a href="${0}.aspx?entityid=${1}&modeid=Detail">${2}</a>',
                                    [parts[1], parts[2], trigger ? trigger.$descriptor : '']);
                            case "GoToGroup":
                                return dojoString.substitute('<a href="javascript: Sage.Utility.Jobs.gotoGroup(\'${1}\',\'${2}\');" title="${0}">${0}</a>',
                                    [trigger ? trigger.$descriptor : '', parts[1], parts[2]]);
                        }
                    }
                }
            }
            return '';
        },
        getTriggerDescription: function (trigger) {
            if (trigger) {
                if (trigger.$descriptor) {
                    return trigger.$descriptor;
                } else {
                    return trigger.$key;
                }
            }
            return '';
        },
        formatProgress: function (progress) {
            if (!progress || typeof progress !== 'number') {
                progress = 0;
            }
            var progressBar = new dijitProgressBar({
                indeterminate: false,
                maximum: 100,
                value: progress
            });
            return progressBar.domNode;
        },
        getParameterRunAsUser: function (parameters) {
            if (parameters) {
                var userId = this._getParameterValue(parameters, "RunAsUserId");
                return utility.getUserName(userId);
            }
            return '';
        },
        refreshList: function (tabId) {
            try {
                var panel = dijitReg.byId('list');
                if (panel) {
                    var grpContextSvc = Sage.Services.getService('ClientGroupContext');
                    if (grpContextSvc) {
                        var ctx = grpContextSvc.getContext();
                        if (tabId === ctx.CurrentGroupID) {
                            panel.refreshView(tabId);
                        }
                    }
                }
            }
            catch (e) {
            }
        },
        /**
        * Return the id of the current group in the listview.
        * @returns {string} - The id of the current group in the listview.
        */
        getCurrentGroupId: function () {
            var svc = Sage.Services.getService('ClientGroupContext');
            var context = svc.getContext();
            return context.CurrentGroupID;
        },
        getLookupConditionsForJob: function () {
            var conditions = [];
            var grpContextSvc = Sage.Services.getService('ClientGroupContext');
            if (grpContextSvc) {
                var contextService = grpContextSvc.getContext();
                if (contextService && contextService.CurrentGroupID === "LOOKUPRESULTS" && contextService.LookupResultsConditions) {
                    var lookupConditions = Sys.Serialization.JavaScriptSerializer.deserialize(contextService.LookupResultsConditions);
                    dojoArray.forEach(lookupConditions, lang.hitch(this, function (condition) {
                        conditions.push({
                            dataPath: this._getDataPathFromLayout(condition.fieldname),
                            op: this._getConditionValue(condition.operator),
                            value: condition.val
                        });
                    }));
                }
            }
            return conditions;
        },
        _getDataPathFromLayout: function (alias) {
            var panel = dijitReg.byId('list');
            var layout = panel._configurationProvider._currentConfiguration ? panel._configurationProvider._currentConfiguration.layout : null;
            for (var i = 0; i < layout.length; i++) {
                var item = layout[i];
                if (item && item.alias === alias) {
                    return item.dataPath;
                }
            }
            return alias;
        },
        getFiltersForJob: function () {
            var filters = [];
            var panel = dijitReg.byId('list');
            var filterManager = panel.get('filterManager');
            var layout = panel._configurationProvider._currentConfiguration ? panel._configurationProvider._currentConfiguration.layout : null;
            var tableAliases = panel._configurationProvider._currentConfiguration ? panel._configurationProvider._currentConfiguration.tableAliases : {};

            var filter = null;
            var definition = null;
            var dataPath = null;
            var filterType;

            for (var key in filterManager._applied) {
                if (filterManager._applied.hasOwnProperty(key)) {
                    filter = filterManager._applied[key];
                    if (filter) {
                        definition = filterManager._definitionSet[key];
                        filterType = (definition.details.rangeFilter && 'rangeFilter') || (definition.details.distinctFilter && 'distinctFilter') || (definition.details.lookupFilter && 'lookupFilter');
                        dataPath = this._resolveProperty(layout, tableAliases, definition.propertyName);
                        switch (filterType) {
                            case 'rangeFilter':
                                filters.push({
                                    filterName: definition.filterName,
                                    tableName: dataPath.tableName,
                                    field: dataPath.alias,
                                    filterType: 'Range',
                                    ranges: this._getFilterValues(filter, filterType)
                                });
                                break;
                            case 'distinctFilter':
                                filters.push({
                                    filterName: definition.filterName,
                                    tableName: dataPath.tableName,
                                    field: dataPath.alias,
                                    filterType: 'Distinct',
                                    value: this._getFilterValues(filter, filterType)
                                });
                                break;
                            case 'lookupFilter':
                                filters.push({
                                    filterName: definition.filterName,
                                    filterType: 'Lookup',
                                    tableName: dataPath.tableName,
                                    field: dataPath.alias,
                                    op: filter.value.operator,
                                    value: [filter.value.value]
                                });
                                break;
                        }
                    }
                }
            }
            return filters;
        },
        _validateOptions: function (options) {
            if (!options) {
                console.log('Invalid parameter: options');
                return false;
            }
            if (typeof options.key !== 'string') {
                console.log('Invalid parameter: options.key');
                return false;
            }
            return true;
        },
        _reset: function () {
            this._intervalId = null;
            this._options = null;
            this._triggerId = null;
        },
        _getErrorMessage: function (xhr) {
            var errorMsg = dojoString.substitute(nlsStrings.errorMessage, [this._options.key, xhr.status, xhr.statusText]);
            return errorMsg;
        },
        _getUnexpectedErrorMessage: function () {
            var errorMsg = dojoString.substitute(nlsStrings.unexpectedErrorMessage, [this._options.key]);
            return errorMsg;
        },
        _getParameterValue: function (parameters, name) {
            var value = "";
            if (parameters) {
                dojoArray.some(parameters, function (entry, i) {
                    if (entry.name === name) {
                        value = entry.value;
                        return true;
                    }
                });
            }
            return value;
        },
        _updateProgressDialog: function (options) {
            if (this.progressBar) {
                if (options && typeof options.progress === 'number') {
                    this.progressBar.update({ progress: options.progress });
                }
                if (options && typeof options.title === 'string') {
                    this.progressBar.update({ title: options.title });
                }
                if (options && typeof options.infoMessage === 'string') {
                    var messageDiv = dDom.byId('progressDialogMessageDiv');
                    if (messageDiv) {
                        messageDiv.innerHTML = options.infoMessage;
                    }
                }
            }
        },
        _showProgressDialog: function (triggerId) {
            this._triggerId = triggerId;
            var options = this._options;

            this.progressDialog = new Dialog({
                title: options.title,
                style: dojoString.substitute('width: ${0}px;', [options.width]),
                closable: options.closable
            });

            //Informational Message
            var messageDiv = new domConstruct.create('div', { innerHTML: options.infoMessage, style: 'text-align: left; margin-top: 5px; margin-bottom: 10px', id: 'progressDialogMessageDiv' });
            this.progressDialog.containerNode.appendChild(messageDiv);
            var linkDiv = new domConstruct.create('div', { style: 'text-align: left; margin-top: 5px; margin-bottom: 10px', id: 'progressDialogLinkDiv', "class": 'display-none' });
            this.progressDialog.containerNode.appendChild(linkDiv);

            this.progressBar = new dijitProgressBar({
                style: 'margin-top: 10px; margin-bottom: 20px',
                indeterminate: options.indeterminate,
                maximum: options.maximum,
                progress: 0
            });

            this.progressDialog.containerNode.appendChild(this.progressBar.domNode);

            //Dismiss button
            if (options.showDismissButton) {
                this.cancelButton = new Button({
                    label: nlsStrings.cancelButtonCaption,
                    style: 'margin-right: 3px;',
                    onClick: lang.hitch(this, function () {
                        this._cancelJob();
                    })
                });
                var closeButton = new Button({
                    label: nlsStrings.closeButtonCaption,
                    onClick: lang.hitch(this, function () {
                        this._closeProgressDialog();
                    })
                });
                var buttonDiv = new domConstruct.create('div', { id: 'progressDialogButtonDiv', style: 'text-align: center;' });
                buttonDiv.appendChild(this.cancelButton.domNode);
                buttonDiv.appendChild(closeButton.domNode);
                this.progressDialog.containerNode.appendChild(buttonDiv);
            }
            this.progressDialog.show();
            if (!this.progressDialog.helpIcon) {
                lang.mixin(this.progressDialog, new dialogHelpIconMixin());
                this.progressDialog.createHelpIconByTopic('jobsProgressDialog');
            }
            this._intervalId = setInterval(function () { Sage.Utility.Jobs._updateProgress(); }, this._pollIntervalInSeconds * 1000);
        },
        _cancelJob: function () {
            clearInterval(this._intervalId);
            if (!this.jobService) {
                this._jobService = Sage.Services.getService('JobService');
            }
            this._jobService.interruptExecution(this._options);
            this._closeProgressDialog();
        },
        _closeProgressDialog: function () {
            clearInterval(this._intervalId);
            if (this.progressDialog) {
                this.progressDialog.hide();
                this.progressDialog.destroyDescendants();
                if (this.cancelButton) {
                    this.cancelButton.destroyRecursive();
                }
            }
        },
        _updateProgress: function () {
            var jobService = Sage.Services.getService('JobService');
            var options = {
                triggerId: this._triggerId,
                success: lang.hitch(this, function (execution, sdata) {
                    options = { progress: execution.progress };
                    this._updateProgressDialog(options);
                    if (execution.status === 'Complete') {
                        domClass.add(this.cancelButton, "display-none");
                        clearInterval(this._intervalId);
                        var resultContainer = dDom.byId('progressDialogMessageDiv');
                        if (resultContainer) {
                            resultContainer.innerHTML = nlsStrings.jobCompletedSuccessfully;
                        }
                        var linkContainer = dDom.byId('progressDialogLinkDiv');
                        if (linkContainer && execution.result) {
                            var parts = execution.result.split('://');
                            if (parts.length > 1) {
                                domClass.remove(linkContainer, 'display-none');
                                switch (parts[0]) {
                                    case "SlxAttachment":
                                        linkContainer.innerHTML = dojoString.substitute('<a onclick="Sage.Utility.Jobs._closeProgressDialog();" href="javascript: Sage.Utility.File.Attachment.getAttachment(\'${1}\');" title="${0}">${0}</a>',
                                            [execution.trigger ? execution.trigger.$descriptor : '', parts[1]]);
                                        break;
                                    case "GoToEntity":
                                        linkContainer.innerHTML = dojoString.substitute('<a onclick="Sage.Utility.Jobs._closeProgressDialog();" href="${0}.aspx?entityid=${1}&modeid=Detail">${2}</a>',
                                            [parts[1], parts[2], execution.trigger ? execution.trigger.$descriptor : '']);
                                        break;
                                    case "GoToGroup":
                                        linkContainer.innerHTML = dojoString.substitute('<a onclick="Sage.Utility.Jobs._closeProgressDialog();" href="javascript: Sage.Utility.Jobs.gotoGroup(\'${1}\',\'${2}\');" title="${0}">${0}</a>',
                                            [execution.trigger ? execution.trigger.$descriptor : '', parts[1], parts[2]]);
                                }
                            }
                        }
                        if (this.cancelButton) {
                            this.cancelButton.destroyRecursive();
                        }
                        if (this._options.showCompleteNotification) {
                            dialogs.showInfo(nlsStrings.jobCompletedSuccessfully, this._options.title);
                        }
                        if (this._options.complete) {
                            this._options.complete(execution);
                        }
                        this._refreshFavorites();
                        connect.publish('/job/execution/changed', [this]);
                    }

                    if (execution.status === 'Error') {
                        clearInterval(this._intervalId);
                        dialogs.closeProgressBar();
                        if (this._options.showErrorNotification) {
                            utility.ErrorHandler.handleHttpError(execution, sdata);
                        }
                        if (this._options.failure) {
                            this._options.failure(execution);
                        }
                        if (this.cancelButton) {
                            this.cancelButton.destroyRecursive();
                        }
                    }
                }),
                failure: lang.hitch(this, function (execution, sdata) {
                    clearInterval(this._intervalId);
                    dialogs.closeProgressBar();
                    if (this._options.showErrorNotification) {
                        var msg = this._errorMessageHandlingBaseOffRequestStatus(execution.status, true);
                        if (msg === "") {
                            utility.ErrorHandler.handleHttpError(execution, sdata);
                        } else {
                            dialogs.showError(msg, this._options.title);
                        }
                    }
                    if (this._options.failure) {
                        this._options.failure(execution);
                    }
                    if (this.cancelButton) {
                        this.cancelButton.destroyRecursive();
                    }
                })
            };
            jobService.getExecution(options);
        },
        _getConditionValue: function (condition) {
            switch (condition) {
                case 'sw':
                    return 'STARTING WITH';
                case 'ne':
                    return '<>';
                case 'gt':
                    return '>';
                case 'ge':
                    return '>=';
                case 'lt':
                    return '<';
                case 'le':
                    return '<=';
                case 'like':
                    return 'LIKE';
                default:
                    return '=';
            }
        },
        _parseProperty: function (propertyName, last) {
            var parts = propertyName.split(".");
            if (last) {
                return parts[parts.length - 1];
            } else {
                return propertyName.substr(0, propertyName.length - parts[parts.length - 1].length - 1);
            }
        },
        _getFilterValues: function (filter, filterType) {
            var values = [];
            for (var name in filter) {
                if (filter.hasOwnProperty(name)) {
                    switch (filterType) {
                        case 'rangeFilter':
                            values.push({ lower: filter[name].lower, upper: filter[name].upper });
                            break;
                        case 'distinctFilter':
                            values.push(name);
                            break;
                        case 'lookupFilter':
                            break;
                    }
                }
            }
            return values;
        },
        _resolveProperty: function (layout, tableAliases, propertyName) {
            if (layout) {
                var dataPath = this._getFilterDataPath(propertyName, layout, tableAliases, false, false);
                if (dataPath) {
                    return dataPath;
                } else {
                    dataPath = this._getFilterDataPath(propertyName, layout, tableAliases, true, false);
                    if (dataPath) {
                        return dataPath;
                    } else {
                        dataPath = this._getFilterDataPath(propertyName, layout, tableAliases, true, true);
                        return dataPath ? dataPath : propertyName;
                    }
                }
            }
            return propertyName;
        },
        _resolveAliasProperty: function (property, tableAliases) {
            var fieldName = property;
            var tableName = '';
            if (property.indexOf("_") > -1) {
                var parts = property.split("_");
                if (parts[0].length === 2) {
                    fieldName = property.slice(parts[0].length + 1); // remove length of table alias and '_' to get the fieldname
                    dojoArray.forEach(tableAliases, function (dataPath) {
                        if (parts[0] === dataPath.alias) {
                            tableName = dataPath.tableName;
                            return;
                        }
                    });
                }
            }
            return { tableName: tableName, alias: fieldName };
        },
        _getFilterDataPath: function (propertyName, layout, tableAliases, splitPath, resolveByItemDataPath) {
            var i, x, item, alias, table, tableAlias, propertyPathSplit, layoutProperty, dataPathSplit;

            for (i = 0; i < layout.length; i++) {
                item = layout[i];
                layoutProperty = item.propertyPath;
                if (splitPath) {
                    propertyPathSplit = item.propertyPath && item.propertyPath.split('.');
                    if (propertyPathSplit.length === 2) {
                        layoutProperty = propertyPathSplit[1];
                    }
                }
                if (layoutProperty === propertyName) {
                    if (item.propertyPath.indexOf(".") > -1) {
                        return this._resolveAliasProperty(item.alias, tableAliases);
                    } else {
                        table = item.dataPath && item.dataPath.split(':')[0];
                        if (/^[a-z]\d+_/i.test(item.alias)) {
                            alias = item.alias;
                        } else {
                            tableAlias = table && tableAliases[table.toUpperCase()];
                            if (tableAlias) {
                                alias = tableAlias + '.' + item.alias;
                            }
                        }
                    }
                    return { tableName: table, alias: alias ? alias : item.alias };
                }
                if (resolveByItemDataPath && item.dataPath !== "") {
                    dataPathSplit = item.dataPath.split(".");
                    if (dataPathSplit.length > 1) {
                        var path = dataPathSplit[dataPathSplit.length - 1];
                        var parts = path.split('!');
                        if (parts.length > 1) {
                            for (x = 0; x < tableAliases.length; x++) {
                                if (tableAliases[x].tableName === parts[0]) {
                                    return { tableName: tableAliases[x].tableName, alias: parts[1] };
                                }
                            }
                        }
                    }
                }
            }
            return null;
        },
        gotoGroup: function (entity, groupId) {
            var service = sDataServiceRegistry.getSDataService('system');
            var request = new Sage.SData.Client.SDataServiceOperationRequest(service)
                .setOperationName('setGroupContext');
            var entry = {
                request: {
                    'currentGroupId': groupId,
                    'currentFamily:': entity,
                    'clearCache': true /* Clear the group cache so that the group created in the job will be available in the client. */
                }
            };
            request.execute(entry, {
                success: function () {
                    window.parent.location = dojoString.substitute("${0}.aspx?gid=${1}&modeid=list", [entity, groupId]);
                },
                scope: this
            });
        },
        // used by other namespaces to get a "read-able" error message based on the status.
        getRequestMessageFromStatus: function (status) {
            return this._errorMessageHandlingBaseOffRequestStatus(status, false);
        },
        _errorMessageHandlingBaseOffRequestStatus: function (status, useDefault) {
            var errorMsg = "";
            switch (status) {
                case 410:
                    errorMsg = nlsStrings.dataExpiredRefreshPage;
                    break;
                case 500:
                    errorMsg = nlsStrings.JobServerviceOff;
                    break;
                default:
                    errorMsg = useDefault ? "" : nlsStrings.generalCheckJobService;
                    break;
            }
            return errorMsg;
        },
        _refreshFavorites: function () {
            var service = sDataServiceRegistry.getSDataService('system');
            var request = new Sage.SData.Client.SDataServiceOperationRequest(service);
            var operation = 'refreshFavorites';

            request.setResourceKind('groups');
            request.setOperationName(operation);

            var entry = {
                '$name': operation,
                request: {}
            };

            request.execute(entry, {
                success: function (data) {
                },
                failure: function (xhr, sdata) {
                    console.log("failed updating group favorites");
                },
                scope: this
            });
        }
    });
    return Sage.Utility.Jobs;
});

},
'Sage/UI/Controls/_DialogHelpIconMixin':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
/* 
Mixin for creating a help icon in dijit/Dialogs (or anything that has a titleBar attach point)
*/
define([
        'dojo/_base/declare',
        'dojo/dom-construct',
        'dojo/dom-attr',
        'dojo/i18n!./nls/_DialogHelpIconMixin'
//'Sage/Link' /* Circular ref between Link/Utility - Don't require this */
],
function (declare, domConstruct, domAttr, nls) {
    return declare('Sage.UI.Controls._DialogHelpIconMixin', null, {
        helpTopic: '',
        createHelpIcon: function (url, target) {
            // Bail out if there is no url or we already have an existing helpIcon
            if (!url || this.helpIcon) {
                //if we have multiple dialogs living in the same workspace the help icon may contain the wrong help context
                domConstruct.destroy(this.helpIcon);
            }

            var link = domConstruct.create('a', { href: url, 'target': target || 'help', 'class': 'dialogHelpIcon' }, this.titleBar, 'first'),
                node = domConstruct.create('div', { 'class': 'Global_Images icon16x16 icon_Help_16x16', title: nls.helpTooltip }, link);

            // Assign a helpIcon attach point for this.
            this.helpIcon = link;
        },
        createHelpIconByTopic: function (topic, subsystem) {
            if (!topic) {
                topic = this.helpTopic;
            } else {
                this.helpTopic = topic;
            }
            var target = Sage.Link.getHelpUrlTarget(),
                url = Sage.Link.getHelpUrl(topic, subsystem);
            this.createHelpIcon(url, target);
        },
        destroy: function () {
            domConstruct.destroy(this.helpIcon);
            this.inherited(arguments);
        },
        _setHelpTopicAttr: function (topic) {
            this.helpTopic = topic;
            if (this.helpIcon) {
                var url = Sage.Link.getHelpUrl(topic);
                domAttr.set(this.helpIcon, 'href', url);
            } else {
                this.createHelpIconByTopic(topic);
            }
        },
        _getHelpTopicAttr: function () {
            return this.helpTopic;
        }
    });
});
},
'Sage/Services/ClientContextService':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/_base/declare'
],
function (declare) {
    var widget = declare('Sage.Services.ClientContextService', null, {
        // summary:
        //      This service provides a place to pass contextual information from the client to the server or server to client.  
        //      The service itself is quite simple; the power of this service is knowing its contents.  The following is a 
        //      list ofthings that are usually avaiable from this service:
        //      -userID : (always available) Contains the user ID of the currently logged in user.
        //      -userPrettyName : (always available) Contains the formatted name of the currently logged in user.
        //      -userDateFmtStr : (always available) Contains the date formatstring based on the language setting of the browser.
        //      -userTimeFmtStr : (always available) Contains the time formatstring based on the language setting of the browser.
        //      -ClientEntityId : (available in detail mode of entity pages) Contains the id of the entity currently being edited in the detail view.
        //      -PreviousEntityId : (available on the server during postbacks specifically for changing to a new entity) Contains the id of the entity we are moving from.  The use of this context key alerts various workitems on the server that the current postback is one in which the current entity is changing.  The context should change from the 'previous entity' to the one identified by "ClientEntityId".
        // example:
        //  |   //This is some server side code (C# - The types are fully qualified here for clarity):
        //  |   Sage.Platform.WebPortal.Services.ClientContextService contextService = PageWorkItem.Services.Get<Sage.Platform.WebPortal.Services.ClientContextService>();
        //  |   if (contextService.CurrentContext.ContainsKey("Foo")) {
        //  |       contextService.CurrentContext["Foo"] = "Bar";
        //  |   } else {
        //  |       contextService.CurrentContext.Add("Foo", "Bar");
        //  |   }
        //  |   
        //  |   //Now some javascript running in the browser can have code like this to show the value of "Foo":
        //  |   var context = Sage.Services.getService("ClientContextService");
        //  |   if (context && context.containsKey("Foo")) {
        //  |       alert("Foo is: " + context.getValue("Foo"));
        //  |   }
        // example:
        //  |   //This JavaScript example gets the currently logged in user's name and shows a personalized message:
        //  |   var contextservice = Sage.Services.getService("ClientContextService");
        //  |   if (contextservice.containsKey("userPrettyName")) {
        //  |       alert("Hello, " + contextservice.getValue("userPrettyName") + " how are you today?");
        //  |   } else {
        //  |       alert("Hello, how are you today?");
        //  |   }

        contextDataFieldId: false,
        _items: [],
        _watches: [],
        constructor: function (opts) {
            dojo.mixin(this, opts);
            this.load();
        },

        //Internal Helper Methods
        _toItemLiteral: function (key, value) {
            var newItem = {};
            newItem.itemKey = key;
            newItem.itemVal = value;
            return newItem;
        },
        _indexOf: function (key) {
            for (var i = 0; i < this._items.length; i++) {
                if (this._items[i].itemKey == key) {
                    return i;
                }
            }
            return -1;
        },
        _indexOfNoCase: function (key) {
            for (var i = 0; i < this._items.length; i++) {
                if (this._items[i].itemKey.toUpperCase() == key.toUpperCase()) {
                    return i;
                }
            }
            return -1;
        },
        _throwKeyNotFound: function (key) {
            throw "Entry Not Found: " + key;
        },
        _throwDuplicateKey: function (key) {
            throw "Entry Already Exists: " + key;
        },

        //public methods...
        add: function (key, value) {
            // summary:
            //      Adds an item to the context dictionary.
            if (this._indexOf(key) === -1) {
                var lit = this._toItemLiteral(key, value);
                this._items.push(lit);
                this.save();
            }
            else
                this._throwDuplicateKey(key);
        },
        remove: function (key) {
            // summary:
            //      Removes the item from the context dictionary.
            var index = this._indexOf(key);
            if (index !== -1) {
                this._items.splice(index, 1);
                this.save();
            }
        },
        setValue: function (key, value) {
            // summary:
            //      Sets a new value to an item that already exists in the context dictionary.
            var index = this._indexOf(key);
            if (index !== -1) {
                this._items[index].itemVal = value;
                this.save();
            }
            else {
                this._throwKeyNotFound(key);
            }
        },
        getValue: function (key) {
            // summary:
            //      Gets the value of the item in the context dictionary by key.
            var index = this._indexOf(key);
            if (index !== -1) {
                return decodeURIComponent(this._items[index].itemVal);
            }
            else {
                this._throwKeyNotFound(key);
            }
        },
        getValueEx: function (key, nocase) {
            // summary:
            //      Gets the value of the item in the context dictionary by key with the ability to specify if the key should or should not be case sensitive.
            var index;
            if (nocase)
                index = this._indexOfNoCase(key);
            else
                index = this._indexOf(key);
            if (index !== -1) {
                return decodeURIComponent(this._items[index].itemVal);
            }
            else {
                this._throwKeyNotFound(key);
            }
        },
        clear: function () {
            // summary:
            //      Removes all items from the context dictionary.
            this._items = [];
            this.save();
        },
        containsKey: function (key) {
            // summary:
            //      Checks to see if an item with the given key exists in the context dictionary.
            return (this._indexOf(key) !== -1);
        },
        containsKeyEx: function (key, nocase) {
            // summary:
            //      Checks to see if an item with the given key exists in the context dictionary with the ability to specify if the key should or should not be case sensitive.
            if (nocase)
                return (this._indexOfNoCase(key) !== -1);
            else
                return (this._indexOf(key) !== -1);
        },
        getCount: function () {
            // summary:
            //      Returns the number of items currently in the context dictionary.
            return this._items.length;
        },
        hasKeys: function () {
            // summary:
            //      Indicates whether there are any items in the context dictionary.
            return this._items.length === 0;
        },
        getKeys: function () {
            // summary:
            //     Returns an array of all the keys of the items in the context dictionary.
            var keyRes = [], i;
            for (i = 0; i < this._items.length; i++) {
                keyRes.push(this._items[i].itemKey);
            }
            return keyRes;
        },
        valueAt: function (index) {
            // summary:
            //      Returns the value of the item in the dictionary at the given location.
            if (this._items[index]) {
                return decodeURIComponent(this._items[index].itemVal);
            }
            else {
                return null;
            }
        },
        keyAt: function (index) {
            // summary:
            //      Returns the key of the item in the dictionary at the given location.
            this.load();
            if (this._items[index])
                return this._items[index].itemKey;
            else
                return null;
        },
        getValues: function () {
            // summary:
            //      Returns an array containing the values of all the items in the context dictionary.
            var valRes = [], i;
            for (i = 0; i < this._items.length; i++) {
                valRes.push(decodeURIComponent(this._items[i].itemVal));
            }
            return valRes;
        },
        save: function (hours) {
            // summary:
            //      Saves the state of the current context to a hidden form field so the data is passed to the server in the form post.
            var data = document.getElementById(this.contextDataFieldId);
            if (data) {
                //alert("saving to: " + data.id);
                data.value = this.toString();
            }
            else {
                alert("can't find context data field");
            }
        },
        load: function () {
            // summary:
            //      Loads the context dictionary from the data found in the hidden form field.
            var data = document.getElementById(this.contextDataFieldId);
            if (data) {
                if (data.value) {
                    //alert("loading from: " + data.id);
                    this.fromString(data.value);
                }
            }
        },
        toString: function () {
            // summary:
            //      Returns a URL Encoded string containing ampersand separated name/value pairs of all the items in the context dictionary.
            var str = "", i;
            for (i = 0; i < this._items.length; i++) {
                str += this._items[i].itemKey + "=" + encodeURIComponent(this._items[i].itemVal);
                if (i !== this._items.length - 1)
                    str += "&";
            }
            return str;
        },
        fromString: function (qString) {
            // summary:
            //      Loads the context dictionary from a URL Encoded string of name/value pairs.
            this._items = [];
            if (qString !== "") {
                var items = qString.split("&"), i;
                for (i = 0; i < items.length; i++) {
                    var pair = items[i].split("=");
                    this._items.push(this._toItemLiteral(pair[0], decodeURIComponent(pair[1])));
                }
            }
            this.save();
        }
    });

    return widget;
});




},
'Sage/Services/ClientEntityContext':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define, TabControl, __doPostBack */
define([
    'dojo/_base/declare',
    'dojo/dom',
    'dojo/dom-style',
    'Sage/Utility'
],
function (declare, dojoDom, domStyle, Utility) {
    var widget = declare('Sage.Services.ClientEntityContext', null, {
        hasClearListener: false,
        tempContext: false,
        constructor: function (options) {
            //console.log('ClientEntityContext is starting up...');
            this.inherited(arguments);
            dojo.mixin(this, options);
            this.emptyContext = { "EntityId": "", "EntityType": "", "Description": "", "EntityTableName": "" };
        },
        getContext: function () {
            if (this.tempContext) {
                return this.tempContext;
            }
            if ((Sage.Data) && (Sage.Data.EntityContextStore)) {
                var obj = Sage.Data.EntityContextStore;
                for (var item in obj) {
                    if (obj.hasOwnProperty(item)) {
                        // the property is encoded in client context services in CI
                        obj[item] = Utility.htmlDecode(obj[item]);
                    }
                }
                return Sage.Data.EntityContextStore;
            }
            return this.emptyContext;
        },
        setContext: function (obj) {
            Sage.Data.EntityContextStore = dojo.mixin(this.emptyContext, obj);
            this.onEntityContextChanged(Sage.Data.EntityContextStore);
        },
        setTemporaryContext: function (obj) {
            this.tempContext = obj;
        },
        clearTemporaryContext: function () {
            this.tempContext = false;
        },
        navigateSLXGroupEntity: function (toEntityId, previousEntityid, clientPosition) {
            if (Sage.Services) {
                var mgr = Sage.Services.getService("ClientBindingManagerService");
                if ((mgr) && (!mgr.canChangeEntityContext())) {
                    return false;
                }

                //the context is changing i.e. we are changing records so lets stop the user from clicking another link 
                //by putting up a loading screen
                var loaderDiv = dojoDom.byId("loader");
                if (loaderDiv) {
                    domStyle.set(loaderDiv, "display", "block");
                    domStyle.set(loaderDiv, "opacity", 0.75);
                }

                var contextservice = Sage.Services.getService("ClientContextService");
                if (contextservice.containsKey("ClientEntityId")) {
                    contextservice.setValue("ClientEntityId", toEntityId);
                } else {
                    contextservice.add("ClientEntityId", toEntityId);
                }
                previousEntityid = (previousEntityid) ? previousEntityid : Sage.Data.EntityContextStore.EntityId;
                if (contextservice.containsKey("PreviousEntityId")) {
                    contextservice.setValue("PreviousEntityId", previousEntityid);
                } else {
                    contextservice.add("PreviousEntityId", previousEntityid);
                }
                if (clientPosition) {
                    if (contextservice.containsKey("ClientEntityPosition")) {
                        contextservice.setValue("ClientEntityPosition", clientPosition);
                    } else {
                        contextservice.add("ClientEntityPosition", clientPosition);
                    }
                }
                //wire up cleanup service...
                if (!this.hasClearListener) {
                    Sys.WebForms.PageRequestManager.getInstance().add_pageLoaded(function () {
                        if (Sage.Services) {
                            var contextservice = Sage.Services.getService("ClientContextService");
                            if (contextservice.containsKey("PreviousEntityId")) {
                                contextservice.remove("PreviousEntityId");
                            }
                        }
                        //the page has returned from the post back and loaded so lets clean up the loading screen
                        var loaderDiv = dojoDom.byId("loader");
                        if (loaderDiv) {
                            domStyle.set(loaderDiv, "display", "none");
                            domStyle.set(loaderDiv, "opacity", 0);
                        }
                    });
                    this.hasClearListener = true;
                }
                //set current state for things that load earlier in the response than the new full context.
                Sage.Data.EntityContextStore.EntityId = toEntityId;
                Sage.Data.EntityContextStore.Description = '';

            }
            if (window.TabControl) {
                var tState = TabControl.getState();
                if (tState) {
                    tState.clearUpdatedTabs();
                    TabControl.updateStateProxy();
                }
            }
            __doPostBack("MainContent", "");
            return true;
        },
        onEntityContextChanged: function (newContext) {

        }
    });

    if (!Sage.Services.hasService('ClientEntityContext')) {
        Sage.Services.addService('ClientEntityContext', new Sage.Services.ClientEntityContext());
    }

    return widget;
});
},
'Sage/Services/LocalStorageService':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define, cookie */
define([
    'Sage/Data/SDataServiceRegistry',
    'dojo/_base/declare',
    'icrm-js-services'
],
/**
 * This is a slxClient wrapper for the icrm-js-sdk caching service.
 *  This instance of the caching service works with the local storage.
 */
function (SDataServiceRegistry, declare, ServiceBundle) {
    // make sure that icrm-js-sdk has a caching service
    var bundledService = {};
    if (ServiceBundle && ServiceBundle.CachingService) {
        bundledService = ServiceBundle.CachingService;
    } else {
        console.error('the caching service is missing from icrm-js-sdk\'s services');
    }

    var svc = declare('Sage.Services.LocalStorageService', [bundledService], {
        constructor: function () {
            if (typeof(this.setCacheStorage) === 'function') {
                this.setCacheStorage(localStorage);
            } else {
                console.error('double check the expected caching service being used.');
            }
        }
    });
    /**
    * Add an instance of this service to the Sage.Services service collection.
    */
    if (!Sage.Services.hasService('LocalStorage'))
        Sage.Services.addService('LocalStorage', new Sage.Services.LocalStorageService());
    return svc;
});
},
'icrm-js-services/icrm-js-services':function(){
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ICRMServicesSDK"] = factory();
	else
		root["ICRMServicesSDK"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _caching = __webpack_require__(1);

Object.keys(_caching).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _caching[key];
    }
  });
});

var _culture = __webpack_require__(2);

Object.keys(_culture).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _culture[key];
    }
  });
});

var _mingle = __webpack_require__(3);

Object.keys(_mingle).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _mingle[key];
    }
  });
});

var _picklist = __webpack_require__(4);

Object.keys(_picklist).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _picklist[key];
    }
  });
});

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GeneralMessages = {
  MissingRequiredFunctionalityError: 'The store provided was not compatible with the generic storage service. the store needs to have the following methods methods: getItem, setItem, removeItem.',
  NoInputNothingSetWarning: 'Nothing was set, input was null.',
  NamespaceAndNameParameterError: 'namespaceOrKey is required to be a string value.',
  CannotRemoveNoItemForLanguageWarning: 'Item missing for the language'
};
var CachingServiceMessages = exports.CachingServiceMessages = {
  constructorError: GeneralMessages.MissingRequiredFunctionalityError,
  setCacheStorageError: GeneralMessages.MissingRequiredFunctionalityError,
  setCacheStorageWarning: GeneralMessages.NoInputNothingSetWarning,
  getItemError: GeneralMessages.NamespaceAndNameParameterError,
  setItemError: GeneralMessages.NamespaceAndNameParameterError,
  removeItemError: GeneralMessages.NamespaceAndNameParameterError,
  removeMissingItemWarning: GeneralMessages.CannotRemoveNoItemForLanguageWarning
};

var UnitOfTime = exports.UnitOfTime = {
  YEAR: 0,
  MONTH: 1,
  DAY: 2,
  HOUR: 3,
  MINUTE: 4,
  SECOND: 5,
  MILLISECOND: 6
};

/**
 * Caching Service class to act as a wrapper for different web/browser data stores.
 * @class CachingService
 */

var CachingService = exports.CachingService = function () {
  /**
   * Initialize Sage.CachingService, a simple wrapper for different web/browser data stores.
   * @param {Object} storage  Will normally be either localStorage, or sessionStorage, but does not need to be.
   *      Though it must have the following functions:
   *                  getItem()
   *                  setItem()
   *                  removeItem()
   * @param {Number} lifecycle a number indicating how long to keep the cache around. default value is 5.
   * @param {UnitOfTime} units describe the provided lifecycle value, and itself is a value from the list:
   *                [years, months, days, hours, minutes, seconds, milliseconds]
   */
  function CachingService(storage, lifecycle, units) {
    _classCallCheck(this, CachingService);

    this.setCacheStorage(storage);
    this.seed = 1;
    this.lifespan = lifecycle || 5;
    this.lifespanUnits = units || UnitOfTime.DAY;
  }

  /**
   * @function set the data store used by this class.
   *
   * @param {Object} storage  Will normally be either localStorage, or sessionStorage, but does not need to be.
   *      Though it must have the following functions:
   *                  getItem()
   *                  setItem()
   *                  removeItem()
   */


  _createClass(CachingService, [{
    key: 'setCacheStorage',
    value: function setCacheStorage(storage) {
      if (storage) {
        if (typeof storage.getItem === 'function' && typeof storage.setItem === 'function' && typeof storage.removeItem === 'function') {
          this._cacheStorage = storage;
        } else {
          throw new Error(CachingServiceMessages.setCacheStorageError);
        }
      } else {
        console.warn(CachingServiceMessages.setCacheStorageWarning); //eslint-disable-line
      }
    }

    /**
     * @function retrieve the data store used by this class.
     */

  }, {
    key: 'getCacheStorage',
    value: function getCacheStorage() {
      return this._cacheStorage;
    }

    /**
     * @function retrieve an item from the data store.
     *
      * @param {String} namespace reference to the map in storage that pairs the object name with the storage id of that object.
     *                            if an name  and context is not provided, then the namespace will be the reference to the object in storage.
     * @param {String} name the name of the object being retrieved. This name is mapped to an id which is used to retrieve the data.
     * @param {String} context a key based off of the current state. It is a reference to a sub object in storage.
     */

  }, {
    key: 'getItem',
    value: function getItem(namespace, name, context) {
      var map = this.convertArgumentsToBitMap(namespace, name, context);
      switch (map) {
        case 7:
          // have a value for namespace, name, context
          {
            var uID = this.addAndGrabNamespaceKey(namespace, name);
            var dataData = this._cacheStorage.getItem(uID);
            var data = dataData ? JSON.parse(dataData) || dataData : null;
            return data && data.context && data.context[context] ? data.context[context] : null;
          }
        case 6:
          // have a value for namespace, name
          {
            var _uID = this.addAndGrabNamespaceKey(namespace, name);
            var _dataData = this._cacheStorage.getItem(_uID);
            var _data = _dataData ? JSON.parse(_dataData) || _dataData : null;
            return _data && _data.data ? _data.data : null;
          }
        case 4:
          // have a value for namespace
          {
            return this._cacheStorage.getItem(namespace);
          }
        default:
          throw new Error(CachingServiceMessages.removeItemError);
      }
    }

    /**
     * @function save an item from the data store.
     *
     * @param {String} namespace reference to the map in storage that pairs the object name with the storage id of that object.
     *                            if an name  and context is not provided, then the namespace will be the reference to the object in storage.
     * @param {String} name the name of the object being retrieved. This name is mapped to an id which is used to retrieve the data.
     * @param {String} context a key based off of the current state. It is a reference to a sub object in storage.
     * @param {Object} item the item to be saved to the data store.
     */

  }, {
    key: 'setItem',
    value: function setItem(namespace, name, context, item) {
      var map = this.convertArgumentsToBitMap(namespace, name, context);
      var uID = namespace;
      switch (map) {
        case 7:
          // have a value for namespace, name, context
          {
            uID = this.addAndGrabNamespaceKey(namespace, name);
            break;
          }
        case 6:
          // have a value for namespace, name
          {
            uID = this.addAndGrabNamespaceKey(namespace, name);
            context = null;
            break;
          }
        case 4:
          // have a value for namespace
          {
            context = null;
            break;
          }
        default:
          throw new Error(CachingServiceMessages.removeItemError);
      }
      this.writeData(uID, item, context);
    }
    /* helper function for getItem*/

  }, {
    key: 'writeData',
    value: function writeData(key, item, context) {
      var foundItem = this._cacheStorage.getItem(key);
      var itemToAdd = context ? { context: {} } : { create: this.timeStamp(), expires: this.expiresStamp() };
      if (context) {
        itemToAdd.context[context + '@'] = this.timeStamp();
        itemToAdd.context[context + '!'] = this.expiresStamp();
      }
      if (foundItem) {
        itemToAdd = JSON.parse(foundItem);
      }
      if (context) {
        itemToAdd.context[context] = item;
      } else {
        itemToAdd.data = item;
      }
      this._cacheStorage.setItem(key, JSON.stringify(itemToAdd));
    }
    /**
     * @function remove an item from the data store.
     *
      * @param {String} namespace reference to the map in storage that pairs the object name with the storage id of that object.
     *                            if an name  and context is not provided, then the namespace will be the reference to the object in storage.
     * @param {String} name the name of the object being retrieved. This name is mapped to an id which is used to retrieve the data.
     * @param {String} context a key based off of the current state. It is a reference to a sub object in storage.
     */

  }, {
    key: 'removeItem',
    value: function removeItem(namespace, name, context) {
      var map = this.convertArgumentsToBitMap(namespace, name, context);
      switch (map) {
        case 7:
          // have a value for namespace, name, context
          {
            var namespaceObj = this._cacheStorage.getItem(namespace);
            if (namespaceObj) {
              var objData = JSON.parse(namespaceObj);
              if (objData.expires && objData.expires < this.timeStamp()) {
                this._cacheStorage.removeItem(name);
              } else {
                if (objData.context) {
                  delete objData.context[context];
                }
                this._cacheStorage.setItem(name, JSON.stringify(objData));
              }
            }
            break;
          }
        case 6:
          // have a value for namespace, name
          {
            var _namespaceObj = this._cacheStorage.getItem(namespace);
            if (_namespaceObj) {
              var _objData = JSON.parse(_namespaceObj);
              if (_objData && _objData.keys) {
                for (var i = 0; i < _objData.keys.length; i++) {
                  var item = _objData.keys[i];
                  if (item && item.name === name) {
                    if (this._cacheStorage.getItem(item.id) != null) {
                      this._cacheStorage.removeItem(item.id);
                    }
                    _objData.keys.splice(i, 1);
                  }
                }
                this._cacheStorage.setItem(namespace, JSON.stringify(_objData));
              }
            }
            break;
          }
        case 4:
          // have a value for namespace
          {
            var keys = this.getNamespaceKeys(namespace);
            if (keys) {
              for (var _i = 0; _i < keys.length; _i++) {
                var _item = keys[_i];
                if (_item && _item.id && this._cacheStorage.getItem(_item.id)) {
                  this._cacheStorage.removeItem(_item.id);
                }
              }
            }
            this._cacheStorage.removeItem(namespace);
            break;
          }
        default:
          throw new Error(CachingServiceMessages.removeItemError);
      }
    }
    /* utility method used for a specific argument pattern used to direct funcitonlity based on arguments provided */

  }, {
    key: 'convertArgumentsToBitMap',
    value: function convertArgumentsToBitMap(namespace, name, context) {
      //eslint-disable-line
      var map = typeof namespace === 'string' ? 1 : 0;
      map = map << 1;
      map = map | (typeof name === 'string' ? 1 : 0);
      map = map << 1;
      map = map | (typeof context === 'string' ? 1 : 0);
      if (map <= 3) {
        // no namespace = error
        throw new Error(CachingServiceMessages.removeItemError);
      }
      if (map === 5) {
        // a context value, but no name = error
        throw new Error(CachingServiceMessages.removeItemError);
      }
      return map;
    }
    /* utility function for getting a UTC timestamp*/

  }, {
    key: 'timeStamp',
    value: function timeStamp() {
      //eslint-disable-line
      var now = new Date();
      return Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds(), now.getUTCMilliseconds());
    }
    /* utility function for getting a UTC timestamp*/

  }, {
    key: 'expiresStamp',
    value: function expiresStamp() {
      //eslint-disable-line
      var expires = new Date(this.timeStamp());
      switch (this.lifespanUnits) {
        case UnitOfTime.YEAR:
          return expires.setYear(expires.getUTCFullYear() + this.lifespan);
        case UnitOfTime.MONTH:
          return expires.setYear(expires.getUTCMonth() + this.lifespan);
        case UnitOfTime.DAY:
          return expires.setYear(expires.getUTCDate() + this.lifespan);
        case UnitOfTime.HOUR:
          return expires.setYear(expires.getUTCHours() + this.lifespan);
        case UnitOfTime.MINUTE:
          return expires.setYear(expires.getUTCMinutes() + this.lifespan);
        case UnitOfTime.SECOND:
          return expires.setYear(expires.getUTCSeconds() + this.lifespan);
        case UnitOfTime.MILLISECOND:
          return expires.setYear(expires.getUTCMilliseconds() + this.lifespan);
        default:
          return expires;
      }
    }
    /* a helper method that controls the id generation logic*/

  }, {
    key: 'uniqueLocalID',
    value: function uniqueLocalID() {
      var date = Date.now();
      // If created at same millisecond as previous
      if (date <= this.seed) {
        date = ++this.seed;
      } else {
        this.seed = date;
      }
      return date;
    }
    /* this helper defines the common task of getting the map of names to id for a provided namespace*/

  }, {
    key: 'getNamespaceKeys',
    value: function getNamespaceKeys(namespace) {
      var namespaceObj = this._cacheStorage.getItem(namespace);
      return JSON.parse(namespaceObj || '{}').keys || null;
    }
    /* a helper that attempts to get the mapped id of an object in a certain namespace.
        If the id does not exist, one is created for the object name and returned*/

  }, {
    key: 'addAndGrabNamespaceKey',
    value: function addAndGrabNamespaceKey(namespace, objectName) {
      var listOfkeys = this.getNamespaceKeys(namespace);
      var uID = null;
      if (listOfkeys) {
        var keyArr = listOfkeys.filter(function (x) {
          return x.name === objectName;
        });
        if (keyArr && keyArr[0] && keyArr[0].id) {
          uID = keyArr[0].id;
        }
      } else {
        listOfkeys = [];
      }
      if (uID === null) {
        uID = this.uniqueLocalID();
        listOfkeys.push({ name: objectName, id: uID });
        this._cacheStorage.setItem(namespace, JSON.stringify({ keys: listOfkeys }));
      }
      return uID;
    }
  }]);

  return CachingService;
}();

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CultureService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _mockSDataCultureClass = __webpack_require__(5);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CultureService = exports.CultureService = function () {
  function CultureService() {
    var cacheService = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    _classCallCheck(this, CultureService);

    this.cache = cacheService;
    this.activeTag = 'ActiveCodes';
    this.allTag = 'AllCodes';
    this.nameSpace = 'CultureCodes';
    this.neutralTag = 'NeutralCodes';
    this.regionTag = 'RegionCodes';
  }

  _createClass(CultureService, [{
    key: 'getAllCodes',
    value: function getAllCodes(query, params) {
      this.getFromCache(this.allTag, query, params);
    }
  }, {
    key: 'getNeutralCodes',
    value: function getNeutralCodes(query, params) {
      this.getFromCache(this.neutralTag, query, params);
    }
  }, {
    key: 'getRegionCodes',
    value: function getRegionCodes(query, params) {
      this.getFromCache(this.regionTag, query, params);
    }
  }, {
    key: 'getActiveCodes',
    value: function getActiveCodes(query, params) {
      // expects the path, ~/App_Data/LanguageList.xml, to exist on the Request's path. See Sage.SalesLogic.Web.EnabledLanguageList.cs
      this.getFromCache(this.activeTag, query, params);
    }
  }, {
    key: 'getFromCache',
    value: function getFromCache(tag, query, params) {
      var data = this.cache.getItem(this.nameSpace, tag) || null;
      if (!(params || {}).onSuccess) {
        throw new Error('A callback function of onSuccess is expected by the method. Without it no data can be accessed.');
      }
      if (!data) {
        this.createQueryForCodes(query, tag, params);
      } else {
        this.onSuccess(data, tag, this, params.onSuccess);
      }
    }
  }, {
    key: 'createQueryForCodes',
    value: function createQueryForCodes(query, tag, params) {
      var me = this; // incase scope is redefined by param
      if (query === null || typeof query === 'undefined' || (params || {}).Test) {
        console.warn('no request is being made, pulling from mock data'); //eslint-disable-line
        me.onSuccess(new _mockSDataCultureClass.MockSDataCulture().makeRequest(), tag, me, (params || {}).onSuccess);
      } else {
        if (!query.read) {
          throw new Error('The method needs to retrieve data, but the query object is missing the expected \'read\' function.');
        }
        query.read({
          async: true, // <-setting to false causes warning in SlxClient so force it to be true.
          success: function success(data) {
            me.onSuccess(data, tag, me, (params || {}).onSuccess);
          },
          failure: (params || {}).onFail || function onFail(o) {
            console.warn('%o', o);
          }, //eslint-disable-line
          scope: (params || {}).scope || me
        });
      }
    }
  }, {
    key: 'onSuccess',
    value: function onSuccess(data, tag, scope, callback) {
      /* marked as a method that should be static, but is a helper method only used in createQueryForCodes method. */ //eslint-disable-line
      var resource = data.$resources ? data.$resources[0] : data;
      var cultureList = [];
      if (resource.response) {
        var lists = resource.response;
        if (lists.allLanguages) {
          var getResult = this.setAndGetFromCache(scope.cache, scope.nameSpace, scope.allTag, lists.allLanguages, scope.allTag === tag);
          cultureList = getResult === null ? cultureList : getResult;
        }
        if (lists.neutralLanguages) {
          var _getResult = this.setAndGetFromCache(scope.cache, scope.nameSpace, scope.neutralTag, lists.neutralLanguages, scope.neutralTag === tag);
          cultureList = _getResult === null ? cultureList : _getResult;
        }
        if (lists.regionLanguage) {
          var _getResult2 = this.setAndGetFromCache(scope.cache, scope.nameSpace, scope.regionTag, lists.regionLanguage, scope.regionTag === tag);
          cultureList = _getResult2 === null ? cultureList : _getResult2;
        }
        if (lists.activeLanguages) {
          var _getResult3 = this.setAndGetFromCache(scope.cache, scope.nameSpace, scope.activeTag, lists.activeLanguages, scope.activeTag === tag);
          cultureList = _getResult3 === null ? cultureList : _getResult3;
        }
      } else {
        cultureList = resource;
      }
      if (callback) {
        callback(typeof cultureList === 'string' ? JSON.parse(cultureList) : cultureList);
      }
    }
  }, {
    key: 'setAndGetFromCache',
    value: function setAndGetFromCache(cache, nameSpace, tagUsed, data, skipGet) {
      /* marked as a method that should be static, but is a helper method only used in onsucess method. */ //eslint-disable-line
      cache.setItem(nameSpace, tagUsed, null, data);
      return skipGet ? cache.getItem(nameSpace, tagUsed) || [] : null;
    }
  }]);

  return CultureService;
}();

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Mingle Service class to handle single sign on and other Ming.le functions
 * @class MingleService
 */
var MingleService = exports.MingleService = function () {
  /**
   * Instantiates the MingleService object
   * @param {Object} options Takes in a configuration object with the following structure:
   * {
   *    accessToken: string;
   *    application: Object; // Based on mobile's version of an application
   *    location: Object; // Based on the window.location
   *    mingleConfig: {
   *      mingleSettings: {
   *        ci: string;
   *        pu: string;
   *        oa: string;
   *      },
   *      mingleRedirectUrl: string;
   *    };
   *    redirectAction: function(url: string) => void;
   *    responseType: string; // Defaulted to 'token'
   * }
   */
  function MingleService() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, MingleService);

    this.accessToken = options.accessToken || '';
    this.application = options.application || {};
    this.location = options.location || window.location;
    this.mingleConfig = options.mingleConfig || {};
    this.redirectAction = options.redirectAction || function redirect(url) {
      this.location.href = url;
    }.bind(this);
    this.responseType = options.responseType || 'token';
  }
  /**
   * @function Populates the access token based on the passed parameters
   * @param {Object} state The current state to be bound to the url request
   */


  _createClass(MingleService, [{
    key: 'redirectToMingle',
    value: function redirectToMingle(state) {
      var authorizationUrl = this.mingleConfig.mingleSettings.pu + this.mingleConfig.mingleSettings.oa;
      var redirectURI = this.mingleConfig.mingleRedirectUrl;
      var clientId = this.mingleConfig.mingleSettings.ci;
      var url = authorizationUrl + '?' + ('client_id=' + encodeURI(clientId) + '&') + ('redirect_uri=' + encodeURI(redirectURI) + '&') + ('response_type=' + encodeURI(this.responseType) + '&') + ('state=' + encodeURI(state) + '&') + 'include_granted_scopes=false';
      this.redirectAction(url);
    }
    /**
     * @function Refreshes the access token for Ming.le
     */

  }, {
    key: 'refreshAccessToken',
    value: function refreshAccessToken() {
      if (!this.application.isOnline()) {
        this.application.requiresMingleRefresh = true;
        return;
      }

      var hash = 'mingleRefresh'; // location.hash.substring(2);
      var state = '';
      if (hash) {
        state = '/redirectTo/' + hash;
      }
      this.redirectToMingle(state);
    }
    /**
     * @function Populates the access token based on the passed parameters
     * @param {Object} toast The toast service used by the application, expects a function 'add'
     *  that is passed the following object:
     *    {
     *      message: string;
     *      title: string;
     *      toastTime: number;
     *      showProgressBar: boolean;
     *    }
     * @param {string} refreshText The message to be displayed by the toast service
     * @param {string} refreshTitle The title of the toast to display when refreshing the token
     */

  }, {
    key: 'populateAccessToken',
    value: function populateAccessToken(toast) {
      var _this = this;

      var refreshText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Refreshing Ming.le token...';
      var refreshTitle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'Ming.le';

      var hash = this.location.hash.substring(1);
      var result = void 0;
      if (hash) {
        result = hash.split('&').reduce(function (values, item) {
          var parts = item.split('=');
          values[parts[0]] = parts[1];
          return values;
        }, {});

        if (result.access_token) {
          this.accessToken = result.access_token;
          if (result.expires_in) {
            // result.expires_in = '420'; // Refresh Test
            setTimeout(function () {
              toast.add({ message: refreshText, title: refreshTitle, toastTime: 300 * 1000, showProgressBar: true });
              setTimeout(function () {
                _this.refreshAccessToken(_this.mingleConfig);
              }, 300 * 1000);
              // Show message to user before 5 minutes of refresh (300 seconds)
            }, (result.expires_in - 300) * 1000);
          }
        }
      }

      if (result) {
        if (result.access_token || result.error) {
          return result;
        }
      }

      this.redirectToMingle(hash);
    }
  }]);

  return MingleService;
}();

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Picklist Service class
 */
var PickListService = exports.PickListService = function () {
  /**
   * Initialize Sage.PickListService
   * @param {Object} storage
   * @param {Object} service
   */
  function PickListService() {
    var storage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var service = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, PickListService);

    this._storage = storage;
    this._service = service;
    this._uri = {};
    this._storageNameSpace = 'PickListData';
    this._storagePropertyDataTypeNameSpace = 'PickListData_PropertyDataType';
    this._storageFormDataTypeNameSpace = 'PickListData_FormDataType';
  }
  /** CRUD **/
  /** Create **/
  /**
   * @function create a picklist header record.
   * @param {PickListObject} header
   * @param {Function} callback defines how to react to a repsonse that is successful.
   * @param {Function} onError defines how to react to a repsonse that is an error.
   * @param {Object} config provides access to variables needed inside the response.
   */


  _createClass(PickListService, [{
    key: 'createHeader',
    value: function createHeader(header, callback, onError, config) {
      this._notImplemented('createHeader', { header: header, callback: callback, onError: onError, config: config });
    }
    /**
     * @function create a picklist item record.
     * @param {String} headerId refers to a picklist header by its id.
     * @param {PickListItemObject} item
     * @param {Function} callback defines how to react to a repsonse that is successful.
     * @param {Function} onError defines how to react to a repsonse that is an error.
     * @param {Object} config provides access to variables needed inside the response.
     */

  }, {
    key: 'createItemByHeaderID',
    value: function createItemByHeaderID(headerId, item, callback, onError, config) {
      this.createItemByHeaderKey(headerId, true, item, callback, onError, config);
    }
    /**
     * @function create a picklist item record.
     * @param {String} headerName refers to a picklist header by its name.
     * @param {PickListItemObject} item
     * @param {Function} callback defines how to react to a repsonse that is successful.
     * @param {Function} onError defines how to react to a repsonse that is an error.
     * @param {Object} config provides access to variables needed inside the response.
     */

  }, {
    key: 'createItemByHeaderName',
    value: function createItemByHeaderName(headerName, item, callback, onError, config) {
      this.createItemByHeaderKey(headerName, false, item, callback, onError, config);
    }
    /**
     * @function create a picklist item record.
     * @param {String} headerKey refers to a picklist by either the Id or Name value.
     * @param {Boolean} isId true ? the headerKey is an Id : the headerKey is a Name
     * @param {PickListItemObject} item
     * @param {Function} callback defines how to react to a repsonse that is successful.
     * @param {Function} onError defines how to react to a repsonse that is an error.
     * @param {Object} config provides access to variables needed inside the response.
     */

  }, {
    key: 'createItemByHeaderKey',
    value: function createItemByHeaderKey(headerKey, isId, item, callback, onError, config) {
      this._notImplemented('createItemByHeaderKey', { headerKey: headerKey, isId: isId, item: item, callback: callback, onError: onError, config: config });
    }
    /**
     * @function create a picklist item record.
     * @param {String} headerId refers to a picklist header by its id.
     * @param {PickListItemObject[]} itemArr
     * @param {Function} callback defines how to react to a repsonse that is successful.
     * @param {Function} onError defines how to react to a repsonse that is an error.
     * @param {Object} config provides access to variables needed inside the response.
     */

  }, {
    key: 'createItemsByHeaderID',
    value: function createItemsByHeaderID(headerId, itemArr, callback, onError, config) {
      this.createItemsByHeaderKey(headerId, true, itemArr, callback, onError, config);
    }
    /**
     * @function create a picklist item record.
     * @param {String} headerName refers to a picklist header by its name.
     * @param {PickListItemObject[]} itemArr
     * @param {Function} callback defines how to react to a repsonse that is successful.
     * @param {Function} onError defines how to react to a repsonse that is an error.
     * @param {Object} config provides access to variables needed inside the response.
     */

  }, {
    key: 'createItemsByHeaderName',
    value: function createItemsByHeaderName(headerName, itemArr, callback, onError, config) {
      this.createItemsByHeaderKey(headerName, false, itemArr, callback, onError, config);
    }
    /**
     * @function create a picklist item record.
     * @param {String} headerKey refers to a picklist by either the Id or Name value.
     * @param {Boolean} isId true ? the headerKey is an Id : the headerKey is a Name
     * @param {PickListItemObject[]} itemArr
     * @param {Function} callback defines how to react to a repsonse that is successful.
     * @param {Function} onError defines how to react to a repsonse that is an error.
     * @param {Object} config provides access to variables needed inside the response.
     */

  }, {
    key: 'createItemsByHeaderKey',
    value: function createItemsByHeaderKey(headerKey, isId, itemArr, callback, onError, config) {
      this._notImplemented('createItemsByHeaderKey', { headerKey: headerKey, isId: isId, itemArr: itemArr, callback: callback, onError: onError, config: config });
    }

    /** Request **/
    /** header and items **/
    /**
     * @function get one picklist(this first found) record with items.
     * @param {String} name refers to the name property of a picklist header.
     * @param {Function} callback defines how to react to a repsonse that is successful.
     * @param {Function} onError defines how to react to a repsonse that is an error.
     * @param {Object} config provides access to variables needed inside the response.
     */

  }, {
    key: 'getFirstByName',
    value: function getFirstByName(name, callback, onError, config) {
      return this.getFirstByKey(name, false, callback, onError, config);
    }
    /**
     * @function get one picklist(this first found) record with items.
     * @param {String} id refers to the id property of a picklist header.
     * @param {Function} callback defines how to react to a repsonse that is successful.
     * @param {Function} onError defines how to react to a repsonse that is an error.
     * @param {Object} config provides access to variables needed inside the response.
     */

  }, {
    key: 'getFirstById',
    value: function getFirstById(id, callback, onError, config) {
      return this.getFirstByKey(id, false, callback, onError, config);
    }
    /**
     * @function get one picklist(this first found) record with items.
     * @param {String} key refers to a picklist by either the Id or Name value.
     * @param {Boolean} isId if true, then the key is an Id, else the key is a Name.
     * @param {Function} callback defines how to react to a repsonse that is successful.
     * @param {Function} onError defines how to react to a repsonse that is an error.
     * @param {Object} config provides access to variables needed inside the response.
     */

  }, {
    key: 'getFirstByKey',
    value: function getFirstByKey(key, isId, callback, onError) {
      var _this = this,
          _arguments = arguments;

      var config = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

      config.language = config.language || this._getBrowserLanguage(false);
      var useCache = typeof config.useCache === 'boolean' && config.useCache;
      var cachedResult = useCache ? this._storage.getItem(this._storageNameSpace, key, config.context || null) : null;
      if (cachedResult) {
        callback(cachedResult);
      } else {
        var options = this._buildOutOptions(config, true);
        options.where = this._isNameOrID(isId, key);
        return {
          options: options,
          handlers: {
            async: typeof config.async === 'boolean' ? config.async : true, // adding back for slxClient's column formatters, they need the call to not be async to work.
            success: function success(result) {
              if (result && result.$resources && result.$resources.length > 0) {
                result = result.$resources[0];
              }
              _this._storage.setItem(_this._storageNameSpace, key, config.context || null, result);
              if (typeof callback === 'function') {
                callback(result);
              } else {
                console.log('picklistservice getByName success: %o', _arguments); //eslint-disable-line
              }
            },
            failure: function failure(response) {
              if (typeof onError === 'function') {
                onError(response);
              } else {
                console.log('picklistservice getByName failure: %o', _arguments); //eslint-disable-line
              }
            },
            config: { passedIn: config }
          }
        };
      }
    }
    /**
     * @function get a list of picklists record with items.
     * @param {String[]} nameArr refers to the name property of a picklist header.
     * @param {Boolean} useCache if true, then cache the response of the request, else don't cache the response.
     * @param {Function} callback defines how to react to a repsonse that is successful.
     * @param {Function} onError defines how to react to a repsonse that is an error.
     * @param {Object} config provides access to variables needed inside the response.
     */

  }, {
    key: 'getAllByName',
    value: function getAllByName(nameArr, callback, onError, config) {
      this.getAllByKey(nameArr, false, callback, onError, config);
    }
    /**
     * @function get a list of picklists record with items.
     * @param {String[]} idArr refers to the id property of a picklist header.
     * @param {Boolean} useCache if true, then cache the response of the request, else don't cache the response.
     * @param {Function} callback defines how to react to a repsonse that is successful.
     * @param {Function} onError defines how to react to a repsonse that is an error.
     * @param {Object} config provides access to variables needed inside the response.
     */

  }, {
    key: 'getAllById',
    value: function getAllById(idArr, callback, onError, config) {
      this.getAllByKey(idArr, true, callback, onError, config);
    }
    /**
     * @function get a list of picklists record with items.
     * @param {String} keyArr refers to a picklist by either the Id or Name value.
     * @param {Boolean} isId if true, then the key is an Id, else the key is a Name.
     * @param {Boolean} useCache if true, then cache the response of the request, else don't cache the response.
     * @param {Function} callback defines how to react to a repsonse that is successful.
     * @param {Function} onError defines how to react to a repsonse that is an error.
     * @param {Object} config provides access to variables needed inside the response.
     */

  }, {
    key: 'getAllByKey',
    value: function getAllByKey(keyArr, isId, callback, onError, config) {
      this._notImplemented('getAllByKey', { keyArr: keyArr, isId: isId, callback: callback, onError: onError, config: config });
    }

    /** Update **/
    /**
     * @function update a picklist record.
     * @param {PickListObject} pickList
     * @param {Function} callback defines how to react to a repsonse that is successful.
     * @param {Function} onError defines how to react to a repsonse that is an error.
     * @param {Object} config provides access to variables needed inside the response.
     */

  }, {
    key: 'update',
    value: function update(pickList, callback, onError, config) {
      this._notImplemented('update', { pickList: pickList, callback: callback, onError: onError, config: config });
    }

    /** Delete **/
    /** header and items **/
    /**
     * @function remove a picklist header and its items record.
     * @param {String} name refers to the name property of a picklist header.
     * @param {Function} callback defines how to react to a repsonse that is successful.
     * @param {Function} onError defines how to react to a repsonse that is an error.
     * @param {Object} config provides access to variables needed inside the response.
     */

  }, {
    key: 'deleteByName',
    value: function deleteByName(name, callback, onError, config) {
      this.deleteByKey(name, false, callback, onError, config);
    }
    /**
     * @function remove a picklist header and its items record.
     * @param {String} name refers to the id property of a picklist header.
     * @param {Function} callback defines how to react to a repsonse that is successful.
     * @param {Function} onError defines how to react to a repsonse that is an error.
     * @param {Object} config provides access to variables needed inside the response.
     */

  }, {
    key: 'deleteById',
    value: function deleteById(id, callback, onError, config) {
      this.deleteByKey(id, true, callback, onError, config);
    }
    /**
     * @function remove a picklist header and its items record.
     * @param {String} key refers to a picklist by either the Id or Name value.
     * @param {Boolean} isId if true, then the key is an Id, else the key is a Name.
     * @param {Function} callback defines how to react to a repsonse that is successful.
     * @param {Function} onError defines how to react to a repsonse that is an error.
     * @param {Object} config provides access to variables needed inside the response.
     */

  }, {
    key: 'deleteByKey',
    value: function deleteByKey(key, isId, callback, onError, config) {
      this._notImplemented('deleteByKey', { key: key, isId: isId, callback: callback, onError: onError, config: config });
    }

    /** No just header delete, because that would produce "orphaned" picklist items **/

    /** just items **/
    /**
     * @function remove a picklist item record.
     * @param {String} name refers to the name property of a picklist header.
     * @param {String} code refers to the code property of a picklist item.
     * @param {String} language refers to the language property of a picklist item.
     * @param {Function} callback defines how to react to a repsonse that is successful.
     * @param {Function} onError defines how to react to a repsonse that is an error.
     * @param {Object} config provides access to variables needed inside the response.
     */

  }, {
    key: 'deleteItemByHeaderName',
    value: function deleteItemByHeaderName(name, code, language, callback, onError, config) {
      this.deleteItemByHeaderKey(name, false, code, language, callback, onError, config);
    }
    /**
     * @function remove a picklist item record.
     * @param {String} id refers to the id property of a picklist header.
     * @param {String} code refers to the code property of a picklist item.
     * @param {String} language refers to the language property of a picklist item.
     * @param {Function} callback defines how to react to a repsonse that is successful.
     * @param {Function} onError defines how to react to a repsonse that is an error.
     * @param {Object} config provides access to variables needed inside the response.
     */

  }, {
    key: 'deleteItemByHeaderId',
    value: function deleteItemByHeaderId(id, code, language, callback, onError, config) {
      this.deleteItemByHeaderKey(id, true, code, language, callback, onError, config);
    }
    /**
     * @function remove a picklist item record.
     * @param {String} key refers to the id or name property of a picklist header.
     * @param {Boolean} isId if true, then the key is an Id, else the key is a Name.
     * @param {String} code refers to the code property of a picklist item.
     * @param {String} language refers to the language property of a picklist item.
     * @param {Function} callback defines how to react to a repsonse that is successful.
     * @param {Function} onError defines how to react to a repsonse that is an error.
     * @param {Object} config provides access to variables needed inside the response.
     */

  }, {
    key: 'deleteItemByHeaderKey',
    value: function deleteItemByHeaderKey(key, isId, code, language, callback, onError, config) {
      this._notImplemented('deleteItemByHeaderKey', { key: key, isId: isId, code: code, language: language, callback: callback, onError: onError, config: config });
    }
    /**
     * @function remove a picklist item record.
     * @param {String} key refers to the id property of a picklist item.
     * @param {Function} callback defines how to react to a repsonse that is successful.
     * @param {Function} onError defines how to react to a repsonse that is an error.
     * @param {Object} config provides access to variables needed inside the response.
     */

  }, {
    key: 'deleteItemById',
    value: function deleteItemById(id, callback, onError, config) {
      this._notImplemented('deleteItemById', { id: id, callback: callback, onError: onError, config: config });
    }

    /** Getting PickList DataTypeData information */

  }, {
    key: 'getPickListDataTypeDataFromEntityProperty',
    value: function getPickListDataTypeDataFromEntityProperty(entityName, propertyName, callback, onError, config) {
      var _this2 = this,
          _arguments2 = arguments;

      config.language = config.language || this._getBrowserLanguage(false);
      var cachedToken = entityName + '_' + propertyName + '_' + config.language;
      var cachedResult = this._storage.getItem(this._storagePropertyDataTypeNameSpace, cachedToken);
      if (cachedResult) {
        callback(cachedResult);
      } else {
        return {
          options: {
            select: ['DataTypeData'],
            resourceKind: 'entities(\'' + entityName + '\')/properties',
            service: 'metadata',
            language: config.language || this._getBrowserLanguage(false),
            filterByLanguage: config.filterByLanguage || false,
            include: ['DataTypeData'],
            where: 'propertyName eq \'' + propertyName + '\''
          },
          handlers: {
            success: function success(result) {
              if (result && result.$resources && result.$resources.length > 0) {
                result = result.$resources[0];
              }
              _this2.parent._storage.setItem(_this2.parent._storageDataTypeNameSpace, cachedToken, result);
              if (typeof callback === 'function') {
                callback(result);
              } else {
                console.log('picklistservice getPickListDataTypeDataFromEntityProperty success: %o', _arguments2); //eslint-disable-line
              }
            },
            failure: function failure(response) {
              if (typeof onError === 'function') {
                onError(response);
              } else {
                console.log('picklistservice getPickListDataTypeDataFromEntityProperty failure: %o', _arguments2); //eslint-disable-line
              }
            },
            config: { parent: this, passedIn: config }
          }
        };
      }
    }
  }, {
    key: 'getPickListDataTypeDataFromForm',
    value: function getPickListDataTypeDataFromForm(formName) {
      var pickListName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var callback = arguments[2];

      var _this3 = this,
          _arguments3 = arguments;

      var onError = arguments[3];
      var config = arguments[4];

      config.language = config.language || this._getBrowserLanguage(false);
      var cachedToken = pickListName ? formName + '_' + pickListName + '_' + config.language : formName + '_' + config.language;
      var cachedResult = this._storage.getItem(this._storageFormDataTypeNameSpace, cachedToken);
      if (cachedResult) {
        callback(cachedResult);
      } else {
        return {
          options: {
            resourceKind: 'forms(\'' + formName + '\')',
            service: 'metadata',
            language: config.language || this._getBrowserLanguage(false)
          },
          handlers: {
            success: function success(result) {
              if (result && result.$resources && result.$resources.length > 0) {
                result = result.$resources[0];
              }
              _this3.parent._storage.setItem(_this3.parent._storageFormDataTypeNameSpace, cachedToken, result);
              if (typeof callback === 'function') {
                callback(result);
              } else {
                console.log('picklistservice getPickListDataTypeDataFromForm success: %o', _arguments3); //eslint-disable-line
              }
            },
            failure: function failure(response) {
              if (typeof onError === 'function') {
                onError(response);
              } else {
                console.log('picklistservice getPickListDataTypeDataFromForm failure: %o', _arguments3); //eslint-disable-line
              }
            },
            config: { parent: this, passedIn: config }
          }
        };
      }
    }
    /** Caching **/
    /**
     * @function removes a cached item.
     * @param {String} name reference to an item that has been cached.
     *
     * --Uses the storage value provided in the constructor.
     */

  }, {
    key: 'clearCache',
    value: function clearCache(name, lang) {
      var item = this._storage.getItem(this._storageNameSpace, name);
      if (item) {
        this._storage.removeItem(this._storageNameSpace, name);
      }
    }

    /** MISC **/
    /**
     * @function clones the this class.
     */

  }, {
    key: 'deepClone',
    value: function deepClone() {
      return JSON.parse(JSON.stringify(this));
    }
    /**
     * @function build up a request
     * @param {Object} obj needs to contain the functions:
     *                      setResourceKind()
     *                      setQueryArg()
     *
     * @param {Object} options can contain
     *                      {
     *                          where: String?
     *                          select: String?
     *                          include: Boolean?
     *                          language: String?
     *                          filterByLanguage: Boolean?
     *                          storageMode: {CODE, ID, TEXT}
     *                      }
     */

  }, {
    key: 'setUpRequest',
    value: function setUpRequest(obj, options) {
      /* though this could be a static function, that does not seem right since it is not much use outside this config*/ //eslint-disable-line 
      if (obj && options) {
        if (typeof obj.setResourceKind === 'function' && typeof obj.setQueryArg === 'function') {
          obj.setResourceKind(options.resourceKind);

          if (options.where && options.where.length > 0) {
            obj.setQueryArg('where', options.where);
          }
          if (options.select && options.select.length > 0) {
            obj.setQueryArg('select', options.select.join(','));
          }
          if (options.include && options.include.length > 0) {
            obj.setQueryArg('include', options.include.join(','));
          }
          if (options.language) {
            obj.setQueryArg('language', options.language);
          }
          if (options.filter) {
            // for testing
            obj.setQueryArg('filter', options.filter);
          }
          if (options.filterByLanguage !== undefined) {
            obj.setQueryArg('filterByLanguage', options.filterByLanguage);
          }
          if (options.storageMode) {
            obj.setQueryArg('storageMode', options.storageMode);
          }
        } else {
          console.warn('argument is the wrong type: %o', obj); //eslint-disable-line
        }
      } else {
        console.warn('arguments cannot be null'); //eslint-disable-line
      }
      return obj;
    }

    /* ** private functions **/

  }, {
    key: '_buildHash',
    value: function _buildHash(results) {
      this._notImplemented('_buildHash', { results: results });
    }
  }, {
    key: '_returnOption',
    value: function _returnOption(optionName, callback, onError, config) {
      this._notImplemented('_returnOption', { optionName: optionName, callback: callback, onError: onError, config: config });
    }
  }, {
    key: '_isNameOrID',
    value: function _isNameOrID(isId, key) {
      /* though this could be a static function, that does not seem right since it is not much use outside this config*/ //eslint-disable-line
      if (typeof isId === 'boolean' && typeof key === 'string') {
        return isId ? 'id eq \'' + key + '\'' : 'name eq \'' + key + '\'';
      }
      throw new Error('isId needs to be a boolean; key needs to be a string');
    }
  }, {
    key: '_buildOutOptions',
    value: function _buildOutOptions() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var includeItems = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var optionsObj = {
        select: ['Id', 'name', 'allowMultiples', 'valueMustExist', 'required', 'alphaSorted', 'noneEditable', 'defaultLanguage', 'defaultCode',
        // Include modifyDate to ensure that local storage data stays current.
        'modifyDate'],
        resourceKind: 'picklists',
        service: this._service,
        language: config.language || this._getBrowserLanguage(false)
      };
      if (includeItems) {
        optionsObj.include = ['items'];
        optionsObj.select.push('items/text');
        optionsObj.select.push('items/code');
        optionsObj.select.push('items/number');
        optionsObj.select.push('items/filter');
        optionsObj.select.push('items/languageCode');
      }
      if (config.pickListServiceOptions) {
        if (config.pickListServiceOptions.filter !== null && typeof config.pickListServiceOptions.filter === 'string') {
          optionsObj.filter = config.pickListServiceOptions.filter;
        }
        if (config.pickListServiceOptions.storageMode !== null && typeof config.pickListServiceOptions.storageMode === 'string') {
          optionsObj.storageMode = config.pickListServiceOptions.storageMode;
        }
        if (config.pickListServiceOptions.filterByLanguage !== null) {
          if (typeof config.pickListServiceOptions.filterByLanguage === 'boolean') {
            optionsObj.filterByLanguage = config.pickListServiceOptions.filterByLanguage;
          } else if (typeof config.pickListServiceOptions.filterByLanguage === 'string') {
            optionsObj.filterByLanguage = config.pickListServiceOptions.filterByLanguage.toLowerCase() === 'true'; // default behavior is false, so assume user will only set if true
          }
        }
      }
      return optionsObj;
    }
  }, {
    key: '_breakDownALanguageCodeIntoFallBackParts',
    value: function _breakDownALanguageCodeIntoFallBackParts() {
      var strLangCode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      /* though this could be a static function, it is a private helper function that works strictly within the config of _getBrowserLanguage*/ //eslint-disable-line
      var userLangs = strLangCode.split('-');
      var potentialLanguage = [];
      for (var i = 0; i < userLangs.length; i++) {
        var strVal = '';
        for (var j = 0; j <= i; j++) {
          strVal = strVal + (strVal.length > 0 ? '_' : '') + userLangs[j];
        }
        potentialLanguage.push(strVal);
      }
      return potentialLanguage;
    }
  }, {
    key: '_getBrowserLanguage',
    value: function _getBrowserLanguage() {
      var includeFallbacks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      var languageFromCookie = this._getLanguageFromCookie();
      var userLang = languageFromCookie || this._getFromLanguageFromNavigator();
      if (!userLang) {
        console.warn('no browser language found, will assume en-us for the rest.'); /* give warning because something went wrong... or in test enviroment */ //eslint-disable-line
        userLang = 'en-us';
      }
      if (includeFallbacks) {
        var languagePlusFallBacks = this._breakDownALanguageCodeIntoFallBackParts(userLang);
        return languagePlusFallBacks;
      }
      return userLang;
    }
  }, {
    key: '_getFromLanguageFromNavigator',
    value: function _getFromLanguageFromNavigator() {
      /* does not need to reference this, it is a helper for _getBrowserLanguage */ //eslint-disable-line
      if (typeof navigator !== 'undefined') {
        return navigator.userLanguage || navigator.browserLanguage || navigator.language;
      }
      console.warn('no navigator object found. hardcoding language to en-us'); /* give warning because something went wrong... or in test enviroment */ //eslint-disable-line
      return null;
    }
  }, {
    key: '_getLanguageFromCookie',
    value: function _getLanguageFromCookie() {
      var languageFromCookie = null;
      var cookieLangaugeKey = 'SLXLanguageSetting';
      if (typeof window !== 'undefined' && window.document && window.document.cookie) {
        if (typeof window.document.cookie.getCookie === 'function') {
          languageFromCookie = window.document.cookie.getCookie(cookieLangaugeKey);
        } else {
          var cookies = window.document.cookie.split(';');
          cookies.forEach(function (cookie) {
            cookie = cookie.trim();
            if (cookie.startsWith(cookieLangaugeKey)) {
              cookie = cookie.replace('' + cookieLangaugeKey, '').trim(); // remove the key part of the cookie and any spaces
              cookie = cookie.replace('=', '').trim(); // because there may or may not be a space between the key and '=', then remove now.
              languageFromCookie = cookie;
            }
          }, this);
        }
      } else {
        console.warn('no window/window.document/window.document.cookie object found'); /* give warning because something went wrong... or in test enviroment */ //eslint-disable-line
      }
      return languageFromCookie;
    }
  }, {
    key: '_notImplemented',
    value: function _notImplemented(functionName, params) {
      /* a function to give the unimplemented functions a call to hush lint errors*/ //eslint-disable-line
      throw new Error('%s with parameters %o is not implemented', functionName, params);
    }
  }]);

  return PickListService;
}();

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MockSDataCulture = exports.MockSDataCulture = function () {
  function MockSDataCulture() {
    _classCallCheck(this, MockSDataCulture);

    this.queryResult = {
      $httpStatus: 200,
      $descriptor: '',
      request: {},
      response: {
        neutralLanguages: [{ DisplayText: ' [ja]', CultureCode: 'ja' }, { DisplayText: '()  [zh-cht]', CultureCode: 'zh-cht' }, { DisplayText: '() [zh-hant]', CultureCode: 'zh-hant' }, { DisplayText: '()  [zh-chs]', CultureCode: 'zh-chs' }, { DisplayText: '() [zh-hans]', CultureCode: 'zh-hans' }, { DisplayText: ' [zh]', CultureCode: 'zh' }, { DisplayText: ' [ko]', CultureCode: 'ko' }, { DisplayText: '  [ii]', CultureCode: 'ii' }, { DisplayText: '  [am]', CultureCode: 'am' }, { DisplayText: ' [iu-cans]', CultureCode: 'iu-cans' }, { DisplayText: ' [km]', CultureCode: 'km' }, { DisplayText: ' [lo]', CultureCode: 'lo' }, { DisplayText: ' [bo]', CultureCode: 'bo' }, { DisplayText: '             [mn-mong]', CultureCode: 'mn-mong' }, { DisplayText: ' [th]', CultureCode: 'th' }, { DisplayText: ' [si]', CultureCode: 'si' }, { DisplayText: ' [ml]', CultureCode: 'ml' }, { DisplayText: ' [kn]', CultureCode: 'kn' }, { DisplayText: ' [te]', CultureCode: 'te' }, { DisplayText: ' [ta]', CultureCode: 'ta' }, { DisplayText: ' [or]', CultureCode: 'or' }, { DisplayText: ' [gu]', CultureCode: 'gu' }, { DisplayText: ' [pa]', CultureCode: 'pa' }, { DisplayText: ' [bn]', CultureCode: 'bn' }, { DisplayText: ' [as]', CultureCode: 'as' }, { DisplayText: ' [hi]', CultureCode: 'hi' }, { DisplayText: ' [sa]', CultureCode: 'sa' }, { DisplayText: '  [mr]', CultureCode: 'mr' }, { DisplayText: ' [ne]', CultureCode: 'ne' }, { DisplayText: ' [kok]', CultureCode: 'kok' }, { DisplayText: ' [dv]', CultureCode: 'dv' }, { DisplayText: ' [syr]', CultureCode: 'syr' }, { DisplayText: ' [ug]', CultureCode: 'ug' }, { DisplayText: ' [fa]', CultureCode: 'fa' }, { DisplayText: ' [prs]', CultureCode: 'prs' }, { DisplayText: ' [ps]', CultureCode: 'ps' }, { DisplayText: ' [ar]', CultureCode: 'ar' }, { DisplayText: ' [ur]', CultureCode: 'ur' }, { DisplayText: ' [he]', CultureCode: 'he' }, { DisplayText: '  [ka]', CultureCode: 'ka' }, { DisplayText: ' [hy]', CultureCode: 'hy' }, { DisplayText: ' [uk]', CultureCode: 'uk' }, { DisplayText: ' [uz-cyrl]', CultureCode: 'uz-cyrl' }, { DisplayText: ' [tg-cyrl]', CultureCode: 'tg-cyrl' }, { DisplayText: ' [tg]', CultureCode: 'tg' }, { DisplayText: ' [tt]', CultureCode: 'tt' }, { DisplayText: ' [sr-cyrl]', CultureCode: 'sr-cyrl' }, { DisplayText: ' [sah]', CultureCode: 'sah' }, { DisplayText: ' [ru]', CultureCode: 'ru' }, { DisplayText: '  [mn-cyrl]', CultureCode: 'mn-cyrl' }, { DisplayText: '  [mn]', CultureCode: 'mn' }, { DisplayText: '  [mk]', CultureCode: 'mk' }, { DisplayText: ' [kk]', CultureCode: 'kk' }, { DisplayText: ' [ky]', CultureCode: 'ky' }, { DisplayText: ' [bg]', CultureCode: 'bg' }, { DisplayText: ' [bs-cyrl]', CultureCode: 'bs-cyrl' }, { DisplayText: ' [be]', CultureCode: 'be' }, { DisplayText: ' [ba]', CultureCode: 'ba' }, { DisplayText: '  [az-cyrl]', CultureCode: 'az-cyrl' }, { DisplayText: ' [el]', CultureCode: 'el' }, { DisplayText: 'Yoruba [yo]', CultureCode: 'yo' }, { DisplayText: 'Wolof [wo]', CultureCode: 'wo' }, { DisplayText: 'U\'zbek [uz-latn]', CultureCode: 'uz-latn' }, { DisplayText: 'U\'zbek [uz]', CultureCode: 'uz' }, { DisplayText: 'trkmene [tk]', CultureCode: 'tk' }, { DisplayText: 'Trke [tr]', CultureCode: 'tr' }, { DisplayText: 'Ting Vit [vi]', CultureCode: 'vi' }, { DisplayText: 'Tamazight [tzm-latn]', CultureCode: 'tzm-latn' }, { DisplayText: 'Tamazight [tzm]', CultureCode: 'tzm' }, { DisplayText: 'svenska [sv]', CultureCode: 'sv' }, { DisplayText: 'suomi [fi]', CultureCode: 'fi' }, { DisplayText: 'srpski [sr-latn]', CultureCode: 'sr-latn' }, { DisplayText: 'srpski [sr]', CultureCode: 'sr' }, { DisplayText: 'slovenski [sl]', CultureCode: 'sl' }, { DisplayText: 'slovenina [sk]', CultureCode: 'sk' }, { DisplayText: 'shqipe [sq]', CultureCode: 'sq' }, { DisplayText: 'Setswana [tn]', CultureCode: 'tn' }, { DisplayText: 'Sesotho sa Leboa [nso]', CultureCode: 'nso' }, { DisplayText: 'smikiel [smn]', CultureCode: 'smn' }, { DisplayText: 'smill [sms]', CultureCode: 'sms' }, { DisplayText: 'runasimi [quz]', CultureCode: 'quz' }, { DisplayText: 'Rumantsch [rm]', CultureCode: 'rm' }, { DisplayText: 'romn [ro]', CultureCode: 'ro' }, { DisplayText: 'Reo Mori [mi]', CultureCode: 'mi' }, { DisplayText: 'Portugus [pt]', CultureCode: 'pt' }, { DisplayText: 'polski [pl]', CultureCode: 'pl' }, { DisplayText: 'Occitan [oc]', CultureCode: 'oc' }, { DisplayText: 'norsk [no]', CultureCode: 'no' }, { DisplayText: 'norsk (nynorsk) [nn]', CultureCode: 'nn' }, { DisplayText: 'norsk (bokml) [nb]', CultureCode: 'nb' }, { DisplayText: 'Nederlands [nl]', CultureCode: 'nl' }, { DisplayText: 'Mapudungun [arn]', CultureCode: 'arn' }, { DisplayText: 'Malti [mt]', CultureCode: 'mt' }, { DisplayText: 'magyar [hu]', CultureCode: 'hu' }, { DisplayText: 'lietuvi [lt]', CultureCode: 'lt' }, { DisplayText: 'Ltzebuergesch [lb]', CultureCode: 'lb' }, { DisplayText: 'latvieu [lv]', CultureCode: 'lv' }, { DisplayText: 'Kiswahili [sw]', CultureCode: 'sw' }, { DisplayText: 'Kinyarwanda [rw]', CultureCode: 'rw' }, { DisplayText: 'K\'iche [qut]', CultureCode: 'qut' }, { DisplayText: 'Kanien\'kha [moh]', CultureCode: 'moh' }, { DisplayText: 'kalaallisut [kl]', CultureCode: 'kl' }, { DisplayText: 'julevusmegiella [smj]', CultureCode: 'smj' }, { DisplayText: 'italiano [it]', CultureCode: 'it' }, { DisplayText: 'slenska [is]', CultureCode: 'is' }, { DisplayText: 'isiZulu [zu]', CultureCode: 'zu' }, { DisplayText: 'isiXhosa [xh]', CultureCode: 'xh' }, { DisplayText: 'Invariant Language (Invariant Country) []', CultureCode: '' }, { DisplayText: 'Inuktitut [iu-latn]', CultureCode: 'iu-latn' }, { DisplayText: 'Inuktitut [iu]', CultureCode: 'iu' }, { DisplayText: 'Igbo [ig]', CultureCode: 'ig' }, { DisplayText: 'hrvatski [hr]', CultureCode: 'hr' }, { DisplayText: 'hornjoserbina [hsb]', CultureCode: 'hsb' }, { DisplayText: 'Hausa [ha-latn]', CultureCode: 'ha-latn' }, { DisplayText: 'Hausa [ha]', CultureCode: 'ha' }, { DisplayText: 'galego [gl]', CultureCode: 'gl' }, { DisplayText: 'G idhlig [gd]', CultureCode: 'gd' }, { DisplayText: 'Gaeilge [ga]', CultureCode: 'ga' }, { DisplayText: 'Frysk [fy]', CultureCode: 'fy' }, { DisplayText: 'franais [fr]', CultureCode: 'fr' }, { DisplayText: 'froyskt [fo]', CultureCode: 'fo' }, { DisplayText: 'Filipino [fil]', CultureCode: 'fil' }, { DisplayText: 'euskara [eu]', CultureCode: 'eu' }, { DisplayText: 'espaol [es]', CultureCode: 'es' }, { DisplayText: 'English [en]', CultureCode: 'en' }, { DisplayText: 'Elsssisch [gsw]', CultureCode: 'gsw' }, { DisplayText: 'eesti [et]', CultureCode: 'et' }, { DisplayText: 'dolnoserbina [dsb]', CultureCode: 'dsb' }, { DisplayText: 'Deutsch [de]', CultureCode: 'de' }, { DisplayText: 'davvismegiella [se]', CultureCode: 'se' }, { DisplayText: 'dansk [da]', CultureCode: 'da' }, { DisplayText: 'Cymraeg [cy]', CultureCode: 'cy' }, { DisplayText: 'Corsu [co]', CultureCode: 'co' }, { DisplayText: 'etina [cs]', CultureCode: 'cs' }, { DisplayText: 'catal  [ca]', CultureCode: 'ca' }, { DisplayText: 'brezhoneg [br]', CultureCode: 'br' }, { DisplayText: 'bosanski [bs-latn]', CultureCode: 'bs-latn' }, { DisplayText: 'bosanski [bs]', CultureCode: 'bs' }, { DisplayText: 'Bahasa Melayu [ms]', CultureCode: 'ms' }, { DisplayText: 'Bahasa Indonesia [id]', CultureCode: 'id' }, { DisplayText: 'Azrbaycanl [az-latn]', CultureCode: 'az-latn' }, { DisplayText: 'Azrbaycanl [az]', CultureCode: 'az' }, { DisplayText: 'Afrikaans [af]', CultureCode: 'af' }, { DisplayText: 'arjelsaemiengiele [sma]', CultureCode: 'sma' }],
        allLanguages: [{ DisplayText: 'arjelsaemiengiele (Nrje) [sma-no]', CultureCode: 'sma-no' }, { DisplayText: 'arjelsaemiengiele (Sveerje) [sma-se]', CultureCode: 'sma-se' }, { DisplayText: 'arjelsaemiengiele [sma]', CultureCode: 'sma' }, { DisplayText: 'Afrikaans (Suid Afrika) [af-za]', CultureCode: 'af-za' }, { DisplayText: 'Afrikaans [af]', CultureCode: 'af' }, { DisplayText: 'Azrbaycanl [az]', CultureCode: 'az' }, { DisplayText: 'Azrbaycanl [az-latn]', CultureCode: 'az-latn' }, { DisplayText: 'Bahasa Indonesia (Indonesia) [id-id]', CultureCode: 'id-id' }, { DisplayText: 'Bahasa Indonesia [id]', CultureCode: 'id' }, { DisplayText: 'Bahasa Melayu (Brunei Darussalam) [ms-bn]', CultureCode: 'ms-bn' }, { DisplayText: 'Bahasa Melayu (Malaysia) [ms-my]', CultureCode: 'ms-my' }, { DisplayText: 'Bahasa Melayu [ms]', CultureCode: 'ms' }, { DisplayText: 'bosanski (Bosna i Hercegovina) [bs-latn-ba]', CultureCode: 'bs-latn-ba' }, { DisplayText: 'bosanski [bs]', CultureCode: 'bs' }, { DisplayText: 'bosanski [bs-latn]', CultureCode: 'bs-latn' }, { DisplayText: 'brezhoneg (Fras) [br-fr]', CultureCode: 'br-fr' }, { DisplayText: 'brezhoneg [br]', CultureCode: 'br' }, { DisplayText: 'catal  (catal ) [ca-es]', CultureCode: 'ca-es' }, { DisplayText: 'catal  [ca]', CultureCode: 'ca' }, { DisplayText: 'etina (esk republika) [cs-cz]', CultureCode: 'cs-cz' }, { DisplayText: 'etina [cs]', CultureCode: 'cs' }, { DisplayText: 'Corsu (France) [co-fr]', CultureCode: 'co-fr' }, { DisplayText: 'Corsu [co]', CultureCode: 'co' }, { DisplayText: 'Cymraeg (y Deyrnas Unedig) [cy-gb]', CultureCode: 'cy-gb' }, { DisplayText: 'Cymraeg [cy]', CultureCode: 'cy' }, { DisplayText: 'dansk (Danmark) [da-dk]', CultureCode: 'da-dk' }, { DisplayText: 'dansk [da]', CultureCode: 'da' }, { DisplayText: 'davvismegiella (Norga) [se-no]', CultureCode: 'se-no' }, { DisplayText: 'davvismegiella (Ruoa) [se-se]', CultureCode: 'se-se' }, { DisplayText: 'davvismegiella (Suopma) [se-fi]', CultureCode: 'se-fi' }, { DisplayText: 'davvismegiella [se]', CultureCode: 'se' }, { DisplayText: 'Deutsch (Deutschland) [de-de]', CultureCode: 'de-de' }, { DisplayText: 'Deutsch (Liechtenstein) [de-li]', CultureCode: 'de-li' }, { DisplayText: 'Deutsch (Luxemburg) [de-lu]', CultureCode: 'de-lu' }, { DisplayText: 'Deutsch (sterreich) [de-at]', CultureCode: 'de-at' }, { DisplayText: 'Deutsch (Schweiz) [de-ch]', CultureCode: 'de-ch' }, { DisplayText: 'Deutsch [de]', CultureCode: 'de' }, { DisplayText: 'dolnoserbina (Nimska) [dsb-de]', CultureCode: 'dsb-de' }, { DisplayText: 'dolnoserbina [dsb]', CultureCode: 'dsb' }, { DisplayText: 'eesti (Eesti) [et-ee]', CultureCode: 'et-ee' }, { DisplayText: 'eesti [et]', CultureCode: 'et' }, { DisplayText: 'Elsssisch (Fr nkrisch) [gsw-fr]', CultureCode: 'gsw-fr' }, { DisplayText: 'Elsssisch [gsw]', CultureCode: 'gsw' }, { DisplayText: 'English (Australia) [en-au]', CultureCode: 'en-au' }, { DisplayText: 'English (Belize) [en-bz]', CultureCode: 'en-bz' }, { DisplayText: 'English (Canada) [en-ca]', CultureCode: 'en-ca' }, { DisplayText: 'English (Caribbean) [en-029]', CultureCode: 'en-029' }, { DisplayText: 'English (India) [en-in]', CultureCode: 'en-in' }, { DisplayText: 'English (Ireland) [en-ie]', CultureCode: 'en-ie' }, { DisplayText: 'English (Jamaica) [en-jm]', CultureCode: 'en-jm' }, { DisplayText: 'English (Malaysia) [en-my]', CultureCode: 'en-my' }, { DisplayText: 'English (New Zealand) [en-nz]', CultureCode: 'en-nz' }, { DisplayText: 'English (Philippines) [en-ph]', CultureCode: 'en-ph' }, { DisplayText: 'English (Singapore) [en-sg]', CultureCode: 'en-sg' }, { DisplayText: 'English (South Africa) [en-za]', CultureCode: 'en-za' }, { DisplayText: 'English (Trinidad y Tobago) [en-tt]', CultureCode: 'en-tt' }, { DisplayText: 'English (United Kingdom) [en-gb]', CultureCode: 'en-gb' }, { DisplayText: 'English (United States) [en-us]', CultureCode: 'en-us' }, { DisplayText: 'English (Zimbabwe) [en-zw]', CultureCode: 'en-zw' }, { DisplayText: 'English [en]', CultureCode: 'en' }, { DisplayText: 'Espaol (Argentina) [es-ar]', CultureCode: 'es-ar' }, { DisplayText: 'Espaol (Bolivia) [es-bo]', CultureCode: 'es-bo' }, { DisplayText: 'Espaol (Chile) [es-cl]', CultureCode: 'es-cl' }, { DisplayText: 'Espaol (Colombia) [es-co]', CultureCode: 'es-co' }, { DisplayText: 'Espaol (Costa Rica) [es-cr]', CultureCode: 'es-cr' }, { DisplayText: 'Espaol (Ecuador) [es-ec]', CultureCode: 'es-ec' }, { DisplayText: 'Espaol (El Salvador) [es-sv]', CultureCode: 'es-sv' }, { DisplayText: 'Espaol (Espaa, alfabetizacin internacional) [es-es]', CultureCode: 'es-es' }, { DisplayText: 'Espaol (Estados Unidos) [es-us]', CultureCode: 'es-us' }, { DisplayText: 'Espaol (Guatemala) [es-gt]', CultureCode: 'es-gt' }, { DisplayText: 'Espaol (Honduras) [es-hn]', CultureCode: 'es-hn' }, { DisplayText: 'Espaol (Mxico) [es-mx]', CultureCode: 'es-mx' }, { DisplayText: 'Espaol (Nicaragua) [es-ni]', CultureCode: 'es-ni' }, { DisplayText: 'Espaol (Panam) [es-pa]', CultureCode: 'es-pa' }, { DisplayText: 'Espaol (Paraguay) [es-py]', CultureCode: 'es-py' }, { DisplayText: 'Espaol (Per) [es-pe]', CultureCode: 'es-pe' }, { DisplayText: 'Espaol (Puerto Rico) [es-pr]', CultureCode: 'es-pr' }, { DisplayText: 'Espaol (Republica Bolivariana de Venezuela) [es-ve]', CultureCode: 'es-ve' }, { DisplayText: 'Espaol (Repblica Dominicana) [es-do]', CultureCode: 'es-do' }, { DisplayText: 'Espaol (Uruguay) [es-uy]', CultureCode: 'es-uy' }, { DisplayText: 'espaol [es]', CultureCode: 'es' }, { DisplayText: 'euskara (euskara) [eu-es]', CultureCode: 'eu-es' }, { DisplayText: 'euskara [eu]', CultureCode: 'eu' }, { DisplayText: 'Filipino (Pilipinas) [fil-ph]', CultureCode: 'fil-ph' }, { DisplayText: 'Filipino [fil]', CultureCode: 'fil' }, { DisplayText: 'froyskt (Froyar) [fo-fo]', CultureCode: 'fo-fo' }, { DisplayText: 'froyskt [fo]', CultureCode: 'fo' }, { DisplayText: 'franais (Belgique) [fr-be]', CultureCode: 'fr-be' }, { DisplayText: 'franais (Canada) [fr-ca]', CultureCode: 'fr-ca' }, { DisplayText: 'franais (France) [fr-fr]', CultureCode: 'fr-fr' }, { DisplayText: 'franais (Luxembourg) [fr-lu]', CultureCode: 'fr-lu' }, { DisplayText: 'franais (Principaut de Monaco) [fr-mc]', CultureCode: 'fr-mc' }, { DisplayText: 'franais (Suisse) [fr-ch]', CultureCode: 'fr-ch' }, { DisplayText: 'franais [fr]', CultureCode: 'fr' }, { DisplayText: 'Frysk (Nederln) [fy-nl]', CultureCode: 'fy-nl' }, { DisplayText: 'Frysk [fy]', CultureCode: 'fy' }, { DisplayText: 'Gaeilge (ire) [ga-ie]', CultureCode: 'ga-ie' }, { DisplayText: 'Gaeilge [ga]', CultureCode: 'ga' }, { DisplayText: 'G idhlig (An Roghachd Aonaichte) [gd-gb]', CultureCode: 'gd-gb' }, { DisplayText: 'G idhlig [gd]', CultureCode: 'gd' }, { DisplayText: 'galego (galego) [gl-es]', CultureCode: 'gl-es' }, { DisplayText: 'galego [gl]', CultureCode: 'gl' }, { DisplayText: 'Hausa (Nigeria) [ha-latn-ng]', CultureCode: 'ha-latn-ng' }, { DisplayText: 'Hausa [ha]', CultureCode: 'ha' }, { DisplayText: 'Hausa [ha-latn]', CultureCode: 'ha-latn' }, { DisplayText: 'hornjoserbina (Nmska) [hsb-de]', CultureCode: 'hsb-de' }, { DisplayText: 'hornjoserbina [hsb]', CultureCode: 'hsb' }, { DisplayText: 'hrvatski (Bosna i Hercegovina) [hr-ba]', CultureCode: 'hr-ba' }, { DisplayText: 'hrvatski (Hrvatska) [hr-hr]', CultureCode: 'hr-hr' }, { DisplayText: 'hrvatski [hr]', CultureCode: 'hr' }, { DisplayText: 'Igbo (Nigeria) [ig-ng]', CultureCode: 'ig-ng' }, { DisplayText: 'Igbo [ig]', CultureCode: 'ig' }, { DisplayText: 'Inuktitut (Kanatami) [iu-latn-ca]', CultureCode: 'iu-latn-ca' }, { DisplayText: 'Inuktitut [iu]', CultureCode: 'iu' }, { DisplayText: 'Inuktitut [iu-latn]', CultureCode: 'iu-latn' }, { DisplayText: 'Invariant Language (Invariant Country) []', CultureCode: '' }, { DisplayText: 'isiXhosa (uMzantsi Afrika) [xh-za]', CultureCode: 'xh-za' }, { DisplayText: 'isiXhosa [xh]', CultureCode: 'xh' }, { DisplayText: 'isiZulu (iNingizimu Afrika) [zu-za]', CultureCode: 'zu-za' }, { DisplayText: 'isiZulu [zu]', CultureCode: 'zu' }, { DisplayText: 'slenska (sland) [is-is]', CultureCode: 'is-is' }, { DisplayText: 'slenska [is]', CultureCode: 'is' }, { DisplayText: 'italiano (Italia) [it-it]', CultureCode: 'it-it' }, { DisplayText: 'italiano (Svizzera) [it-ch]', CultureCode: 'it-ch' }, { DisplayText: 'italiano [it]', CultureCode: 'it' }, { DisplayText: 'julevusmegiella (Svierik) [smj-se]', CultureCode: 'smj-se' }, { DisplayText: 'julevusmegiella (Vuodna) [smj-no]', CultureCode: 'smj-no' }, { DisplayText: 'julevusmegiella [smj]', CultureCode: 'smj' }, { DisplayText: 'kalaallisut (Kalaallit Nunaat) [kl-gl]', CultureCode: 'kl-gl' }, { DisplayText: 'kalaallisut [kl]', CultureCode: 'kl' }, { DisplayText: 'Kanien\'kha [moh]', CultureCode: 'moh' }, { DisplayText: 'Kanien\'kha [moh-ca]', CultureCode: 'moh-ca' }, { DisplayText: 'K\'iche (Guatemala) [qut-gt]', CultureCode: 'qut-gt' }, { DisplayText: 'K\'iche [qut]', CultureCode: 'qut' }, { DisplayText: 'Kinyarwanda (Rwanda) [rw-rw]', CultureCode: 'rw-rw' }, { DisplayText: 'Kinyarwanda [rw]', CultureCode: 'rw' }, { DisplayText: 'Kiswahili (Kenya) [sw-ke]', CultureCode: 'sw-ke' }, { DisplayText: 'Kiswahili [sw]', CultureCode: 'sw' }, { DisplayText: 'latvieu (Latvija) [lv-lv]', CultureCode: 'lv-lv' }, { DisplayText: 'latvieu [lv]', CultureCode: 'lv' }, { DisplayText: 'Ltzebuergesch (Luxembourg) [lb-lu]', CultureCode: 'lb-lu' }, { DisplayText: 'Ltzebuergesch [lb]', CultureCode: 'lb' }, { DisplayText: 'lietuvi (Lietuva) [lt-lt]', CultureCode: 'lt-lt' }, { DisplayText: 'lietuvi [lt]', CultureCode: 'lt' }, { DisplayText: 'magyar (Magyarorszg) [hu-hu]', CultureCode: 'hu-hu' }, { DisplayText: 'magyar [hu]', CultureCode: 'hu' }, { DisplayText: 'Malti (Malta) [mt-mt]', CultureCode: 'mt-mt' }, { DisplayText: 'Malti [mt]', CultureCode: 'mt' }, { DisplayText: 'Mapudungun (Chile) [arn-cl]', CultureCode: 'arn-cl' }, { DisplayText: 'Mapudungun [arn]', CultureCode: 'arn' }, { DisplayText: 'Nederlands (Belgi) [nl-be]', CultureCode: 'nl-be' }, { DisplayText: 'Nederlands (Nederland) [nl-nl]', CultureCode: 'nl-nl' }, { DisplayText: 'Nederlands [nl]', CultureCode: 'nl' }, { DisplayText: 'norsk (bokml) [nb]', CultureCode: 'nb' }, { DisplayText: 'norsk (nynorsk) [nn]', CultureCode: 'nn' }, { DisplayText: 'norsk [no]', CultureCode: 'no' }, { DisplayText: 'norsk, bokml (Norge) [nb-no]', CultureCode: 'nb-no' }, { DisplayText: 'norsk, nynorsk (Noreg) [nn-no]', CultureCode: 'nn-no' }, { DisplayText: 'Occitan (Frana) [oc-fr]', CultureCode: 'oc-fr' }, { DisplayText: 'Occitan [oc]', CultureCode: 'oc' }, { DisplayText: 'polski (Polska) [pl-pl]', CultureCode: 'pl-pl' }, { DisplayText: 'polski [pl]', CultureCode: 'pl' }, { DisplayText: 'Portugus (Brasil) [pt-br]', CultureCode: 'pt-br' }, { DisplayText: 'portugus (Portugal) [pt-pt]', CultureCode: 'pt-pt' }, { DisplayText: 'Portugus [pt]', CultureCode: 'pt' }, { DisplayText: 'Reo Mori (Aotearoa) [mi-nz]', CultureCode: 'mi-nz' }, { DisplayText: 'Reo Mori [mi]', CultureCode: 'mi' }, { DisplayText: 'romn (Romnia) [ro-ro]', CultureCode: 'ro-ro' }, { DisplayText: 'romn [ro]', CultureCode: 'ro' }, { DisplayText: 'Rumantsch (Svizra) [rm-ch]', CultureCode: 'rm-ch' }, { DisplayText: 'Rumantsch [rm]', CultureCode: 'rm' }, { DisplayText: 'runasimi (Ecuador) [quz-ec]', CultureCode: 'quz-ec' }, { DisplayText: 'runasimi (Piruw) [quz-pe]', CultureCode: 'quz-pe' }, { DisplayText: 'runasimi (Qullasuyu) [quz-bo]', CultureCode: 'quz-bo' }, { DisplayText: 'runasimi [quz]', CultureCode: 'quz' }, { DisplayText: 'smill (Lddjnnam) [sms-fi]', CultureCode: 'sms-fi' }, { DisplayText: 'smill [sms]', CultureCode: 'sms' }, { DisplayText: 'smikiel (Suom) [smn-fi]', CultureCode: 'smn-fi' }, { DisplayText: 'smikiel [smn]', CultureCode: 'smn' }, { DisplayText: 'Sesotho sa Leboa (Afrika Borwa) [nso-za]', CultureCode: 'nso-za' }, { DisplayText: 'Sesotho sa Leboa [nso]', CultureCode: 'nso' }, { DisplayText: 'Setswana (Aforika Borwa) [tn-za]', CultureCode: 'tn-za' }, { DisplayText: 'Setswana [tn]', CultureCode: 'tn' }, { DisplayText: 'shqipe (Shqipria) [sq-al]', CultureCode: 'sq-al' }, { DisplayText: 'shqipe [sq]', CultureCode: 'sq' }, { DisplayText: 'slovenina (Slovensk republika) [sk-sk]', CultureCode: 'sk-sk' }, { DisplayText: 'slovenina [sk]', CultureCode: 'sk' }, { DisplayText: 'slovenski (Slovenija) [sl-si]', CultureCode: 'sl-si' }, { DisplayText: 'slovenski [sl]', CultureCode: 'sl' }, { DisplayText: 'srpski (Bosna i Hercegovina) [sr-latn-ba]', CultureCode: 'sr-latn-ba' }, { DisplayText: 'srpski (Crna Gora) [sr-latn-me]', CultureCode: 'sr-latn-me' }, { DisplayText: 'srpski (Srbija i Crna Gora (Prethodno)) [sr-latn-cs]', CultureCode: 'sr-latn-cs' }, { DisplayText: 'srpski (Srbija) [sr-latn-rs]', CultureCode: 'sr-latn-rs' }, { DisplayText: 'srpski [sr]', CultureCode: 'sr' }, { DisplayText: 'srpski [sr-latn]', CultureCode: 'sr-latn' }, { DisplayText: 'suomi (Suomi) [fi-fi]', CultureCode: 'fi-fi' }, { DisplayText: 'suomi [fi]', CultureCode: 'fi' }, { DisplayText: 'svenska (Finland) [sv-fi]', CultureCode: 'sv-fi' }, { DisplayText: 'svenska (Sverige) [sv-se]', CultureCode: 'sv-se' }, { DisplayText: 'svenska [sv]', CultureCode: 'sv' }, { DisplayText: 'Tamazight (Djazar) [tzm-latn-dz]', CultureCode: 'tzm-latn-dz' }, { DisplayText: 'Tamazight [tzm]', CultureCode: 'tzm' }, { DisplayText: 'Tamazight [tzm-latn]', CultureCode: 'tzm-latn' }, { DisplayText: 'Ting Vit (Vit Nam) [vi-vn]', CultureCode: 'vi-vn' }, { DisplayText: 'Ting Vit [vi]', CultureCode: 'vi' }, { DisplayText: 'Trke [tr]', CultureCode: 'tr' }, { DisplayText: 'trkmene (Trkmenistan) [tk-tm]', CultureCode: 'tk-tm' }, { DisplayText: 'trkmene [tk]', CultureCode: 'tk' }, { DisplayText: 'U\'zbek (U\'zbekiston Respublikasi) [uz-latn-uz]', CultureCode: 'uz-latn-uz' }, { DisplayText: 'U\'zbek [uz]', CultureCode: 'uz' }, { DisplayText: 'U\'zbek [uz-latn]', CultureCode: 'uz-latn' }, { DisplayText: 'Wolof (Sngal) [wo-sn]', CultureCode: 'wo-sn' }, { DisplayText: 'Wolof [wo]', CultureCode: 'wo' }, { DisplayText: 'Yoruba (Nigeria) [yo-ng]', CultureCode: 'yo-ng' }, { DisplayText: 'Yoruba [yo]', CultureCode: 'yo' }, { DisplayText: ' () [el-gr]', CultureCode: 'el-gr' }, { DisplayText: ' [el]', CultureCode: 'el' }, { DisplayText: '  [az-cyrl]', CultureCode: 'az-cyrl' }, { DisplayText: ' ( ) [ba-ru]', CultureCode: 'ba-ru' }, { DisplayText: ' [ba]', CultureCode: 'ba' }, { DisplayText: ' () [be-by]', CultureCode: 'be-by' }, { DisplayText: ' [be]', CultureCode: 'be' }, { DisplayText: ' (  ) [bs-cyrl-ba]', CultureCode: 'bs-cyrl-ba' }, { DisplayText: ' [bs-cyrl]', CultureCode: 'bs-cyrl' }, { DisplayText: ' () [bg-bg]', CultureCode: 'bg-bg' }, { DisplayText: ' [bg]', CultureCode: 'bg' }, { DisplayText: ' () [ky-kg]', CultureCode: 'ky-kg' }, { DisplayText: ' [ky]', CultureCode: 'ky' }, { DisplayText: ' () [kk-kz]', CultureCode: 'kk-kz' }, { DisplayText: ' [kk]', CultureCode: 'kk' }, { DisplayText: '  () [mk-mk]', CultureCode: 'mk-mk' }, { DisplayText: '  [mk]', CultureCode: 'mk' }, { DisplayText: '  ( ) [mn-mn]', CultureCode: 'mn-mn' }, { DisplayText: '  [mn]', CultureCode: 'mn' }, { DisplayText: '  [mn-cyrl]', CultureCode: 'mn-cyrl' }, { DisplayText: ' ( ) [ru-ru]', CultureCode: 'ru-ru' }, { DisplayText: ' [ru]', CultureCode: 'ru' }, { DisplayText: ' ( ) [sah-ru]', CultureCode: 'sah-ru' }, { DisplayText: ' [sah]', CultureCode: 'sah' }, { DisplayText: ' (  ) [sr-cyrl-ba]', CultureCode: 'sr-cyrl-ba' }, { DisplayText: ' (    ()) [sr-cyrl-cs]', CultureCode: 'sr-cyrl-cs' }, { DisplayText: ' () [sr-cyrl-rs]', CultureCode: 'sr-cyrl-rs' }, { DisplayText: ' ( ) [sr-cyrl-me]', CultureCode: 'sr-cyrl-me' }, { DisplayText: ' [sr-cyrl]', CultureCode: 'sr-cyrl' }, { DisplayText: ' ( ) [tt-ru]', CultureCode: 'tt-ru' }, { DisplayText: ' [tt]', CultureCode: 'tt' }, { DisplayText: ' () [tg-cyrl-tj]', CultureCode: 'tg-cyrl-tj' }, { DisplayText: ' [tg]', CultureCode: 'tg' }, { DisplayText: ' [tg-cyrl]', CultureCode: 'tg-cyrl' }, { DisplayText: ' () [uz-cyrl-uz]', CultureCode: 'uz-cyrl-uz' }, { DisplayText: ' [uz-cyrl]', CultureCode: 'uz-cyrl' }, { DisplayText: ' () [uk-ua]', CultureCode: 'uk-ua' }, { DisplayText: ' [uk]', CultureCode: 'uk' }, { DisplayText: ' () [hy-am]', CultureCode: 'hy-am' }, { DisplayText: ' [hy]', CultureCode: 'hy' }, { DisplayText: '  ( ) [ka-ge]', CultureCode: 'ka-ge' }, { DisplayText: '  [ka]', CultureCode: 'ka' }, { DisplayText: ' () [he-il]', CultureCode: 'he-il' }, { DisplayText: ' [he]', CultureCode: 'he' }, { DisplayText: ' () [ur-pk]', CultureCode: 'ur-pk' }, { DisplayText: ' [ur]', CultureCode: 'ur' }, { DisplayText: ' () [ar-jo]', CultureCode: 'ar-jo' }, { DisplayText: ' (  ) [ar-ae]', CultureCode: 'ar-ae' }, { DisplayText: ' () [ar-bh]', CultureCode: 'ar-bh' }, { DisplayText: ' () [ar-dz]', CultureCode: 'ar-dz' }, { DisplayText: ' () [ar-iq]', CultureCode: 'ar-iq' }, { DisplayText: ' () [ar-kw]', CultureCode: 'ar-kw' }, { DisplayText: ' (  ) [ar-sa]', CultureCode: 'ar-sa' }, { DisplayText: ' ( ) [ar-ma]', CultureCode: 'ar-ma' }, { DisplayText: ' () [ar-ye]', CultureCode: 'ar-ye' }, { DisplayText: ' () [ar-tn]', CultureCode: 'ar-tn' }, { DisplayText: ' () [ar-sy]', CultureCode: 'ar-sy' }, { DisplayText: ' () [ar-om]', CultureCode: 'ar-om' }, { DisplayText: ' () [ar-qa]', CultureCode: 'ar-qa' }, { DisplayText: ' () [ar-lb]', CultureCode: 'ar-lb' }, { DisplayText: ' () [ar-ly]', CultureCode: 'ar-ly' }, { DisplayText: ' () [ar-eg]', CultureCode: 'ar-eg' }, { DisplayText: ' [ar]', CultureCode: 'ar' }, { DisplayText: ' () [ps-af]', CultureCode: 'ps-af' }, { DisplayText: ' [ps]', CultureCode: 'ps' }, { DisplayText: ' () [prs-af]', CultureCode: 'prs-af' }, { DisplayText: ' [prs]', CultureCode: 'prs' }, { DisplayText: ' () [fa-ir]', CultureCode: 'fa-ir' }, { DisplayText: ' [fa]', CultureCode: 'fa' }, { DisplayText: ' (  ) [ug-cn]', CultureCode: 'ug-cn' }, { DisplayText: ' [ug]', CultureCode: 'ug' }, { DisplayText: ' () [syr-sy]', CultureCode: 'syr-sy' }, { DisplayText: ' [syr]', CultureCode: 'syr' }, { DisplayText: ' ( ) [dv-mv]', CultureCode: 'dv-mv' }, { DisplayText: ' [dv]', CultureCode: 'dv' }, { DisplayText: ' () [kok-in]', CultureCode: 'kok-in' }, { DisplayText: ' [kok]', CultureCode: 'kok' }, { DisplayText: ' () [ne-np]', CultureCode: 'ne-np' }, { DisplayText: ' [ne]', CultureCode: 'ne' }, { DisplayText: '  () [mr-in]', CultureCode: 'mr-in' }, { DisplayText: '  [mr]', CultureCode: 'mr' }, { DisplayText: ' () [sa-in]', CultureCode: 'sa-in' }, { DisplayText: ' [sa]', CultureCode: 'sa' }, { DisplayText: ' () [hi-in]', CultureCode: 'hi-in' }, { DisplayText: ' [hi]', CultureCode: 'hi' }, { DisplayText: ' () [as-in]', CultureCode: 'as-in' }, { DisplayText: ' [as]', CultureCode: 'as' }, { DisplayText: ' () [bn-bd]', CultureCode: 'bn-bd' }, { DisplayText: ' () [bn-in]', CultureCode: 'bn-in' }, { DisplayText: ' [bn]', CultureCode: 'bn' }, { DisplayText: ' () [pa-in]', CultureCode: 'pa-in' }, { DisplayText: ' [pa]', CultureCode: 'pa' }, { DisplayText: ' () [gu-in]', CultureCode: 'gu-in' }, { DisplayText: ' [gu]', CultureCode: 'gu' }, { DisplayText: ' () [or-in]', CultureCode: 'or-in' }, { DisplayText: ' [or]', CultureCode: 'or' }, { DisplayText: ' () [ta-in]', CultureCode: 'ta-in' }, { DisplayText: ' [ta]', CultureCode: 'ta' }, { DisplayText: ' ( ) [te-in]', CultureCode: 'te-in' }, { DisplayText: ' [te]', CultureCode: 'te' }, { DisplayText: ' () [kn-in]', CultureCode: 'kn-in' }, { DisplayText: ' [kn]', CultureCode: 'kn' }, { DisplayText: ' () [ml-in]', CultureCode: 'ml-in' }, { DisplayText: ' [ml]', CultureCode: 'ml' }, { DisplayText: ' ( ) [si-lk]', CultureCode: 'si-lk' }, { DisplayText: ' [si]', CultureCode: 'si' }, { DisplayText: ' () [th-th]', CultureCode: 'th-th' }, { DisplayText: ' [th]', CultureCode: 'th' }, { DisplayText: '             (                                         ) [mn-mong-cn]', CultureCode: 'mn-mong-cn' }, { DisplayText: '             [mn-mong]', CultureCode: 'mn-mong' }, { DisplayText: ' () [bo-cn]', CultureCode: 'bo-cn' }, { DisplayText: ' [bo]', CultureCode: 'bo' }, { DisplayText: ' (... ) [lo-la]', CultureCode: 'lo-la' }, { DisplayText: ' [lo]', CultureCode: 'lo' }, { DisplayText: ' () [km-kh]', CultureCode: 'km-kh' }, { DisplayText: ' [km]', CultureCode: 'km' }, { DisplayText: ' () [iu-cans-ca]', CultureCode: 'iu-cans-ca' }, { DisplayText: ' [iu-cans]', CultureCode: 'iu-cans' }, { DisplayText: '  () [am-et]', CultureCode: 'am-et' }, { DisplayText: '  [am]', CultureCode: 'am' }, { DisplayText: '  () [ii-cn]', CultureCode: 'ii-cn' }, { DisplayText: '  [ii]', CultureCode: 'ii' }, { DisplayText: ' () [ko-kr]', CultureCode: 'ko-kr' }, { DisplayText: ' [ko]', CultureCode: 'ko' }, { DisplayText: ' [zh]', CultureCode: 'zh' }, { DisplayText: '() [zh-cn]', CultureCode: 'zh-cn' }, { DisplayText: '() [zh-tw]', CultureCode: 'zh-tw' }, { DisplayText: '( ) [zh-sg]', CultureCode: 'zh-sg' }, { DisplayText: '() [zh-mo]', CultureCode: 'zh-mo' }, { DisplayText: '() [zh-hans]', CultureCode: 'zh-hans' }, { DisplayText: '()  [zh-chs]', CultureCode: 'zh-chs' }, { DisplayText: '() [zh-hant]', CultureCode: 'zh-hant' }, { DisplayText: '()  [zh-cht]', CultureCode: 'zh-cht' }, { DisplayText: '() [zh-hk]', CultureCode: 'zh-hk' }, { DisplayText: ' () [ja-jp]', CultureCode: 'ja-jp' }, { DisplayText: ' [ja]', CultureCode: 'ja' }],
        regionLanguage: [{ DisplayText: 'arjelsaemiengiele (Nrje) [sma-no]', CultureCode: 'sma-no' }, { DisplayText: 'arjelsaemiengiele (Sveerje) [sma-se]', CultureCode: 'sma-se' }, { DisplayText: 'arjelsaemiengiele [sma]', CultureCode: 'sma' }, { DisplayText: 'Afrikaans (Suid Afrika) [af-za]', CultureCode: 'af-za' }, { DisplayText: 'Afrikaans [af]', CultureCode: 'af' }, { DisplayText: 'Azrbaycanl [az]', CultureCode: 'az' }, { DisplayText: 'Azrbaycanl [az-latn]', CultureCode: 'az-latn' }, { DisplayText: 'Bahasa Indonesia (Indonesia) [id-id]', CultureCode: 'id-id' }, { DisplayText: 'Bahasa Indonesia [id]', CultureCode: 'id' }, { DisplayText: 'Bahasa Melayu (Brunei Darussalam) [ms-bn]', CultureCode: 'ms-bn' }, { DisplayText: 'Bahasa Melayu (Malaysia) [ms-my]', CultureCode: 'ms-my' }, { DisplayText: 'Bahasa Melayu [ms]', CultureCode: 'ms' }, { DisplayText: 'bosanski (Bosna i Hercegovina) [bs-latn-ba]', CultureCode: 'bs-latn-ba' }, { DisplayText: 'bosanski [bs]', CultureCode: 'bs' }, { DisplayText: 'bosanski [bs-latn]', CultureCode: 'bs-latn' }, { DisplayText: 'brezhoneg (Fras) [br-fr]', CultureCode: 'br-fr' }, { DisplayText: 'brezhoneg [br]', CultureCode: 'br' }, { DisplayText: 'catal  (catal ) [ca-es]', CultureCode: 'ca-es' }, { DisplayText: 'catal  [ca]', CultureCode: 'ca' }, { DisplayText: 'etina (esk republika) [cs-cz]', CultureCode: 'cs-cz' }, { DisplayText: 'etina [cs]', CultureCode: 'cs' }, { DisplayText: 'Corsu (France) [co-fr]', CultureCode: 'co-fr' }, { DisplayText: 'Corsu [co]', CultureCode: 'co' }, { DisplayText: 'Cymraeg (y Deyrnas Unedig) [cy-gb]', CultureCode: 'cy-gb' }, { DisplayText: 'Cymraeg [cy]', CultureCode: 'cy' }, { DisplayText: 'dansk (Danmark) [da-dk]', CultureCode: 'da-dk' }, { DisplayText: 'dansk [da]', CultureCode: 'da' }, { DisplayText: 'davvismegiella (Norga) [se-no]', CultureCode: 'se-no' }, { DisplayText: 'davvismegiella (Ruoa) [se-se]', CultureCode: 'se-se' }, { DisplayText: 'davvismegiella (Suopma) [se-fi]', CultureCode: 'se-fi' }, { DisplayText: 'davvismegiella [se]', CultureCode: 'se' }, { DisplayText: 'Deutsch (Deutschland) [de-de]', CultureCode: 'de-de' }, { DisplayText: 'Deutsch (Liechtenstein) [de-li]', CultureCode: 'de-li' }, { DisplayText: 'Deutsch (Luxemburg) [de-lu]', CultureCode: 'de-lu' }, { DisplayText: 'Deutsch (sterreich) [de-at]', CultureCode: 'de-at' }, { DisplayText: 'Deutsch (Schweiz) [de-ch]', CultureCode: 'de-ch' }, { DisplayText: 'Deutsch [de]', CultureCode: 'de' }, { DisplayText: 'dolnoserbina (Nimska) [dsb-de]', CultureCode: 'dsb-de' }, { DisplayText: 'dolnoserbina [dsb]', CultureCode: 'dsb' }, { DisplayText: 'eesti (Eesti) [et-ee]', CultureCode: 'et-ee' }, { DisplayText: 'eesti [et]', CultureCode: 'et' }, { DisplayText: 'Elsssisch (Fr nkrisch) [gsw-fr]', CultureCode: 'gsw-fr' }, { DisplayText: 'Elsssisch [gsw]', CultureCode: 'gsw' }, { DisplayText: 'English (Australia) [en-au]', CultureCode: 'en-au' }, { DisplayText: 'English (Belize) [en-bz]', CultureCode: 'en-bz' }, { DisplayText: 'English (Canada) [en-ca]', CultureCode: 'en-ca' }, { DisplayText: 'English (Caribbean) [en-029]', CultureCode: 'en-029' }, { DisplayText: 'English (India) [en-in]', CultureCode: 'en-in' }, { DisplayText: 'English (Ireland) [en-ie]', CultureCode: 'en-ie' }, { DisplayText: 'English (Jamaica) [en-jm]', CultureCode: 'en-jm' }, { DisplayText: 'English (Malaysia) [en-my]', CultureCode: 'en-my' }, { DisplayText: 'English (New Zealand) [en-nz]', CultureCode: 'en-nz' }, { DisplayText: 'English (Philippines) [en-ph]', CultureCode: 'en-ph' }, { DisplayText: 'English (Singapore) [en-sg]', CultureCode: 'en-sg' }, { DisplayText: 'English (South Africa) [en-za]', CultureCode: 'en-za' }, { DisplayText: 'English (Trinidad y Tobago) [en-tt]', CultureCode: 'en-tt' }, { DisplayText: 'English (United Kingdom) [en-gb]', CultureCode: 'en-gb' }, { DisplayText: 'English (United States) [en-us]', CultureCode: 'en-us' }, { DisplayText: 'English (Zimbabwe) [en-zw]', CultureCode: 'en-zw' }, { DisplayText: 'English [en]', CultureCode: 'en' }, { DisplayText: 'Espaol (Argentina) [es-ar]', CultureCode: 'es-ar' }, { DisplayText: 'Espaol (Bolivia) [es-bo]', CultureCode: 'es-bo' }, { DisplayText: 'Espaol (Chile) [es-cl]', CultureCode: 'es-cl' }, { DisplayText: 'Espaol (Colombia) [es-co]', CultureCode: 'es-co' }, { DisplayText: 'Espaol (Costa Rica) [es-cr]', CultureCode: 'es-cr' }, { DisplayText: 'Espaol (Ecuador) [es-ec]', CultureCode: 'es-ec' }, { DisplayText: 'Espaol (El Salvador) [es-sv]', CultureCode: 'es-sv' }, { DisplayText: 'Espaol (Espaa, alfabetizacin internacional) [es-es]', CultureCode: 'es-es' }, { DisplayText: 'Espaol (Estados Unidos) [es-us]', CultureCode: 'es-us' }, { DisplayText: 'Espaol (Guatemala) [es-gt]', CultureCode: 'es-gt' }, { DisplayText: 'Espaol (Honduras) [es-hn]', CultureCode: 'es-hn' }, { DisplayText: 'Espaol (Mxico) [es-mx]', CultureCode: 'es-mx' }, { DisplayText: 'Espaol (Nicaragua) [es-ni]', CultureCode: 'es-ni' }, { DisplayText: 'Espaol (Panam) [es-pa]', CultureCode: 'es-pa' }, { DisplayText: 'Espaol (Paraguay) [es-py]', CultureCode: 'es-py' }, { DisplayText: 'Espaol (Per) [es-pe]', CultureCode: 'es-pe' }, { DisplayText: 'Espaol (Puerto Rico) [es-pr]', CultureCode: 'es-pr' }, { DisplayText: 'Espaol (Republica Bolivariana de Venezuela) [es-ve]', CultureCode: 'es-ve' }, { DisplayText: 'Espaol (Repblica Dominicana) [es-do]', CultureCode: 'es-do' }, { DisplayText: 'Espaol (Uruguay) [es-uy]', CultureCode: 'es-uy' }, { DisplayText: 'espaol [es]', CultureCode: 'es' }, { DisplayText: 'euskara (euskara) [eu-es]', CultureCode: 'eu-es' }, { DisplayText: 'euskara [eu]', CultureCode: 'eu' }, { DisplayText: 'Filipino (Pilipinas) [fil-ph]', CultureCode: 'fil-ph' }, { DisplayText: 'Filipino [fil]', CultureCode: 'fil' }, { DisplayText: 'froyskt (Froyar) [fo-fo]', CultureCode: 'fo-fo' }, { DisplayText: 'froyskt [fo]', CultureCode: 'fo' }, { DisplayText: 'franais (Belgique) [fr-be]', CultureCode: 'fr-be' }, { DisplayText: 'franais (Canada) [fr-ca]', CultureCode: 'fr-ca' }, { DisplayText: 'franais (France) [fr-fr]', CultureCode: 'fr-fr' }, { DisplayText: 'franais (Luxembourg) [fr-lu]', CultureCode: 'fr-lu' }, { DisplayText: 'franais (Principaut de Monaco) [fr-mc]', CultureCode: 'fr-mc' }, { DisplayText: 'franais (Suisse) [fr-ch]', CultureCode: 'fr-ch' }, { DisplayText: 'franais [fr]', CultureCode: 'fr' }, { DisplayText: 'Frysk (Nederln) [fy-nl]', CultureCode: 'fy-nl' }, { DisplayText: 'Frysk [fy]', CultureCode: 'fy' }, { DisplayText: 'Gaeilge (ire) [ga-ie]', CultureCode: 'ga-ie' }, { DisplayText: 'Gaeilge [ga]', CultureCode: 'ga' }, { DisplayText: 'G idhlig (An Roghachd Aonaichte) [gd-gb]', CultureCode: 'gd-gb' }, { DisplayText: 'G idhlig [gd]', CultureCode: 'gd' }, { DisplayText: 'galego (galego) [gl-es]', CultureCode: 'gl-es' }, { DisplayText: 'galego [gl]', CultureCode: 'gl' }, { DisplayText: 'Hausa (Nigeria) [ha-latn-ng]', CultureCode: 'ha-latn-ng' }, { DisplayText: 'Hausa [ha]', CultureCode: 'ha' }, { DisplayText: 'Hausa [ha-latn]', CultureCode: 'ha-latn' }, { DisplayText: 'hornjoserbina (Nmska) [hsb-de]', CultureCode: 'hsb-de' }, { DisplayText: 'hornjoserbina [hsb]', CultureCode: 'hsb' }, { DisplayText: 'hrvatski (Bosna i Hercegovina) [hr-ba]', CultureCode: 'hr-ba' }, { DisplayText: 'hrvatski (Hrvatska) [hr-hr]', CultureCode: 'hr-hr' }, { DisplayText: 'hrvatski [hr]', CultureCode: 'hr' }, { DisplayText: 'Igbo (Nigeria) [ig-ng]', CultureCode: 'ig-ng' }, { DisplayText: 'Igbo [ig]', CultureCode: 'ig' }, { DisplayText: 'Inuktitut (Kanatami) [iu-latn-ca]', CultureCode: 'iu-latn-ca' }, { DisplayText: 'Inuktitut [iu]', CultureCode: 'iu' }, { DisplayText: 'Inuktitut [iu-latn]', CultureCode: 'iu-latn' }, { DisplayText: 'Invariant Language (Invariant Country) []', CultureCode: '' }, { DisplayText: 'isiXhosa (uMzantsi Afrika) [xh-za]', CultureCode: 'xh-za' }, { DisplayText: 'isiXhosa [xh]', CultureCode: 'xh' }, { DisplayText: 'isiZulu (iNingizimu Afrika) [zu-za]', CultureCode: 'zu-za' }, { DisplayText: 'isiZulu [zu]', CultureCode: 'zu' }, { DisplayText: 'slenska (sland) [is-is]', CultureCode: 'is-is' }, { DisplayText: 'slenska [is]', CultureCode: 'is' }, { DisplayText: 'italiano (Italia) [it-it]', CultureCode: 'it-it' }, { DisplayText: 'italiano (Svizzera) [it-ch]', CultureCode: 'it-ch' }, { DisplayText: 'italiano [it]', CultureCode: 'it' }, { DisplayText: 'julevusmegiella (Svierik) [smj-se]', CultureCode: 'smj-se' }, { DisplayText: 'julevusmegiella (Vuodna) [smj-no]', CultureCode: 'smj-no' }, { DisplayText: 'julevusmegiella [smj]', CultureCode: 'smj' }, { DisplayText: 'kalaallisut (Kalaallit Nunaat) [kl-gl]', CultureCode: 'kl-gl' }, { DisplayText: 'kalaallisut [kl]', CultureCode: 'kl' }, { DisplayText: 'Kanien\'kha [moh]', CultureCode: 'moh' }, { DisplayText: 'Kanien\'kha [moh-ca]', CultureCode: 'moh-ca' }, { DisplayText: 'K\'iche (Guatemala) [qut-gt]', CultureCode: 'qut-gt' }, { DisplayText: 'K\'iche [qut]', CultureCode: 'qut' }, { DisplayText: 'Kinyarwanda (Rwanda) [rw-rw]', CultureCode: 'rw-rw' }, { DisplayText: 'Kinyarwanda [rw]', CultureCode: 'rw' }, { DisplayText: 'Kiswahili (Kenya) [sw-ke]', CultureCode: 'sw-ke' }, { DisplayText: 'Kiswahili [sw]', CultureCode: 'sw' }, { DisplayText: 'latvieu (Latvija) [lv-lv]', CultureCode: 'lv-lv' }, { DisplayText: 'latvieu [lv]', CultureCode: 'lv' }, { DisplayText: 'Ltzebuergesch (Luxembourg) [lb-lu]', CultureCode: 'lb-lu' }, { DisplayText: 'Ltzebuergesch [lb]', CultureCode: 'lb' }, { DisplayText: 'lietuvi (Lietuva) [lt-lt]', CultureCode: 'lt-lt' }, { DisplayText: 'lietuvi [lt]', CultureCode: 'lt' }, { DisplayText: 'magyar (Magyarorszg) [hu-hu]', CultureCode: 'hu-hu' }, { DisplayText: 'magyar [hu]', CultureCode: 'hu' }, { DisplayText: 'Malti (Malta) [mt-mt]', CultureCode: 'mt-mt' }, { DisplayText: 'Malti [mt]', CultureCode: 'mt' }, { DisplayText: 'Mapudungun (Chile) [arn-cl]', CultureCode: 'arn-cl' }, { DisplayText: 'Mapudungun [arn]', CultureCode: 'arn' }, { DisplayText: 'Nederlands (Belgi) [nl-be]', CultureCode: 'nl-be' }, { DisplayText: 'Nederlands (Nederland) [nl-nl]', CultureCode: 'nl-nl' }, { DisplayText: 'Nederlands [nl]', CultureCode: 'nl' }, { DisplayText: 'norsk (bokml) [nb]', CultureCode: 'nb' }, { DisplayText: 'norsk (nynorsk) [nn]', CultureCode: 'nn' }, { DisplayText: 'norsk [no]', CultureCode: 'no' }, { DisplayText: 'norsk, bokml (Norge) [nb-no]', CultureCode: 'nb-no' }, { DisplayText: 'norsk, nynorsk (Noreg) [nn-no]', CultureCode: 'nn-no' }, { DisplayText: 'Occitan (Frana) [oc-fr]', CultureCode: 'oc-fr' }, { DisplayText: 'Occitan [oc]', CultureCode: 'oc' }, { DisplayText: 'polski (Polska) [pl-pl]', CultureCode: 'pl-pl' }, { DisplayText: 'polski [pl]', CultureCode: 'pl' }, { DisplayText: 'Portugus (Brasil) [pt-br]', CultureCode: 'pt-br' }, { DisplayText: 'portugus (Portugal) [pt-pt]', CultureCode: 'pt-pt' }, { DisplayText: 'Portugus [pt]', CultureCode: 'pt' }, { DisplayText: 'Reo Mori (Aotearoa) [mi-nz]', CultureCode: 'mi-nz' }, { DisplayText: 'Reo Mori [mi]', CultureCode: 'mi' }, { DisplayText: 'romn (Romnia) [ro-ro]', CultureCode: 'ro-ro' }, { DisplayText: 'romn [ro]', CultureCode: 'ro' }, { DisplayText: 'Rumantsch (Svizra) [rm-ch]', CultureCode: 'rm-ch' }, { DisplayText: 'Rumantsch [rm]', CultureCode: 'rm' }, { DisplayText: 'runasimi (Ecuador) [quz-ec]', CultureCode: 'quz-ec' }, { DisplayText: 'runasimi (Piruw) [quz-pe]', CultureCode: 'quz-pe' }, { DisplayText: 'runasimi (Qullasuyu) [quz-bo]', CultureCode: 'quz-bo' }, { DisplayText: 'runasimi [quz]', CultureCode: 'quz' }, { DisplayText: 'smill (Lddjnnam) [sms-fi]', CultureCode: 'sms-fi' }, { DisplayText: 'smill [sms]', CultureCode: 'sms' }, { DisplayText: 'smikiel (Suom) [smn-fi]', CultureCode: 'smn-fi' }, { DisplayText: 'smikiel [smn]', CultureCode: 'smn' }, { DisplayText: 'Sesotho sa Leboa (Afrika Borwa) [nso-za]', CultureCode: 'nso-za' }, { DisplayText: 'Sesotho sa Leboa [nso]', CultureCode: 'nso' }, { DisplayText: 'Setswana (Aforika Borwa) [tn-za]', CultureCode: 'tn-za' }, { DisplayText: 'Setswana [tn]', CultureCode: 'tn' }, { DisplayText: 'shqipe (Shqipria) [sq-al]', CultureCode: 'sq-al' }, { DisplayText: 'shqipe [sq]', CultureCode: 'sq' }, { DisplayText: 'slovenina (Slovensk republika) [sk-sk]', CultureCode: 'sk-sk' }, { DisplayText: 'slovenina [sk]', CultureCode: 'sk' }, { DisplayText: 'slovenski (Slovenija) [sl-si]', CultureCode: 'sl-si' }, { DisplayText: 'slovenski [sl]', CultureCode: 'sl' }, { DisplayText: 'srpski (Bosna i Hercegovina) [sr-latn-ba]', CultureCode: 'sr-latn-ba' }, { DisplayText: 'srpski (Crna Gora) [sr-latn-me]', CultureCode: 'sr-latn-me' }, { DisplayText: 'srpski (Srbija i Crna Gora (Prethodno)) [sr-latn-cs]', CultureCode: 'sr-latn-cs' }, { DisplayText: 'srpski (Srbija) [sr-latn-rs]', CultureCode: 'sr-latn-rs' }, { DisplayText: 'srpski [sr]', CultureCode: 'sr' }, { DisplayText: 'srpski [sr-latn]', CultureCode: 'sr-latn' }, { DisplayText: 'suomi (Suomi) [fi-fi]', CultureCode: 'fi-fi' }, { DisplayText: 'suomi [fi]', CultureCode: 'fi' }, { DisplayText: 'svenska (Finland) [sv-fi]', CultureCode: 'sv-fi' }, { DisplayText: 'svenska (Sverige) [sv-se]', CultureCode: 'sv-se' }, { DisplayText: 'svenska [sv]', CultureCode: 'sv' }, { DisplayText: 'Tamazight (Djazar) [tzm-latn-dz]', CultureCode: 'tzm-latn-dz' }, { DisplayText: 'Tamazight [tzm]', CultureCode: 'tzm' }, { DisplayText: 'Tamazight [tzm-latn]', CultureCode: 'tzm-latn' }, { DisplayText: 'Ting Vit (Vit Nam) [vi-vn]', CultureCode: 'vi-vn' }, { DisplayText: 'Ting Vit [vi]', CultureCode: 'vi' }, { DisplayText: 'Trke [tr]', CultureCode: 'tr' }, { DisplayText: 'trkmene (Trkmenistan) [tk-tm]', CultureCode: 'tk-tm' }, { DisplayText: 'trkmene [tk]', CultureCode: 'tk' }, { DisplayText: 'U\'zbek (U\'zbekiston Respublikasi) [uz-latn-uz]', CultureCode: 'uz-latn-uz' }, { DisplayText: 'U\'zbek [uz]', CultureCode: 'uz' }, { DisplayText: 'U\'zbek [uz-latn]', CultureCode: 'uz-latn' }, { DisplayText: 'Wolof (Sngal) [wo-sn]', CultureCode: 'wo-sn' }, { DisplayText: 'Wolof [wo]', CultureCode: 'wo' }, { DisplayText: 'Yoruba (Nigeria) [yo-ng]', CultureCode: 'yo-ng' }, { DisplayText: 'Yoruba [yo]', CultureCode: 'yo' }, { DisplayText: ' () [el-gr]', CultureCode: 'el-gr' }, { DisplayText: ' [el]', CultureCode: 'el' }, { DisplayText: '  [az-cyrl]', CultureCode: 'az-cyrl' }, { DisplayText: ' ( ) [ba-ru]', CultureCode: 'ba-ru' }, { DisplayText: ' [ba]', CultureCode: 'ba' }, { DisplayText: ' () [be-by]', CultureCode: 'be-by' }, { DisplayText: ' [be]', CultureCode: 'be' }, { DisplayText: ' (  ) [bs-cyrl-ba]', CultureCode: 'bs-cyrl-ba' }, { DisplayText: ' [bs-cyrl]', CultureCode: 'bs-cyrl' }, { DisplayText: ' () [bg-bg]', CultureCode: 'bg-bg' }, { DisplayText: ' [bg]', CultureCode: 'bg' }, { DisplayText: ' () [ky-kg]', CultureCode: 'ky-kg' }, { DisplayText: ' [ky]', CultureCode: 'ky' }, { DisplayText: ' () [kk-kz]', CultureCode: 'kk-kz' }, { DisplayText: ' [kk]', CultureCode: 'kk' }, { DisplayText: '  () [mk-mk]', CultureCode: 'mk-mk' }, { DisplayText: '  [mk]', CultureCode: 'mk' }, { DisplayText: '  ( ) [mn-mn]', CultureCode: 'mn-mn' }, { DisplayText: '  [mn]', CultureCode: 'mn' }, { DisplayText: '  [mn-cyrl]', CultureCode: 'mn-cyrl' }, { DisplayText: ' ( ) [ru-ru]', CultureCode: 'ru-ru' }, { DisplayText: ' [ru]', CultureCode: 'ru' }, { DisplayText: ' ( ) [sah-ru]', CultureCode: 'sah-ru' }, { DisplayText: ' [sah]', CultureCode: 'sah' }, { DisplayText: ' (  ) [sr-cyrl-ba]', CultureCode: 'sr-cyrl-ba' }, { DisplayText: ' (    ()) [sr-cyrl-cs]', CultureCode: 'sr-cyrl-cs' }, { DisplayText: ' () [sr-cyrl-rs]', CultureCode: 'sr-cyrl-rs' }, { DisplayText: ' ( ) [sr-cyrl-me]', CultureCode: 'sr-cyrl-me' }, { DisplayText: ' [sr-cyrl]', CultureCode: 'sr-cyrl' }, { DisplayText: ' ( ) [tt-ru]', CultureCode: 'tt-ru' }, { DisplayText: ' [tt]', CultureCode: 'tt' }, { DisplayText: ' () [tg-cyrl-tj]', CultureCode: 'tg-cyrl-tj' }, { DisplayText: ' [tg]', CultureCode: 'tg' }, { DisplayText: ' [tg-cyrl]', CultureCode: 'tg-cyrl' }, { DisplayText: ' () [uz-cyrl-uz]', CultureCode: 'uz-cyrl-uz' }, { DisplayText: ' [uz-cyrl]', CultureCode: 'uz-cyrl' }, { DisplayText: ' () [uk-ua]', CultureCode: 'uk-ua' }, { DisplayText: ' [uk]', CultureCode: 'uk' }, { DisplayText: ' () [hy-am]', CultureCode: 'hy-am' }, { DisplayText: ' [hy]', CultureCode: 'hy' }, { DisplayText: '  ( ) [ka-ge]', CultureCode: 'ka-ge' }, { DisplayText: '  [ka]', CultureCode: 'ka' }, { DisplayText: ' () [he-il]', CultureCode: 'he-il' }, { DisplayText: ' [he]', CultureCode: 'he' }, { DisplayText: ' () [ur-pk]', CultureCode: 'ur-pk' }, { DisplayText: ' [ur]', CultureCode: 'ur' }, { DisplayText: ' () [ar-jo]', CultureCode: 'ar-jo' }, { DisplayText: ' (  ) [ar-ae]', CultureCode: 'ar-ae' }, { DisplayText: ' () [ar-bh]', CultureCode: 'ar-bh' }, { DisplayText: ' () [ar-dz]', CultureCode: 'ar-dz' }, { DisplayText: ' () [ar-iq]', CultureCode: 'ar-iq' }, { DisplayText: ' () [ar-kw]', CultureCode: 'ar-kw' }, { DisplayText: ' (  ) [ar-sa]', CultureCode: 'ar-sa' }, { DisplayText: ' ( ) [ar-ma]', CultureCode: 'ar-ma' }, { DisplayText: ' () [ar-ye]', CultureCode: 'ar-ye' }, { DisplayText: ' () [ar-tn]', CultureCode: 'ar-tn' }, { DisplayText: ' () [ar-sy]', CultureCode: 'ar-sy' }, { DisplayText: ' () [ar-om]', CultureCode: 'ar-om' }, { DisplayText: ' () [ar-qa]', CultureCode: 'ar-qa' }, { DisplayText: ' () [ar-lb]', CultureCode: 'ar-lb' }, { DisplayText: ' () [ar-ly]', CultureCode: 'ar-ly' }, { DisplayText: ' () [ar-eg]', CultureCode: 'ar-eg' }, { DisplayText: ' [ar]', CultureCode: 'ar' }, { DisplayText: ' () [ps-af]', CultureCode: 'ps-af' }, { DisplayText: ' [ps]', CultureCode: 'ps' }, { DisplayText: ' () [prs-af]', CultureCode: 'prs-af' }, { DisplayText: ' [prs]', CultureCode: 'prs' }, { DisplayText: ' () [fa-ir]', CultureCode: 'fa-ir' }, { DisplayText: ' [fa]', CultureCode: 'fa' }, { DisplayText: ' (  ) [ug-cn]', CultureCode: 'ug-cn' }, { DisplayText: ' [ug]', CultureCode: 'ug' }, { DisplayText: ' () [syr-sy]', CultureCode: 'syr-sy' }, { DisplayText: ' [syr]', CultureCode: 'syr' }, { DisplayText: ' ( ) [dv-mv]', CultureCode: 'dv-mv' }, { DisplayText: ' [dv]', CultureCode: 'dv' }, { DisplayText: ' () [kok-in]', CultureCode: 'kok-in' }, { DisplayText: ' [kok]', CultureCode: 'kok' }, { DisplayText: ' () [ne-np]', CultureCode: 'ne-np' }, { DisplayText: ' [ne]', CultureCode: 'ne' }, { DisplayText: '  () [mr-in]', CultureCode: 'mr-in' }, { DisplayText: '  [mr]', CultureCode: 'mr' }, { DisplayText: ' () [sa-in]', CultureCode: 'sa-in' }, { DisplayText: ' [sa]', CultureCode: 'sa' }, { DisplayText: ' () [hi-in]', CultureCode: 'hi-in' }, { DisplayText: ' [hi]', CultureCode: 'hi' }, { DisplayText: ' () [as-in]', CultureCode: 'as-in' }, { DisplayText: ' [as]', CultureCode: 'as' }, { DisplayText: ' () [bn-bd]', CultureCode: 'bn-bd' }, { DisplayText: ' () [bn-in]', CultureCode: 'bn-in' }, { DisplayText: ' [bn]', CultureCode: 'bn' }, { DisplayText: ' () [pa-in]', CultureCode: 'pa-in' }, { DisplayText: ' [pa]', CultureCode: 'pa' }, { DisplayText: ' () [gu-in]', CultureCode: 'gu-in' }, { DisplayText: ' [gu]', CultureCode: 'gu' }, { DisplayText: ' () [or-in]', CultureCode: 'or-in' }, { DisplayText: ' [or]', CultureCode: 'or' }, { DisplayText: ' () [ta-in]', CultureCode: 'ta-in' }, { DisplayText: ' [ta]', CultureCode: 'ta' }, { DisplayText: ' ( ) [te-in]', CultureCode: 'te-in' }, { DisplayText: ' [te]', CultureCode: 'te' }, { DisplayText: ' () [kn-in]', CultureCode: 'kn-in' }, { DisplayText: ' [kn]', CultureCode: 'kn' }, { DisplayText: ' () [ml-in]', CultureCode: 'ml-in' }, { DisplayText: ' [ml]', CultureCode: 'ml' }, { DisplayText: ' ( ) [si-lk]', CultureCode: 'si-lk' }, { DisplayText: ' [si]', CultureCode: 'si' }, { DisplayText: ' () [th-th]', CultureCode: 'th-th' }, { DisplayText: ' [th]', CultureCode: 'th' }, { DisplayText: '             (                                         ) [mn-mong-cn]', CultureCode: 'mn-mong-cn' }, { DisplayText: '             [mn-mong]', CultureCode: 'mn-mong' }, { DisplayText: ' () [bo-cn]', CultureCode: 'bo-cn' }, { DisplayText: ' [bo]', CultureCode: 'bo' }, { DisplayText: ' (... ) [lo-la]', CultureCode: 'lo-la' }, { DisplayText: ' [lo]', CultureCode: 'lo' }, { DisplayText: ' () [km-kh]', CultureCode: 'km-kh' }, { DisplayText: ' [km]', CultureCode: 'km' }, { DisplayText: ' () [iu-cans-ca]', CultureCode: 'iu-cans-ca' }, { DisplayText: ' [iu-cans]', CultureCode: 'iu-cans' }, { DisplayText: '  () [am-et]', CultureCode: 'am-et' }, { DisplayText: '  [am]', CultureCode: 'am' }, { DisplayText: '  () [ii-cn]', CultureCode: 'ii-cn' }, { DisplayText: '  [ii]', CultureCode: 'ii' }, { DisplayText: ' () [ko-kr]', CultureCode: 'ko-kr' }, { DisplayText: ' [ko]', CultureCode: 'ko' }, { DisplayText: ' [zh]', CultureCode: 'zh' }, { DisplayText: '() [zh-cn]', CultureCode: 'zh-cn' }, { DisplayText: '() [zh-tw]', CultureCode: 'zh-tw' }, { DisplayText: '( ) [zh-sg]', CultureCode: 'zh-sg' }, { DisplayText: '() [zh-mo]', CultureCode: 'zh-mo' }, { DisplayText: '() [zh-hans]', CultureCode: 'zh-hans' }, { DisplayText: '()  [zh-chs]', CultureCode: 'zh-chs' }, { DisplayText: '() [zh-hant]', CultureCode: 'zh-hant' }, { DisplayText: '()  [zh-cht]', CultureCode: 'zh-cht' }, { DisplayText: '() [zh-hk]', CultureCode: 'zh-hk' }, { DisplayText: ' () [ja-jp]', CultureCode: 'ja-jp' }, { DisplayText: ' [ja]', CultureCode: 'ja' }]
      }
    };
  }

  _createClass(MockSDataCulture, [{
    key: 'read',
    value: function read(params) {
      if (params) {
        if (params.expectSuccess && params.success) {
          params.success(this.queryResult);
          return;
        } else if (!params.expectSuccess && params.failure) {
          params.failure('class query failed');
          return;
        }
      }
      console.error('params needs to exist and have the functions success and failure'); //eslint-disable-line
    }
  }]);

  return MockSDataCulture;
}();

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _src = __webpack_require__(0);

Object.keys(_src).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _src[key];
    }
  });
});

/***/ }
/******/ ]);
});
//# sourceMappingURL=icrm-js-services.js.map
},
'Sage/Services/PickListService':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define, cookie */
define([
    'Sage/Data/SDataServiceRegistry',
    'dojo/_base/declare',
    'icrm-js-services',
    'Sage/Services/LocalStorageService'
],
/**
 * This is a slxClient wrapper for the icrm-js-sdk pick list service.
 */
function (SDataServiceRegistry, declare, ServiceBundle, LocalStorageService) {
    // make sure that icrm-js-sdk has a pick list service
    var bundledService = {};
    if (ServiceBundle && ServiceBundle.PickListService) {
        bundledService = ServiceBundle.PickListService;
    } else {
        console.warn('the pick list service is missing from icrm-js-sdk');
    }
    var svc = declare('Sage.Services.PickListService', [bundledService], {
        constructor: function () {
            if (!Sage.Services.hasService('LocalStorage')) {
                if (Sage.Services.LocalStorageService) {
                    Sage.Services.addService('LocalStorage', new Sage.Services.LocalStorageService());
                } else {
                    Sage.Services.addService('LocalStorage', new LocalStorageService());
                }
            }

            this._storage = Sage.Services.getService('LocalStorage');
            this._service = SDataServiceRegistry.getSDataService('system', false, true, false);
        },
        read: function (arg) {
            if (arg && arg.handlers && arg.options) {
                var handlers = arg.handlers,
                    options = arg.options;
                var request = this.setUpRequest(new Sage.SData.Client.SDataResourceCollectionRequest(options.service), options);
                request.read(arg.handlers);
            }
        }
    });
    /**
      * Add an instance of this service to the Sage.Services service collection.
    */
    if (!Sage.Services.hasService('PickList'))
        Sage.Services.addService('PickList', new Sage.Services.PickListService());

    return svc;
});
},
'Sage/UI/Calendar':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
        'dijit/Calendar',
        'dojo/_base/declare'
    ],
    function (dijitCalendar, declare) {
        var calendar = declare('Sage.UI.Calendar', dijitCalendar, {
            _dateModifiedExternal: false,
            displayMode: '',
            constructor: function (options) {
                this.displayMode = options.displayMode;
                var self = this;
                this.lang = Sys.CultureInfo.CurrentCulture.name;

                //displaymode "popup" is for the calendar defined in Sage/UI/Controls/DatetimePicker.html
                if (this.displayMode === "popup") {
                    dojo.connect(this, "_setValueAttr", function (/*Date|Number*/value, /*Boolean*/priorityChange) {
                        // summary:
                        //  Support set("value", ...)
                        // description:
                        //  Set the current date and update the UI.  If the date is disabled, the value will
                        //  not change, but the display will change to the corresponding month.
                        // value:
                        //  Either a Date or the number of seconds since 1970.
                        // tags:
                        //      protected
                        if (value) {
                            // convert from Number to Date, or make copy of Date object so that setHours() call below
                            // doesn't affect original value
                            value = new self.dateClassObj(value);
                        }
                        if (self._isValidDate(value)) {
                            //if (!self._isValidDate(self.value) || self.dateFuncObj.compare(value, self.value)) {
                            //Saleslogix update : Commented above condition to allow the clicking on current date so that we can close the popup
                            value.setHours(1, 0, 0, 0); // round to nearest day (1am to avoid issues when DST shift occurs at midnight, see #8521, #9366)

                            if (!self.isDisabledDate(value, self.lang)) {
                                self._set("value", value);

                                // Set focus cell to the new value.   Arguably this should only happen when there isn't a current
                                // focus point.   This will also repopulate the grid, showing the new selected value (and possibly
                                // new month/year).
                                if (self.monthWidget && self.monthWidget.dropDown) {
                                    self.set("currentFocus", value);
                                }

                                if (priorityChange || typeof priorityChange == "undefined") {
                                    self.onChange(self.get('value'));
                                }
                            }
                            // }
                        } else {
                            // clear value, and repopulate grid (to deselect the previously selected day) without changing currentFocus
                            self._set("value", null);
                            self.set("currentFocus", self.currentFocus);
                        }
                    });
                } else {
                    dojo.subscribe("/entity/activity/calendar/schedulerDateChanged", function (data) {
                        (function () {
                            self._dateModifiedExternal = true;
                            self.set('value', data.date);
                            self._dateModifiedExternal = false;
                        })();
                    });
                    /**
                    This will keep the date selected when the month/year changed
                    */
                    dojo.connect(this, "_setCurrentFocusAttr", function (date) {
                        // Grab the original _setCurrentFocusAttr reference
                        var original = self._setCurrentFocusAttr;

                        // Setting the value will cause _setCurrentFocusAttr to fire again, prevent this
                        // by setting _setCurrentFocusAttr to a no-op
                        self._setCurrentFocusAttr = function () { };
                        self.set('value', date);

                        // Restore the original
                        self._setCurrentFocusAttr = original;
                    });
                }
                this.inherited(arguments);
            },
            onValueSelected: function (date) {
                if (this.displayMode != "popup") {
                    if (!this._dateModifiedExternal) {
                        this._dateModifiedExternal = false;
                        dojo.publish('/entity/activity/calendar/navigationCalendarDateChanged', [date, this]);
                        this._dateModifiedExternal = false;
                    }
                }
            },
            getClassForDate: function (date) {
                var day = date.getDay();
                if ((day === 6) || (day === 0)) {
                    return "dijitCalendarWeekEndDate";
                }
            }
        });
        return calendar;
    });
   

},
'dijit/Calendar':function(){
define([
	"dojo/_base/array", // array.map
	"dojo/date",
	"dojo/date/locale",
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.get
	"dojo/dom-class", // domClass.add domClass.contains domClass.remove domClass.toggle
	"dojo/dom-construct",	// create
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/keys", // keys
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/sniff", // has("ie")
	"./CalendarLite",
	"./_Widget",
	"./_CssStateMixin",
	"./_TemplatedMixin",
	"./form/DropDownButton"
], function(array, date, local, declare, domAttr, domClass, domConstruct, kernel, keys, lang, on, has,
			CalendarLite, _Widget, _CssStateMixin, _TemplatedMixin, DropDownButton){

	// module:
	//		dijit/Calendar

	// _Widget for deprecated methods like setAttribute()
	var Calendar = declare("dijit.Calendar", [CalendarLite, _Widget, _CssStateMixin], {
		// summary:
		//		A simple GUI for choosing a date in the context of a monthly calendar.
		//
		// description:
		//		See CalendarLite for general description.   Calendar extends CalendarLite, adding:
		//
		//		- month drop down list
		//		- keyboard navigation
		//		- CSS classes for hover/mousepress on date, month, and year nodes
		//		- support of deprecated methods (will be removed in 2.0)

		baseClass: "dijitCalendar",

		// Set node classes for various mouse events, see dijit._CssStateMixin for more details
		cssStateNodes: {
			"decrementMonth": "dijitCalendarArrow",
			"incrementMonth": "dijitCalendarArrow",
			"previousYearLabelNode": "dijitCalendarPreviousYear",
			"nextYearLabelNode": "dijitCalendarNextYear"
		},

		setValue: function(/*Date*/ value){
			// summary:
			//		Deprecated.   Use set('value', ...) instead.
			// tags:
			//		deprecated
			kernel.deprecated("dijit.Calendar:setValue() is deprecated.  Use set('value', ...) instead.", "", "2.0");
			this.set('value', value);
		},

		_createMonthWidget: function(){
			// summary:
			//		Creates the drop down button that displays the current month and lets user pick a new one

			return new Calendar._MonthDropDownButton({
				id: this.id + "_mddb",
				tabIndex: -1,
				onMonthSelect: lang.hitch(this, "_onMonthSelect"),
				lang: this.lang,
				dateLocaleModule: this.dateLocaleModule
			}, this.monthNode);
		},

		postCreate: function(){
			this.inherited(arguments);

			// Events specific to Calendar, not used in CalendarLite
			this.own(
				on(this.domNode, "keydown", lang.hitch(this, "_onKeyDown")),
				on(this.dateRowsNode, "mouseover", lang.hitch(this, "_onDayMouseOver")),
				on(this.dateRowsNode, "mouseout", lang.hitch(this, "_onDayMouseOut")),
				on(this.dateRowsNode, "mousedown", lang.hitch(this, "_onDayMouseDown")),
				on(this.dateRowsNode, "mouseup", lang.hitch(this, "_onDayMouseUp"))
			);
		},

		_onMonthSelect: function(/*Number*/ newMonth){
			// summary:
			//		Handler for when user selects a month from the drop down list
			// tags:
			//		protected

			// move to selected month, bounding by the number of days in the month
			// (ex: jan 31 --> feb 28, not feb 31)
			var date = new this.dateClassObj(this.currentFocus);
			date.setDate(1);
			date.setMonth(newMonth);
			var daysInMonth = this.dateModule.getDaysInMonth(date);
			var currentDate = this.currentFocus.getDate();
			date.setDate(Math.min(currentDate, daysInMonth));
			this._setCurrentFocusAttr(date);
		},

		_onDayMouseOver: function(/*Event*/ evt){
			// summary:
			//		Handler for mouse over events on days, sets hovered style
			// tags:
			//		protected

			// event can occur on <td> or the <span> inside the td,
			// set node to the <td>.
			var node =
				domClass.contains(evt.target, "dijitCalendarDateLabel") ?
					evt.target.parentNode :
					evt.target;

			if(node && (
				(node.dijitDateValue && !domClass.contains(node, "dijitCalendarDisabledDate"))
					|| node == this.previousYearLabelNode || node == this.nextYearLabelNode
				)){
				domClass.add(node, "dijitCalendarHoveredDate");
				this._currentNode = node;
			}
		},

		_onDayMouseOut: function(/*Event*/ evt){
			// summary:
			//		Handler for mouse out events on days, clears hovered style
			// tags:
			//		protected

			if(!this._currentNode){
				return;
			}

			// if mouse out occurs moving from <td> to <span> inside <td>, ignore it
			if(evt.relatedTarget && evt.relatedTarget.parentNode == this._currentNode){
				return;
			}
			var cls = "dijitCalendarHoveredDate";
			if(domClass.contains(this._currentNode, "dijitCalendarActiveDate")){
				cls += " dijitCalendarActiveDate";
			}
			domClass.remove(this._currentNode, cls);
			this._currentNode = null;
		},

		_onDayMouseDown: function(/*Event*/ evt){
			var node = evt.target.parentNode;
			if(node && node.dijitDateValue && !domClass.contains(node, "dijitCalendarDisabledDate")){
				domClass.add(node, "dijitCalendarActiveDate");
				this._currentNode = node;
			}
		},

		_onDayMouseUp: function(/*Event*/ evt){
			var node = evt.target.parentNode;
			if(node && node.dijitDateValue){
				domClass.remove(node, "dijitCalendarActiveDate");
			}
		},

		handleKey: function(/*Event*/ evt){
			// summary:
			//		Provides keyboard navigation of calendar.
			// description:
			//		Called from _onKeyDown() to handle keydown on a stand alone Calendar,
			//		and also from `dijit/form/_DateTimeTextBox` to pass a keydown event
			//		from the `dijit/form/DateTextBox` to be handled in this widget
			// returns:
			//		False if the key was recognized as a navigation key,
			//		to indicate that the event was handled by Calendar and shouldn't be propagated
			// tags:
			//		protected
			var increment = -1,
				interval,
				newValue = this.currentFocus;
			switch(evt.keyCode){
				case keys.RIGHT_ARROW:
					increment = 1;
				//fallthrough...
				case keys.LEFT_ARROW:
					interval = "day";
					if(!this.isLeftToRight()){
						increment *= -1;
					}
					break;
				case keys.DOWN_ARROW:
					increment = 1;
				//fallthrough...
				case keys.UP_ARROW:
					interval = "week";
					break;
				case keys.PAGE_DOWN:
					increment = 1;
				//fallthrough...
				case keys.PAGE_UP:
					interval = evt.ctrlKey || evt.altKey ? "year" : "month";
					break;
				case keys.END:
					// go to the next month
					newValue = this.dateModule.add(newValue, "month", 1);
					// subtract a day from the result when we're done
					interval = "day";
				//fallthrough...
				case keys.HOME:
					newValue = new this.dateClassObj(newValue);
					newValue.setDate(1);
					break;
				default:
					return true;
			}

			if(interval){
				newValue = this.dateModule.add(newValue, interval, increment);
			}

			this._setCurrentFocusAttr(newValue);

			return false;
		},

		_onKeyDown: function(/*Event*/ evt){
			// summary:
			//		For handling keydown events on a stand alone calendar
			if(!this.handleKey(evt)){
				evt.stopPropagation();
				evt.preventDefault();
			}
		},

		onValueSelected: function(/*Date*/ /*===== date =====*/){
			// summary:
			//		Deprecated.   Notification that a date cell was selected.  It may be the same as the previous value.
			// description:
			//		Formerly used by `dijit/form/_DateTimeTextBox` (and thus `dijit/form/DateTextBox`)
			//		to get notification when the user has clicked a date.  Now onExecute() (above) is used.
			// tags:
			//		protected
		},

		onChange: function(value){
			this.onValueSelected(value);	// remove in 2.0
		},

		getClassForDate: function(/*===== dateObject, locale =====*/){
			// summary:
			//		May be overridden to return CSS classes to associate with the date entry for the given dateObject,
			//		for example to indicate a holiday in specified locale.
			// dateObject: Date
			// locale: String?
			// tags:
			//		extension

			/*=====
			 return ""; // String
			 =====*/
		}
	});

	Calendar._MonthDropDownButton = declare("dijit.Calendar._MonthDropDownButton", DropDownButton, {
		// summary:
		//		DropDownButton for the current month.    Displays name of current month
		//		and a list of month names in the drop down

		onMonthSelect: function(){
		},

		postCreate: function(){
			this.inherited(arguments);
			this.dropDown = new Calendar._MonthDropDown({
				id: this.id + "_mdd", //do not change this id because it is referenced in the template
				onChange: this.onMonthSelect
			});
		},
		_setMonthAttr: function(month){
			// summary:
			//		Set the current month to display as a label
			var monthNames = this.dateLocaleModule.getNames('months', 'wide', 'standAlone', this.lang, month);
			this.dropDown.set("months", monthNames);

			// Set name of current month and also fill in spacer element with all the month names
			// (invisible) so that the maximum width will affect layout.   But not on IE6 because then
			// the center <TH> overlaps the right <TH> (due to a browser bug).
			this.containerNode.innerHTML =
				(has("ie") == 6 ? "" : "<div class='dijitSpacer'>" + this.dropDown.domNode.innerHTML + "</div>") +
					"<div class='dijitCalendarMonthLabel dijitCalendarCurrentMonthLabel'>" + monthNames[month.getMonth()] + "</div>";
		}
	});

	Calendar._MonthDropDown = declare("dijit.Calendar._MonthDropDown", [_Widget, _TemplatedMixin, _CssStateMixin], {
		// summary:
		//		The list-of-months drop down from the MonthDropDownButton

		// months: String[]
		//		List of names of months, possibly w/some undefined entries for Hebrew leap months
		//		(ex: ["January", "February", undefined, "April", ...])
		months: [],

		baseClass: "dijitCalendarMonthMenu dijitMenu",

		templateString: "<div data-dojo-attach-event='ondijitclick:_onClick'></div>",

		_setMonthsAttr: function(/*String[]*/ months){
			this.domNode.innerHTML = "";
			array.forEach(months, function(month, idx){
				var div = domConstruct.create("div", {
					className: "dijitCalendarMonthLabel",
					month: idx,
					innerHTML: month
				}, this.domNode);
				div._cssState = "dijitCalendarMonthLabel";	// trigger _CSSStateMixin magic; property, not attribute.
			}, this);
		},

		_onClick: function(/*Event*/ evt){
			this.onChange(domAttr.get(evt.target, "month"));
		},

		onChange: function(/*Number*/ /*===== month =====*/){
			// summary:
			//		Callback when month is selected from drop down
		}
	});

	return Calendar;
});

},
'dijit/CalendarLite':function(){
define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/declare", // declare
	"dojo/cldr/supplemental", // cldrSupplemental.getFirstDayOfWeek
	"dojo/date", // date
	"dojo/date/locale",
	"dojo/date/stamp", // stamp.fromISOString
	"dojo/dom", // dom.setSelectable
	"dojo/dom-class", // domClass.contains
	"dojo/_base/lang", // lang.getObject, lang.hitch
	"dojo/on",
	"dojo/sniff", // has("ie") has("webkit")
	"dojo/string", // string.substitute
	"./_WidgetBase",
	"./_TemplatedMixin",
	"dojo/text!./templates/Calendar.html",
	"./a11yclick",	// not used directly, but template has ondijitclick in it
	"./hccss"    // not used directly, but sets CSS class on <body>
], function(array, declare, cldrSupplemental, date, locale, stamp, dom, domClass, lang, on, has, string, _WidgetBase, _TemplatedMixin, template){


	// module:
	//		dijit/CalendarLite

	var CalendarLite = declare("dijit.CalendarLite", [_WidgetBase, _TemplatedMixin], {
		// summary:
		//		Lightweight version of Calendar widget aimed towards mobile use
		//
		// description:
		//		A simple GUI for choosing a date in the context of a monthly calendar.
		//		This widget can't be used in a form because it doesn't serialize the date to an
		//		`<input>` field.  For a form element, use dijit/form/DateTextBox instead.
		//
		//		Note that the parser takes all dates attributes passed in the
		//		[RFC 3339 format](http://www.faqs.org/rfcs/rfc3339.html), e.g. `2005-06-30T08:05:00-07:00`
		//		so that they are serializable and locale-independent.
		//
		//		Also note that this widget isn't keyboard accessible; use dijit.Calendar for that
		// example:
		//	|	var calendar = new dijit.CalendarLite({}, dojo.byId("calendarNode"));
		//
		// example:
		//	|	<div data-dojo-type="dijit/CalendarLite"></div>

		// Template for main calendar
		templateString: template,

		// Template for cell for a day of the week (ex: M)
		dowTemplateString: '<th class="dijitReset dijitCalendarDayLabelTemplate" role="columnheader" scope="col"><span class="dijitCalendarDayLabel">${d}</span></th>',

		// Templates for a single date (ex: 13), and for a row for a week (ex: 20 21 22 23 24 25 26)
		dateTemplateString: '<td class="dijitReset" role="gridcell" data-dojo-attach-point="dateCells"><span class="dijitCalendarDateLabel" data-dojo-attach-point="dateLabels"></span></td>',
		weekTemplateString: '<tr class="dijitReset dijitCalendarWeekTemplate" role="row">${d}${d}${d}${d}${d}${d}${d}</tr>',

		// value: Date
		//		The currently selected Date, initially set to invalid date to indicate no selection.
		value: new Date(""),
		// TODO: for 2.0 make this a string (ISO format) rather than a Date

		// datePackage: String
		//		JavaScript namespace to find calendar routines.	 If unspecified, uses Gregorian calendar routines
		//		at dojo/date and dojo/date/locale.
		datePackage: "",
		//		TODO: for 2.0, replace datePackage with dateModule and dateLocalModule attributes specifying MIDs,
		//		or alternately just get rid of this completely and tell user to use module ID remapping
		//		via require

		// dayWidth: String
		//		How to represent the days of the week in the calendar header. See locale
		dayWidth: "narrow",

		// tabIndex: String
		//		Order fields are traversed when user hits the tab key
		tabIndex: "0",

		// currentFocus: Date
		//		Date object containing the currently focused date, or the date which would be focused
		//		if the calendar itself was focused.   Also indicates which year and month to display,
		//		i.e. the current "page" the calendar is on.
		currentFocus: new Date(),

		// Put the summary to the node with role=grid
		_setSummaryAttr: "gridNode",

		baseClass: "dijitCalendar dijitCalendarLite",

		_isValidDate: function(/*Date*/ value){
			// summary:
			//		Runs various tests on the value, checking that it's a valid date, rather
			//		than blank or NaN.
			// tags:
			//		private
			return value && !isNaN(value) && typeof value == "object" &&
				value.toString() != this.constructor.prototype.value.toString();
		},

		_getValueAttr: function(){
			// summary:
			//		Support get('value')

			// this.value is set to 1AM, but return midnight, local time for back-compat
			var storedVal = this._get("value");
			if(storedVal && !isNaN(storedVal)){
				var value = new this.dateClassObj(storedVal);
				value.setHours(0, 0, 0, 0);

				// If daylight savings pushes midnight to the previous date, fix the Date
				// object to point at 1am so it will represent the correct day. See #9366
				if(value.getDate() < storedVal.getDate()){
					value = this.dateModule.add(value, "hour", 1);
				}
				return value;
			}else{
				return null;
			}
		},

		_setValueAttr: function(/*Date|Number*/ value, /*Boolean*/ priorityChange){
			// summary:
			//		Support set("value", ...)
			// description:
			//		Set the current date and update the UI.  If the date is disabled, the value will
			//		not change, but the display will change to the corresponding month.
			// value:
			//		Either a Date or the number of seconds since 1970.
			// tags:
			//		protected
			if(typeof value == "string"){
				value = stamp.fromISOString(value);
			}
			value = this._patchDate(value);

			if(this._isValidDate(value) && !this.isDisabledDate(value, this.lang)){
				this._set("value", value);

				// Set focus cell to the new value.   Arguably this should only happen when there isn't a current
				// focus point.   This will also repopulate the grid to new month/year if necessary.
				this.set("currentFocus", value);

				// Mark the selected date
				this._markSelectedDates([value]);

				if(this._created && (priorityChange || typeof priorityChange == "undefined")){
					this.onChange(this.get('value'));
				}
			}else{
				// clear value, and mark all dates as unselected
				this._set("value", null);
				this._markSelectedDates([]);
			}
		},

		_patchDate: function(/*Date|Number*/ value){
			// summary:
			//		Convert Number into Date, or copy Date object.   Then, round to nearest day,
			//		setting to 1am to avoid issues when DST shift occurs at midnight, see #8521, #9366)
			if(value){
				value = new this.dateClassObj(value);
				value.setHours(1, 0, 0, 0);
			}
			return value;
		},

		_setText: function(node, text){
			// summary:
			//		This just sets the content of node to the specified text.
			//		Can't do "node.innerHTML=text" because of an IE bug w/tables, see #3434.
			// tags:
			//		private
			while(node.firstChild){
				node.removeChild(node.firstChild);
			}
			node.appendChild(node.ownerDocument.createTextNode(text));
		},

		_populateGrid: function(){
			// summary:
			//		Fills in the calendar grid with each day (1-31).
			//		Call this on creation, when moving to a new month.
			// tags:
			//		private

			var month = new this.dateClassObj(this.currentFocus);
			month.setDate(1);
			month = this._patchDate(month);	// needed if currentFocus is start or end of DST, see #17033

			var firstDay = month.getDay(),
				daysInMonth = this.dateModule.getDaysInMonth(month),
				daysInPreviousMonth = this.dateModule.getDaysInMonth(this.dateModule.add(month, "month", -1)),
				today = new this.dateClassObj(),
				dayOffset = cldrSupplemental.getFirstDayOfWeek(this.lang);
			if(dayOffset > firstDay){
				dayOffset -= 7;
			}

			// If they didn't provide a summary, change the default summary to match with the new month
			if(!this.summary){
				var monthNames = this.dateLocaleModule.getNames('months', 'wide', 'standAlone', this.lang, month)
				this.gridNode.setAttribute("summary", monthNames[month.getMonth()]);
			}

			// Mapping from date (as specified by number returned from Date.valueOf()) to corresponding <td>
			this._date2cell = {};

			// Iterate through dates in the calendar and fill in date numbers and style info
			array.forEach(this.dateCells, function(template, idx){
				var i = idx + dayOffset;
				var date = new this.dateClassObj(month),
					number, clazz = "dijitCalendar", adj = 0;

				if(i < firstDay){
					number = daysInPreviousMonth - firstDay + i + 1;
					adj = -1;
					clazz += "Previous";
				}else if(i >= (firstDay + daysInMonth)){
					number = i - firstDay - daysInMonth + 1;
					adj = 1;
					clazz += "Next";
				}else{
					number = i - firstDay + 1;
					clazz += "Current";
				}

				if(adj){
					date = this.dateModule.add(date, "month", adj);
				}
				date.setDate(number);

				if(!this.dateModule.compare(date, today, "date")){
					clazz = "dijitCalendarCurrentDate " + clazz;
				}

				if(this.isDisabledDate(date, this.lang)){
					clazz = "dijitCalendarDisabledDate " + clazz;
					template.setAttribute("aria-disabled", "true");
				}else{
					clazz = "dijitCalendarEnabledDate " + clazz;
					template.removeAttribute("aria-disabled");
					template.setAttribute("aria-selected", "false");
				}

				var clazz2 = this.getClassForDate(date, this.lang);
				if(clazz2){
					clazz = clazz2 + " " + clazz;
				}

				template.className = clazz + "Month dijitCalendarDateTemplate";

				// Each cell has an associated integer value representing it's date
				var dateVal = date.valueOf();
				this._date2cell[dateVal] = template;
				template.dijitDateValue = dateVal;

				// Set Date string (ex: "13").
				this._setText(this.dateLabels[idx], date.getDateLocalized ? date.getDateLocalized(this.lang) : date.getDate());
			}, this);
		},

		_populateControls: function(){
			// summary:
			//		Fill in localized month, and prev/current/next years
			// tags:
			//		protected

			var month = new this.dateClassObj(this.currentFocus);
			month.setDate(1);

			// set name of this month
			this.monthWidget.set("month", month);

			var y = month.getFullYear() - 1;
			var d = new this.dateClassObj();
			array.forEach(["previous", "current", "next"], function(name){
				d.setFullYear(y++);
				this._setText(this[name + "YearLabelNode"],
					this.dateLocaleModule.format(d, {selector: 'year', locale: this.lang}));
			}, this);
		},

		goToToday: function(){
			// summary:
			//		Sets calendar's value to today's date
			this.set('value', new this.dateClassObj());
		},

		constructor: function(params /*===== , srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree

			this.dateModule = params.datePackage ? lang.getObject(params.datePackage, false) : date;
			this.dateClassObj = this.dateModule.Date || Date;
			this.dateLocaleModule = params.datePackage ? lang.getObject(params.datePackage + ".locale", false) : locale;
		},

		_createMonthWidget: function(){
			// summary:
			//		Creates the drop down button that displays the current month and lets user pick a new one

			return CalendarLite._MonthWidget({
				id: this.id + "_mddb",
				lang: this.lang,
				dateLocaleModule: this.dateLocaleModule
			}, this.monthNode);
		},

		buildRendering: function(){
			// Markup for days of the week (referenced from template)
			var d = this.dowTemplateString,
				dayNames = this.dateLocaleModule.getNames('days', this.dayWidth, 'standAlone', this.lang),
				dayOffset = cldrSupplemental.getFirstDayOfWeek(this.lang);
			this.dayCellsHtml = string.substitute([d, d, d, d, d, d, d].join(""), {d: ""}, function(){
				return dayNames[dayOffset++ % 7];
			});

			// Markup for dates of the month (referenced from template), but without numbers filled in
			var r = string.substitute(this.weekTemplateString, {d: this.dateTemplateString});
			this.dateRowsHtml = [r, r, r, r, r, r].join("");

			// Instantiate from template.
			// dateCells and dateLabels arrays filled when _Templated parses my template.
			this.dateCells = [];
			this.dateLabels = [];
			this.inherited(arguments);

			dom.setSelectable(this.domNode, false);

			var dateObj = new this.dateClassObj(this.currentFocus);

			this.monthWidget = this._createMonthWidget();

			this.set('currentFocus', dateObj, false);	// draw the grid to the month specified by currentFocus
		},

		postCreate: function(){
			this.inherited(arguments);
			this._connectControls();
		},

		_connectControls: function(){
			// summary:
			//		Set up connects for increment/decrement of months/years
			// tags:
			//		protected

			var connect = lang.hitch(this, function(nodeProp, part, amount){
				this[nodeProp].dojoClick = true;
				return on(this[nodeProp], "click", lang.hitch(this, function(){
					this._setCurrentFocusAttr(this.dateModule.add(this.currentFocus, part, amount));
				}));
			});

			this.own(
				connect("incrementMonth", "month", 1),
				connect("decrementMonth", "month", -1),
				connect("nextYearLabelNode", "year", 1),
				connect("previousYearLabelNode", "year", -1)
			);
		},

		_setCurrentFocusAttr: function(/*Date*/ date, /*Boolean*/ forceFocus){
			// summary:
			//		If the calendar currently has focus, then focuses specified date,
			//		changing the currently displayed month/year if necessary.
			//		If the calendar doesn't have focus, updates currently
			//		displayed month/year, and sets the cell that will get focus
			//		when Calendar is focused.
			// forceFocus:
			//		If true, will focus() the cell even if calendar itself doesn't have focus

			var oldFocus = this.currentFocus,
				oldCell = this._getNodeByDate(oldFocus);
			date = this._patchDate(date);

			this._set("currentFocus", date);

			// If the focus is on a different month than the current calendar month, switch the displayed month.
			// Also will populate the grid initially, on Calendar creation.
			if(!this._date2cell || this.dateModule.difference(oldFocus, date, "month") != 0){
				this._populateGrid();
				this._populateControls();
				this._markSelectedDates([this.value]);
			}

			// set tabIndex=0 on new cell, and focus it (but only if Calendar itself is focused)
			var newCell = this._getNodeByDate(date);
			newCell.setAttribute("tabIndex", this.tabIndex);
			if(this.focused || forceFocus){
				newCell.focus();
			}

			// set tabIndex=-1 on old focusable cell
			if(oldCell && oldCell != newCell){
				if(has("webkit")){    // see #11064 about webkit bug
					oldCell.setAttribute("tabIndex", "-1");
				}else{
					oldCell.removeAttribute("tabIndex");
				}
			}
		},

		focus: function(){
			// summary:
			//		Focus the calendar by focusing one of the calendar cells
			this._setCurrentFocusAttr(this.currentFocus, true);
		},

		_onDayClick: function(/*Event*/ evt){
			// summary:
			//		Handler for day clicks, selects the date if appropriate
			// tags:
			//		protected
			evt.stopPropagation();
			evt.preventDefault();
			for(var node = evt.target; node && !node.dijitDateValue; node = node.parentNode){
				;
			}
			if(node && !domClass.contains(node, "dijitCalendarDisabledDate")){
				this.set('value', node.dijitDateValue);
			}
		},

		_getNodeByDate: function(/*Date*/ value){
			// summary:
			//		Returns the cell corresponding to the date, or null if the date is not within the currently
			//		displayed month.
			value = this._patchDate(value);
			return value && this._date2cell ? this._date2cell[value.valueOf()] : null;
		},

		_markSelectedDates: function(/*Date[]*/ dates){
			// summary:
			//		Marks the specified cells as selected, and clears cells previously marked as selected.
			//		For CalendarLite at most one cell is selected at any point, but this allows an array
			//		for easy subclassing.

			// Function to mark a cell as selected or unselected
			function mark(/*Boolean*/ selected, /*DomNode*/ cell){
				domClass.toggle(cell, "dijitCalendarSelectedDate", selected);
				cell.setAttribute("aria-selected", selected ? "true" : "false");
			}

			// Clear previously selected cells.
			array.forEach(this._selectedCells || [], lang.partial(mark, false));

			// Mark newly selected cells.  Ignore dates outside the currently displayed month.
			this._selectedCells = array.filter(array.map(dates, this._getNodeByDate, this), function(n){
				return n;
			});
			array.forEach(this._selectedCells, lang.partial(mark, true));
		},

		onChange: function(/*Date*/ /*===== date =====*/){
			// summary:
			//		Called only when the selected date has changed
		},

		isDisabledDate: function(/*===== dateObject, locale =====*/){
			// summary:
			//		May be overridden to disable certain dates in the calendar e.g. `isDisabledDate=dojo.date.locale.isWeekend`
			// dateObject: Date
			// locale: String?
			// tags:
			//		extension
			/*=====
			 return false; // Boolean
			 =====*/
		},

		getClassForDate: function(/*===== dateObject, locale =====*/){
			// summary:
			//		May be overridden to return CSS classes to associate with the date entry for the given dateObject,
			//		for example to indicate a holiday in specified locale.
			// dateObject: Date
			// locale: String?
			// tags:
			//		extension

			/*=====
			 return ""; // String
			 =====*/
		}
	});

	CalendarLite._MonthWidget = declare("dijit.CalendarLite._MonthWidget", _WidgetBase, {
		// summary:
		//		Displays name of current month padded to the width of the month
		//		w/the longest name, so that changing months doesn't change width.
		//
		//		Create as:
		// |	new Calendar._MonthWidget({
		// |			lang: ...,
		// |			dateLocaleModule: ...
		// |		})

		_setMonthAttr: function(month){
			// summary:
			//		Set the current month to display as a label
			var monthNames = this.dateLocaleModule.getNames('months', 'wide', 'standAlone', this.lang, month),
				spacer =
					(has("ie") == 6 ? "" : "<div class='dijitSpacer'>" +
						array.map(monthNames,function(s){
							return "<div>" + s + "</div>";
						}).join("") + "</div>");

			// Set name of current month and also fill in spacer element with all the month names
			// (invisible) so that the maximum width will affect layout.   But not on IE6 because then
			// the center <TH> overlaps the right <TH> (due to a browser bug).
			this.domNode.innerHTML =
				spacer +
					"<div class='dijitCalendarMonthLabel dijitCalendarCurrentMonthLabel'>" +
					monthNames[month.getMonth()] + "</div>";
		}
	});

	return CalendarLite;
});

},
'dijit/form/DropDownButton':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // hitch
	"dojo/query", // query
	"../registry", // registry.byNode
	"../popup", // dijit.popup2.hide
	"./Button",
	"../_Container",
	"../_HasDropDown",
	"dojo/text!./templates/DropDownButton.html",
	"../a11yclick"	// template uses ondijitclick
], function(declare, lang, query, registry, popup, Button, _Container, _HasDropDown, template){

	// module:
	//		dijit/form/DropDownButton

	return declare("dijit.form.DropDownButton", [Button, _Container, _HasDropDown], {
		// summary:
		//		A button with a drop down
		//
		// example:
		// |	<button data-dojo-type="dijit/form/DropDownButton">
		// |		Hello world
		// |		<div data-dojo-type="dijit/Menu">...</div>
		// |	</button>
		//
		// example:
		// |	var button1 = new DropDownButton({ label: "hi", dropDown: new dijit.Menu(...) });
		// |	win.body().appendChild(button1);
		//

		baseClass: "dijitDropDownButton",

		templateString: template,

		_fillContent: function(){
			// Overrides Button._fillContent().
			//
			// My inner HTML contains both the button contents and a drop down widget, like
			// <DropDownButton>  <span>push me</span>  <Menu> ... </Menu> </DropDownButton>
			// The first node is assumed to be the button content. The widget is the popup.

			if(this.srcNodeRef){ // programatically created buttons might not define srcNodeRef
				//FIXME: figure out how to filter out the widget and use all remaining nodes as button
				//	content, not just nodes[0]
				var nodes = query("*", this.srcNodeRef);
				this.inherited(arguments, [nodes[0]]);

				// save pointer to srcNode so we can grab the drop down widget after it's instantiated
				this.dropDownContainer = this.srcNodeRef;
			}
		},

		startup: function(){
			if(this._started){
				return;
			}

			// the child widget from srcNodeRef is the dropdown widget.  Insert it in the page DOM,
			// make it invisible, and store a reference to pass to the popup code.
			if(!this.dropDown && this.dropDownContainer){
				var dropDownNode = query("[widgetId]", this.dropDownContainer)[0];
				if(dropDownNode){
					this.dropDown = registry.byNode(dropDownNode);
				}
				delete this.dropDownContainer;
			}
			if(this.dropDown){
				popup.hide(this.dropDown);
			}

			this.inherited(arguments);
		},

		isLoaded: function(){
			// Returns whether or not we are loaded - if our dropdown has an href,
			// then we want to check that.
			var dropDown = this.dropDown;
			return (!!dropDown && (!dropDown.href || dropDown.isLoaded));
		},

		loadDropDown: function(/*Function*/ callback){
			// Default implementation assumes that drop down already exists,
			// but hasn't loaded it's data (ex: ContentPane w/href).
			// App must override if the drop down is lazy-created.
			var dropDown = this.dropDown;
			var handler = dropDown.on("load", lang.hitch(this, function(){
				handler.remove();
				callback();
			}));
			dropDown.refresh();		// tell it to load
		},

		isFocusable: function(){
			// Overridden so that focus is handled by the _HasDropDown mixin, not by
			// the _FormWidget mixin.
			return this.inherited(arguments) && !this._mouseDown;
		}
	});
});

},
'dijit/popup':function(){
define([
	"dojo/_base/array", // array.forEach array.some
	"dojo/aspect",
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.isDescendant
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-construct", // domConstruct.create domConstruct.destroy
	"dojo/dom-geometry", // domGeometry.isBodyLtr
	"dojo/dom-style", // domStyle.set
	"dojo/has", // has("config-bgIframe")
	"dojo/keys",
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"./place",
	"./BackgroundIframe",
	"./Viewport",
	"./main"    // dijit (defining dijit.popup to match API doc)
], function(array, aspect, declare, dom, domAttr, domConstruct, domGeometry, domStyle, has, keys, lang, on,
			place, BackgroundIframe, Viewport, dijit){

	// module:
	//		dijit/popup

	/*=====
	 var __OpenArgs = {
		 // popup: Widget
		 //		widget to display
		 // parent: Widget
		 //		the button etc. that is displaying this popup
		 // around: DomNode
		 //		DOM node (typically a button); place popup relative to this node.  (Specify this *or* "x" and "y" parameters.)
		 // x: Integer
		 //		Absolute horizontal position (in pixels) to place node at.  (Specify this *or* "around" parameter.)
		 // y: Integer
		 //		Absolute vertical position (in pixels) to place node at.  (Specify this *or* "around" parameter.)
		 // orient: Object|String
		 //		When the around parameter is specified, orient should be a list of positions to try, ex:
		 //	|	[ "below", "above" ]
		 //		For backwards compatibility it can also be an (ordered) hash of tuples of the form
		 //		(around-node-corner, popup-node-corner), ex:
		 //	|	{ "BL": "TL", "TL": "BL" }
		 //		where BL means "bottom left" and "TL" means "top left", etc.
		 //
		 //		dijit/popup.open() tries to position the popup according to each specified position, in order,
		 //		until the popup appears fully within the viewport.
		 //
		 //		The default value is ["below", "above"]
		 //
		 //		When an (x,y) position is specified rather than an around node, orient is either
		 //		"R" or "L".  R (for right) means that it tries to put the popup to the right of the mouse,
		 //		specifically positioning the popup's top-right corner at the mouse position, and if that doesn't
		 //		fit in the viewport, then it tries, in order, the bottom-right corner, the top left corner,
		 //		and the top-right corner.
		 // onCancel: Function
		 //		callback when user has canceled the popup by:
		 //
		 //		1. hitting ESC or
		 //		2. by using the popup widget's proprietary cancel mechanism (like a cancel button in a dialog);
		 //		   i.e. whenever popupWidget.onCancel() is called, args.onCancel is called
		 // onClose: Function
		 //		callback whenever this popup is closed
		 // onExecute: Function
		 //		callback when user "executed" on the popup/sub-popup by selecting a menu choice, etc. (top menu only)
		 // padding: place.__Position
		 //		adding a buffer around the opening position. This is only useful when around is not set.
		 // maxHeight: Integer
		 //		The max height for the popup.  Any popup taller than this will have scrollbars.
		 //		Set to Infinity for no max height.  Default is to limit height to available space in viewport,
		 //		above or below the aroundNode or specified x/y position.
	 };
	 =====*/

	function destroyWrapper(){
		// summary:
		//		Function to destroy wrapper when popup widget is destroyed.
		//		Left in this scope to avoid memory leak on IE8 on refresh page, see #15206.
		if(this._popupWrapper){
			domConstruct.destroy(this._popupWrapper);
			delete this._popupWrapper;
		}
	}

	var PopupManager = declare(null, {
		// summary:
		//		Used to show drop downs (ex: the select list of a ComboBox)
		//		or popups (ex: right-click context menus).

		// _stack: dijit/_WidgetBase[]
		//		Stack of currently popped up widgets.
		//		(someone opened _stack[0], and then it opened _stack[1], etc.)
		_stack: [],

		// _beginZIndex: Number
		//		Z-index of the first popup.   (If first popup opens other
		//		popups they get a higher z-index.)
		_beginZIndex: 1000,

		_idGen: 1,

		_repositionAll: function(){
			// summary:
			//		If screen has been scrolled, reposition all the popups in the stack.
			//		Then set timer to check again later.

			if(this._firstAroundNode){	// guard for when clearTimeout() on IE doesn't work
				var oldPos = this._firstAroundPosition,
					newPos = domGeometry.position(this._firstAroundNode, true),
					dx = newPos.x - oldPos.x,
					dy = newPos.y - oldPos.y;

				if(dx || dy){
					this._firstAroundPosition = newPos;
					for(var i = 0; i < this._stack.length; i++){
						var style = this._stack[i].wrapper.style;
						style.top = (parseFloat(style.top) + dy) + "px";
						if(style.right == "auto"){
							style.left = (parseFloat(style.left) + dx) + "px";
						}else{
							style.right = (parseFloat(style.right) - dx) + "px";
						}
					}
				}

				this._aroundMoveListener = setTimeout(lang.hitch(this, "_repositionAll"), dx || dy ? 10 : 50);
			}
		},

		_createWrapper: function(/*Widget*/ widget){
			// summary:
			//		Initialization for widgets that will be used as popups.
			//		Puts widget inside a wrapper DIV (if not already in one),
			//		and returns pointer to that wrapper DIV.

			var wrapper = widget._popupWrapper,
				node = widget.domNode;

			if(!wrapper){
				// Create wrapper <div> for when this widget [in the future] will be used as a popup.
				// This is done early because of IE bugs where creating/moving DOM nodes causes focus
				// to go wonky, see tests/robot/Toolbar.html to reproduce
				wrapper = domConstruct.create("div", {
					"class": "dijitPopup",
					style: { display: "none"},
					role: "region",
					"aria-label": widget["aria-label"] || widget.label || widget.name || widget.id
				}, widget.ownerDocumentBody);
				wrapper.appendChild(node);

				var s = node.style;
				s.display = "";
				s.visibility = "";
				s.position = "";
				s.top = "0px";

				widget._popupWrapper = wrapper;
				aspect.after(widget, "destroy", destroyWrapper, true);

				// Workaround iOS problem where clicking a Menu can focus an <input> (or click a button) behind it.
				// Need to be careful though that you can still focus <input>'s and click <button>'s in a TooltipDialog.
				// Also, be careful not to break (native) scrolling of dropdown like ComboBox's options list.
				if("ontouchend" in document) {
					on(wrapper, "touchend", function (evt){
						if(!/^(input|button|textarea)$/i.test(evt.target.tagName)) {
							evt.preventDefault();
						}
					});
				}
			}

			return wrapper;
		},

		moveOffScreen: function(/*Widget*/ widget){
			// summary:
			//		Moves the popup widget off-screen.
			//		Do not use this method to hide popups when not in use, because
			//		that will create an accessibility issue: the offscreen popup is
			//		still in the tabbing order.

			// Create wrapper if not already there
			var wrapper = this._createWrapper(widget);

			// Besides setting visibility:hidden, move it out of the viewport, see #5776, #10111, #13604
			var ltr = domGeometry.isBodyLtr(widget.ownerDocument),
				style = {
					visibility: "hidden",
					top: "-9999px",
					display: ""
				};
			style[ltr ? "left" : "right"] = "-9999px";
			style[ltr ? "right" : "left"] = "auto";
			domStyle.set(wrapper, style);

			return wrapper;
		},

		hide: function(/*Widget*/ widget){
			// summary:
			//		Hide this popup widget (until it is ready to be shown).
			//		Initialization for widgets that will be used as popups
			//
			//		Also puts widget inside a wrapper DIV (if not already in one)
			//
			//		If popup widget needs to layout it should
			//		do so when it is made visible, and popup._onShow() is called.

			// Create wrapper if not already there
			var wrapper = this._createWrapper(widget);

			domStyle.set(wrapper, {
				display: "none",
				height: "auto",		// Open may have limited the height to fit in the viewport
				overflow: "visible",
				border: ""			// Open() may have moved border from popup to wrapper.
			});

			// Open() may have moved border from popup to wrapper.  Move it back.
			var node = widget.domNode;
			if("_originalStyle" in node){
				node.style.cssText = node._originalStyle;
			}
		},

		getTopPopup: function(){
			// summary:
			//		Compute the closest ancestor popup that's *not* a child of another popup.
			//		Ex: For a TooltipDialog with a button that spawns a tree of menus, find the popup of the button.
			var stack = this._stack;
			for(var pi = stack.length - 1; pi > 0 && stack[pi].parent === stack[pi - 1].widget; pi--){
				/* do nothing, just trying to get right value for pi */
			}
			return stack[pi];
		},

		open: function(/*__OpenArgs*/ args){
			// summary:
			//		Popup the widget at the specified position
			//
			// example:
			//		opening at the mouse position
			//		|		popup.open({popup: menuWidget, x: evt.pageX, y: evt.pageY});
			//
			// example:
			//		opening the widget as a dropdown
			//		|		popup.open({parent: this, popup: menuWidget, around: this.domNode, onClose: function(){...}});
			//
			//		Note that whatever widget called dijit/popup.open() should also listen to its own _onBlur callback
			//		(fired from _base/focus.js) to know that focus has moved somewhere else and thus the popup should be closed.

			var stack = this._stack,
				widget = args.popup,
				node = widget.domNode,
				orient = args.orient || ["below", "below-alt", "above", "above-alt"],
				ltr = args.parent ? args.parent.isLeftToRight() : domGeometry.isBodyLtr(widget.ownerDocument),
				around = args.around,
				id = (args.around && args.around.id) ? (args.around.id + "_dropdown") : ("popup_" + this._idGen++);

			// If we are opening a new popup that isn't a child of a currently opened popup, then
			// close currently opened popup(s).   This should happen automatically when the old popups
			// gets the _onBlur() event, except that the _onBlur() event isn't reliable on IE, see [22198].
			while(stack.length && (!args.parent || !dom.isDescendant(args.parent.domNode, stack[stack.length - 1].widget.domNode))){
				this.close(stack[stack.length - 1].widget);
			}

			// Get pointer to popup wrapper, and create wrapper if it doesn't exist.  Remove display:none (but keep
			// off screen) so we can do sizing calculations.
			var wrapper = this.moveOffScreen(widget);

			if(widget.startup && !widget._started){
				widget.startup(); // this has to be done after being added to the DOM
			}

			// Limit height to space available in viewport either above or below aroundNode (whichever side has more
			// room), adding scrollbar if necessary. Can't add scrollbar to widget because it may be a <table> (ex:
			// dijit/Menu), so add to wrapper, and then move popup's border to wrapper so scroll bar inside border.
			var maxHeight, popupSize = domGeometry.position(node);
			if("maxHeight" in args && args.maxHeight != -1){
				maxHeight = args.maxHeight || Infinity;	// map 0 --> infinity for back-compat of _HasDropDown.maxHeight
			}else{
				var viewport = Viewport.getEffectiveBox(this.ownerDocument),
					aroundPos = around ? domGeometry.position(around, false) : {y: args.y - (args.padding||0), h: (args.padding||0) * 2};
				maxHeight = Math.floor(Math.max(aroundPos.y, viewport.h - (aroundPos.y + aroundPos.h)));
			}
			if(popupSize.h > maxHeight){
				// Get style of popup's border.  Unfortunately domStyle.get(node, "border") doesn't work on FF or IE,
				// and domStyle.get(node, "borderColor") etc. doesn't work on FF, so need to use fully qualified names.
				var cs = domStyle.getComputedStyle(node),
					borderStyle = cs.borderLeftWidth + " " + cs.borderLeftStyle + " " + cs.borderLeftColor;
				domStyle.set(wrapper, {
					overflowY: "scroll",
					height: maxHeight + "px",
					border: borderStyle	// so scrollbar is inside border
				});
				node._originalStyle = node.style.cssText;
				node.style.border = "none";
			}

			domAttr.set(wrapper, {
				id: id,
				style: {
					zIndex: this._beginZIndex + stack.length
				},
				"class": "dijitPopup " + (widget.baseClass || widget["class"] || "").split(" ")[0] + "Popup",
				dijitPopupParent: args.parent ? args.parent.id : ""
			});

			if(stack.length == 0 && around){
				// First element on stack. Save position of aroundNode and setup listener for changes to that position.
				this._firstAroundNode = around;
				this._firstAroundPosition = domGeometry.position(around, true);
				this._aroundMoveListener = setTimeout(lang.hitch(this, "_repositionAll"), 50);
			}

			if(has("config-bgIframe") && !widget.bgIframe){
				// setting widget.bgIframe triggers cleanup in _WidgetBase.destroyRendering()
				widget.bgIframe = new BackgroundIframe(wrapper);
			}

			// position the wrapper node and make it visible
			var layoutFunc = widget.orient ? lang.hitch(widget, "orient") : null,
				best = around ?
					place.around(wrapper, around, orient, ltr, layoutFunc) :
					place.at(wrapper, args, orient == 'R' ? ['TR', 'BR', 'TL', 'BL'] : ['TL', 'BL', 'TR', 'BR'], args.padding,
						layoutFunc);

			wrapper.style.visibility = "visible";
			node.style.visibility = "visible";	// counteract effects from _HasDropDown

			var handlers = [];

			// provide default escape and tab key handling
			// (this will work for any widget, not just menu)
			handlers.push(on(wrapper, "keydown", lang.hitch(this, function(evt){
				if(evt.keyCode == keys.ESCAPE && args.onCancel){
					evt.stopPropagation();
					evt.preventDefault();
					args.onCancel();
				}else if(evt.keyCode == keys.TAB){
					evt.stopPropagation();
					evt.preventDefault();
					var topPopup = this.getTopPopup();
					if(topPopup && topPopup.onCancel){
						topPopup.onCancel();
					}
				}
			})));

			// watch for cancel/execute events on the popup and notify the caller
			// (for a menu, "execute" means clicking an item)
			if(widget.onCancel && args.onCancel){
				handlers.push(widget.on("cancel", args.onCancel));
			}

			handlers.push(widget.on(widget.onExecute ? "execute" : "change", lang.hitch(this, function(){
				var topPopup = this.getTopPopup();
				if(topPopup && topPopup.onExecute){
					topPopup.onExecute();
				}
			})));

			stack.push({
				widget: widget,
				wrapper: wrapper,
				parent: args.parent,
				onExecute: args.onExecute,
				onCancel: args.onCancel,
				onClose: args.onClose,
				handlers: handlers
			});

			if(widget.onOpen){
				// TODO: in 2.0 standardize onShow() (used by StackContainer) and onOpen() (used here)
				widget.onOpen(best);
			}

			return best;
		},

		close: function(/*Widget?*/ popup){
			// summary:
			//		Close specified popup and any popups that it parented.
			//		If no popup is specified, closes all popups.

			var stack = this._stack;

			// Basically work backwards from the top of the stack closing popups
			// until we hit the specified popup, but IIRC there was some issue where closing
			// a popup would cause others to close too.  Thus if we are trying to close B in [A,B,C]
			// closing C might close B indirectly and then the while() condition will run where stack==[A]...
			// so the while condition is constructed defensively.
			while((popup && array.some(stack, function(elem){
				return elem.widget == popup;
			})) ||
				(!popup && stack.length)){
				var top = stack.pop(),
					widget = top.widget,
					onClose = top.onClose;

				if (widget.bgIframe) {
					// push the iframe back onto the stack.
					widget.bgIframe.destroy();
					delete widget.bgIframe;
				}

				if(widget.onClose){
					// TODO: in 2.0 standardize onHide() (used by StackContainer) and onClose() (used here).
					// Actually, StackContainer also calls onClose(), but to mean that the pane is being deleted
					// (i.e. that the TabContainer's tab's [x] icon was clicked)
					widget.onClose();
				}

				var h;
				while(h = top.handlers.pop()){
					h.remove();
				}

				// Hide the widget and it's wrapper unless it has already been destroyed in above onClose() etc.
				if(widget && widget.domNode){
					this.hide(widget);
				}

				if(onClose){
					onClose();
				}
			}

			if(stack.length == 0 && this._aroundMoveListener){
				clearTimeout(this._aroundMoveListener);
				this._firstAroundNode = this._firstAroundPosition = this._aroundMoveListener = null;
			}
		}
	});

	return (dijit.popup = new PopupManager());
});

},
'dijit/_HasDropDown':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/_base/Deferred",
	"dojo/dom", // dom.isDescendant
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-class", // domClass.add domClass.contains domClass.remove
	"dojo/dom-geometry", // domGeometry.marginBox domGeometry.position
	"dojo/dom-style", // domStyle.set
	"dojo/has", // has("touch")
	"dojo/keys", // keys.DOWN_ARROW keys.ENTER keys.ESCAPE
	"dojo/_base/lang", // lang.hitch lang.isFunction
	"dojo/on",
	"dojo/touch",
	"./registry", // registry.byNode()
	"./focus",
	"./popup",
	"./_FocusMixin"
], function(declare, Deferred, dom, domAttr, domClass, domGeometry, domStyle, has, keys, lang, on, touch,
			registry, focus, popup, _FocusMixin){


	// module:
	//		dijit/_HasDropDown

	return declare("dijit._HasDropDown", _FocusMixin, {
		// summary:
		//		Mixin for widgets that need drop down ability.

		// _buttonNode: [protected] DomNode
		//		The button/icon/node to click to display the drop down.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then either focusNode or domNode (if focusNode is also missing) will be used.
		_buttonNode: null,

		// _arrowWrapperNode: [protected] DomNode
		//		Will set CSS class dijitUpArrow, dijitDownArrow, dijitRightArrow etc. on this node depending
		//		on where the drop down is set to be positioned.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then _buttonNode will be used.
		_arrowWrapperNode: null,

		// _popupStateNode: [protected] DomNode
		//		The node to set the aria-expanded class on.
		//		Also sets popupActive class but that will be removed in 2.0.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then focusNode or _buttonNode (if focusNode is missing) will be used.
		_popupStateNode: null,

		// _aroundNode: [protected] DomNode
		//		The node to display the popup around.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then domNode will be used.
		_aroundNode: null,

		// dropDown: [protected] Widget
		//		The widget to display as a popup.  This widget *must* be
		//		defined before the startup function is called.
		dropDown: null,

		// autoWidth: [protected] Boolean
		//		Set to true to make the drop down at least as wide as this
		//		widget.  Set to false if the drop down should just be its
		//		default width.
		autoWidth: true,

		// forceWidth: [protected] Boolean
		//		Set to true to make the drop down exactly as wide as this
		//		widget.  Overrides autoWidth.
		forceWidth: false,

		// maxHeight: [protected] Integer
		//		The max height for our dropdown.
		//		Any dropdown taller than this will have scrollbars.
		//		Set to 0 for no max height, or -1 to limit height to available space in viewport
		maxHeight: -1,

		// dropDownPosition: [const] String[]
		//		This variable controls the position of the drop down.
		//		It's an array of strings with the following values:
		//
		//		- before: places drop down to the left of the target node/widget, or to the right in
		//		  the case of RTL scripts like Hebrew and Arabic
		//		- after: places drop down to the right of the target node/widget, or to the left in
		//		  the case of RTL scripts like Hebrew and Arabic
		//		- above: drop down goes above target node
		//		- below: drop down goes below target node
		//
		//		The list is positions is tried, in order, until a position is found where the drop down fits
		//		within the viewport.
		//
		dropDownPosition: ["below", "above"],

		// _stopClickEvents: Boolean
		//		When set to false, the click events will not be stopped, in
		//		case you want to use them in your subclass
		_stopClickEvents: true,

		_onDropDownMouseDown: function(/*Event*/ e){
			// summary:
			//		Callback when the user mousedown/touchstart on the arrow icon.

			if(this.disabled || this.readOnly){
				return;
			}

			// Prevent default to stop things like text selection, but don't stop propagation, so that:
			//		1. TimeTextBox etc. can focus the <input> on mousedown
			//		2. dropDownButtonActive class applied by _CssStateMixin (on button depress)
			//		3. user defined onMouseDown handler fires
			//
			// Also, don't call preventDefault() on MSPointerDown event (on IE10) because that prevents the button
			// from getting focus, and then the focus manager doesn't know what's going on (#17262)
			if(e.type != "MSPointerDown" && e.type != "pointerdown"){
				e.preventDefault();
			}

			this.own(on.once(this.ownerDocument, touch.release, lang.hitch(this, "_onDropDownMouseUp")));

			this.toggleDropDown();
		},

		_onDropDownMouseUp: function(/*Event?*/ e){
			// summary:
			//		Callback on mouseup/touchend after mousedown/touchstart on the arrow icon.
			//		Note that this function is called regardless of what node the event occurred on (but only after
			//		a mousedown/touchstart on the arrow).
			//
			//		If the drop down is a simple menu and the cursor is over the menu, we execute it, otherwise, we focus our
			//		drop down widget.  If the event is missing, then we are not
			//		a mouseup event.
			//
			//		This is useful for the common mouse movement pattern
			//		with native browser `<select>` nodes:
			//
			//		1. mouse down on the select node (probably on the arrow)
			//		2. move mouse to a menu item while holding down the mouse button
			//		3. mouse up.  this selects the menu item as though the user had clicked it.

			var dropDown = this.dropDown, overMenu = false;

			if(e && this._opened){
				// This code deals with the corner-case when the drop down covers the original widget,
				// because it's so large.  In that case mouse-up shouldn't select a value from the menu.
				// Find out if our target is somewhere in our dropdown widget,
				// but not over our _buttonNode (the clickable node)
				var c = domGeometry.position(this._buttonNode, true);
				if(!(e.pageX >= c.x && e.pageX <= c.x + c.w) || !(e.pageY >= c.y && e.pageY <= c.y + c.h)){
					var t = e.target;
					while(t && !overMenu){
						if(domClass.contains(t, "dijitPopup")){
							overMenu = true;
						}else{
							t = t.parentNode;
						}
					}
					if(overMenu){
						t = e.target;
						if(dropDown.onItemClick){
							var menuItem;
							while(t && !(menuItem = registry.byNode(t))){
								t = t.parentNode;
							}
							if(menuItem && menuItem.onClick && menuItem.getParent){
								menuItem.getParent().onItemClick(menuItem, e);
							}
						}
						return;
					}
				}
			}
			if(this._opened){
				// Focus the dropdown widget unless it's a menu (in which case autoFocus is set to false).
				// Even if it's a menu, we need to focus it if this is a fake mouse event caused by the user typing
				// SPACE/ENTER while using JAWS.  Jaws converts the SPACE/ENTER key into mousedown/mouseup events.
				// If this.hovering is false then it's presumably actually a keyboard event.
				if(dropDown.focus && (dropDown.autoFocus !== false || (e.type == "mouseup" && !this.hovering))){
					// Do it on a delay so that we don't steal back focus from the dropdown.
					this._focusDropDownTimer = this.defer(function(){
						dropDown.focus();
						delete this._focusDropDownTimer;
					});
				}
			}else{
				// The drop down arrow icon probably can't receive focus, but widget itself should get focus.
				// defer() needed to make it work on IE (test DateTextBox)
				if(this.focus){
					this.defer("focus");
				}
			}
		},

		_onDropDownClick: function(/*Event*/ e){
			// The drop down was already opened on mousedown/keydown; just need to stop the event
			if(this._stopClickEvents){
				e.stopPropagation();
				e.preventDefault();
			}
		},

		buildRendering: function(){
			this.inherited(arguments);

			this._buttonNode = this._buttonNode || this.focusNode || this.domNode;
			this._popupStateNode = this._popupStateNode || this.focusNode || this._buttonNode;

			// Add a class to the "dijitDownArrowButton" type class to _buttonNode so theme can set direction of arrow
			// based on where drop down will normally appear
			var defaultPos = {
				"after": this.isLeftToRight() ? "Right" : "Left",
				"before": this.isLeftToRight() ? "Left" : "Right",
				"above": "Up",
				"below": "Down",
				"left": "Left",
				"right": "Right"
			}[this.dropDownPosition[0]] || this.dropDownPosition[0] || "Down";
			domClass.add(this._arrowWrapperNode || this._buttonNode, "dijit" + defaultPos + "ArrowButton");
		},

		postCreate: function(){
			// summary:
			//		set up nodes and connect our mouse and keyboard events

			this.inherited(arguments);

			var keyboardEventNode = this.focusNode || this.domNode;
			this.own(
				on(this._buttonNode, touch.press, lang.hitch(this, "_onDropDownMouseDown")),
				on(this._buttonNode, "click", lang.hitch(this, "_onDropDownClick")),
				on(keyboardEventNode, "keydown", lang.hitch(this, "_onKey")),
				on(keyboardEventNode, "keyup", lang.hitch(this, "_onKeyUp"))
			);
		},

		destroy: function(){
			// If dropdown is open, close it, to avoid leaving dijit/focus in a strange state.
			// Put focus back on me to avoid the focused node getting destroyed, which flummoxes IE.
			if(this._opened){
				this.closeDropDown(true);
			}

			if(this.dropDown){
				// Destroy the drop down, unless it's already been destroyed.  This can happen because
				// the drop down is a direct child of <body> even though it's logically my child.
				if(!this.dropDown._destroyed){
					this.dropDown.destroyRecursive();
				}
				delete this.dropDown;
			}
			this.inherited(arguments);
		},

		_onKey: function(/*Event*/ e){
			// summary:
			//		Callback when the user presses a key while focused on the button node

			if(this.disabled || this.readOnly){
				return;
			}
			var d = this.dropDown, target = e.target;
			if(d && this._opened && d.handleKey){
				if(d.handleKey(e) === false){
					/* false return code means that the drop down handled the key */
					e.stopPropagation();
					e.preventDefault();
					return;
				}
			}
			if(d && this._opened && e.keyCode == keys.ESCAPE){
				this.closeDropDown();
				e.stopPropagation();
				e.preventDefault();
			}else if(!this._opened &&
				(e.keyCode == keys.DOWN_ARROW ||
					// ignore unmodified SPACE if _KeyNavMixin has active searching in progress
					( (e.keyCode == keys.ENTER || (e.keyCode == keys.SPACE && (!this._searchTimer || (e.ctrlKey || e.altKey || e.metaKey)))) &&
						//ignore enter and space if the event is for a text input
						((target.tagName || "").toLowerCase() !== 'input' ||
							(target.type && target.type.toLowerCase() !== 'text'))))){
				// Toggle the drop down, but wait until keyup so that the drop down doesn't
				// get a stray keyup event, or in the case of key-repeat (because user held
				// down key for too long), stray keydown events
				this._toggleOnKeyUp = true;
				e.stopPropagation();
				e.preventDefault();
			}
		},

		_onKeyUp: function(){
			if(this._toggleOnKeyUp){
				delete this._toggleOnKeyUp;
				this.toggleDropDown();
				var d = this.dropDown;	// drop down may not exist until toggleDropDown() call
				if(d && d.focus){
					this.defer(lang.hitch(d, "focus"), 1);
				}
			}
		},

		_onBlur: function(){
			// summary:
			//		Called magically when focus has shifted away from this widget and it's dropdown

			// Close dropdown but don't focus my <input>.  User may have focused somewhere else (ex: clicked another
			// input), and even if they just clicked a blank area of the screen, focusing my <input> will unwantedly
			// popup the keyboard on mobile.
			this.closeDropDown(false);

			this.inherited(arguments);
		},

		isLoaded: function(){
			// summary:
			//		Returns true if the dropdown exists and it's data is loaded.  This can
			//		be overridden in order to force a call to loadDropDown().
			// tags:
			//		protected

			return true;
		},

		loadDropDown: function(/*Function*/ loadCallback){
			// summary:
			//		Creates the drop down if it doesn't exist, loads the data
			//		if there's an href and it hasn't been loaded yet, and then calls
			//		the given callback.
			// tags:
			//		protected

			// TODO: for 2.0, change API to return a Deferred, instead of calling loadCallback?
			loadCallback();
		},

		loadAndOpenDropDown: function(){
			// summary:
			//		Creates the drop down if it doesn't exist, loads the data
			//		if there's an href and it hasn't been loaded yet, and
			//		then opens the drop down.  This is basically a callback when the
			//		user presses the down arrow button to open the drop down.
			// returns: Deferred
			//		Deferred for the drop down widget that
			//		fires when drop down is created and loaded
			// tags:
			//		protected
			var d = new Deferred(),
				afterLoad = lang.hitch(this, function(){
					this.openDropDown();
					d.resolve(this.dropDown);
				});
			if(!this.isLoaded()){
				this.loadDropDown(afterLoad);
			}else{
				afterLoad();
			}
			return d;
		},

		toggleDropDown: function(){
			// summary:
			//		Callback when the user presses the down arrow button or presses
			//		the down arrow key to open/close the drop down.
			//		Toggle the drop-down widget; if it is up, close it, if not, open it
			// tags:
			//		protected

			if(this.disabled || this.readOnly){
				return;
			}
			if(!this._opened){
				this.loadAndOpenDropDown();
			}else{
				this.closeDropDown(true);	// refocus button to avoid hiding node w/focus
			}
		},

		openDropDown: function(){
			// summary:
			//		Opens the dropdown for this widget.   To be called only when this.dropDown
			//		has been created and is ready to display (ie, it's data is loaded).
			// returns:
			//		return value of dijit/popup.open()
			// tags:
			//		protected

			var dropDown = this.dropDown,
				ddNode = dropDown.domNode,
				aroundNode = this._aroundNode || this.domNode,
				self = this;

			var retVal = popup.open({
				parent: this,
				popup: dropDown,
				around: aroundNode,
				orient: this.dropDownPosition,
				maxHeight: this.maxHeight,
				onExecute: function(){
					self.closeDropDown(true);
				},
				onCancel: function(){
					self.closeDropDown(true);
				},
				onClose: function(){
					domAttr.set(self._popupStateNode, "popupActive", false);
					domClass.remove(self._popupStateNode, "dijitHasDropDownOpen");
					self._set("_opened", false);	// use set() because _CssStateMixin is watching
				}
			});

			// Set width of drop down if necessary, so that dropdown width + width of scrollbar (from popup wrapper)
			// matches width of aroundNode
			if(this.forceWidth || (this.autoWidth && aroundNode.offsetWidth > dropDown._popupWrapper.offsetWidth)){
				var widthAdjust = aroundNode.offsetWidth - dropDown._popupWrapper.offsetWidth;
				var resizeArgs = {
					w: dropDown.domNode.offsetWidth + widthAdjust
				};
				if(lang.isFunction(dropDown.resize)){
					dropDown.resize(resizeArgs);
				}else{
					domGeometry.setMarginBox(ddNode, resizeArgs);
				}

				// If dropdown is right-aligned then compensate for width change by changing horizontal position
				if(retVal.corner[1] == "R"){
					dropDown._popupWrapper.style.left =
						(dropDown._popupWrapper.style.left.replace("px", "") - widthAdjust) + "px";
				}
			}

			domAttr.set(this._popupStateNode, "popupActive", "true");
			domClass.add(this._popupStateNode, "dijitHasDropDownOpen");
			this._set("_opened", true);	// use set() because _CssStateMixin is watching

			this._popupStateNode.setAttribute("aria-expanded", "true");
			this._popupStateNode.setAttribute("aria-owns", dropDown.id);

			// Set aria-labelledby on dropdown if it's not already set to something more meaningful
			if(ddNode.getAttribute("role") !== "presentation" && !ddNode.getAttribute("aria-labelledby")){
				ddNode.setAttribute("aria-labelledby", this.id);
			}

			return retVal;
		},

		closeDropDown: function(/*Boolean*/ focus){
			// summary:
			//		Closes the drop down on this widget
			// focus:
			//		If true, refocuses the button widget
			// tags:
			//		protected

			if(this._focusDropDownTimer){
				this._focusDropDownTimer.remove();
				delete this._focusDropDownTimer;
			}

			if(this._opened){
				this._popupStateNode.setAttribute("aria-expanded", "false");
				if(focus && this.focus){
					this.focus();
				}
				popup.close(this.dropDown);
				this._opened = false;
			}
		}

	});
});

},
'Sage/UI/Controls/Grid':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
/**
* @class Sage.UI.Controls.Grid
* Base class for Grid control
*
* See the example:
*
*     @example
*     var grid = new Grid({
*           store: new dojo.store.Memory([data: []]),
*           sort: {["attribute": "id"]},
*           id: 'grid',
*           columns:[ {
*               field: 'attachDate',
*               label: 'attachDate',
*               width: '175px'
*           }, {
*               field: 'fileSize',
*               label: 'fileSize',
*               width: '120px'
*           }],
*           placeHolder: 'placeHoldeId',
*           columnHiding: true,
*           columnResizing: true,
*           columnReordering: true,
*           selectionMode: 'single',
*           rowSelection: true
*       });
*
*/
define([
    'dijit/_Widget',
    'dojo/_base/declare',
    'dojo/_base/lang',
    'dojo/on',
    'dojo/_base/array',
    'dgrid/Selection',
    'dgrid/OnDemandGrid',
    'dgrid/Grid',
    'dgrid/Keyboard',
    'dgrid/editor',
    'dgrid/selector',
    'dgrid/extensions/ColumnHider',
    'dgrid/extensions/ColumnReorder',
    'dgrid/extensions/ColumnResizer',
    'dgrid/extensions/Pagination',
    'dgrid/extensions/DnD',
    'dgrid/util/mouse',
    'put-selector/put',
    'dojo/dom-construct',
    'dojo/dom-class',
    'Sage/Utility',
    'Sage/Utility/_LocalStorageMixin',
    'dojo/dom-attr',
    'dojo/query',
    'dojo/keys',
    'dojo/i18n!./nls/Grid'
],
function (
    _Widget,
    declare,
    lang,
    on,
    array,
    Selection,
    OnDemandGrid,
    Grid,
    Keyboard,
    Editor,
    Selector,
    ColumnHider,
    ColumnReorder,
    ColumnResizer,
    Pagination,
    DnD,
    mouse,
    put,
    domConstruct,
    domClass,
    Utility,
    _LocalStorageMixin,
    domAttr,
    query,
    keys,
    nlsResource
) {
    var widget = declare('Sage.UI.Controls.Grid', [_Widget, _LocalStorageMixin], {
        /**
        * @property {Boolean}
        * Whether to allow row selection within the grid.
        * @default false
        */
        rowSelection: false,
        /**
        * @property {Boolean}
        * Whether to allow temporary hiding of columns via menu.
        * @default false
        */
        columnHiding: false,
        /**
        * @property {Boolean}
        * Whether to include a checkbox column for indirect row selection.
        * @default false
        */
        indirectSelection: false,
        /**
        * @property {Boolean}
        * Whether to allow columns to be resized.
        * @default false
        */
        columnResizing: false,
        /**
        * @property {Boolean}
        * Whether to allow columns to be reordered.
        * @default false
        */
        columnReordering: false,
        /**
        * @property {Boolean}
        * Whether to allow rows can be dragged.
        * @default false
        */
        dnd: false,
        /**
        * @property {Boolean}
        * Whether to used fixed page sizes as opposed to virtual/infinite scrolling behavior.
        * This behavior is NOT RECOMMENDED.
        * @default false
        */
        // TODO: We'll need to validate that this works, or we need to remove the option.
        pagination: false,
        /**
        * @property {String}
        * Add a custom class to grid while rendering
        * @default empty string
        */
        // NOTE: this property cannot be renamed to 'className' since grid.js being a widget - overwrites all default grid styles
        classNames: '',
        /**
        * @property {Boolean}
        * Whether to generate a tooltip to display text that would otherwise be truncated by ellipsis.
        * @default true
        */
        // TODO: Mix-in?
        tooltipForTruncatedData: true,
        /**
        * @property {Boolean}
        * Whether to allow keyboard navigation of the grid.
        * @default true
        */
        keyboardNavigation: true,
        /**
        * @property {Boolean}
        * Whether to allow editor to be dismissed on hitting enter.
        * @default true
        */
        dismissOnEnter: true,
        /**
        * @property {DomNode or DomId}
        * DOM node to contain the grid.
        * @default null
        */
        placeHolder: '',
        /**
        * @property {Array}
        * Describes the structure of the grid to be created.
        * If the indirect selection feature is enabled, a checkbox column will be prepended to the given structure before it is used to build the grid.
        */
        selection: null,
        columns: null,
        showHiderIcon: true,
        formatterScope: null,
        domNode: null,
        heightByVisibleRecords: null,
        id: null,
        store: null,
        query: null,
        queryOptions: null,
        selectionMode: 'single',
        _grid: null,
        allowSelectAll: false,
        cellNavigation: false,
        setUserPreferences: true,
        togglePreRowsFlag: true,

        // Dgrid default settings
        farOffRemoval: 2000,
        pagingDelay: 15,
        minRowsPerPage: 25,
        maxRowsPerPage: 250,
        /**
        * @property {number}
        * this property applies only for pagination
        */
        rowsPerPage: 15,
        keepScrollPosition: true,
        queryRowsOverlap: 0,
        previewLength: 255,
        maxEmptySpace: 'Infinity',
        where: '',
        forceAutoId: false,
        region: 'center',
        STORE_NS: 'SAGE_UI_GRIDVIEW_',
        STORE_KEY_SORT: '_GRID_SORT_PROPS_',
        STORE_KEY_COLUMN_SIZE: '_COLUMN_UNIT_WIDTH_',
        STORE_KEY_HIDE: '_GRID_TOTTLE_PROPS_',
        STORE_KEY_REORDER: '_GRID_LAYOUT_PROPS_',
        STORE_KEY_TOGGLEPREVIEW: '_TOGGLEPREVIEW_INFO_',
        /**
        * Creates an instance of the Grid.
        * @constructor
        */
        constructor: function (args) {
            this.columns = [];
            lang.mixin(this, args);
            lang.mixin(this, nlsResource);
            this._validatePropertiesForGrid();

            if (this.columns.length > 0) {
                this.columns = this._applyFormatterForLegacyColumns(this.columns);
            }

            if (this.indirectSelection === true) {
                this.columns = this._addSelectorColumnToColumns(this.columns);
            }

            var options = this._prepareGridOptions();
            var mixins = this._getGridMixins();

            var grid = this._grid = new (declare(mixins))(options);
            this.domNode = grid.domNode;

            if (this.previewField) {
                this._attachPreviewExpando();
            }

            if (this.tooltipForTruncatedData) {
                grid.on(mouse.enterCell, this._onCellMouseOver(grid));
                grid.on(mouse.leaveCell, this._onCellMouseLeave(grid));
            }

            this.eventHandlerSubs = [];
            this.eventHandlerSubs.push(grid.on('.dgrid-row:click', lang.hitch(this, function (evt) { this._onRowClick(evt); })));
            this.eventHandlerSubs.push(grid.on('.dgrid-row:dblclick', lang.hitch(this, function (evt) { this._onRowDblClick(evt); })));
            this.eventHandlerSubs.push(grid.on('dgrid-select', lang.hitch(this, function (evt) { this._onSelection(evt); })));
            this.eventHandlerSubs.push(grid.on('dgrid-deselect', lang.hitch(this, function (evt) { this._onDeselection(evt); })));
            this.eventHandlerSubs.push(grid.on('dgrid-error', lang.hitch(this, function (evt) { this._onError(evt); })));
            this.eventHandlerSubs.push(grid.on('dgrid-sort', lang.hitch(this, function (evt) { this._onGridSort(evt); })));
            this.eventHandlerSubs.push(grid.on('dgrid-datachange', lang.hitch(this, function (evt) { this._onDataChange(evt); })));
            this.eventHandlerSubs.push(grid.on('dgrid-refresh-complete', lang.hitch(this, function (evt) { this._onLoadComplete(evt); })));
            this.eventHandlerSubs.push(grid.on('.dgrid-row:contextmenu', lang.hitch(this, function (evt) { this._onContextActivate(evt); })));
            this.eventHandlerSubs.push(grid.on('.dgrid-header:click', lang.hitch(this, function (evt) { this._onHeaderClick(evt); })));
            this.eventHandlerSubs.push(grid.on('dgrid-columnresize', lang.hitch(this, function (evt) { this._onColumnResize(evt); })));
            this.eventHandlerSubs.push(grid.on('dgrid-columnstatechange', lang.hitch(this, function (evt) { this._onColumnHide(evt); })));
            this.eventHandlerSubs.push(grid.on('dgrid-columnreorder', lang.hitch(this, function (evt) { this._onColumnReorder(evt); })));
            this.eventHandlerSubs.push(grid.on('dgrid-editor-show', lang.hitch(this, function (evt) { this._onEditorShow(evt); })));
            this.eventHandlerSubs.push(grid.on('dgrid-editor-hide', lang.hitch(this, function (evt) { this._onEditorHide(evt); })));
            this.eventHandlerSubs.push(grid.on('keydown', lang.hitch(this, function (evt) { this._onKeyDown(evt); })));

            if (this.placeHolder) {
                domConstruct.place(this._grid.domNode, this.placeHolder);
            }
            if (this.showHiderIcon === false) {
                this.classNames += ' hideColumnHider';
            }
            domClass.add(grid.domNode, this.classNames);
            this._grid.startup();

            // Adjust height of grid as per number of records requested for view
            if (this.heightByVisibleRecords) {
                domAttr.set(query('.dgrid-scroller', this._grid.domNode)[0], 'style', 'max-height:' + (this.heightByVisibleRecords) * 31 + 'px');
            }
        },
        /**
        * Destroys the Grid instance
        */
        destroy: function () {
            array.forEach(this.eventHandlerSubs, function (item) {
                item.remove();
            });
            this._grid.destroy();
            this.inherited(arguments);
        },
        /**
        * @private
        * @TODO: Potentially extract this into preview row feature mixin.
        */
        _attachPreviewExpando: function () {
            var grid = this._grid;
            var expandedNode, expandoListener = on(grid.domNode, ".dgrid-row:click", function (evt) {
                if (domClass.contains(evt.srcElement, "morelink")) {
                    return false;
                }
                var node = grid.row(evt).element,
                    collapsed = node.className.indexOf("collapsed") >= 0;

                // toggle state of node which was clicked
                put(node, (collapsed ? "!" : ".") + "collapsed");

                // if clicked row wasn't expanded, collapse any previously-expanded row
                if (collapsed && expandedNode) {
                    put(expandedNode, ".collapsed");
                }

                // if the row clicked was previously expanded, nothing is expanded now
                expandedNode = collapsed ? node : null;
            });
        },
        /**
        * @private
        */
        _prepareGridOptions: function () {
            if (this.setUserPreferences !== false) {
                this._loadUserPrefrences();
            }

            var options = {
                columns: this.columns,
                store: this.store,
                allowSelectAll: false,
                dismissOnEnter: this.dismissOnEnter,
                cellNavigation: this.cellNavigation,
                query: this.query ? this.query : {},
                farOffRemoval: this.farOffRemoval,
                pagingDelay: this.pagingDelay,
                minRowsPerPage: this.minRowsPerPage,
                maxRowsPerPage: this.maxRowsPerPage,
                rowsPerPage: this.rowsPerPage,
                keepScrollPosition: this.keepScrollPosition,
                loadingMessage: this.loadingMessage,
                noDataMessage: this.noDataMessage,
                queryRowsOverlap: this.queryRowsOverlap,
                maxEmptySpace: this.maxEmptySpace,
                selectionMode: (this.selectionMode === 'Multi') ? 'extended' : this.selectionMode.toLowerCase(), // sage entities save mode as "Multi"
                sort: this.sort,
                forceAutoId: this.forceAutoId,
                keyboardNavigation: this.keyboardNavigation,
                formatterScope: this.formatterScope
            };
            if (this.id) {
                options.id = this.id;
            } else {
                console.warn("ID needs to be explicitly assigned to this Grid since this is a widget.");
            }

            if (this.previewField) {
                var self = this;
                options.renderRow = function (obj, options) {
                    var previewFullText = (self.previewField.indexOf('.') !== -1) ? Utility.splitField(obj, self.previewField) : obj[self.previewField];
                    var displayText = '';

                    if (previewFullText) {
                        // populate only 255 chars to DOM
                        displayText = [
                            Utility.htmlEncode(previewFullText.substr(0, self.previewLength)).replace(/(?:\r\n|\r|\n)/g, '<br />'),
                            '.... <a href="#" class="morelink">' + self.showMore + '</a>'
                        ].join('');
                    }
                    var collapsed = (self.togglePreRowsFlag) ? '.expando' : '.expando.collapsed';
                    var div = put("div" + collapsed, OnDemandGrid.prototype.renderRow.apply(this, arguments)),
                        expando = put(div, "div" + collapsed + " div.preview", { innerHTML: (displayText) });
                    return div;
                };
            }
            return options;
        },
        /**
        * Assign user preferences to grid columns
        * @private
        */
        _loadUserPrefrences: function () {
            this._setUserPrefColumnWidths();
            this._setUserSortInfo();
            this._setUserHideInfo();
            this._setUserColumnReorderInfo();
            this._setToggleForPreviewRows();
        },
        /**
        * Assign column order info to grid columns as available in local storage
        * @private
        */
        _setUserColumnReorderInfo: function () {
            var localColumns = this.getFromLocalStorage(this.STORE_KEY_REORDER + this.id, this.STORE_NS);

            if (localColumns && localColumns.length === this.columns.length) {
                var columns = [];
                var col = null;

                // add columns order property so grid can reorder them
                for (var j = 0; j < localColumns.length; j++) {
                    var colAdded = false;
                    var localCol = localColumns[j];
                    for (var i = 0; i < this.columns.length; i++) {
                        col = this.columns[i];
                        if (localCol.field === col.field && typeof col._columnOrder === 'undefined') {
                            col._columnOrder = i;
                            columns.push(col);
                            colAdded = true;
                            break;
                        }
                    }
                }

                // add any columns which are new to the list and not part of local storage
                for (var k = 0; k < this.columns.length; k++) {
                    col = this.columns[k];
                    if (typeof col._columnOrder === "undefined") {
                        columns.push(col);
                    }
                }
                this.columns = columns;
            }
        },
        /**
        * Assign column sort info to grid columns as available in local storage
        * @private
        */
        _setUserSortInfo: function () {
            var key = this.STORE_KEY_SORT + this.id;
            var sortProps = this.getFromLocalStorage(key, this.STORE_NS);
            if (sortProps) {
                this.sort = sortProps;
            }
        },
        /**
        * Assign column hide info to grid columns as available in local storage
        * @private
        */
        _setUserHideInfo: function () {
            array.forEach(this.columns, lang.hitch(this, function (col) {
                if (col && col.field) {
                    var key = this._getColumnLocalKey(col, this.STORE_KEY_HIDE),
                        value = this.getFromLocalStorage(key, this.STORE_NS);
                    if (value === true || value === false) {
                        col.hidden = value;
                    }
                }
            }));
        },
        /**
        * Assign column width to grid columns as available in local storage
        * @private
        */
        _setUserPrefColumnWidths: function () {
            array.forEach(this.columns, lang.hitch(this, function (col) {
                if (col && col.field) {
                    var key = this._getColumnLocalKey(col, this.STORE_KEY_COLUMN_SIZE),
                        value = this.getFromLocalStorage(key, this.STORE_NS);
                    if (value) {
                        col.width = value;
                    }
                }
            }));
        },
        /**
        * @param {object} col array
        * @param {string} unit string
        * @private
        */
        _getColumnLocalKey: function (col, unit) {
            var fieldStripped, id;
            if (col !== undefined && col.field !== undefined) {
                fieldStripped = col.field.replace(/[\.\$]/g, '_');
                id = [this.id, '_', unit, fieldStripped].join('');
            }
            return id;
        },
        /**
        * @private
        */
        _validatePropertiesForGrid: function () {
            if (!this.placeHolder) {
                console.warn("No destinationNode defined. Grid will need to be placed into DOM manually.");
            }
            if (this.className) {
                console.warn("Setting className property on grid will replace any implicit properties which this widget will try to set. Please use 'classNames' property to add classes to the grid.");
            }
        },
        /**
        * @private
        */
        _getGridMixins: function () {
            var mixins = [];
            // Note: onDemandGrid does not support pagination
            mixins.push(this.pagination ? Grid : OnDemandGrid);

            var _includeMixin = function (classObj, include) {
                if (include === true) {
                    mixins.push(classObj);
                }
            };

            _includeMixin(ColumnReorder, this.columnReordering);
            _includeMixin(ColumnResizer, this.columnResizing);
            _includeMixin(Selection, this.rowSelection);
            _includeMixin(ColumnHider, this.columnHiding);
            _includeMixin(Pagination, this.pagination);
            _includeMixin(Keyboard, this.keyboardNavigation);
            _includeMixin(DnD, this.dnd);

            return mixins;
        },
        /**
        * @param {array} columns array
        * @private
        */
        _applyFormatterForLegacyColumns: function (columns) {
            // convert type to formatter for legacy Sage/UI/Column formatters
            var tmpCols = [];
            var self = this;
            if (columns) {
                for (var i = 0; i < columns.length; i++) {
                    var column = columns[i];
                    if (column.type) {
                        column.formatter = function (value, data) {
                            var columnType = new this.type(this);

                            // Use this if needing to encode all raw data in dGrid columns
                            // will cause large overhead as it will be called recursively for each
                            // data object contained within the data object on the row
                            // Utility.encodeObjectStrings(data);

                            if (columnType.domNode) {
                                return columnType.domNode;
                            }
                            return columnType.format(value, data);
                        };
                    }

                    if (column.editor) {
                        this.cellNavigation = true;

                        if (typeof column.editable === 'undefined' || column.editable === true) {
                            column = Editor(column, column.editor, (column.editOn ? column.editOn : ''));
                        } else {
                            column.editor = null;
                        }
                    }
                    if (column.field && column.field.indexOf('.') !== -1 && !column.get) {
                        column.get = function (dataItem) {
                            return Utility.splitField(dataItem, this.field);
                        };
                        column.set = function (dataItem) {
                            return Utility.setField(dataItem, this.field, dataItem[this.field]);
                        };
                    }
                    if (column.width) {
                        column.width = parseInt(column.width, 10);
                    }
                    tmpCols.push(column);
                }
            }
            return tmpCols;
        },
        /**
        * @param {array} columns array
        *
        * @private
        */
        _addSelectorColumnToColumns: function (columns) {
            var selectorColumn = Selector({
                selectorType: 'checkbox',

                // TODO : Convert below code to dijit control. This implementation skips row selection events as handled as of now
                // It needs to be as defined in selector.js setupSelectionEvents()...

                //selectorType: function (value, cell, object) {
                //    var parent = cell.parentNode,
                //        disabled;

                //    // column.disabled gets initialized or wrapped in setupSelectionEvents
                //    disabled = object.disabled;

                //    // must set the class name on the outer cell in IE for keystrokes to be intercepted
                //    put(parent && parent.contents ? parent : cell, ".dgrid-selector");
                //    debugger;
                //    var input = cell.input || (cell.input = put(cell, (new CheckBox()).domNode, {
                //        tabIndex: isNaN(object.tabIndex) ? -1 : object.tabIndex,
                //        disabled: disabled && (typeof disabled == "function" ?
                //            disabled.call(object, object) : disabled),
                //        checked: value
                //    }));
                //    input.setAttribute("aria-checked", !!value);

                //    return input;
                //},
                label: '',
                editable: true,
                sortable: false,
                reorderable: false,
                unhidable: true,
                className: 'field-checkbox'
            });
            columns.splice(0, 0, selectorColumn); // insert the selector column to be first
            return columns;
        },
        /**
        * Overridable event triggered when editor is activated by cell click
        * @param {Event} evt
        * @event
        */
        onEditorShow: function (evt) { },
        /*
        * Event triggered when editor is activated by cell click
        * @param {Event} evt
        * @private
        */
        _onEditorShow: function (evt) {
            this.onEditorShow(evt);
        },
        /*
        * Overridable event triggered when editor is deactivated by cell blur event
        * @event
        */
        onEditorHide: function (evt) { },
        /**
        * Event triggered when editor is deactivated by cell blur event
        * @param {Event} evt
        * @private
        * @event
        */
        _onEditorHide: function (evt) {
            this.onEditorHide(evt);
        },
        /*
        * Overridable event triggered when keyboard is pressed
        * @event
        */
        onKeyDown: function (evt) { },
        /**
        * Event triggered when keyboard is pressed
        * @param {Event} evt
        * @private
        * @event
        */
        _onKeyDown: function (evt) {
            if (this.keyboardNavigation === true) {
                if (evt.keyCode === keys.TAB) {
                    if (!evt.shiftKey) {
                        Keyboard.moveFocusRight.call(this._grid, evt);
                    } else {
                        Keyboard.moveFocusLeft.call(this._grid, evt);
                    }
                }
                this.onKeyDown(evt);
            }
        },
        /**
        * Overridable event handler that fires when selecting a row or rows within the grid.
        * @param {Event} evt
        * Event parameter contains information regarding selection made.
        * @event
        */
        onColumnReorder: function (evt) {
        },
        /**
        * @param {Event} evt
        * @private
        * @event
        */
        _onColumnReorder: function (evt) {
            var order = [];
            array.forEach(evt.subRow, function (col) {
                order.push({
                    field: col.field
                });
            });
            this.saveToLocalStorage(this.STORE_KEY_REORDER + this.id, order, this.STORE_NS);
            this.onColumnReorder(evt);
        },
        /*
        * Overridable event handler that fires when column is hidden or made visible
        * @param {Event} evt
        * @event
        */
        onColumnHide: function (evt) {
        },
        /**
        * @param {Event} evt
        * @private
        * @event
        */
        _onColumnHide: function (evt) {
            this.saveToLocalStorage(this._getColumnLocalKey(evt.column, this.STORE_KEY_HIDE), evt.hidden, this.STORE_NS);
            this.onColumnHide(evt);
        },
        /**
        * Overridable event handler that fires when selecting a row or rows within the grid.
        * @param {Event} evt
        * Event parameter contains information regarding selection made.
        * @event
        */
        onSelection: function (evt) { },
        /**
        * @param {Event} evt
        * @private
        * @event
        */
        _onSelection: function (evt) {
            this.selectedItem = evt.rows[0].data;
            this.selection = this._grid.selection;
            this.onSelection(evt);
        },
        /**
        * Overridable event handler that fires when deselecting a row or rows within the grid.
        * @param {Event} evt
        * Event parameter contains information regarding deselection made.
        * @event
        */
        onDeselection: function (evt) { },
        /**
        * @param {Event} evt
        * @private
        * @event
        */
        _onDeselection: function (evt) {
            this.selectedItem = false;
            this.onDeselection(evt);
        },
        /**
        * Overridable event handler that fires when grid errors
        * @param {Event} evt
        * Event parameter contains information regarding error
        * @event
        */
        onError: function (evt) { },
        /**
        * Event handler that fires when grid errors
        * @param {Event} evt
        * @private
        * @event
        */
        _onError: function (evt) {
            console.error(evt.error.message);
            this.onError(evt);
        },
        /**
        * Event triggered on grid header row click
        * @event
        */
        onHeaderClick: function (evt) { },
        /**
        * Event triggered on grid header row click
        * @param {Event} evt
        * @private
        * @event
        */
        _onHeaderClick: function (evt) {
            this.onHeaderClick(evt);
        },
        /**
        * Overridable event handler that fires when grid data changes
        * @param {Event} evt
        * Event parameter contains information regarding data changes
        * @event
        */
        onDataChange: function (evt) { },
        /**
        * Event handler that fires when grid data changes
        * @param {Event} evt
        * @private
        * @event
        */
        _onDataChange: function (evt) {
            console.log("data changed: ", evt.oldValue, " -> ", evt.value, evt);
            console.log("cell: ", evt.cell, evt.cell.row.id);
            this.onDataChange(evt);
        },
        /**
        * Overridable event handler that fires when activating a context menu. This can be a mouse "right-click", or SHIFT + F10 on keyboard.
        * @param {Event} evt
        * @event
        */
        // TODO: Consider renaming? Intent isn't clear/descriptive when referenced from other code.
        onContextActivate: function (evt) {
        },
        /**
        * event handler that fires when activating a context menu. This can be a mouse "right-click", or SHIFT + F10 on keyboard.
        * @param {Event} evt
        * @private
        * @event
        */
        _onContextActivate: function (evt) {
            this.onContextActivate(evt);
        },
        /**
        * Overridable event handler that fires when a column is resized
        * @param {Event} evt
        * @event
        */
        onColumnResize: function (evt) { },
        /**
        * Event handler that fires when a column is resized
        * @param {Event} evt
        * @private
        * @event
        */
        _onColumnResize: function (evt) {
            var cell = evt.grid.columns[evt.columnId],
                value = evt.width,
                key = this._getColumnLocalKey(cell, this.STORE_KEY_COLUMN_SIZE);
            if (key !== undefined) {
                this.saveToLocalStorage(key, value, this.STORE_NS);
            }
            this.onColumnResize(evt);
        },
        /**
        * Overridable event handler that fires when grid data refresh is complete
        * @param {Event} evt
        * @event
        */
        onLoadComplete: function (evt) { },
        /**
        * Event handler that fires when grid data refresh is complete
        * @param {Event} evt
        * @private
        * @event
        */
        _onLoadComplete: function (evt) {
            console.log("dgrid-refresh-complete: ", evt);
            this.totalRecords = (typeof evt.results.total !== 'undefined') ? evt.results.total : evt.results.length;
            this.onLoadComplete(evt);
        },
        /**
        * Overridable event handler that fires when the grid is sorted, either programmatically or via UI interaction.
        * @param {Event} evt
        */
        // TODO: Validate it also fires on programmatic sort.
        onGridSort: function (evt) { },
        /**
        * @private
        * @param {Event} evt
        * @event
        */
        _onGridSort: function (evt) {
            // summary:
            // OVERRIDE of event fired when a header cell is clicked.
            // e: Event
            // Decorated event object which contains reference to grid, cell, and rowIndex
            // description:
            // Override for grid sorting to allow for:
            // 1. Disabling of sorting on a column level.
            // 2. Disabling of sorting on Insert mode due to limitations in the WritableStore.
            // 3. Displaying PageExitWarningMessage when unsaved data exists.
            if (this._grid.cell(evt).column.sortable === false || this.mode === 'insert') {
                evt.preventDefault();
            } else {
                this.saveToLocalStorage(this.STORE_KEY_SORT + this.id, evt.sort, this.STORE_NS);
            }
            this.onGridSort(evt);
        },
        /**
        * Overridable event handler that fires on cell mouse over
        * @param {Event} evt
        * @event
        */
        onCellMouseOver: function (evt) { },
        /**
        * Event handler that fires on cell mouse over
        * @private
        * @event
        */
        _onCellMouseOver: function () {
            // show tooltip if cell overflows
            return lang.hitch(this, function (evt) {
                var obj = this._grid.cell(evt);
                if (obj.element.offsetWidth < obj.element.scrollWidth) {
                    // FF operates on element.textContent
                    var text = (typeof obj.element.innerText === 'undefined') ? obj.element.textContent : obj.element.innerText;
                    if (text !== "") {
                        dijit.showTooltip(Utility.htmlEncode(text), obj.element);
                    }
                }
                this.onCellMouseOver(evt);
            });
        },
        /**
        * Overridable event handler that fires on cell mouse leave
        * @event
        */
        onCellMouseLeave: function () { },
        /**
        * @private
        * @event
        */
        _onCellMouseLeave: function () {
            return lang.hitch(this, function (evt) {
                // hide tooltip
                dijit.hideTooltip(this._grid.cell(evt).element);
                this.onCellMouseLeave(evt);
            });
        },
        /**
        * Overridable event trigger on grid row click
        * @event
        */
        onRowClick: function (evt, row) { },
        /**
        * Event trigger on grid row click
        * @param {event} evt
        * @private
        * @event
        */
        _onRowClick: function (evt) {
            var row = this._grid.row(evt);
            if (this.previewField) {
                this._moreClick(evt, row);
            }
            this.onRowClick(evt, row);
        },
        /**
        * Overridable event trigger on grid row double click
        * @param {object} row object data
        * @event
        */
        onRowDblClick: function (row) { },
        /*
        * Event trigger on grid row double click
        * @param {event} evt
        * @private
        * @event
        */
        _onRowDblClick: function (evt) {
            var row = this._grid.row(evt);
            this.onRowDblClick(row);
        },
        /**
        * Resize the grid by providing afresh height and margins to header and scroller-box
        */
        resize: function () {
            this._grid.resize();
        },
        /**
        * Refresh the grid. Rebinds the grid to the data store.
        */
        refresh: function () {
            console.log('Refresh grid');
            this._grid.refresh();
        },
        /**
        * Revert any changes made on editors within the grid. This avoids grid data rebind from store as done by #refresh
        */
        revert: function () {
            this._grid.revert();
        },
        /**
        * Saves data changed on the grid by pushing only modified row data to the store.
        * @returns promise
        */
        save: function () {
            return this._grid.save();
        },
        /**
        * Clears any row selections made by mouse
        */
        clearSelection: function () {
            this._grid.clearSelection();
        },
        /**
        * Sets the sorting properties for the grid. This will make a call to the store and rebind data on grid.
        * @param {object} sortColumn
        * @param {boolean} descending
        */
        setSort: function (sortColumn, descending) {
            console.log("SetSort called %o, %o", sortColumn, descending);
            this._grid.set("sort", sortColumn, descending);
        },
        /**
        * Provide a store to grid. This will make a call to the store and rebind data on grid.
        * @param {object} store
        * @param {object} query
        * @param {object} queryOptions
        */
        setStore: function (store, query, queryOptions) {
            console.log("SetStore called");
            this.store = store;
            this.query = query;
            this.queryOptions = queryOptions;
            this._grid.set("store", this.store, this.query, this.queryOptions);
        },
        /**
        * Provides a new array columns to the grid. This will make a call to the store and rebind data on grid.
        * @param {array} columns array
        */
        setColumns: function (columns) {
            console.log("SetColumns called");
            var tmpCols = columns;
            this._applyFormatterForLegacyColumns(columns);
            if (this.indirectSelection === true) {
                tmpCols = this._addSelectorColumnToColumns(columns);
            }
            this.columns = tmpCols;
            if (this.setUserPreferences !== false) {
                this._loadUserPrefrences();
            }
            this._grid.set("columns", this.columns);
        },
        /**
        * Change selection mode on grid.
        * @param {string} selectionMode single/extended/multiple
        */
        setSelectionMode: function (selectionMode) {
            this._grid.set("selectionMode", selectionMode);
            console.log("SetSelectionMode called");
        },
        /**
        * Allow hiding on grid header
        * @param {boolean} isVisible boolean
        */
        setHeaderVisibility: function (isVisible) {
            this._grid.set("showHeader", isVisible);
        },
        /**
        * Retrieve data of selected row
        * @param {object} fields
        * @returns data array
        */
        getSelectedRowData: function (fields) {
            var selectedItems = [];
            if (fields && fields.length > 0) {
                for (var id in this._grid.selection) {
                    var result = {};
                    array.forEach(fields, lang.hitch(this, function (fieldName) {
                        result[fieldName] = this._grid.row(id).data[fieldName];
                    }));
                    selectedItems.push(result);
                }
            } else {
                for (var item in this._grid.selection) {
                    selectedItems.push(this._grid.row(item).data);
                }
            }
            return selectedItems;
        },
        /**
        * Retrieve row idProperty of selected row
        * @returns idProperty
        */
        getSelectedRowId: function () {
            for (var id in this._grid.selection) {
                if (this._grid.selection[id]) {
                    return id;
                }
            }
            return null;
        },
        /**
        * Sets the width of a given column to the given width.
        * @param {object} Column representation from structure object.
        * @param {int} Width to set column to (in pixels).
        */
        setColumnWidth: function (colObj, width) {
            if (this.columnResizing === true) {
                this._grid.resizeColumnWidth(colObj["id"], width);
            }
            else {
                console.warn("Column resizing is not enabled for this grid.");
            }
        },
        /**
        * Set filter on store to retrieve subset of data
        * @param {object} query may also be a string
        */
        setFilter: function (query) {
            this.query = query;
            this.setStore(this.store, query, this.queryOptions);
        },
        /**
        *
        *  @param {function} fn function
        */
        setRowRenderFunction: function (fn) {
            if (fn) {
                this._grid.renderRow = fn;
            }
            else if (this._oldRenderRow) {
                this._grid.renderRow = this._oldRenderRow;
            }
        },
        /**
         * Remove specified row from grid
         * @param {object} object grid row data)
         */
        removeRow: function (object) {
            if (this.store.data) {
                this.store.data.remove(object);
            } else {
                this.store.remove(object["$key"], this.store);
            }
            this.refresh();
        },
        /**
        * Re-render a specified grid row object
        * @param {object} rowObj grid row data
        */
        reRenderRow: function (rowObj) {
            return this._grid.renderRow(rowObj);
        },
        /**
         * Add a single row item to grid
         * @param {object} object grid row data
         */
        addItem: function (object) {
            this._grid.store.add(object);
        },
        /**
         * Toggles state of preview rows
         */
        togglePreviewRows: function () {
            this.togglePreRowsFlag = !this.togglePreRowsFlag;
            this.saveToLocalStorage(this.STORE_KEY_TOGGLEPREVIEW + this.id, this.togglePreRowsFlag, this.STORE_NS);
            var rows = this._grid.domNode.getElementsByClassName('dgrid-row');
            for (var i = 0; i < rows.length; i++) {
                // toggle state of node which was clicked
                put(rows[i], (this.togglePreRowsFlag ? "!" : ".") + "collapsed");
            }
        },
        _setToggleForPreviewRows: function () {
            var flag = this.getFromLocalStorage(this.STORE_KEY_TOGGLEPREVIEW + this.id, this.STORE_NS);
            if (flag !== null) {
                this.togglePreRowsFlag = flag;
            }
        },
        /**
         * Handles more click event on preview row
         * @param {event} grid row click evt
         * @param {object} row object
         *
         * @event
         */
        _moreClick: function (evt, row) {
            if (evt.target.className.indexOf('morelink') !== -1) {
                if (evt.target.className.indexOf('less') !== -1) {
                    // on show less click - contains full message - hide it
                    domClass.add(evt.target.parentNode.parentNode.children[1], 'display-none');
                    domClass.remove(evt.target.parentNode.parentNode.children[0], 'display-none');

                    var revertHide = evt.target.parentNode.getElementsByClassName('display');
                    for (var i = 0; i < revertHide.length; i++) {
                        domClass.add(revertHide[i], 'display-none');
                    }

                } else if (evt.target.className.indexOf('full') === -1) {
                    // does not contain full message - fetch and show next block of 255 chars
                    if (this.fullNoteField) {
                        this.store.select.push(this.fullNoteField);
                    }
                    var record = this.store.query("id eq '" + row.id + "'", null);
                    record.then(lang.hitch(this, function (record) {
                        var finalarray = [];
                        var incrementalDisplay = '</span><span class="display-none">';

                        // break long note into equal sized string array
                        var noteField = this.fullNoteField ? this.fullNoteField : this.previewField;
                        var fullNoteFieldText = (noteField.indexOf('.') !== -1) ? Utility.splitField(record[0], noteField) : record[0][noteField];
                        var splitText = fullNoteFieldText.match(/[\S\s]{1,255}/g);

                        finalarray.push(Utility.htmlEncode(splitText[0]).replace(/(?:\r\n|\r|\n)/g, '<br />'));
                        finalarray.push('</span><span class="display">');

                        for (var i = 1; i < splitText.length; i++) {
                            // if this is done before for loop, we will end up with unequal lengths of strings
                            finalarray.push(Utility.htmlEncode(splitText[i]).replace(/(?:\r\n|\r|\n)/g, '<br />'));
                            // push to array
                            if (i !== splitText.length - 1) {
                                finalarray.push(incrementalDisplay);
                            }
                        }
                        finalarray.push('</span> <br />');

                        // don't show more link if no extra data is available
                        if (splitText.length > 2) {
                            finalarray.push('<a href="#" class="morelink more full">' + this.showMore + '</a>');
                        }
                        finalarray.push('<a href="#" class="morelink less full">' + this.showLess + '</a>');

                        var displayText = finalarray.join('');
                        put(evt.target.parentNode.parentNode, 'div.moreView', { innerHTML: displayText });

                        // hide preview div and remove show more
                        domClass.add(evt.target.parentNode, 'display-none');

                        // indicate full text is available
                        domClass.add(evt.target, 'full');
                        evt.target.innerHTML = this.showMore;
                    }));
                    evt.target.innerHTML = 'loading...';

                } else {
                    // on click of show more - contains full message - just show it incrementally

                    // ensure preview is hidden
                    domClass.add(evt.target.parentNode.parentNode.children[0], 'display-none');
                    var node = evt.target.parentNode;
                    var targetPreviewNode = (node.className.indexOf('preview') !== -1);

                    // reset full mode view
                    if (targetPreviewNode) {
                        node = evt.target.parentNode.parentNode.children[1];
                        domClass.remove(node, 'display-none');

                        // check if show more was made visible - happens in case of span = 2
                        if (node.getElementsByClassName('more').length > 0) {
                            domClass.remove(node.getElementsByClassName('more')[0], 'display-none');
                        }
                    }

                    var moreSections = node.getElementsByClassName('display-none');
                    // display next section of notes
                    if (moreSections.length > 0) {
                        if (moreSections.length === 1 && !targetPreviewNode) {
                            // hide more link if no more data is available
                            domClass.add(evt.target, 'display-none');
                        }
                        domClass.add(moreSections[0], 'display');
                        domClass.remove(moreSections[0], 'display-none');
                    }
                }
            }
        }
    });
    return widget;
});

},
'dgrid/Selection':function(){
define(["dojo/_base/kernel", "dojo/_base/declare", "dojo/_base/Deferred", "dojo/on", "dojo/has", "dojo/aspect", "./List", "dojo/has!touch?./util/touch", "put-selector/put", "dojo/query", "dojo/_base/sniff", "dojo/dom"],
function (kernel, declare, Deferred, on, has, aspect, List, touchUtil, put) {

    has.add("dom-comparedocumentposition", function (global, doc, element) {
        return !!element.compareDocumentPosition;
    });

    has.add("pointer", function (global) {
        return "PointerEvent" in global ? "pointer" :
            "MSPointerEvent" in global ? "MSPointer" : false;
    });

    // Also add a feature test for the onselectstart event, which offers a more
    // graceful fallback solution than node.unselectable.
    has.add("dom-selectstart", typeof document.onselectstart !== "undefined");

    var ctrlEquiv = has("mac") ? "metaKey" : "ctrlKey",
        hasUserSelect = has("css-user-select"),
        hasPointer = has("pointer"),
        hasMSPointer = hasPointer && hasPointer.slice(0, 2) === "MS",
        downType = hasPointer ? hasPointer + (hasMSPointer ? "Down" : "down") : "mousedown",
        upType = hasPointer ? hasPointer + (hasMSPointer ? "Up" : "up") : "mouseup";
    if (hasUserSelect === 'WebkitUserSelect' && typeof document.documentElement.style.msUserSelect !== 'undefined') {
        // Edge defines both webkit and ms prefixes, rendering feature detects as brittle as UA sniffs...
        hasUserSelect = false;
    }

    function makeUnselectable(node, unselectable) {
        // Utility function used in fallback path for recursively setting unselectable
        var value = node.unselectable = unselectable ? "on" : "",
            elements = node.getElementsByTagName("*"),
            i = elements.length;

        while (--i) {
            if (elements[i].tagName === "INPUT" || elements[i].tagName === "TEXTAREA") {
                continue; // Don't prevent text selection in text input fields.
            }
            elements[i].unselectable = value;
        }
    }

    function setSelectable(grid, selectable) {
        // Alternative version of dojo/dom.setSelectable based on feature detection.

        // For FF < 21, use -moz-none, which will respect -moz-user-select: text on
        // child elements (e.g. form inputs).  In FF 21, none behaves the same.
        // See https://developer.mozilla.org/en-US/docs/CSS/user-select
        var node = grid.bodyNode,
            value = selectable ? "text" : has("ff") < 21 ? "-moz-none" : "none";

        // In IE10+, -ms-user-select: none will block selection from starting within the
        // element, but will not block an existing selection from entering the element.
        // When using a modifier key, IE will select text inside of the element as well
        // as outside of the element, because it thinks the selection started outside.
        // Therefore, fall back to other means of blocking selection for IE10+.
        if (hasUserSelect && hasUserSelect !== "msUserSelect") {
            node.style[hasUserSelect] = value;
        } else if (has("dom-selectstart")) {
            // For browsers that don't support user-select but support selectstart (IE<10),
            // we can hook up an event handler as necessary.  Since selectstart bubbles,
            // it will handle any child elements as well.
            // Note, however, that both this and the unselectable fallback below are
            // incapable of preventing text selection from outside the targeted node.
            if (!selectable && !grid._selectstartHandle) {
                grid._selectstartHandle = on(node, "selectstart", function (evt) {
                    var tag = evt.target && evt.target.tagName;

                    // Prevent selection except where a text input field is involved.
                    if (tag !== "INPUT" && tag !== "TEXTAREA") {
                        evt.preventDefault();
                    }
                });
            } else if (selectable && grid._selectstartHandle) {
                grid._selectstartHandle.remove();
                delete grid._selectstartHandle;
            }
        } else {
            // For browsers that don't support either user-select or selectstart (Opera),
            // we need to resort to setting the unselectable attribute on all nodes
            // involved.  Since this doesn't automatically apply to child nodes, we also
            // need to re-apply it whenever rows are rendered.
            makeUnselectable(node, !selectable);
            if (!selectable && !grid._unselectableHandle) {
                grid._unselectableHandle = aspect.after(grid, "renderRow", function (row) {
                    makeUnselectable(row, true);
                    return row;
                });
            } else if (selectable && grid._unselectableHandle) {
                grid._unselectableHandle.remove();
                delete grid._unselectableHandle;
            }
        }
    }

    return declare(null, {
        // summary:
        //		Add selection capabilities to a grid. The grid will have a selection property and
        //		fire "dgrid-select" and "dgrid-deselect" events.

        // selectionDelegate: String
        //		Selector to delegate to as target of selection events.
        selectionDelegate: ".dgrid-row",

        // selectionEvents: String|Function
        //		Event (or comma-delimited events, or extension event) to listen on
        //		to trigger select logic.
        selectionEvents: downType + "," + upType + ",dgrid-cellfocusin",

        // selectionTouchEvents: String|Function
        //		Event (or comma-delimited events, or extension event) to listen on
        //		in addition to selectionEvents for touch devices.
        selectionTouchEvents: has("touch") ? touchUtil.tap : null,

        // deselectOnRefresh: Boolean
        //		If true, the selection object will be cleared when refresh is called.
        deselectOnRefresh: true,

        // allowSelectAll: Boolean
        //		If true, allow ctrl/cmd+A to select all rows.
        //		Also consulted by the selector plugin for showing select-all checkbox.
        allowSelectAll: false,

        // selection:
        //		An object where the property names correspond to 
        //		object ids and values are true or false depending on whether an item is selected
        selection: {},

        // selectionMode: String
        //		The selection mode to use, can be "none", "multiple", "single", or "extended".
        selectionMode: "extended",

        // allowTextSelection: Boolean
        //		Whether to still allow text within cells to be selected.  The default
        //		behavior is to allow text selection only when selectionMode is none;
        //		setting this property to either true or false will explicitly set the
        //		behavior regardless of selectionMode.
        allowTextSelection: undefined,

        // _selectionTargetType: String
        //		Indicates the property added to emitted events for selected targets;
        //		overridden in CellSelection
        _selectionTargetType: "rows",

        create: function () {
            this.selection = {};
            return this.inherited(arguments);
        },
        postCreate: function () {
            this.inherited(arguments);

            this._initSelectionEvents();

            // Force selectionMode setter to run
            var selectionMode = this.selectionMode;
            this.selectionMode = "";
            this._setSelectionMode(selectionMode);
        },

        destroy: function () {
            this.inherited(arguments);

            // Remove any extra handles added by Selection.
            if (this._selectstartHandle) { this._selectstartHandle.remove(); }
            if (this._unselectableHandle) { this._unselectableHandle.remove(); }
            if (this._removeDeselectSignals) { this._removeDeselectSignals(); }
        },

        _setSelectionMode: function (mode) {
            // summary:
            //		Updates selectionMode, resetting necessary variables.
            if (mode == this.selectionMode) { return; } // prevent unnecessary spinning

            // Start selection fresh when switching mode.
            this.clearSelection();

            this.selectionMode = mode;

            // Compute name of selection handler for this mode once
            // (in the form of _fooSelectionHandler)
            this._selectionHandlerName = "_" + mode + "SelectionHandler";

            // Also re-run allowTextSelection setter in case it is in automatic mode.
            this._setAllowTextSelection(this.allowTextSelection);
        },
        setSelectionMode: function (mode) {
            kernel.deprecated("setSelectionMode(...)", 'use set("selectionMode", ...) instead', "dgrid 0.4");
            this.set("selectionMode", mode);
        },

        _setAllowTextSelection: function (allow) {
            if (typeof allow !== "undefined") {
                setSelectable(this, allow);
            } else {
                setSelectable(this, this.selectionMode === "none");
            }
            this.allowTextSelection = allow;
        },

        _handleSelect: function (event, target) {
            // Don't run if selection mode doesn't have a handler (incl. "none"), target can't be selected,
            // or if coming from a dgrid-cellfocusin from a mousedown
            if (!this[this._selectionHandlerName] || !this.allowSelect(this.row(target)) ||
                    (event.type === "dgrid-cellfocusin" && event.parentType === "mousedown") ||
                    (event.type === upType && target != this._waitForMouseUp)) {
                return;
            }
            this._waitForMouseUp = null;
            this._selectionTriggerEvent = event;

            // Don't call select handler for ctrl+navigation
            if (!event.keyCode || !event.ctrlKey || event.keyCode == 32) {
                // If clicking a selected item, wait for mouseup so that drag n' drop
                // is possible without losing our selection
                if (!event.shiftKey && event.type === downType && this.isSelected(target)) {
                    this._waitForMouseUp = target;
                } else {
                    this[this._selectionHandlerName](event, target);
                }
            }
            this._selectionTriggerEvent = null;
        },

        _singleSelectionHandler: function (event, target) {
            // summary:
            //		Selection handler for "single" mode, where only one target may be
            //		selected at a time.

            var ctrlKey = event.keyCode ? event.ctrlKey : event[ctrlEquiv];
            if (this._lastSelected === target) {
                // Allow ctrl to toggle selection, even within single select mode.
                this.select(target, null, !ctrlKey || !this.isSelected(target));
            } else {
                this.clearSelection();
                this.select(target);
                this._lastSelected = target;
            }
        },

        _multipleSelectionHandler: function (event, target) {
            // summary:
            //		Selection handler for "multiple" mode, where shift can be held to
            //		select ranges, ctrl/cmd can be held to toggle, and clicks/keystrokes
            //		without modifier keys will add to the current selection.

            var lastRow = this._lastSelected,
                ctrlKey = event.keyCode ? event.ctrlKey : event[ctrlEquiv],
                value;

            if (!event.shiftKey) {
                // Toggle if ctrl is held; otherwise select
                value = ctrlKey ? null : true;
                lastRow = null;
            }
            this.select(target, lastRow, value);

            if (!lastRow) {
                // Update reference for potential subsequent shift+select
                // (current row was already selected above)
                this._lastSelected = target;
            }
        },

        _extendedSelectionHandler: function (event, target) {
            // summary:
            //		Selection handler for "extended" mode, which is like multiple mode
            //		except that clicks/keystrokes without modifier keys will clear
            //		the previous selection.

            // Clear selection first for right-clicks outside selection and non-ctrl-clicks;
            // otherwise, extended mode logic is identical to multiple mode
            if (event.button === 2 ? !this.isSelected(target) :
                    !(event.keyCode ? event.ctrlKey : event[ctrlEquiv])) {
                this.clearSelection(null, true);
            }
            this._multipleSelectionHandler(event, target);
        },

        _toggleSelectionHandler: function (event, target) {
            // summary:
            //		Selection handler for "toggle" mode which simply toggles the selection
            //		of the given target.  Primarily useful for touch input.

            this.select(target, null, null);
        },

        _initSelectionEvents: function () {
            // summary:
            //		Performs first-time hookup of event handlers containing logic
            //		required for selection to operate.

            var grid = this,
                contentNode = this.contentNode,
                selector = this.selectionDelegate;

            this._selectionEventQueues = {
                deselect: [],
                select: []
            };

            if (has("touch") && !has("pointer") && this.selectionTouchEvents) {
                // Listen for taps, and also for mouse/keyboard, making sure not
                // to trigger both for the same interaction
                on(contentNode, touchUtil.selector(selector, this.selectionTouchEvents), function (evt) {
                    grid._handleSelect(evt, this);
                    grid._ignoreMouseSelect = this;
                });
                on(contentNode, on.selector(selector, this.selectionEvents), function (event) {
                    if (grid._ignoreMouseSelect !== this) {
                        grid._handleSelect(event, this);
                    } else if (event.type === upType) {
                        grid._ignoreMouseSelect = null;
                    }
                });
            } else {
                // Listen for mouse/keyboard actions that should cause selections
                on(contentNode, on.selector(selector, this.selectionEvents), function (event) {
                    grid._handleSelect(event, this);
                });
            }

            // Also hook up spacebar (for ctrl+space)
            if (this.addKeyHandler) {
                this.addKeyHandler(32, function (event) {
                    grid._handleSelect(event, event.target);
                });
            }

            // If allowSelectAll is true, bind ctrl/cmd+A to (de)select all rows,
            // unless the event was received from an editor component.
            // (Handler further checks against _allowSelectAll, which may be updated
            // if selectionMode is changed post-init.)
            if (this.allowSelectAll) {
                this.on("keydown", function (event) {
                    if (event[ctrlEquiv] && event.keyCode == 65 &&
                            !/\bdgrid-input\b/.test(event.target.className)) {
                        event.preventDefault();
                        grid[grid.allSelected ? "clearSelection" : "selectAll"]();
                    }
                });
            }

            // Update aspects if there is a store change
            if (this._setStore) {
                aspect.after(this, "_setStore", function () {
                    grid._updateDeselectionAspect();
                });
            }
            this._updateDeselectionAspect();
        },

        _updateDeselectionAspect: function () {
            // summary:
            //		Hooks up logic to handle deselection of removed items.
            //		Aspects to an observable store's notify method if applicable,
            //		or to the list/grid's removeRow method otherwise.

            var self = this,
                store = this.store,
                beforeSignal,
                afterSignal;

            function ifSelected(object, idToUpdate, methodName) {
                // Calls a method if the row corresponding to the object is selected.
                var id = idToUpdate || (object && object[self.idProperty || "id"]);
                if (id != null) {
                    var row = self.row(id),
                        selection = row && self.selection[row.id];
                    // Is the row currently in the selection list.
                    if (selection) {
                        self[methodName](row, null, selection);
                    }
                }
            }

            // Remove anything previously configured
            if (this._removeDeselectSignals) {
                this._removeDeselectSignals();
            }

            // Is there currently an observable store?
            if (store && store.notify) {
                beforeSignal = aspect.before(store, "notify", function (object, idToUpdate) {
                    if (!object) {
                        // Call deselect on the row if the object is being removed.  This allows the
                        // deselect event to reference the row element while it still exists in the DOM.
                        ifSelected(object, idToUpdate, "deselect");
                    }
                });
                afterSignal = aspect.after(store, "notify", function (object, idToUpdate) {
                    // When List updates an item, the row element is removed and a new one inserted.
                    // If at this point the object is still in grid.selection, then call select on the row so the
                    // element's CSS is updated.  If the object was removed then the aspect-before has already deselected it.
                    ifSelected(object, idToUpdate, "select");
                }, true);

                this._removeDeselectSignals = function () {
                    beforeSignal.remove();
                    afterSignal.remove();
                };
            } else {
                beforeSignal = aspect.before(this, "removeRow", function (rowElement, justCleanup) {
                    var row;
                    if (!justCleanup) {
                        row = this.row(rowElement);
                        // if it is a real row removal for a selected item, deselect it
                        if (row && (row.id in this.selection)) {
                            this.deselect(row);
                        }
                    }
                });
                this._removeDeselectSignals = function () {
                    beforeSignal.remove();
                };
            }
        },

        allowSelect: function (row) {
            // summary:
            //		A method that can be overriden to determine whether or not a row (or 
            //		cell) can be selected. By default, all rows (or cells) are selectable.
            return true;
        },

        _fireSelectionEvent: function (type) {
            // summary:
            //		Fires an event for the accumulated rows once a selection
            //		operation is finished (whether singular or for a range)

            var queue = this._selectionEventQueues[type],
                triggerEvent = this._selectionTriggerEvent,
                eventObject;

            eventObject = {
                bubbles: true,
                grid: this
            };
            if (triggerEvent) {
                eventObject.parentType = triggerEvent.type;
            }
            eventObject[this._selectionTargetType] = queue;

            // Clear the queue so that the next round of (de)selections starts anew
            this._selectionEventQueues[type] = [];

            on.emit(this.contentNode, "dgrid-" + type, eventObject);
        },

        _fireSelectionEvents: function () {
            var queues = this._selectionEventQueues,
                type;

            for (type in queues) {
                if (queues[type].length) {
                    this._fireSelectionEvent(type);
                }
            }
        },

        _select: function (row, toRow, value) {
            // summary:
            //		Contains logic for determining whether to select targets, but
            //		does not emit events.  Called from select, deselect, selectAll,
            //		and clearSelection.

            var selection,
                previousValue,
                element,
                toElement,
                direction;

            if (typeof value === "undefined") {
                // default to true
                value = true;
            }
            if (!row.element) {
                row = this.row(row);
            }

            // Check whether we're allowed to select the given row before proceeding.
            // If a deselect operation is being performed, this check is skipped,
            // to avoid errors when changing column definitions, and since disabled
            // rows shouldn't ever be selected anyway.
            if (value === false || this.allowSelect(row)) {
                selection = this.selection;
                previousValue = !!selection[row.id];
                if (value === null) {
                    // indicates a toggle
                    value = !previousValue;
                }
                element = row.element;
                if (!value && !this.allSelected) {
                    delete this.selection[row.id];
                } else {
                    selection[row.id] = value;
                }
                if (element) {
                    // add or remove classes as appropriate
                    if (value) {
                        put(element, ".dgrid-selected" +
                            (this.addUiClasses ? ".ui-state-active" : ""));
                    } else {
                        put(element, "!dgrid-selected!ui-state-active");
                    }
                }
				if ( (value !== previousValue && element) || (value !== previousValue && row.id) ){
                    // add to the queue of row events
                    this._selectionEventQueues[(value ? "" : "de") + "select"].push(row);
                }

                if (toRow) {
                    if (!toRow.element) {
                        toRow = this.row(toRow);
                    }

                    if (!toRow) {
                        this._lastSelected = element;
                        console.warn("The selection range has been reset because the " +
                            "beginning of the selection is no longer in the DOM. " +
                            "If you are using OnDemandList, you may wish to increase " +
                            "farOffRemoval to avoid this, but note that keeping more nodes " +
                            "in the DOM may impact performance.");
                        return;
                    }

                    toElement = toRow.element;
                    if (toElement) {
                        direction = this._determineSelectionDirection(element, toElement);
                        if (!direction) {
                            // The original element was actually replaced
                            toElement = document.getElementById(toElement.id);
                            direction = this._determineSelectionDirection(element, toElement);
                        }
                        while (row.element != toElement && (row = this[direction](row))) {
                            this._select(row, null, value);
                        }
                    }
                }
            }
        },

        // Implement _determineSelectionDirection differently based on whether the
        // browser supports element.compareDocumentPosition; use sourceIndex for IE<9
        _determineSelectionDirection: has("dom-comparedocumentposition") ? function (from, to) {
            var result = to.compareDocumentPosition(from);
            if (result & 1) {
                return false; // Out of document
            }
            return result === 2 ? "down" : "up";
        } : function (from, to) {
            if (to.sourceIndex < 1) {
                return false; // Out of document
            }
            return to.sourceIndex > from.sourceIndex ? "down" : "up";
        },

        select: function (row, toRow, value) {
            // summary:
            //		Selects or deselects the given row or range of rows.
            // row: Mixed
            //		Row object (or something that can resolve to one) to (de)select
            // toRow: Mixed
            //		If specified, the inclusive range between row and toRow will
            //		be (de)selected
            // value: Boolean|Null
            //		Whether to select (true/default), deselect (false), or toggle
            //		(null) the row

            this._select(row, toRow, value);
            this._fireSelectionEvents();
        },
        deselect: function (row, toRow) {
            // summary:
            //		Deselects the given row or range of rows.
            // row: Mixed
            //		Row object (or something that can resolve to one) to deselect
            // toRow: Mixed
            //		If specified, the inclusive range between row and toRow will
            //		be deselected

            this.select(row, toRow, false);
        },

        clearSelection: function (exceptId, dontResetLastSelected) {
            // summary:
            //		Deselects any currently-selected items.
            // exceptId: Mixed?
            //		If specified, the given id will not be deselected.

            this.allSelected = false;
            for (var id in this.selection) {
                if (exceptId !== id) {
                    this._select(id, null, false);
                }
            }
            if (!dontResetLastSelected) {
                this._lastSelected = null;
            }
            this._fireSelectionEvents();
        },
        selectAll: function () {
            this.allSelected = true;
            this.selection = {}; // we do this to clear out pages from previous sorts
            for (var i in this._rowIdToObject) {
                var row = this.row(this._rowIdToObject[i]);
                this._select(row.id, null, true);
            }
            this._fireSelectionEvents();
        },

        isSelected: function (object) {
            // summary:
            //		Returns true if the indicated row is selected.

            if (typeof object === "undefined" || object === null) {
                return false;
            }
            if (!object.element) {
                object = this.row(object);
            }

            // First check whether the given row is indicated in the selection hash;
            // failing that, check if allSelected is true (testing against the
            // allowSelect method if possible)
            return (object.id in this.selection) ? !!this.selection[object.id] :
                this.allSelected && (!object.data || this.allowSelect(object));
        },

        refresh: function () {
            if (this.deselectOnRefresh) {
                this.clearSelection();
            }
            this._lastSelected = null;
            return this.inherited(arguments);
        },

        renderArray: function () {
            var grid = this,
                rows = this.inherited(arguments);

            Deferred.when(rows, function (rows) {
                var selection = grid.selection,
                    i, row, selected;
                for (i = 0; i < rows.length; i++) {
                    row = grid.row(rows[i]);
                    selected = row.id in selection ? selection[row.id] : grid.allSelected;
                    if (selected) {
                        grid._select(row, null, selected);
                    }
                }
                grid._fireSelectionEvents();
            });
            return rows;
        }
    });

});

},
'dgrid/List':function(){
define(["dojo/_base/kernel", "dojo/_base/declare", "dojo/dom", "dojo/on", "dojo/has", "./util/misc", "dojo/has!touch?./TouchScroll", "xstyle/has-class", "put-selector/put", "dojo/_base/sniff", "xstyle/css!./css/dgrid.css"],
function(kernel, declare, dom, listen, has, miscUtil, TouchScroll, hasClass, put){
	// Add user agent/feature CSS classes 
	hasClass("mozilla", "opera", "webkit", "ie", "ie-6", "ie-6-7", "quirks", "no-quirks", "touch");
	
	var oddClass = "dgrid-row-odd",
		evenClass = "dgrid-row-even",
		scrollbarWidth, scrollbarHeight;
	
	function byId(id){
		return document.getElementById(id);
	}
	
	function cleanupTestElement(element){
		element.className = "";
		document.body.removeChild(element);
	}
	
	function getScrollbarSize(element, dimension){
		// Used by has tests for scrollbar width/height
		put(document.body, element, ".dgrid-scrollbar-measure");
		var size = element["offset" + dimension] - element["client" + dimension];
		cleanupTestElement(element);
		return size;
	}
	has.add("dom-scrollbar-width", function(global, doc, element){
		return getScrollbarSize(element, "Width");
	});
	has.add("dom-scrollbar-height", function(global, doc, element){
		return getScrollbarSize(element, "Height");
	});
	
	has.add("dom-rtl-scrollbar-left", function(global, doc, element){
		var div = put("div"),
			isLeft;
		
		put(document.body, element, ".dgrid-scrollbar-measure[dir=rtl]");
		put(element, div);
		
		// position: absolute makes IE always report child's offsetLeft as 0,
		// but it conveniently makes other browsers reset to 0 as base, and all
		// versions of IE are known to move the scrollbar to the left side for rtl
		isLeft = !!has("ie") || !!has("trident") || div.offsetLeft >= has("dom-scrollbar-width");
		cleanupTestElement(element);
		put(div, "!");
		element.removeAttribute("dir");
		return isLeft;
	});
	
	// var and function for autogenerating ID when one isn't provided
	var autogen = 0;
	function generateId(){
		return "dgrid_" + autogen++;
	}
	
	// common functions for class and className setters/getters
	// (these are run in instance context)
	var spaceRx = / +/g;
	function setClass(cls){
		// Format input appropriately for use with put...
		var putClass = cls ? "." + cls.replace(spaceRx, ".") : "";
		
		// Remove any old classes, and add new ones.
		if(this._class){
			putClass = "!" + this._class.replace(spaceRx, "!") + putClass;
		}
		put(this.domNode, putClass);
		
		// Store for later retrieval/removal.
		this._class = cls;
	}
	function getClass(){
		return this._class;
	}
	
	// window resize event handler, run in context of List instance
	var winResizeHandler = has("ie") < 7 && !has("quirks") ? function(){
		// IE6 triggers window.resize on any element resize;
		// avoid useless calls (and infinite loop if height: auto).
		// The measurement logic here is based on dojo/window logic.
		var root, w, h, dims;
		
		if(!this._started){ return; } // no sense calling resize yet
		
		root = document.documentElement;
		w = root.clientWidth;
		h = root.clientHeight;
		dims = this._prevWinDims || [];
		if(dims[0] !== w || dims[1] !== h){
			this.resize();
			this._prevWinDims = [w, h];
		}
	} :
	function(){
		if(this._started){ this.resize(); }
	};
	
	// Desktop versions of functions, deferred to when there is no touch support,
	// or when the useTouchScroll instance property is set to false
	
	function desktopGetScrollPosition(){
		return {
			x: this.bodyNode.scrollLeft,
			y: this.bodyNode.scrollTop
		};
	}
	
	function desktopScrollTo(options){
		if(typeof options.x !== "undefined"){
			this.bodyNode.scrollLeft = options.x;
		}
		if(typeof options.y !== "undefined"){
			this.bodyNode.scrollTop = options.y;
		}
	}
	
	return declare(has("touch") ? TouchScroll : null, {
		tabableHeader: false,
		// showHeader: Boolean
		//		Whether to render header (sub)rows.
		showHeader: false,
		
		// showFooter: Boolean
		//		Whether to render footer area.  Extensions which display content
		//		in the footer area should set this to true.
		showFooter: false,
		
		// maintainOddEven: Boolean
		//		Whether to maintain the odd/even classes when new rows are inserted.
		//		This can be disabled to improve insertion performance if odd/even styling is not employed.
		maintainOddEven: true,
		
		// cleanAddedRules: Boolean
		//		Whether to track rules added via the addCssRule method to be removed
		//		when the list is destroyed.  Note this is effective at the time of
		//		the call to addCssRule, not at the time of destruction.
		cleanAddedRules: true,
		
		// useTouchScroll: Boolean
		//		If touch support is available, this determines whether to
		//		incorporate logic from the TouchScroll module (at the expense of
		//		normal desktop/mouse or native mobile scrolling functionality).
		useTouchScroll: null,
		
		// addUiClasses: Boolean
		//		Whether to add jQuery UI classes to various elements in dgrid's DOM.
		addUiClasses: true,

		// shouldObserveStore: Boolean
		//		Whether this instance should observe any observable store it is passed.
		shouldObserveStore: true,
		
		// cleanEmptyObservers: Boolean
		//		Whether to clean up observers for empty result sets.
		cleanEmptyObservers: true,

		// highlightDuration: Integer
		//		The amount of time (in milliseconds) that a row should remain
		//		highlighted after it has been updated.
		highlightDuration: 250,
		
		postscript: function(params, srcNodeRef){
			// perform setup and invoke create in postScript to allow descendants to
			// perform logic before create/postCreate happen (a la dijit/_WidgetBase)
			var grid = this;
			
			(this._Row = function(id, object, element){
				this.id = id;
				this.data = object;
				this.element = element;
			}).prototype.remove = function(){
				grid.removeRow(this.element);
			};
			
			if(srcNodeRef){
				// normalize srcNodeRef and store on instance during create process.
				// Doing this in postscript is a bit earlier than dijit would do it,
				// but allows subclasses to access it pre-normalized during create.
				this.srcNodeRef = srcNodeRef =
					srcNodeRef.nodeType ? srcNodeRef : byId(srcNodeRef);
			}
			this.create(params, srcNodeRef);
		},
		listType: "list",
		
		create: function(params, srcNodeRef){
			var domNode = this.domNode = srcNodeRef || put("div"),
				cls;
			
			if(params){
				this.params = params;
				declare.safeMixin(this, params);
				
				// Check for initial class or className in params or on domNode
				cls = params["class"] || params.className || domNode.className;
				
				// handle sort param - TODO: revise @ 0.4 when _sort -> sort
				this._sort = params.sort || [];
				delete this.sort; // ensure back-compat method isn't shadowed
			}else{
				this._sort = [];
			}
			
			// ensure arrays and hashes are initialized
			this.observers = [];
			this._numObservers = 0;
			this._listeners = [];
			this._rowIdToObject = {};
			
			this.postMixInProperties && this.postMixInProperties();
			
			// Apply id to widget and domNode,
			// from incoming node, widget params, or autogenerated.
			this.id = domNode.id = domNode.id || this.id || generateId();
			
			// If useTouchScroll wasn't explicitly set on the instance, set it
			// now during creation (not up-front, in case document isn't ready)
			if(this.useTouchScroll === null){
				this.useTouchScroll = !has("dom-scrollbar-width");
			}
			
			// Perform initial rendering, and apply classes if any were specified.
			this.buildRendering();
			if(cls){ setClass.call(this, cls); }
			
			this.postCreate();
			
			// remove srcNodeRef instance property post-create
			delete this.srcNodeRef;
			// to preserve "it just works" behavior, call startup if we're visible
			if(this.domNode.offsetHeight){
				this.startup();
			}
		},
		buildRendering: function(){
			var domNode = this.domNode,
				addUiClasses = this.addUiClasses,
				self = this,
				headerNode, spacerNode, bodyNode, footerNode, isRTL;
			
			// Detect RTL on html/body nodes; taken from dojo/dom-geometry
			isRTL = this.isRTL = (document.body.dir || document.documentElement.dir ||
				document.body.style.direction).toLowerCase() == "rtl";
			
			// Clear out className (any pre-applied classes will be re-applied via the
			// class / className setter), then apply standard classes/attributes
			domNode.className = "";
			
			put(domNode, "[role=grid].dgrid.dgrid-" + this.listType +
				(addUiClasses ? ".ui-widget" : ""));
			
			// Place header node (initially hidden if showHeader is false).
			headerNode = this.headerNode = put(domNode, 
				"div.dgrid-header.dgrid-header-row" +
				(addUiClasses ? ".ui-widget-header" : "") +
				(this.showHeader ? "" : ".dgrid-header-hidden"));
			if(has("quirks") || has("ie") < 8){
				spacerNode = put(domNode, "div.dgrid-spacer");
			}
			bodyNode = this.bodyNode = put(domNode, "div.dgrid-scroller");
			
			// Firefox 4+ adds overflow: auto elements to the tab index by default;
			// force them to not be tabbable, but restrict this to Firefox,
			// since it breaks accessibility support in other browsers
			if(has("ff")){
				bodyNode.tabIndex = -1;
			}
			
			this.headerScrollNode = put(domNode, "div.dgrid-header.dgrid-header-scroll.dgrid-scrollbar-width" +
				(addUiClasses ? ".ui-widget-header" : ""));
			
			// Place footer node (initially hidden if showFooter is false).
			footerNode = this.footerNode = put("div.dgrid-footer" +
				(this.showFooter ? "" : ".dgrid-footer-hidden"));
			put(domNode, footerNode);
			
			if(isRTL){
				domNode.className += " dgrid-rtl" +
					(has("dom-rtl-scrollbar-left") ? " dgrid-rtl-swap" : "");
			}
			
			listen(bodyNode, "scroll", function(event){
				if(self.showHeader){
					// keep the header aligned with the body
					headerNode.scrollLeft = event.scrollLeft || bodyNode.scrollLeft;
				}
				// re-fire, since browsers are not consistent about propagation here
				event.stopPropagation();
				listen.emit(domNode, "scroll", {scrollTarget: bodyNode});
			});
			this.configStructure();
			this.renderHeader();
			
			this.contentNode = this.touchNode = put(this.bodyNode,
				"div.dgrid-content" + (addUiClasses ? ".ui-widget-content" : ""));
			// add window resize handler, with reference for later removal if needed
			this._listeners.push(this._resizeHandle = listen(window, "resize",
				miscUtil.throttleDelayed(winResizeHandler, this)));
		},
		
		postCreate: has("touch") ? function(){
			if(this.useTouchScroll){
				this.inherited(arguments);
			}
		} : function(){},
		
		startup: function(){
			// summary:
			//		Called automatically after postCreate if the component is already
			//		visible; otherwise, should be called manually once placed.
			
			if(this._started){ return; } // prevent double-triggering
			this.inherited(arguments);
			this._started = true;
			this.resize();
			// apply sort (and refresh) now that we're ready to render
			this.set("sort", this._sort);
		},
		
		configStructure: function(){
			// does nothing in List, this is more of a hook for the Grid
		},
		resize: function(){
			var
				bodyNode = this.bodyNode,
				headerNode = this.headerNode,
				footerNode = this.footerNode,
				headerHeight = headerNode.offsetHeight,
				footerHeight = this.showFooter ? footerNode.offsetHeight : 0,
				quirks = has("quirks") || has("ie") < 7;
			
			this.headerScrollNode.style.height = bodyNode.style.marginTop = headerHeight + "px";
			bodyNode.style.marginBottom = footerHeight + "px";
			
			if(quirks){
				// in IE6 and quirks mode, the "bottom" CSS property is ignored.
				// We guard against negative values in case of issues with external CSS.
				bodyNode.style.height = ""; // reset first
				bodyNode.style.height =
					Math.max((this.domNode.offsetHeight - headerHeight - footerHeight), 0) + "px";
				if (footerHeight) {
					// Work around additional glitch where IE 6 / quirks fails to update
					// the position of the bottom-aligned footer; this jogs its memory.
					footerNode.style.bottom = '1px';
					setTimeout(function(){ footerNode.style.bottom = ''; }, 0);
				}
			}
			
			if(!scrollbarWidth){
				// Measure the browser's scrollbar width using a DIV we'll delete right away
				scrollbarWidth = has("dom-scrollbar-width");
				scrollbarHeight = has("dom-scrollbar-height");
				
				// Avoid issues with certain widgets inside in IE7, and
				// ColumnSet scroll issues with all supported IE versions
				if(has("ie")){
					scrollbarWidth++;
					scrollbarHeight++;
				}
				
				// add rules that can be used where scrollbar width/height is needed
				miscUtil.addCssRule(".dgrid-scrollbar-width", "width: " + scrollbarWidth + "px");
				miscUtil.addCssRule(".dgrid-scrollbar-height", "height: " + scrollbarHeight + "px");
				
				if(scrollbarWidth != 17 && !quirks){
					// for modern browsers, we can perform a one-time operation which adds
					// a rule to account for scrollbar width in all grid headers.
					miscUtil.addCssRule(".dgrid-header-row", "right: " + scrollbarWidth + "px");
					// add another for RTL grids
					miscUtil.addCssRule(".dgrid-rtl-swap .dgrid-header-row", "left: " + scrollbarWidth + "px");
				}
			}
			
			if(quirks){
				// old IE doesn't support left + right + width:auto; set width directly
				headerNode.style.width = bodyNode.clientWidth + "px";
				setTimeout(function(){
					// sync up (after the browser catches up with the new width)
					headerNode.scrollLeft = bodyNode.scrollLeft;
				}, 0);
			}
		},
		
		addCssRule: function(selector, css){
			// summary:
			//		Version of util/misc.addCssRule which tracks added rules and removes
			//		them when the List is destroyed.
			
			var rule = miscUtil.addCssRule(selector, css);
			if(this.cleanAddedRules){
				// Although this isn't a listener, it shares the same remove contract
				this._listeners.push(rule);
			}
			return rule;
		},
		
		on: function(eventType, listener){
			// delegate events to the domNode
			var signal = listen(this.domNode, eventType, listener);
			if(!has("dom-addeventlistener")){
				this._listeners.push(signal);
			}
			return signal;
		},
		
		cleanup: function(){
			// summary:
			//		Clears out all rows currently in the list.
			
			var observers = this.observers,
				i;
			for(i in this._rowIdToObject){
				if(this._rowIdToObject[i] != this.columns){
					var rowElement = byId(i);
					if(rowElement){
						this.removeRow(rowElement, true);
					}
				}
			}
			// remove any store observers
			for(i = 0;i < observers.length; i++){
				var observer = observers[i];
				observer && observer.cancel();
			}
			this.observers = [];
			this._numObservers = 0;
			this.preload = null;
		},
		destroy: function(){
			// summary:
			//		Destroys this grid
			
			// Remove any event listeners and other such removables
			if(this._listeners){ // Guard against accidental subsequent calls to destroy
				for(var i = this._listeners.length; i--;){
					this._listeners[i].remove();
				}
				delete this._listeners;
			}
			
			this._started = false;
			this.cleanup();
			// destroy DOM
			put(this.domNode, "!");
			
			if(this.useTouchScroll){
				// Only call TouchScroll#destroy if we also initialized it
				this.inherited(arguments);
			}
		},
		refresh: function(){
			// summary:
			//		refreshes the contents of the grid
			this.cleanup();
			this._rowIdToObject = {};
			this._autoId = 0;
			
			// make sure all the content has been removed so it can be recreated
			this.contentNode.innerHTML = "";
			// Ensure scroll position always resets (especially for TouchScroll).
			this.scrollTo({ x: 0, y: 0 });
		},
		
		newRow: function(object, parentNode, beforeNode, i, options){
			if(parentNode){
				var row = this.insertRow(object, parentNode, beforeNode, i, options);
				put(row, ".dgrid-highlight" +
					(this.addUiClasses ? ".ui-state-highlight" : ""));
				setTimeout(function(){
					put(row, "!dgrid-highlight!ui-state-highlight");
				}, this.highlightDuration);
				return row;
			}
		},
		adjustRowIndices: function(firstRow){
			// this traverses through rows to maintain odd/even classes on the rows when indexes shift;
			var next = firstRow;
			var rowIndex = next.rowIndex;
			if(rowIndex > -1){ // make sure we have a real number in case this is called on a non-row
				do{
					// Skip non-numeric, non-rows
					if(next.rowIndex > -1){
						if(this.maintainOddEven){
							if((next.className + ' ').indexOf("dgrid-row ") > -1){
								put(next, '.' + (rowIndex % 2 == 1 ? oddClass : evenClass) + '!' + (rowIndex % 2 == 0 ? oddClass : evenClass));
							}
						}
						next.rowIndex = rowIndex++;
					}
				}while((next = next.nextSibling) && next.rowIndex != rowIndex);
			}
		},
		renderArray: function(results, beforeNode, options){
			// summary:
			//		This renders an array or collection of objects as rows in the grid, before the
			//		given node. This will listen for changes in the collection if an observe method
			//		is available (as it should be if it comes from an Observable data store).
			options = options || {};
			var self = this,
				start = options.start || 0,
				observers = this.observers,
				rows, container, observerIndex;
			
			if(!beforeNode){
				this._lastCollection = results;
			}
			if(results.observe && this.shouldObserveStore){
				// observe the results for changes
				self._numObservers++;
				var observer = results.observe(function(object, from, to){
					var row, firstRow, nextNode, parentNode;
					
					function advanceNext() {
						nextNode = (nextNode.connected || nextNode).nextSibling;
					}
					
					// a change in the data took place
					if(from > -1 && rows[from]){
						// remove from old slot
						row = rows.splice(from, 1)[0];
						// check to make sure the node is still there before we try to remove it
						// (in case it was moved to a different place in the DOM)
						if(row.parentNode == container){
							firstRow = row.nextSibling;
							if(firstRow){ // it's possible for this to have been already removed if it is in overlapping query results
								if(from != to){ // if from and to are identical, it is an in-place update and we don't want to alter the rowIndex at all
									firstRow.rowIndex--; // adjust the rowIndex so adjustRowIndices has the right starting point
								}
							}
							self.removeRow(row);
						}
						// Update count to reflect that we lost one row
						options.count--;
						// The removal of rows could cause us to need to page in more items
						if(self._processScroll){
							self._processScroll();
						}
					}
					if(to > -1){
						// Add to new slot (either before an existing row, or at the end)
						// First determine the DOM node that this should be placed before.
						if(rows.length){
							if(to === 0){ // if it is the first row, we can safely get the next item
								nextNode = rows[to];
								// Re-retrieve the element in case we are referring to an orphan
								nextNode = nextNode && correctElement(nextNode);
							}else{
								// If we are near the end of the page, we may not be able to retrieve the 
								// result from our own array, so go from the previous row and advance one
								nextNode = rows[to - 1];
								if(nextNode){
									nextNode = correctElement(nextNode);
									// Make sure to skip connected nodes, so we don't accidentally
									// insert a row in between a parent and its children.
									advanceNext();
								}
							}
						}else{
							// There are no rows.  Allow for subclasses to insert new rows somewhere other than
							// at the end of the parent node.
							nextNode = self._getFirstRowSibling && self._getFirstRowSibling(container);
						}
						// Make sure we don't trip over a stale reference to a
						// node that was removed, or try to place a node before
						// itself (due to overlapped queries)
						if(row && nextNode && row.id === nextNode.id){
							advanceNext();
						}
						if(nextNode && !nextNode.parentNode){
							nextNode = byId(nextNode.id);
						}
						parentNode = (beforeNode && beforeNode.parentNode) ||
							(nextNode && nextNode.parentNode) || self.contentNode;
						row = self.newRow(object, parentNode, nextNode, options.start + to, options);
						
						if(row){
							row.observerIndex = observerIndex;
							rows.splice(to, 0, row);
							if(!firstRow || to < from){
								// the inserted row is first, so we update firstRow to point to it
								var previous = row.previousSibling;
								// if we are not in sync with the previous row, roll the firstRow back one so adjustRowIndices can sync everything back up.
								firstRow = !previous || previous.rowIndex + 1 == row.rowIndex || row.rowIndex == 0 ?
									row : previous;
							}
						}
						options.count++;
					}
					
					if(from === 0){
						overlapRows(1, 1);
					}else if(from === results.length - (to === -1 ? 0 : 1)){
						// It was (re)moved from the end
						// (which was the previous length if it was a removal)
						overlapRows(0, 0);
					}
					
					from != to && firstRow && self.adjustRowIndices(firstRow);
					self._onNotification(rows, object, from, to);
				}, true);
				observerIndex = observers.push(observer) - 1;
			}
			var rowsFragment = document.createDocumentFragment(),
				lastRow;

			function overlapRows(){
				// This is responsible for setting row overlaps in result sets to
				// ensure that observable can always properly determine which page
				// an object belongs to.
				// This function uses kind of an esoteric argument, optimized for
				// performance and size, since it is called quite frequently.
				// `sides` is an array of overlapping operations, with a falsy item indicating
				// to add an overlap to the top, and a truthy item means to add an overlap
				// to the bottom (so [0, 1] adds one overlap to the top and the bottom)
				
				var sides = arguments;
				// Only perform row overlap in the case of observable results
				if(observerIndex > -1){
					// Iterate through the sides operations
					for(var i = 0; i < sides.length; i++){
						var top = sides[i];
						var lastRow = rows[top ? 0 : rows.length-1];
						lastRow = lastRow && correctElement(lastRow);
						// check to make sure we have a row, we won't if we don't have any rows
						if(lastRow){
							// Make sure we have the correct row element
							// (not one that was previously removed)
							var row = lastRow[top ? "previousSibling" : "nextSibling"];
							if(row){
								row = self.row(row);
							}
							if(row && row.element != lastRow){
								var method = top ? "unshift" : "push";
								// Take the row and data from the adjacent page and unshift to the
								// top or push to the bottom of our array of rows and results,
								// and adjust the count
								results[method](row.data);
								rows[method](row.element);
								options.count++;
							}
						}
					}
				}
			}
			function correctElement(row){
				// If a node has been orphaned, try to retrieve the correct in-document element
				// (use isDescendant since offsetParent is faulty in IE<9)
				if(!dom.isDescendant(row, self.domNode) && byId(row.id)){
					return self.row(row.id.slice(self.id.length + 5)).element;
				}
				// Fall back to the originally-specified element
				return row;
			}
			
			function mapEach(object){
				lastRow = self.insertRow(object, rowsFragment, null, start++, options);
				lastRow.observerIndex = observerIndex;
				return lastRow;
			}
			function whenError(error){
				if(typeof observerIndex !== "undefined"){
					observers[observerIndex].cancel();
					observers[observerIndex] = 0;
					self._numObservers--;
				}
				if(error){
					throw error;
				}
			}
			var originalRows;
			function whenDone(resolvedRows){
				// Save the original rows, before the overlapping is performed
				originalRows = resolvedRows.slice(0);
				container = beforeNode ? beforeNode.parentNode : self.contentNode;
				if(container && container.parentNode &&
						(container !== self.contentNode || resolvedRows.length)){
					container.insertBefore(rowsFragment, beforeNode || null);
					lastRow = resolvedRows[resolvedRows.length - 1];
					lastRow && self.adjustRowIndices(lastRow);
				}else if(observers[observerIndex] && self.cleanEmptyObservers){
					// Remove the observer and don't bother inserting;
					// rows are already out of view or there were none to track
					whenError();
				}
				rows = resolvedRows;
				if(observer){
					observer.rows = rows;
				}
			}
			
			// Now render the results
			if(results.map){
				rows = results.map(mapEach, console.error);
				if(rows.then){
					return results.then(function(resultsArray){
						results = resultsArray;
						return rows.then(function(resolvedRows){
							whenDone(resolvedRows);
							// Overlap rows in the results array when using observable
							// so that we can determine page boundary changes
							// (but return the original set)
							overlapRows(1, 1, 0, 0);
							return originalRows;
						});
					});
				}
			}else{
				rows = [];
				for(var i = 0, l = results.length; i < l; i++){
					rows[i] = mapEach(results[i]);
				}
			}
			
			whenDone(rows);
			overlapRows(1, 1, 0, 0);
			// Return the original rows, not the overlapped set
			return originalRows;
		},

		_onNotification: function(rows, object, from, to){
			// summary:
			//		Protected method called whenever a store notification is observed.
			//		Intended to be extended as necessary by mixins/extensions.
		},

		renderHeader: function(){
			// no-op in a plain list
		},
	    forceAutoId: false,
		_autoId: 0,
		insertRow: function(object, parent, beforeNode, i, options){
			// summary:
			//		Creates a single row in the grid.
			
			// Include parentId within row identifier if one was specified in options.
			// (This is used by tree to allow the same object to appear under
			// multiple parents.)
			var parentId = options.parentId,
				id = this.id + "-row-" + (parentId ? parentId + "-" : "") + 
					((this.store && this.store.getIdentity) ?
						this.store.getIdentity(object) : i),
				row = byId(id),
				previousRow = row && row.previousSibling;
			
			if(row){// if it existed elsewhere in the DOM, we will remove it, so we can recreate it
				if(row === beforeNode){
					beforeNode = (beforeNode.connected || beforeNode).nextSibling;
				}
				this.removeRow(row);
			}
			row = this.renderRow(object, options);
			row.className = (row.className || "") + " dgrid-row " +
				(i % 2 == 1 ? oddClass : evenClass) +
				(this.addUiClasses ? " ui-state-default" : "");
			// get the row id for easy retrieval
			this._rowIdToObject[row.id = id] = object;
			parent.insertBefore(row, beforeNode || null);
			if(previousRow){
				// in this case, we are pulling the row from another location in the grid, and we need to readjust the rowIndices from the point it was removed
				this.adjustRowIndices(previousRow);
			}
			row.rowIndex = i;
			return row;
		},
		renderRow: function(value, options){
			// summary:
			//		Responsible for returning the DOM for a single row in the grid.
			
			return put("div", "" + value);
		},
		removeRow: function(rowElement, justCleanup){
			// summary:
			//		Simply deletes the node in a plain List.
			//		Column plugins may aspect this to implement their own cleanup routines.
			// rowElement: Object|DOMNode
			//		Object or element representing the row to be removed.
			// justCleanup: Boolean
			//		If true, the row element will not be removed from the DOM; this can
			//		be used by extensions/plugins in cases where the DOM will be
			//		massively cleaned up at a later point in time.
			
			rowElement = rowElement.element || rowElement;
			delete this._rowIdToObject[rowElement.id];
			if(!justCleanup){
				put(rowElement, "!");
			}
		},
		
		row: function(target){
			// summary:
			//		Get the row object by id, object, node, or event
			var id;
			
			if(target instanceof this._Row){ return target; } // no-op; already a row
			
			if(target.target && target.target.nodeType){
				// event
				target = target.target;
			}
			if(target.nodeType){
				var object;
				do{
					var rowId = target.id;
					if((object = this._rowIdToObject[rowId])){
						return new this._Row(rowId.substring(this.id.length + 5), object, target); 
					}
					target = target.parentNode;
				}while(target && target != this.domNode);
				return;
			}
			if(typeof target == "object"){
				// assume target represents a store item
				id = this.store.getIdentity(target);
			}else{
				// assume target is a row ID
				id = target;
				target = this._rowIdToObject[this.id + "-row-" + id];
			}
			return new this._Row(id, target, byId(this.id + "-row-" + id));
		},
		cell: function(target){
			// this doesn't do much in a plain list
			return {
				row: this.row(target)
			};
		},
		
		_move: function(item, steps, targetClass, visible){
			var nextSibling, current, element;
			// Start at the element indicated by the provided row or cell object.
			element = current = item.element;
			steps = steps || 1;
			
			do{
				// Outer loop: move in the appropriate direction.
				if((nextSibling = current[steps < 0 ? "previousSibling" : "nextSibling"])){
					do{
						// Inner loop: advance, and dig into children if applicable.
						current = nextSibling;
						if(current && (current.className + " ").indexOf(targetClass + " ") > -1){
							// Element with the appropriate class name; count step, stop digging.
							element = current;
							steps += steps < 0 ? 1 : -1;
							break;
						}
						// If the next sibling isn't a match, drill down to search, unless
						// visible is true and children are hidden.
					}while((nextSibling = (!visible || !current.hidden) && current[steps < 0 ? "lastChild" : "firstChild"]));
				}else{
					current = current.parentNode;
					if(!current || current === this.bodyNode || current === this.headerNode){
						// Break out if we step out of the navigation area entirely.
						break;
					}
				}
			}while(steps);
			// Return the final element we arrived at, which might still be the
			// starting element if we couldn't navigate further in that direction.
			return element;
		},
		
		up: function(row, steps, visible){
			// summary:
			//		Returns the row that is the given number of steps (1 by default)
			//		above the row represented by the given object.
			// row:
			//		The row to navigate upward from.
			// steps:
			//		Number of steps to navigate up from the given row; default is 1.
			// visible:
			//		If true, rows that are currently hidden (i.e. children of
			//		collapsed tree rows) will not be counted in the traversal.
			// returns:
			//		A row object representing the appropriate row.  If the top of the
			//		list is reached before the given number of steps, the first row will
			//		be returned.
			if(!row.element){ row = this.row(row); }
			return this.row(this._move(row, -(steps || 1), "dgrid-row", visible));
		},
		down: function(row, steps, visible){
			// summary:
			//		Returns the row that is the given number of steps (1 by default)
			//		below the row represented by the given object.
			// row:
			//		The row to navigate downward from.
			// steps:
			//		Number of steps to navigate down from the given row; default is 1.
			// visible:
			//		If true, rows that are currently hidden (i.e. children of
			//		collapsed tree rows) will not be counted in the traversal.
			// returns:
			//		A row object representing the appropriate row.  If the bottom of the
			//		list is reached before the given number of steps, the last row will
			//		be returned.
			if(!row.element){ row = this.row(row); }
			return this.row(this._move(row, steps || 1, "dgrid-row", visible));
		},
		
		scrollTo: has("touch") ? function(options){
			// If TouchScroll is the superclass, defer to its implementation.
			return this.useTouchScroll ? this.inherited(arguments) :
				desktopScrollTo.call(this, options);
		} : desktopScrollTo,
		
		getScrollPosition: has("touch") ? function(){
			// If TouchScroll is the superclass, defer to its implementation.
			return this.useTouchScroll ? this.inherited(arguments) :
				desktopGetScrollPosition.call(this);
		} : desktopGetScrollPosition,
		
		get: function(/*String*/ name /*, ... */){
			// summary:
			//		Get a property on a List instance.
			//	name:
			//		The property to get.
			//	returns:
			//		The property value on this List instance.
			// description:
			//		Get a named property on a List object. The property may
			//		potentially be retrieved via a getter method in subclasses. In the base class
			//		this just retrieves the object's property.
			
			var fn = "_get" + name.charAt(0).toUpperCase() + name.slice(1);
			
			if(typeof this[fn] === "function"){
				return this[fn].apply(this, [].slice.call(arguments, 1));
			}
			
			// Alert users that try to use Dijit-style getter/setters so they dont get confused
			// if they try to use them and it does not work
			if(! 1  && typeof this[fn + "Attr"] === "function"){
				console.warn("dgrid: Use " + fn + " instead of " + fn + "Attr for getting " + name);
			}
			
			return this[name];
		},
		
		set: function(/*String*/ name, /*Object*/ value /*, ... */){
			//	summary:
			//		Set a property on a List instance
			//	name:
			//		The property to set.
			//	value:
			//		The value to set in the property.
			//	returns:
			//		The function returns this List instance.
			//	description:
			//		Sets named properties on a List object.
			//		A programmatic setter may be defined in subclasses.
			//
			//		set() may also be called with a hash of name/value pairs, ex:
			//	|	myObj.set({
			//	|		foo: "Howdy",
			//	|		bar: 3
			//	|	})
			//		This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
			
			if(typeof name === "object"){
				for(var k in name){
					this.set(k, name[k]);
				}
			}else{
				var fn = "_set" + name.charAt(0).toUpperCase() + name.slice(1);
				
				if(typeof this[fn] === "function"){
					this[fn].apply(this, [].slice.call(arguments, 1));
				}else{
					// Alert users that try to use Dijit-style getter/setters so they dont get confused
					// if they try to use them and it does not work
					if(! 1  && typeof this[fn + "Attr"] === "function"){
						console.warn("dgrid: Use " + fn + " instead of " + fn + "Attr for setting " + name);
					}
					
					this[name] = value;
				}
			}
			
			return this;
		},
		
		// Accept both class and className programmatically to set domNode class.
		_getClass: getClass,
		_setClass: setClass,
		_getClassName: getClass,
		_setClassName: setClass,
		
		_setSort: function(property, descending){
			// summary:
			//		Sort the content
			// property: String|Array
			//		String specifying field to sort by, or actual array of objects
			//		with attribute and descending properties
			// descending: boolean
			//		In the case where property is a string, this argument
			//		specifies whether to sort ascending (false) or descending (true)
			
			this._sort = typeof property != "string" ? property :
				[{attribute: property, descending: descending}];
			
			this.refresh();
			
			if(this._lastCollection){
				if(property.length){
					// if an array was passed in, flatten to just first sort attribute
					// for default array sort logic
					if(typeof property != "string"){
						descending = property[0].descending;
						property = property[0].attribute;
					}
					
					this._lastCollection.sort(function(a,b){
						var aVal = a[property], bVal = b[property];
						// fall back undefined values to "" for more consistent behavior
						if(aVal === undefined){ aVal = ""; }
						if(bVal === undefined){ bVal = ""; }
						return aVal == bVal ? 0 : (aVal > bVal == !descending ? 1 : -1);
					});
				}
				this.renderArray(this._lastCollection);
			}
		},
		// TODO: remove the following two (and rename _sort to sort) in 0.4
		sort: function(property, descending){
			kernel.deprecated("sort(...)", 'use set("sort", ...) instead', "dgrid 0.4");
			this.set("sort", property, descending);
		},
		_getSort: function(){
			return this._sort;
		},
		
		_setShowHeader: function(show){
			// this is in List rather than just in Grid, primarily for two reasons:
			// (1) just in case someone *does* want to show a header in a List
			// (2) helps address IE < 8 header display issue in List
			
			var headerNode = this.headerNode;
			
			this.showHeader = show;
			
			// add/remove class which has styles for "hiding" header
			put(headerNode, (show ? "!" : ".") + "dgrid-header-hidden");
			
			this.renderHeader();
			this.resize(); // resize to account for (dis)appearance of header
			
			if(show){
				// Update scroll position of header to make sure it's in sync.
				headerNode.scrollLeft = this.getScrollPosition().x;
			}
		},
		setShowHeader: function(show){
			kernel.deprecated("setShowHeader(...)", 'use set("showHeader", ...) instead', "dgrid 0.4");
			this.set("showHeader", show);
		},
		
		_setShowFooter: function(show){
			this.showFooter = show;
			
			// add/remove class which has styles for hiding footer
			put(this.footerNode, (show ? "!" : ".") + "dgrid-footer-hidden");
			
			this.resize(); // to account for (dis)appearance of footer
		}
	});
});

},
'dgrid/util/misc':function(){
define([
	"dojo/has",
	"put-selector/put"
], function(has, put){
	// summary:
	//		This module defines miscellaneous utility methods for purposes of
	//		adding styles, and throttling/debouncing function calls.
	
	has.add("dom-contains", function(global, doc, element){
		return !!element.contains; // not supported by FF < 9
	});
	
	// establish an extra stylesheet which addCssRule calls will use,
	// plus an array to track actual indices in stylesheet for removal
	var extraRules = [],
		extraSheet,
		removeMethod,
		rulesProperty,
		invalidCssChars = /([^A-Za-z0-9_\u00A0-\uFFFF-])/g;
	
	function removeRule(index){
		// Function called by the remove method on objects returned by addCssRule.
		var realIndex = extraRules[index],
			i, l;
		if (realIndex === undefined) { return; } // already removed
		
		// remove rule indicated in internal array at index
		extraSheet[removeMethod](realIndex);
		
		// Clear internal array item representing rule that was just deleted.
		// NOTE: we do NOT splice, since the point of this array is specifically
		// to negotiate the splicing that occurs in the stylesheet itself!
		extraRules[index] = undefined;
		
		// Then update array items as necessary to downshift remaining rule indices.
		// Can start at index + 1, since array is sparse but strictly increasing.
		for(i = index + 1, l = extraRules.length; i < l; i++){
			if(extraRules[i] > realIndex){ extraRules[i]--; }
		}
	}
	
	var util = {
		// Throttle/debounce functions
		
		defaultDelay: 15,
		throttle: function(cb, context, delay){
			// summary:
			//		Returns a function which calls the given callback at most once per
			//		delay milliseconds.  (Inspired by plugd)
			var ran = false;
			delay = delay || util.defaultDelay;
			return function(){
				if(ran){ return; }
				ran = true;
				cb.apply(context, arguments);
				setTimeout(function(){ ran = false; }, delay);
			};
		},
		throttleDelayed: function(cb, context, delay){
			// summary:
			//		Like throttle, except that the callback runs after the delay,
			//		rather than before it.
			var ran = false;
			delay = delay || util.defaultDelay;
			return function(){
				if(ran){ return; }
				ran = true;
				var a = arguments;
				setTimeout(function(){
					ran = false;
					cb.apply(context, a);
				}, delay);
			};
		},
		debounce: function(cb, context, delay){
			// summary:
			//		Returns a function which calls the given callback only after a
			//		certain time has passed without successive calls.  (Inspired by plugd)
			var timer;
			delay = delay || util.defaultDelay;
			return function(){
				if(timer){
					clearTimeout(timer);
					timer = null;
				}
				var a = arguments;
				timer = setTimeout(function(){
					cb.apply(context, a);
				}, delay);
			};
		},
		
		// Iterative functions
		
		each: function(arrayOrObject, callback, context){
			// summary:
			//		Given an array or object, iterates through its keys.
			//		Does not use hasOwnProperty (since even Dojo does not
			//		consistently use it), but will iterate using a for or for-in
			//		loop as appropriate.
			
			var i, len;
			
			if(!arrayOrObject){
				return;
			}
			
			if(typeof arrayOrObject.length === "number"){
				for(i = 0, len = arrayOrObject.length; i < len; i++){
					callback.call(context, arrayOrObject[i], i, arrayOrObject);
				}
			}else{
				for(i in arrayOrObject){
					callback.call(context, arrayOrObject[i], i, arrayOrObject);
				}
			}
		},
		
		// DOM-related functions
		
		contains: function(parent, node){
			// summary:
			//		Checks to see if an element is contained in another element.
			
			if(has("dom-contains")){
				return parent.contains(node);
			}else{
				return parent.compareDocumentPosition(node) & 8 /* DOCUMENT_POSITION_CONTAINS */;
			}
		},
		
		// CSS-related functions
		
		addCssRule: function(selector, css){
			// summary:
			//		Dynamically adds a style rule to the document.  Returns an object
			//		with a remove method which can be called to later remove the rule.
			
			if(!extraSheet){
				// First time, create an extra stylesheet for adding rules
				extraSheet = put(document.getElementsByTagName("head")[0], "style");
				// Keep reference to actual StyleSheet object (`styleSheet` for IE < 9)
				extraSheet = extraSheet.sheet || extraSheet.styleSheet;
				// Store name of method used to remove rules (`removeRule` for IE < 9)
				removeMethod = extraSheet.deleteRule ? "deleteRule" : "removeRule";
				// Store name of property used to access rules (`rules` for IE < 9)
				rulesProperty = extraSheet.cssRules ? "cssRules" : "rules";
			}
			
			var index = extraRules.length;
			extraRules[index] = (extraSheet.cssRules || extraSheet.rules).length;
			extraSheet.addRule ?
				extraSheet.addRule(selector, css) :
				extraSheet.insertRule(selector + '{' + css + '}', extraRules[index]);
			
			return {
				get: function(prop) {
					return extraSheet[rulesProperty][extraRules[index]].style[prop];
				},
				set: function(prop, value) {
					if (typeof extraRules[index] !== "undefined") {
						extraSheet[rulesProperty][extraRules[index]].style[prop] = value;
					}
				},
				remove: function(){
					removeRule(index);
				}
			};
		},
		
		escapeCssIdentifier: function(id, replace){
			// summary:
			//		Escapes normally-invalid characters in a CSS identifier (such as . or :);
			//		see http://www.w3.org/TR/CSS2/syndata.html#value-def-identifier
			// id: String
			//		CSS identifier (e.g. tag name, class, or id) to be escaped
			// replace: String?
			//		If specified, indicates that invalid characters should be
			//		replaced by the given string rather than being escaped
			
			return typeof id === 'string' ? id.replace(invalidCssChars, replace || "\\$1") : id;
		}
	};
	return util;
});
},
'put-selector/put':function(){
(function(define){
var forDocument, fragmentFasterHeuristic = /[-+,> ]/; // if it has any of these combinators, it is probably going to be faster with a document fragment 
define([], forDocument = function(doc, newFragmentFasterHeuristic){
	// module:
	//		put-selector/put
	// summary:
	//		This module defines a fast lightweight function for updating and creating new elements
	//		terse, CSS selector-based syntax. The single function from this module creates
	// 		new DOM elements and updates existing elements. See README.md for more information.
	//	examples:
	//		To create a simple div with a class name of "foo":
	//		|	put("div.foo");
	fragmentFasterHeuristic = newFragmentFasterHeuristic || fragmentFasterHeuristic;
	var selectorParse = /(?:\s*([-+ ,<>]))?\s*(\.|!\.?|#)?([-\w%$|]+)?(?:\[([^\]=]+)=?['"]?([^\]'"]*)['"]?\])?/g,
		undefined, namespaceIndex, namespaces = false,
		doc = doc || document,
		ieCreateElement = typeof doc.createElement == "object"; // telltale sign of the old IE behavior with createElement that does not support later addition of name 
	function insertTextNode(element, text){
		element.appendChild(doc.createTextNode(text));
	}
	function put(topReferenceElement){
		var fragment, lastSelectorArg, nextSibling, referenceElement, current,
			args = arguments,
			returnValue = args[0]; // use the first argument as the default return value in case only an element is passed in
		function insertLastElement(){
			// we perform insertBefore actions after the element is fully created to work properly with 
			// <input> tags in older versions of IE that require type attributes
			//	to be set before it is attached to a parent.
			// We also handle top level as a document fragment actions in a complex creation 
			// are done on a detached DOM which is much faster
			// Also if there is a parse error, we generally error out before doing any DOM operations (more atomic) 
			if(current && referenceElement && current != referenceElement){
				(referenceElement == topReferenceElement &&
					// top level, may use fragment for faster access 
					(fragment || 
						// fragment doesn't exist yet, check to see if we really want to create it 
						(fragment = fragmentFasterHeuristic.test(argument) && doc.createDocumentFragment()))
							// any of the above fails just use the referenceElement  
							 ? fragment : referenceElement).
								insertBefore(current, nextSibling || null); // do the actual insertion
			}
		}
		for(var i = 0; i < args.length; i++){
			var argument = args[i];
			if(typeof argument == "object"){
				lastSelectorArg = false;
				if(argument instanceof Array){
					// an array
					current = doc.createDocumentFragment();
					for(var key = 0; key < argument.length; key++){
						current.appendChild(put(argument[key]));
					}
					argument = current;
				}
				if(argument.nodeType){
					current = argument;
					insertLastElement();
					referenceElement = argument;
					nextSibling = 0;
				}else{
					// an object hash
					for(var key in argument){
						current[key] = argument[key];
					}				
				}
			}else if(lastSelectorArg){
				// a text node should be created
				// take a scalar value, use createTextNode so it is properly escaped
				// createTextNode is generally several times faster than doing an escaped innerHTML insertion: http://jsperf.com/createtextnode-vs-innerhtml/2
				lastSelectorArg = false;
				insertTextNode(current, argument);
			}else{
				if(i < 1){
					// if we are starting with a selector, there is no top element
					topReferenceElement = null;
				}
				lastSelectorArg = true;
				var leftoverCharacters = argument.replace(selectorParse, function(t, combinator, prefix, value, attrName, attrValue){
					if(combinator){
						// insert the last current object
						insertLastElement();
						if(combinator == '-' || combinator == '+'){
							// + or - combinator, 
							// TODO: add support for >- as a means of indicating before the first child?
							referenceElement = (nextSibling = (current || referenceElement)).parentNode;
							current = null;
							if(combinator == "+"){
								nextSibling = nextSibling.nextSibling;
							}// else a - operator, again not in CSS, but obvious in it's meaning (create next element before the current/referenceElement)
						}else{
							if(combinator == "<"){
								// parent combinator (not really in CSS, but theorized, and obvious in it's meaning)
								referenceElement = current = (current || referenceElement).parentNode;
							}else{
								if(combinator == ","){
									// comma combinator, start a new selector
									referenceElement = topReferenceElement;
								}else if(current){
									// else descendent or child selector (doesn't matter, treated the same),
									referenceElement = current;
								}
								current = null;
							}
							nextSibling = 0;
						}
						if(current){
							referenceElement = current;
						}
					}
					var tag = !prefix && value;
					if(tag || (!current && (prefix || attrName))){
						if(tag == "$"){
							// this is a variable to be replaced with a text node
							insertTextNode(referenceElement, args[++i]);
						}else{
							// Need to create an element
							tag = tag || put.defaultTag;
							var ieInputName = ieCreateElement && args[i +1] && args[i +1].name;
							if(ieInputName){
								// in IE, we have to use the crazy non-standard createElement to create input's that have a name 
								tag = '<' + tag + ' name="' + ieInputName + '">';
							}
							// we swtich between creation methods based on namespace usage
							current = namespaces && ~(namespaceIndex = tag.indexOf('|')) ?
								doc.createElementNS(namespaces[tag.slice(0, namespaceIndex)], tag.slice(namespaceIndex + 1)) : 
								doc.createElement(tag);
						}
					}
					if(prefix){
						if(value == "$"){
							value = args[++i];
						}
						if(prefix == "#"){
							// #id was specified
							current.id = value;
						}else{
							// we are in the className addition and removal branch
							var currentClassName = current.className;
							// remove the className (needed for addition or removal)
							// see http://jsperf.com/remove-class-name-algorithm/2 for some tests on this
							var removed = currentClassName && (" " + currentClassName + " ").replace(" " + value + " ", " ");
							if(prefix == "."){
								// addition, add the className
								current.className = currentClassName ? (removed + value).substring(1) : value;
							}else{
								// else a '!' class removal
								if(argument == "!"){
									var parentNode;
									// special signal to delete this element
									if(ieCreateElement){
										// use the ol' innerHTML trick to get IE to do some cleanup
										put("div", current, '<').innerHTML = "";
									}else if(parentNode = current.parentNode){ // intentional assigment
										// use a faster, and more correct (for namespaced elements) removal (http://jsperf.com/removechild-innerhtml)
										parentNode.removeChild(current);
									}
								}else{
									// we already have removed the class, just need to trim
									removed = removed.substring(1, removed.length - 1);
									// only assign if it changed, this can save a lot of time
									if(removed != currentClassName){
										current.className = removed;
									}
								}
							}
							// CSS class removal
						}
					}
					if(attrName){
						if(attrValue == "$"){
							attrValue = args[++i];
						}
						// [name=value]
						if(attrName == "style"){
							// handle the special case of setAttribute not working in old IE
							current.style.cssText = attrValue;
						}else{
							var method = attrName.charAt(0) == "!" ? (attrName = attrName.substring(1)) && 'removeAttribute' : 'setAttribute';
							attrValue = attrValue === '' ? attrName : attrValue;
							// determine if we need to use a namespace
							namespaces && ~(namespaceIndex = attrName.indexOf('|')) ?
								current[method + "NS"](namespaces[attrName.slice(0, namespaceIndex)], attrName.slice(namespaceIndex + 1), attrValue) :
								current[method](attrName, attrValue);
						}
					}
					return '';
				});
				if(leftoverCharacters){
					throw new SyntaxError("Unexpected char " + leftoverCharacters + " in " + argument);
				}
				insertLastElement();
				referenceElement = returnValue = current || referenceElement;
			}
		}
		if(topReferenceElement && fragment){
			// we now insert the top level elements for the fragment if it exists
			topReferenceElement.appendChild(fragment);
		}
		return returnValue;
	}
	put.addNamespace = function(name, uri){
		if(doc.createElementNS){
			(namespaces || (namespaces = {}))[name] = uri;
		}else{
			// for old IE
			doc.namespaces.add(name, uri);
		}
	};
	put.defaultTag = "div";
	put.forDocument = forDocument;
	return put;
});
})(function(id, deps, factory){
	factory = factory || deps;
	if(typeof define === "function"){
		// AMD loader
		define([], function(){
			return factory();
		});
	}else if(typeof window == "undefined"){
		// server side JavaScript, probably (hopefully) NodeJS
		require("./node-html")(module, factory);
	}else{
		// plain script in a browser
		put = factory();
	}
});

},
'xstyle/has-class':function(){
define(["dojo/has"], function(has){
	var tested = {};
	return function(){
		var test, args = arguments;
		for(var i = 0; i < args.length; i++){
			var test = args[i];
			if(!tested[test]){
				tested[test] = true;
				var parts = test.match(/^(no-)?(.+?)((-[\d\.]+)(-[\d\.]+)?)?$/), // parse the class name
					hasResult = has(parts[2]), // the actual has test
					lower = -parts[4]; // lower bound if it is in the form of test-4 or test-4-6 (would be 4)
				if((lower > 0 ? lower <= hasResult && (-parts[5] || lower) >= hasResult :  // if it has a range boundary, compare to see if we are in it
						!!hasResult) == !parts[1]){ // parts[1] is the no- prefix that can negate the result
					document.documentElement.className += ' has-' + test;
				}
			}
		}
	}
});
},
'xstyle/css':function(){
define(["require"], function(moduleRequire){
/*
 * AMD css! plugin
 * This plugin will load and wait for css files.  This could be handy when
 * loading css files as part of a layer or as a way to apply a run-time theme. This
 * module checks to see if the CSS is already loaded before incurring the cost
 * of loading the full CSS loader codebase
 */
 	function testElementStyle(tag, id, property){
 		// test an element's style
		var docElement = document.documentElement;
		var testDiv = docElement.insertBefore(document.createElement(tag), docElement.firstChild);
		testDiv.id = id;
		var styleValue = (testDiv.currentStyle || getComputedStyle(testDiv, null))[property];
		docElement.removeChild(testDiv);
 		return styleValue;
 	} 
 	return {
		load: function(resourceDef, require, callback, config) {
			var url = require.toUrl(resourceDef);
			var cachedCss = require.cache && require.cache['url:' + url];
			if(cachedCss){
				// we have CSS cached inline in the build
				if(cachedCss.xCss){
					var parser = cachedCss.parser;
					var xCss =cachedCss.xCss;
					cachedCss = cachedCss.cssText;
				}
				moduleRequire(['./util/createStyleSheet'],function(createStyleSheet){
					createStyleSheet(cachedCss);
				});
				if(xCss){
					//require([parsed], callback);
				}
				return checkForParser();
			}
			function checkForParser(){
				var parser = testElementStyle('x-parse', null, 'content');
				if(parser && parser != 'none' && parser != 'normal'){
					// TODO: wait for parser to load
					require([eval(parser)], callback);
				}else{
					callback();
				}
			}
			
			// if there is an id test available, see if the referenced rule is already loaded,
			// and if so we can completely avoid any dynamic CSS loading. If it is
			// not present, we need to use the dynamic CSS loader.
			var displayStyle = testElementStyle('div', resourceDef.replace(/\//g,'-').replace(/\..*/,'') + "-loaded", 'display');
			if(displayStyle == "none"){
				return checkForParser();
			}
			// use dynamic loader
			moduleRequire(["./core/load-css"], function(load){
				load(url, checkForParser);
			});
		}
	};
});

},
'xstyle/util/createStyleSheet':function(){
define([], function(){
	function has(){
		return !document.createStyleSheet;
	}
	var head = document.head;
	return function insertCss(css){
		if(has("dom-create-style-element")){
			// we can use standard <style> element creation
			styleSheet = document.createElement("style");
			styleSheet.setAttribute("type", "text/css");
			styleSheet.appendChild(document.createTextNode(css));
			head.insertBefore(styleSheet, head.lastChild);
			return styleSheet;
		}
		else{
			var styleSheet = document.createStyleSheet();
			styleSheet.cssText = css;
			return styleSheet.owningElement;
		}
	}
});
},
'dgrid/OnDemandGrid':function(){
define(["dojo/_base/declare", "./Grid", "./OnDemandList"], function(declare, Grid, OnDemandList){
	return declare([Grid, OnDemandList], {});
});
},
'dgrid/Grid':function(){
define(["dojo/_base/kernel", "dojo/_base/declare", "dojo/on", "dojo/has", "put-selector/put", "./List", "./util/misc", "dojo/_base/sniff"],
function(kernel, declare, listen, has, put, List, miscUtil){
	var contentBoxSizing = has("ie") < 8 && !has("quirks");
	
	function appendIfNode(parent, subNode){
		if(subNode && subNode.nodeType){
			parent.appendChild(subNode);
		}
	}
	
	function replaceInvalidChars(str) {
		// Replaces invalid characters for a CSS identifier with hyphen,
		// as dgrid does for field names / column IDs when adding classes.
		return miscUtil.escapeCssIdentifier(str, "-");
	}
	
	var Grid = declare(List, {
		columns: null,
		// cellNavigation: Boolean
		//		This indicates that focus is at the cell level. This may be set to false to cause
		//		focus to be at the row level, which is useful if you want only want row-level
		//		navigation.
		cellNavigation: true,
		tabableHeader: true,
		showHeader: true,
		column: function(target){
			// summary:
			//		Get the column object by node, or event, or a columnId
			if(typeof target != "object"){
				return this.columns[target];
			}else{
				return this.cell(target).column;
			}
		},
		listType: "grid",
		cell: function(target, columnId){
			// summary:
			//		Get the cell object by node, or event, id, plus a columnId
			
			if(target.column && target.element){ return target; }
			
			if(target.target && target.target.nodeType){
				// event
				target = target.target;
			}
			var element;
			if(target.nodeType){
				var object;
				do{
					if(this._rowIdToObject[target.id]){
						break;
					}
					var colId = target.columnId;
					if(colId){
						columnId = colId;
						element = target;
						break;
					}
					target = target.parentNode;
				}while(target && target != this.domNode);
			}
			if(!element && typeof columnId != "undefined"){
				var row = this.row(target),
					rowElement = row && row.element;
				if(rowElement){
					var elements = rowElement.getElementsByTagName("td");
					for(var i = 0; i < elements.length; i++){
						if(elements[i].columnId == columnId){
							element = elements[i];
							break;
						}
					}
				}
			}
			if(target != null){
				return {
					row: row || this.row(target),
					column: columnId && this.column(columnId),
					element: element
				};
			}
		},
		
		createRowCells: function(tag, each, subRows, object){
			// summary:
			//		Generates the grid for each row (used by renderHeader and and renderRow)
			var row = put("table.dgrid-row-table[role=presentation]"),
				cellNavigation = this.cellNavigation,
				// IE < 9 needs an explicit tbody; other browsers do not
				tbody = (has("ie") < 9 || has("quirks")) ? put(row, "tbody") : row,
				tr,
				si, sl, i, l, // iterators
				subRow, column, id, extraClasses, className,
				cell, innerCell, colSpan, rowSpan; // used inside loops
			
			// Allow specification of custom/specific subRows, falling back to
			// those defined on the instance.
			subRows = subRows || this.subRows;
			
			for(si = 0, sl = subRows.length; si < sl; si++){
				subRow = subRows[si];
				// for single-subrow cases in modern browsers, TR can be skipped
				// http://jsperf.com/table-without-trs
				tr = put(tbody, "tr");
				if(subRow.className){
					put(tr, "." + subRow.className);
				}

				for(i = 0, l = subRow.length; i < l; i++){
					// iterate through the columns
					column = subRow[i];
					id = column.id;

					extraClasses = column.field ?
						".field-" + replaceInvalidChars(column.field) :
						"";
					className = typeof column.className === "function" ?
						column.className(object) : column.className;
					if(className){
						extraClasses += "." + className;
					}

					cell = put(tag + (
							".dgrid-cell.dgrid-cell-padding" +
							(id ? ".dgrid-column-" + replaceInvalidChars(id) : "") +
							extraClasses.replace(/ +/g, ".")
						) + "[role=" + (tag === "th" ? "columnheader" : "gridcell") + "]");
					cell.columnId = id;
					if(contentBoxSizing){
						// The browser (IE7-) does not support box-sizing: border-box, so we emulate it with a padding div
						innerCell = put(cell, "!dgrid-cell-padding div.dgrid-cell-padding");// remove the dgrid-cell-padding, and create a child with that class
						cell.contents = innerCell;
					}else{
						innerCell = cell;
					}
					colSpan = column.colSpan;
					if(colSpan){
						cell.colSpan = colSpan;
					}
					rowSpan = column.rowSpan;
					if(rowSpan){
						cell.rowSpan = rowSpan;
					}
					each(innerCell, column);
					// add the td to the tr at the end for better performance
					tr.appendChild(cell);
				}
			}
			return row;
		},
		
		left: function(cell, steps){
			if(!cell.element){ cell = this.cell(cell); }
			return this.cell(this._move(cell, -(steps || 1), "dgrid-cell"));
		},
		right: function(cell, steps){
			if(!cell.element){ cell = this.cell(cell); }
			return this.cell(this._move(cell, steps || 1, "dgrid-cell"));
		},
		
		renderRow: function(object, options){
			var self = this;
			var row = this.createRowCells("td", function(td, column){
				var data = object;
				// Support get function or field property (similar to DataGrid)
				if(column.get){
					data = column.get(object);
				}else if("field" in column && column.field != "_item"){
					data = data[column.field];
				}
				
				if(column.renderCell){
					// A column can provide a renderCell method to do its own DOM manipulation,
					// event handling, etc.
					appendIfNode(td, column.renderCell(object, data, td, options));
				}else{
					defaultRenderCell.call(column, object, data, td, options);
				}
			}, options && options.subRows, object);
			// row gets a wrapper div for a couple reasons:
			//	1. So that one can set a fixed height on rows (heights can't be set on <table>'s AFAICT)
			// 2. So that outline style can be set on a row when it is focused, and Safari's outline style is broken on <table>
			return put("div[role=row]>", row);
		},
		renderHeader: function(){
			// summary:
			//		Setup the headers for the grid
			var
				grid = this,
				columns = this.columns,
				headerNode = this.headerNode,
				i = headerNode.childNodes.length;
			
			headerNode.setAttribute("role", "row");
			
			// clear out existing header in case we're resetting
			while(i--){
				put(headerNode.childNodes[i], "!");
			}
			
			var row = this.createRowCells("th", function(th, column){
				var contentNode = column.headerNode = th;
				if(contentBoxSizing){
					// we're interested in the th, but we're passed the inner div
					th = th.parentNode;
				}
				var field = column.field;
				if(field){
					th.field = field;
				}
				// allow for custom header content manipulation
				if(column.renderHeaderCell){
					appendIfNode(contentNode, column.renderHeaderCell(contentNode));
				}else if("label" in column || column.field){
					contentNode.appendChild(document.createTextNode(
						"label" in column ? column.label : column.field));
				}
				if(column.sortable !== false && field && field != "_item"){
					th.sortable = true;
					th.className += " dgrid-sortable";
				}
			}, this.subRows && this.subRows.headerRows);
			this._rowIdToObject[row.id = this.id + "-header"] = this.columns;
			headerNode.appendChild(row);
			
			// If the columns are sortable, re-sort on clicks.
			// Use a separate listener property to be managed by renderHeader in case
			// of subsequent calls.
			if(this._sortListener){
				this._sortListener.remove();
			}
			this._sortListener = listen(row, "click,keydown", function(event){
				// respond to click, space keypress, or enter keypress
				if(event.type == "click" || event.keyCode == 32 /* space bar */ || (!has("opera") && event.keyCode == 13) /* enter */){
					var target = event.target,
						field, sort, newSort, eventObj;
					do{
						if(target.sortable){
							// If the click is on the same column as the active sort,
							// reverse sort direction
							newSort = [{
								attribute: (field = target.field || target.columnId),
								descending: (sort = grid._sort[0]) && sort.attribute == field &&
									!sort.descending
							}];
							
							// Emit an event with the new sort
							eventObj = {
								bubbles: true,
								cancelable: true,
								grid: grid,
								parentType: event.type,
								sort: newSort
							};
							
							if (listen.emit(event.target, "dgrid-sort", eventObj)){
								// Stash node subject to DOM manipulations,
								// to be referenced then removed by sort()
								grid._sortNode = target;
								grid.set("sort", newSort);
							}
							
							break;
						}
					}while((target = target.parentNode) && target != headerNode);
				}
			});
		},
		
		resize: function(){
			// extension of List.resize to allow accounting for
			// column sizes larger than actual grid area
			var
				headerTableNode = this.headerNode.firstChild,
				contentNode = this.contentNode,
				width;
			
			this.inherited(arguments);
			
			if(!has("ie") || (has("ie") > 7 && !has("quirks"))){
				// Force contentNode width to match up with header width.
				// (Old IEs don't have a problem due to how they layout.)
				
				contentNode.style.width = ""; // reset first
				
				if(contentNode && headerTableNode){
					if((width = headerTableNode.offsetWidth) != contentNode.offsetWidth){
						// update size of content node if necessary (to match size of rows)
						// (if headerTableNode can't be found, there isn't much we can do)
						contentNode.style.width = width + "px";
					}
				}
			}
		},
		
		destroy: function(){
			// Run _destroyColumns first to perform any column plugin tear-down logic.
			this._destroyColumns();
			if(this._sortListener){
				this._sortListener.remove();
			}
			
			this.inherited(arguments);
		},
		
		_setSort: function(property, descending){
			// summary:
			//		Extension of List.js sort to update sort arrow in UI
			
			// Normalize _sort first via inherited logic, then update the sort arrow
			this.inherited(arguments);
			this.updateSortArrow(this._sort);
		},
		
		_findSortArrowParent: function(field){
			// summary:
			//		Method responsible for finding cell that sort arrow should be
			//		added under.  Called by updateSortArrow; separated for extensibility.
			
			var columns = this.columns;
			for(var i in columns){
				var column = columns[i];
				if(column.field == field){
					return column.headerNode;
				}
			}
		},
		
		updateSortArrow: function(sort, updateSort){
			// summary:
			//		Method responsible for updating the placement of the arrow in the
			//		appropriate header cell.  Typically this should not be called (call
			//		set("sort", ...) when actually updating sort programmatically), but
			//		this method may be used by code which is customizing sort (e.g.
			//		by reacting to the dgrid-sort event, canceling it, then
			//		performing logic and calling this manually).
			// sort: Array
			//		Standard sort parameter - array of object(s) containing attribute
			//		and optionally descending property
			// updateSort: Boolean?
			//		If true, will update this._sort based on the passed sort array
			//		(i.e. to keep it in sync when custom logic is otherwise preventing
			//		it from being updated); defaults to false
			
			// Clean up UI from any previous sort
			if(this._lastSortedArrow){
				// Remove the sort classes from the parent node
				put(this._lastSortedArrow, "<!dgrid-sort-up!dgrid-sort-down");
				// Destroy the lastSortedArrow node
				put(this._lastSortedArrow, "!");
				delete this._lastSortedArrow;
			}
			
			if(updateSort){ this._sort = sort; }
			if(!sort[0]){ return; } // nothing to do if no sort is specified
			
			var prop = sort[0].attribute,
				desc = sort[0].descending,
				// if invoked from header click, target is stashed in _sortNode
				target = this._sortNode || this._findSortArrowParent(prop),
				arrowNode;
			
			delete this._sortNode;
			
			// Skip this logic if field being sorted isn't actually displayed
			if(target){
				target = target.contents || target;
				// Place sort arrow under clicked node, and add up/down sort class
				arrowNode = this._lastSortedArrow = put("div.dgrid-sort-arrow.ui-icon[role=presentation]");
				arrowNode.innerHTML = "&nbsp;";
				target.insertBefore(arrowNode, target.firstChild);
				put(target, desc ? ".dgrid-sort-down" : ".dgrid-sort-up");
				// Call resize in case relocation of sort arrow caused any height changes
				this.resize();
			}
		},
		
		styleColumn: function(colId, css){
			// summary:
			//		Dynamically creates a stylesheet rule to alter a column's style.
			
			return this.addCssRule("#" + miscUtil.escapeCssIdentifier(this.domNode.id) +
				" .dgrid-column-" + replaceInvalidChars(colId), css);
		},
		
		/*=====
		_configColumn: function(column, columnId, rowColumns, prefix){
			// summary:
			//		Method called when normalizing base configuration of a single
			//		column.  Can be used as an extension point for behavior requiring
			//		access to columns when a new configuration is applied.
		},=====*/
		
		_configColumns: function(prefix, rowColumns){
			// configure the current column
			var subRow = [],
				isArray = rowColumns instanceof Array;
			
			function configColumn(column, columnId){
				if(typeof column == "string"){
					rowColumns[columnId] = column = {label:column};
				}
				if(!isArray && !column.field){
					column.field = columnId;
				}
				columnId = column.id = column.id || (isNaN(columnId) ? columnId : (prefix + columnId));
				// allow further base configuration in subclasses
				if(this._configColumn){
					this._configColumn(column, columnId, rowColumns, prefix);
					// Allow the subclasses to modify the column id.
					columnId = column.id;
				}
				if(isArray){ this.columns[columnId] = column; }

				// add grid reference to each column object for potential use by plugins
				column.grid = this;
				if(typeof column.init === "function"){ column.init(); }
				
				subRow.push(column); // make sure it can be iterated on
			}
			
			miscUtil.each(rowColumns, configColumn, this);
			return isArray ? rowColumns : subRow;
		},
		
		_destroyColumns: function(){
			// summary:
			//		Iterates existing subRows looking for any column definitions with
			//		destroy methods (defined by plugins) and calls them.  This is called
			//		immediately before configuring a new column structure.
			
			var subRows = this.subRows,
				// if we have column sets, then we don't need to do anything with the missing subRows, ColumnSet will handle it
				subRowsLength = subRows && subRows.length,
				i, j, column, len;
			
			// First remove rows (since they'll be refreshed after we're done),
			// so that anything aspected onto removeRow by plugins can run.
			// (cleanup will end up running again, but with nothing to iterate.)
			this.cleanup();
			
			for(i = 0; i < subRowsLength; i++){
				for(j = 0, len = subRows[i].length; j < len; j++){
					column = subRows[i][j];
					if(typeof column.destroy === "function"){ column.destroy(); }
				}
			}
		},
		
		configStructure: function(){
			// configure the columns and subRows
			var subRows = this.subRows,
				columns = this._columns = this.columns;
			
			// Reset this.columns unless it was already passed in as an object
			this.columns = !columns || columns instanceof Array ? {} : columns;
			
			if(subRows){
				// Process subrows, which will in turn populate the this.columns object
				for(var i = 0; i < subRows.length; i++){
					subRows[i] = this._configColumns(i + "-", subRows[i]);
				}
			}else{
				this.subRows = [this._configColumns("", columns)];
			}
		},
		
		_getColumns: function(){
			// _columns preserves what was passed to set("columns"), but if subRows
			// was set instead, columns contains the "object-ified" version, which
			// was always accessible in the past, so maintain that accessibility going
			// forward.
			return this._columns || this.columns;
		},
		_setColumns: function(columns){
			this._destroyColumns();
			// reset instance variables
			this.subRows = null;
			this.columns = columns;
			// re-run logic
			this._updateColumns();
		},
		
		_setSubRows: function(subrows){
			this._destroyColumns();
			this.subRows = subrows;
			this._updateColumns();
		},
		
		setColumns: function(columns){
			kernel.deprecated("setColumns(...)", 'use set("columns", ...) instead', "dgrid 0.4");
			this.set("columns", columns);
		},
		setSubRows: function(subrows){
			kernel.deprecated("setSubRows(...)", 'use set("subRows", ...) instead', "dgrid 0.4");
			this.set("subRows", subrows);
		},
		
		_updateColumns: function(){
			// summary:
			//		Called when columns, subRows, or columnSets are reset
			
			this.configStructure();
			this.renderHeader();
			
			this.refresh();
			// re-render last collection if present
			this._lastCollection && this.renderArray(this._lastCollection);
			
			// After re-rendering the header, re-apply the sort arrow if needed.
			if(this._started){
				if(this._sort && this._sort.length){
					this.updateSortArrow(this._sort);
				} else {
					// Only call resize directly if we didn't call updateSortArrow,
					// since that calls resize itself when it updates.
					this.resize();
				}
			}
		}
	});
	
	function defaultRenderCell(object, data, td, options){
		if(this.formatter){
			// Support formatter, with or without formatterScope
			var formatter = this.formatter,
				formatterScope = this.grid.formatterScope;
			td.innerHTML = typeof formatter === "string" && formatterScope ?
				formatterScope[formatter](data, object) : this.formatter(data, object);
		}else if(data != null){
			td.appendChild(document.createTextNode(data)); 
		}
	}
	
	// expose appendIfNode and default implementation of renderCell,
	// e.g. for use by column plugins
	Grid.appendIfNode = appendIfNode;
	Grid.defaultRenderCell = defaultRenderCell;
	
	return Grid;
});

},
'dgrid/OnDemandList':function(){
define(["./List", "./_StoreMixin", "dojo/_base/declare", "dojo/_base/lang", "dojo/_base/Deferred", "dojo/dom", "dojo/on", "./util/misc", "put-selector/put"],
function(List, _StoreMixin, declare, lang, Deferred, dom, listen, miscUtil, put){

return declare([List, _StoreMixin], {
	// summary:
	//		Extends List to include virtual scrolling functionality, querying a
	//		dojo/store instance for the appropriate range when the user scrolls.
	
	// minRowsPerPage: Integer
	//		The minimum number of rows to request at one time.
	minRowsPerPage: 25,
	
	// maxRowsPerPage: Integer
	//		The maximum number of rows to request at one time.
	maxRowsPerPage: 250,
	
	// maxEmptySpace: Integer
	//		Defines the maximum size (in pixels) of unrendered space below the
	//		currently-rendered rows. Setting this to less than Infinity can be useful if you
	//		wish to limit the initial vertical scrolling of the grid so that the scrolling is
	// 		not excessively sensitive. With very large grids of data this may make scrolling
	//		easier to use, albiet it can limit the ability to instantly scroll to the end.
	maxEmptySpace: Infinity,	
	
	// bufferRows: Integer
	//	  The number of rows to keep ready on each side of the viewport area so that the user can
	//	  perform local scrolling without seeing the grid being built. Increasing this number can
	//	  improve perceived performance when the data is being retrieved over a slow network.
	bufferRows: 10,
	
	// farOffRemoval: Integer
	//		Defines the minimum distance (in pixels) from the visible viewport area
	//		rows must be in order to be removed.  Setting to Infinity causes rows
	//		to never be removed.
	farOffRemoval: 2000,
	
	// queryRowsOverlap: Integer
	//		Indicates the number of rows to overlap queries. This helps keep
	//		continuous data when underlying data changes (and thus pages don't
	//		exactly align)
	queryRowsOverlap: 0,
	
	// pagingMethod: String
	//		Method (from dgrid/util/misc) to use to either throttle or debounce
	//		requests.  Default is "debounce" which will cause the grid to wait until
	//		the user pauses scrolling before firing any requests; can be set to
	//		"throttleDelayed" instead to progressively request as the user scrolls,
	//		which generally incurs more overhead but might appear more responsive.
	pagingMethod: "debounce",
	
	// pagingDelay: Integer
	//		Indicates the delay (in milliseconds) imposed upon pagingMethod, to wait
	//		before paging in more data on scroll events. This can be increased to
	//		reduce client-side overhead or the number of requests sent to a server.
	pagingDelay: miscUtil.defaultDelay,
	
	// keepScrollPosition: Boolean
	//		When refreshing the list, controls whether the scroll position is
	//		preserved, or reset to the top.  This can also be overridden for
	//		specific calls to refresh.
	keepScrollPosition: false,
	
	rowHeight: 22,
	
	postCreate: function(){
		this.inherited(arguments);
		var self = this;
		// check visibility on scroll events
		listen(this.bodyNode, "scroll",
			miscUtil[this.pagingMethod](function(event){ self._processScroll(event); },
				null, this.pagingDelay));
	},
	
	destroy: function(){
		this.inherited(arguments);
		if (this._refreshTimeout) {
			clearTimeout(this._refreshTimeout);
		}
	},
	
	renderQuery: function(query, options){
		// summary:
		//		Creates a preload node for rendering a query into, and executes the query
		//		for the first page of data. Subsequent data will be downloaded as it comes
		//		into view.
		var self = this,
			container = (options && options.container) || this.contentNode,
			preload = {
				query: query,
				count: 0,
				options: options
			},
			preloadNode,
			priorPreload = this.preload,
			results;
		
		// Initial query; set up top and bottom preload nodes
		var topPreload = {
			node: put(container, "div.dgrid-preload", {
				rowIndex: 0
			}),
			count: 0,
			query: query,
			next: preload,
			options: options
		};
		topPreload.node.style.height = "0";
		preload.node = preloadNode = put(container, "div.dgrid-preload");
		preload.previous = topPreload;
		
		// this preload node is used to represent the area of the grid that hasn't been
		// downloaded yet
		preloadNode.rowIndex = this.minRowsPerPage;

		if(priorPreload){
			// the preload nodes (if there are multiple) are represented as a linked list, need to insert it
			if((preload.next = priorPreload.next) && 
					// is this preload node below the prior preload node?
					preloadNode.offsetTop >= priorPreload.node.offsetTop){
				// the prior preload is above/before in the linked list
				preload.previous = priorPreload;
			}else{
				// the prior preload is below/after in the linked list
				preload.next = priorPreload;
				preload.previous = priorPreload.previous;
			}
			// adjust the previous and next links so the linked list is proper
			preload.previous.next = preload;
			preload.next.previous = preload; 
		}else{
			this.preload = preload;
		}
		
		var loadingNode = put(preloadNode, "-div.dgrid-loading"),
			innerNode = put(loadingNode, "div.dgrid-below");
		innerNode.innerHTML = this.loadingMessage;

		function errback(err) {
			// Used as errback for when calls;
			// remove the loadingNode and re-throw if an error was passed
			put(loadingNode, "!");
			
			if(err){
				if(self._refreshDeferred){
					self._refreshDeferred.reject(err);
					delete self._refreshDeferred;
				}
				throw err;
			}
		}

		// Establish query options, mixing in our own.
		// (The getter returns a delegated object, so simply using mixin is safe.)
		options = lang.mixin(this.get("queryOptions"), options, 
			{ start: 0, count: this.minRowsPerPage },
			"level" in query ? { queryLevel: query.level } : null);
		
		// Protect the query within a _trackError call, but return the QueryResults
		this._trackError(function(){ return results = query(options); });
		
		if(typeof results === "undefined"){
			// Synchronous error occurred (but was caught by _trackError)
			errback();
			return;
		}
		
		// Render the result set
		Deferred.when(self.renderArray(results, preloadNode, options), function(trs){
			var total = typeof results.total === "undefined" ?
				results.length : results.total;
			return Deferred.when(total, function(total){
				var trCount = trs.length,
					parentNode = preloadNode.parentNode,
					noDataNode = self.noDataNode;
				
				put(loadingNode, "!");
				if(!("queryLevel" in options)){
					self._total = total;
				}
				// now we need to adjust the height and total count based on the first result set
				if(total === 0 && parentNode){
					if(noDataNode){
						put(noDataNode, "!");
						delete self.noDataNode;
					}
					self.noDataNode = noDataNode = put("div.dgrid-no-data");
					parentNode.insertBefore(noDataNode, self._getFirstRowSibling(parentNode));
					noDataNode.innerHTML = self.noDataMessage;
				}
				var height = 0;
				for(var i = 0; i < trCount; i++){
					height += self._calcRowHeight(trs[i]);
				}
				// only update rowHeight if we actually got results and are visible
				if(trCount && height){ self.rowHeight = height / trCount; }
				
				total -= trCount;
				preload.count = total;
				preloadNode.rowIndex = trCount;
				if(total){
					preloadNode.style.height = Math.min(total * self.rowHeight, self.maxEmptySpace) + "px";
				}else{
					// if total is 0, IE quirks mode can't handle 0px height for some reason, I don't know why, but we are setting display: none for now
					preloadNode.style.display = "none";
					// This is a hack to get Observable to recognize that this is the
					// last page, like is done in the processScroll function
					options.count++;
				}
				
				if (self._previousScrollPosition) {
					// Restore position after a refresh operation w/ keepScrollPosition
					self.scrollTo(self._previousScrollPosition);
					delete self._previousScrollPosition;
				}
				
				// Redo scroll processing in case the query didn't fill the screen,
				// or in case scroll position was restored
				self._processScroll();
				
				// If _refreshDeferred is still defined after calling _processScroll,
				// resolve it now (_processScroll will remove it and resolve it itself
				// otherwise)
				if(self._refreshDeferred){
					self._refreshDeferred.resolve(results);
					delete self._refreshDeferred;
				}
				
				return trs;
			}, errback);
		}, errback);
		
		return results;
	},
	
	refresh: function(options){
		// summary:
		//		Refreshes the contents of the grid.
		// options: Object?
		//		Optional object, supporting the following parameters:
		//		* keepScrollPosition: like the keepScrollPosition instance property;
		//			specifying it in the options here will override the instance
		//			property's value for this specific refresh call only.
		
		var self = this,
			keep = (options && options.keepScrollPosition),
			dfd, results;
		
		// Fall back to instance property if option is not defined
		if(typeof keep === "undefined"){ keep = this.keepScrollPosition; }
		
		// Store scroll position to be restored after new total is received
		if(keep){ this._previousScrollPosition = this.getScrollPosition(); }
		
		this.inherited(arguments);
		if(this.store){
			// render the query
			dfd = this._refreshDeferred = new Deferred();
			
			// renderQuery calls _trackError internally
			results = self.renderQuery(function(queryOptions){
				return self.store.query(self.query, queryOptions);
			});
			if(typeof results === "undefined"){
				// Synchronous error occurred; reject the refresh promise.
				dfd.reject();
			}
			
			// Internally, _refreshDeferred will always be resolved with an object
			// containing `results` (QueryResults) and `rows` (the rendered rows);
			// externally the promise will resolve simply with the QueryResults, but
			// the event will be emitted with both under respective properties.
			return dfd.then(function(results){
				// Emit on a separate turn to enable event to be used consistently for
				// initial render, regardless of whether the backing store is async
				self._refreshTimeout = setTimeout(function() {
					listen.emit(self.domNode, "dgrid-refresh-complete", {
						bubbles: true,
						cancelable: false,
						grid: self,
						results: results // QueryResults object (may be a wrapped promise)
					});
					self._refreshTimeout = null;
				}, 0);
				
				// Delete the Deferred immediately so nothing tries to re-resolve
				delete self._refreshDeferred;
				
				// Resolve externally with just the QueryResults
				return results;
			}, function(err){
				delete self._refreshDeferred;
				throw err;
			});
		}
	},
	
	resize: function(){
		this.inherited(arguments);
		this._processScroll();
	},

	_getFirstRowSibling: function(container){
		// summary:
		//		Returns the DOM node that a new row should be inserted before
		//		when there are no other rows in the current result set.
		//		In the case of OnDemandList, this will always be the last child
		//		of the container (which will be a trailing preload node).
		return container.lastChild;
	},
	
	_calcRowHeight: function(rowElement){
		// summary:
		//		Calculate the height of a row. This is a method so it can be overriden for
		//		plugins that add connected elements to a row, like the tree
		
		var sibling = rowElement.nextSibling;
		
		// If a next row exists, compare the top of this row with the
		// next one (in case "rows" are actually rendering side-by-side).
		// If no next row exists, this is either the last or only row,
		// in which case we count its own height.
		if(sibling && !/\bdgrid-preload\b/.test(sibling.className)){
			return sibling.offsetTop - rowElement.offsetTop;
		}
		
		return rowElement.offsetHeight;
	},
	
	lastScrollTop: 0,
	_processScroll: function(evt){
		// summary:
		//		Checks to make sure that everything in the viewable area has been
		//		downloaded, and triggering a request for the necessary data when needed.
		var grid = this,
			scrollNode = grid.bodyNode,
			// grab current visible top from event if provided, otherwise from node
			visibleTop = (evt && evt.scrollTop) || this.getScrollPosition().y,
			visibleBottom = scrollNode.offsetHeight + visibleTop,
			priorPreload, preloadNode, preload = grid.preload,
			lastScrollTop = grid.lastScrollTop,
			requestBuffer = grid.bufferRows * grid.rowHeight,
			searchBuffer = requestBuffer - grid.rowHeight, // Avoid rounding causing multiple queries
			// References related to emitting dgrid-refresh-complete if applicable
			refreshDfd,
			lastResults,
			lastRows,
			preloadSearchNext = true;
		
		// XXX: I do not know why this happens.
		// munging the actual location of the viewport relative to the preload node by a few pixels in either
		// direction is necessary because at least WebKit on Windows seems to have an error that causes it to
		// not quite get the entire element being focused in the viewport during keyboard navigation,
		// which means it becomes impossible to load more data using keyboard navigation because there is
		// no more data to scroll to to trigger the fetch.
		// 1 is arbitrary and just gets it to work correctly with our current test cases; dont wanna go
		// crazy and set it to a big number without understanding more about what is going on.
		// wondering if it has to do with border-box or something, but changing the border widths does not
		// seem to make it break more or less, so I do not know
		var mungeAmount = 1;
		
		grid.lastScrollTop = visibleTop;

		function removeDistantNodes(preload, distanceOff, traversal, below){
			// we check to see the the nodes are "far off"
			var farOffRemoval = grid.farOffRemoval,
				preloadNode = preload.node;
			// by checking to see if it is the farOffRemoval distance away
			if(distanceOff > 2 * farOffRemoval){
				// ok, there is preloadNode that is far off, let's remove rows until we get to in the current viewpoint
				var row, nextRow = preloadNode[traversal];
				var reclaimedHeight = 0;
				var count = 0;
				var toDelete = [];
				while((row = nextRow)){
					var rowHeight = grid._calcRowHeight(row);
					if(reclaimedHeight + rowHeight + farOffRemoval > distanceOff || (nextRow.className.indexOf("dgrid-row") < 0 && nextRow.className.indexOf("dgrid-loading") < 0)){
						// we have reclaimed enough rows or we have gone beyond grid rows, let's call it good
						break;
					}
					var nextRow = row[traversal]; // have to do this before removing it
					reclaimedHeight += rowHeight;
					count += row.count || 1;
					// we just do cleanup here, as we will do a more efficient node destruction in the setTimeout below
					grid.removeRow(row, true);
					toDelete.push(row);
				}
				// now adjust the preloadNode based on the reclaimed space
				preload.count += count;
				if(below){
					preloadNode.rowIndex -= count;
					adjustHeight(preload);
				}else{
					// if it is above, we can calculate the change in exact row changes, which we must do to not mess with the scrolling
					preloadNode.style.height = (preloadNode.offsetHeight + reclaimedHeight) + "px";
				}
				// we remove the elements after expanding the preload node so that the contraction doesn't alter the scroll position
				var trashBin = put("div", toDelete);
				setTimeout(function(){
					// we can defer the destruction until later
					put(trashBin, "!");
				},1);
			}
		}
		
		function adjustHeight(preload, noMax){
			preload.node.style.height = Math.min(preload.count * grid.rowHeight, noMax ? Infinity : grid.maxEmptySpace) + "px";
		}
		function traversePreload(preload, moveNext){
			do{
				preload = moveNext ? preload.next : preload.previous;
			}while(preload && !preload.node.offsetWidth);// skip past preloads that are not currently connected
			return preload;
		}
		while(preload && !preload.node.offsetWidth){
			// skip past preloads that are not currently connected
			preload = preload.previous;
		}
		// there can be multiple preloadNodes (if they split, or multiple queries are created),
		//	so we can traverse them until we find whatever is in the current viewport, making
		//	sure we don't backtrack
		while(preload && preload != priorPreload){
			priorPreload = grid.preload;
			grid.preload = preload;
			preloadNode = preload.node;
			var preloadTop = preloadNode.offsetTop;
			var preloadHeight;
			
			if(visibleBottom + mungeAmount + searchBuffer < preloadTop){
				// the preload is below the line of sight
				preload = traversePreload(preload, (preloadSearchNext = false));
			}else if(visibleTop - mungeAmount - searchBuffer > (preloadTop + (preloadHeight = preloadNode.offsetHeight))){
				// the preload is above the line of sight
				preload = traversePreload(preload, (preloadSearchNext = true));
			}else{
				// the preload node is visible, or close to visible, better show it
				var offset = ((preloadNode.rowIndex ? visibleTop - requestBuffer : visibleBottom) - preloadTop) / grid.rowHeight;
				var count = (visibleBottom - visibleTop + 2 * requestBuffer) / grid.rowHeight;
				// utilize momentum for predictions
				var momentum = Math.max(Math.min((visibleTop - lastScrollTop) * grid.rowHeight, grid.maxRowsPerPage/2), grid.maxRowsPerPage/-2);
				count += Math.min(Math.abs(momentum), 10);
				if(preloadNode.rowIndex == 0){
					// at the top, adjust from bottom to top
					offset -= count;
				}
				offset = Math.max(offset, 0);
				if(offset < 10 && offset > 0 && count + offset < grid.maxRowsPerPage){
					// connect to the top of the preloadNode if possible to avoid excessive adjustments
					count += Math.max(0, offset);
					offset = 0;
				}
				count = Math.min(Math.max(count, grid.minRowsPerPage),
									grid.maxRowsPerPage, preload.count);
				
				if(count == 0){
					preload = traversePreload(preload, preloadSearchNext);
					continue;
				}
				
				count = Math.ceil(count);
				offset = Math.min(Math.floor(offset), preload.count - count);
				var options = lang.mixin(grid.get("queryOptions"), preload.options);
				preload.count -= count;
				var beforeNode = preloadNode,
					keepScrollTo, queryRowsOverlap = grid.queryRowsOverlap,
					below = (preloadNode.rowIndex > 0 || preloadNode.offsetTop > visibleTop) && preload;
				if(below){
					// add new rows below
					var previous = preload.previous;
					if(previous){
						removeDistantNodes(previous, visibleTop - (previous.node.offsetTop + previous.node.offsetHeight), 'nextSibling');
						if(offset > 0 && previous.node == preloadNode.previousSibling){
							// all of the nodes above were removed
							offset = Math.min(preload.count, offset);
							preload.previous.count += offset;
							adjustHeight(preload.previous, true);
							preloadNode.rowIndex += offset;
							queryRowsOverlap = 0;
						}else{
							count += offset;
						}
						preload.count -= offset;
					}
					options.start = preloadNode.rowIndex - queryRowsOverlap;
					options.count = Math.min(count + queryRowsOverlap, grid.maxRowsPerPage);
					preloadNode.rowIndex = options.start + options.count;
				}else{
					// add new rows above
					if(preload.next){
						// remove out of sight nodes first
						removeDistantNodes(preload.next, preload.next.node.offsetTop - visibleBottom, 'previousSibling', true);
						var beforeNode = preloadNode.nextSibling;
						if(beforeNode == preload.next.node){
							// all of the nodes were removed, can position wherever we want
							preload.next.count += preload.count - offset;
							preload.next.node.rowIndex = offset + count;
							adjustHeight(preload.next);
							preload.count = offset;
							queryRowsOverlap = 0;
						}else{
							keepScrollTo = true;
						}
						
					}
					options.start = preload.count;
					options.count = Math.min(count + queryRowsOverlap, grid.maxRowsPerPage);
				}
				if(keepScrollTo && beforeNode && beforeNode.offsetWidth){
					keepScrollTo = beforeNode.offsetTop;
				}

				adjustHeight(preload);
				
				// use the query associated with the preload node to get the next "page"
				if("level" in preload.query){
					options.queryLevel = preload.query.level;
				}
				
				// Avoid spurious queries (ideally this should be unnecessary...)
				if(!("queryLevel" in options) && (options.start > grid._total || options.count < 0)){
					continue;
				}
				
				// create a loading node as a placeholder while the data is loaded
				var loadingNode = put(beforeNode, "-div.dgrid-loading[style=height:" + count * grid.rowHeight + "px]"),
					innerNode = put(loadingNode, "div.dgrid-" + (below ? "below" : "above"));
				innerNode.innerHTML = grid.loadingMessage;
				loadingNode.count = count;
				
				// Query now to fill in these rows.
				// Keep _trackError-wrapped results separate, since if results is a
				// promise, it will lose QueryResults functions when chained by `when`
				var results = preload.query(options),
					trackedResults = grid._trackError(function(){ return results; });
				
				if(trackedResults === undefined){
					// Sync query failed
					put(loadingNode, "!");
					return;
				}

				// Isolate the variables in case we make multiple requests
				// (which can happen if we need to render on both sides of an island of already-rendered rows)
				(function(loadingNode, below, keepScrollTo, results){
					lastRows = Deferred.when(grid.renderArray(results, loadingNode, options), function(rows){
						lastResults = results;
						
						// can remove the loading node now
						beforeNode = loadingNode.nextSibling;
						put(loadingNode, "!");
						if(keepScrollTo && beforeNode && beforeNode.offsetWidth){ // beforeNode may have been removed if the query results loading node was a removed as a distant node before rendering 
							// if the preload area above the nodes is approximated based on average
							// row height, we may need to adjust the scroll once they are filled in
							// so we don't "jump" in the scrolling position
							var pos = grid.getScrollPosition();
							grid.scrollTo({
								// Since we already had to query the scroll position,
								// include x to avoid TouchScroll querying it again on its end.
								x: pos.x,
								y: pos.y + beforeNode.offsetTop - keepScrollTo,
								// Don't kill momentum mid-scroll (for TouchScroll only).
								preserveMomentum: true
							});
						}
						
						Deferred.when(results.total || results.length, function(total){
							if(!("queryLevel" in options)){
								grid._total = total;
							}
							if(below){
								// if it is below, we will use the total from the results to update
								// the count of the last preload in case the total changes as later pages are retrieved
								// (not uncommon when total counts are estimated for db perf reasons)
								
								// recalculate the count
								below.count = total - below.node.rowIndex;
								// check to see if we are on the last page
								if(below.count === 0){
									// This is a hack to get Observable to recognize that this is the
									// last page; if the count doesn't match results.length, Observable
									// will think this is the last page and properly handle additions to the bottom
									options.count++;
								}
								// readjust the height
								adjustHeight(below);
							}
						});
						
						// make sure we have covered the visible area
						grid._processScroll();
						return rows;
					}, function (e) {
						put(loadingNode, "!");
						throw e;
					});
				}).call(this, loadingNode, below, keepScrollTo, results);
				preload = preload.previous;
			}
		}
		
		// After iterating, if additional requests have been made mid-refresh,
		// resolve the refresh promise based on the latest results obtained
		if (lastRows && (refreshDfd = this._refreshDeferred)) {
			delete this._refreshDeferred;
			Deferred.when(lastRows, function() {
				refreshDfd.resolve(lastResults);
			});
		}
	},

	removeRow: function(rowElement, justCleanup){
		function chooseIndex(index1, index2){
			return index1 != null ? index1 : index2;
		}

		if(rowElement){
			// Clean up observers that need to be cleaned up.
			var previousNode = rowElement.previousSibling,
				nextNode = rowElement.nextSibling,
				prevIndex = previousNode && chooseIndex(previousNode.observerIndex, previousNode.previousObserverIndex),
				nextIndex = nextNode && chooseIndex(nextNode.observerIndex, nextNode.nextObserverIndex),
				thisIndex = rowElement.observerIndex;

			// Clear the observerIndex on the node being removed so it will not be considered any longer.
			rowElement.observerIndex = undefined;
			if(justCleanup){
				// Save the indexes from the siblings for future calls to removeRow.
				rowElement.nextObserverIndex = nextIndex;
				rowElement.previousObserverIndex = prevIndex;
			}

			// Is this row's observer index different than those on either side?
			if(this.cleanEmptyObservers && thisIndex > -1 && thisIndex !== prevIndex && thisIndex !== nextIndex){
				// This is the last row that references the observer index.  Cancel the observer.
				var observers = this.observers;
				var observer = observers[thisIndex];
				if(observer){
					// justCleanup is set to true when the list is being cleaned out.  The rows are left in the DOM
					// and later they are removed altogether.  Skip the check for overlapping rows because
					// in the end, all of the rows will be removed and all of the observers need to be canceled.
					if(!justCleanup){
					// We need to verify that all the rows really have been removed. If there
					// are overlapping rows, it is possible another element exists
						var rows = observer.rows;
						for(var i = 0; i < rows.length; i++){
							if(rows[i] != rowElement && dom.isDescendant(rows[i], this.domNode)){
								// still rows in this list, abandon
								return this.inherited(arguments);
							}
						}
					}
					observer.cancel();
					this._numObservers--;
					observers[thisIndex] = 0; // remove it so we don't call cancel twice
				}
			}
		}
		// Finish the row removal.
		this.inherited(arguments);
	}
});

});

},
'dgrid/_StoreMixin':function(){
define(["dojo/_base/kernel", "dojo/_base/declare", "dojo/_base/lang", "dojo/_base/Deferred", "dojo/on", "dojo/aspect", "put-selector/put"],
function(kernel, declare, lang, Deferred, listen, aspect, put){
	// This module isolates the base logic required by store-aware list/grid
	// components, e.g. OnDemandList/Grid and the Pagination extension.
	
	// Noop function, needed for _trackError when callback due to a bug in 1.8
	// (see http://bugs.dojotoolkit.org/ticket/16667)
	function noop(value){ return value; }
	
	function emitError(err){
		// called by _trackError in context of list/grid, if an error is encountered
		if(typeof err !== "object"){
			// Ensure we actually have an error object, so we can attach a reference.
			err = new Error(err);
		}else if(err.dojoType === "cancel"){
			// Don't fire dgrid-error events for errors due to canceled requests
			// (unfortunately, the Deferred instrumentation will still log them)
			return;
		}
		// TODO: remove this @ 0.4 (prefer grid property directly on event object)
		err.grid = this;
		
		if(listen.emit(this.domNode, "dgrid-error", {
				grid: this,
				error: err,
				cancelable: true,
				bubbles: true })){
			console.error(err);
		}
	}
	
	return declare(null, {
		// store: Object
		//		The object store (implementing the dojo/store API) from which data is
		//		to be fetched.
		store: null,
		
		// query: Object
		//		Specifies query parameter(s) to pass to store.query calls.
		query: null,
		
		// queryOptions: Object
		//		Specifies additional query options to mix in when calling store.query;
		//		sort, start, and count are already handled.
		queryOptions: null,
		
		// getBeforePut: boolean
		//		If true, a get request will be performed to the store before each put
		//		as a baseline when saving; otherwise, existing row data will be used.
		getBeforePut: true,
		
		// noDataMessage: String
		//		Message to be displayed when no results exist for a query, whether at
		//		the time of the initial query or upon subsequent observed changes.
		//		Defined by _StoreMixin, but to be implemented by subclasses.
		noDataMessage: "",
		
		// loadingMessage: String
		//		Message displayed when data is loading.
		//		Defined by _StoreMixin, but to be implemented by subclasses.
		loadingMessage: "",
		
		constructor: function(){
			// Create empty objects on each instance, not the prototype
			this.query = {};
			this.queryOptions = {};
			this.dirty = {};
			this._updating = {}; // Tracks rows that are mid-update
			this._columnsWithSet = {};

			// Reset _columnsWithSet whenever column configuration is reset
			aspect.before(this, "configStructure", lang.hitch(this, function(){
				this._columnsWithSet = {};
			}));
		},
		
		postCreate: function(){
			this.inherited(arguments);
			if(this.store){
				this._updateNotifyHandle(this.store);
			}
		},
		
		destroy: function(){
			this.inherited(arguments);
			if(this._notifyHandle){
				this._notifyHandle.remove();
			}
		},
		
		_configColumn: function(column){
			// summary:
			//		Implements extension point provided by Grid to store references to
			//		any columns with `set` methods, for use during `save`.
			if (column.set){
				this._columnsWithSet[column.field] = column;
			}
			this.inherited(arguments);
		},
		
		_updateNotifyHandle: function(store){
			// summary:
			//		Unhooks any previously-existing store.notify handle, and
			//		hooks up a new one for the given store.
			
			if(this._notifyHandle){
				// Unhook notify handler from previous store
				this._notifyHandle.remove();
				delete this._notifyHandle;
			}
			if(store && typeof store.notify === "function" && this.shouldObserveStore){
				this._notifyHandle = aspect.after(store, "notify",
					lang.hitch(this, "_onNotify"), true);
				
				var sort = this.get("sort");
				if (!sort || !sort.length) {
					console.warn("Observable store detected, but no sort order specified. " +
						"You may experience quirks when adding/updating items.  " +
						"These can be resolved by setting a sort order on the list or grid.");
				}
			}
		},
		
		_setStore: function(store, query, queryOptions){
			// summary:
			//		Assigns a new store (and optionally query/queryOptions) to the list,
			//		and tells it to refresh.
			
			this._updateNotifyHandle(store);
			
			this.store = store;
			this.dirty = {}; // discard dirty map, as it applied to a previous store
			this.set("query", query, queryOptions);
		},
		_setQuery: function(query, queryOptions){
			// summary:
			//		Assigns a new query (and optionally queryOptions) to the list,
			//		and tells it to refresh.
			
			var sort = queryOptions && queryOptions.sort;
			
			this.query = query !== undefined ? query : this.query;
			this.queryOptions = queryOptions || this.queryOptions;
			
			// Avoid unnecessary refresh if instance hasn't started yet (startup will refresh)
			if (this._started) {
				// If we have new sort criteria, pass them through sort
				// (which will update _sort and call refresh in itself).
				// Otherwise, just refresh.
				sort ? this.set("sort", sort) : this.refresh();
			}
		},
		setStore: function(store, query, queryOptions){
			kernel.deprecated("setStore(...)", 'use set("store", ...) instead', "dgrid 0.4");
			this.set("store", store, query, queryOptions);
		},
		setQuery: function(query, queryOptions){
			kernel.deprecated("setQuery(...)", 'use set("query", ...) instead', "dgrid 0.4");
			this.set("query", query, queryOptions);
		},
		
		_getQueryOptions: function(){
			// summary:
			//		Get a fresh queryOptions object, also including the current sort
			var options = lang.delegate(this.queryOptions, {});
			if(typeof(this._sort) === "function" || this._sort.length){
				// Prevents SimpleQueryEngine from doing unnecessary "null" sorts (which can
				// change the ordering in browsers that don't use a stable sort algorithm, eg Chrome)
				options.sort = this._sort;
			}
			return options;
		},
		_getQuery: function(){
			// summary:
			//		Implemented consistent with _getQueryOptions so that if query is
			//		an object, this returns a protected (delegated) object instead of
			//		the original.
			var q = this.query;
			return typeof q == "object" && q != null ? lang.delegate(q, {}) : q;
		},
		
		_setSort: function(property, descending){
			// summary:
			//		Sort the content
			
			// prevent default storeless sort logic as long as we have a store
			if(this.store){ this._lastCollection = null; }
			this.inherited(arguments);
		},
		
		_onNotify: function(object, existingId){
			// summary:
			//		Method called when the store's notify method is called.
			
			// Call inherited in case anything was mixed in earlier
			this.inherited(arguments);
			
			// For adds/puts, check whether any observers are hooked up;
			// if not, force a refresh to properly hook one up now that there is data
			if(object && this._numObservers < 1){
				this.refresh({ keepScrollPosition: true });
			}
		},
		
		refresh: function(){
			var result = this.inherited(arguments);
			
			if(!this.store){
				this.noDataNode = put(this.contentNode, "div.dgrid-no-data");
				this.noDataNode.innerHTML = this.noDataMessage;
			}
			
			return result;
		},
		
		renderArray: function(){
			var self = this;
			var rows = this.inherited(arguments);
			
			if(!this.store){
				Deferred.when(rows, function(resolvedRows){
					if(resolvedRows.length && self.noDataNode){
						put(self.noDataNode, "!");
					}
				});
			}
			return rows;
		},
		
		insertRow: function(object, parent, beforeNode, i, options){
			var store = this.store,
				dirty = this.dirty,
				id = store && store.getIdentity(object),
				dirtyObj;
			
			if(id in dirty && !(id in this._updating)){ dirtyObj = dirty[id]; }
			if(dirtyObj){
				// restore dirty object as delegate on top of original object,
				// to provide protection for subsequent changes as well
				object = lang.delegate(object, dirtyObj);
			}
			return this.inherited(arguments);
		},
		
		updateDirty: function(id, field, value){
			// summary:
			//		Updates dirty data of a field for the item with the specified ID.
			var dirty = this.dirty,
				dirtyObj = dirty[id];
			
			if(!dirtyObj){
				dirtyObj = dirty[id] = {};
			}
			dirtyObj[field] = value;
		},
		setDirty: function(id, field, value){
			kernel.deprecated("setDirty(...)", "use updateDirty() instead", "dgrid 0.4");
			this.updateDirty(id, field, value);
		},
		
		save: function() {
			// Keep track of the store and puts
			var self = this,
				store = this.store,
				dirty = this.dirty,
				dfd = new Deferred(), promise = dfd.promise,
				getFunc = function(id){
					// returns a function to pass as a step in the promise chain,
					// with the id variable closured
					var data;
					return (self.getBeforePut || !(data = self.row(id).data)) ?
						function(){ return store.get(id); } :
						function(){ return data; };
				};
			
			// function called within loop to generate a function for putting an item
			function putter(id, dirtyObj) {
				// Return a function handler
				return function(object) {
					var colsWithSet = self._columnsWithSet,
						updating = self._updating,
						key, data;

					if (typeof object.set === "function") {
						object.set(dirtyObj);
					} else {
						// Copy dirty props to the original, applying setters if applicable
						for(key in dirtyObj){
							object[key] = dirtyObj[key];
						}
					}

					// Apply any set methods in column definitions.
					// Note that while in the most common cases column.set is intended
					// to return transformed data for the key in question, it is also
					// possible to directly modify the object to be saved.
					for(key in colsWithSet){
						data = colsWithSet[key].set(object);
						if(data !== undefined){ object[key] = data; }
					}
					
					updating[id] = true;
					// Put it in the store, returning the result/promise
					return Deferred.when(store.put(object), function() {
						// Clear the item now that it's been confirmed updated
						delete dirty[id];
						delete updating[id];
					});
				};
			}
			
			// For every dirty item, grab the ID
			for(var id in dirty) {
				// Create put function to handle the saving of the the item
				var put = putter(id, dirty[id]);
				
				// Add this item onto the promise chain,
				// getting the item from the store first if desired.
				promise = promise.then(getFunc(id)).then(put);
			}
			
			// Kick off and return the promise representing all applicable get/put ops.
			// If the success callback is fired, all operations succeeded; otherwise,
			// save will stop at the first error it encounters.
			dfd.resolve();
			return promise;
		},
		
		revert: function(){
			// summary:
			//		Reverts any changes since the previous save.
			this.dirty = {};
			this.refresh();
		},
		
		_trackError: function(func){
			// summary:
			//		Utility function to handle emitting of error events.
			// func: Function|String
			//		A function which performs some store operation, or a String identifying
			//		a function to be invoked (sans arguments) hitched against the instance.
			//		If sync, it can return a value, but may throw an error on failure.
			//		If async, it should return a promise, which would fire the error
			//		callback on failure.
			// tags:
			//		protected
			
			var result;
			
			if(typeof func == "string"){ func = lang.hitch(this, func); }
			
			try{
				result = func();
			}catch(err){
				// report sync error
				emitError.call(this, err);
			}
			
			// wrap in when call to handle reporting of potential async error
			return Deferred.when(result, noop, lang.hitch(this, emitError));
		},
		
		newRow: function(){
			// Override to remove no data message when a new row appears.
			// Run inherited logic first to prevent confusion due to noDataNode
			// no longer being present as a sibling.
			var row = this.inherited(arguments);
			if(this.noDataNode){
				put(this.noDataNode, "!");
				delete this.noDataNode;
			}
			return row;
		},
		removeRow: function(rowElement, justCleanup){
			var row = {element: rowElement};
			// Check to see if we are now empty...
			if(!justCleanup && this.noDataMessage &&
					(this.up(row).element === rowElement) &&
					(this.down(row).element === rowElement)){
				// ...we are empty, so show the no data message.
				this.noDataNode = put(this.contentNode, "div.dgrid-no-data");
				this.noDataNode.innerHTML = this.noDataMessage;
			}
			return this.inherited(arguments);
		}
	});
});

},
'dgrid/Keyboard':function(){
define([
	"dojo/_base/declare",
	"dojo/aspect",
	"dojo/on",
	"dojo/_base/lang",
	"dojo/has",
	"put-selector/put",
	"./util/misc",
	"dojo/_base/Deferred",
	"dojo/_base/sniff"
], function(declare, aspect, on, lang, has, put, miscUtil, Deferred){

var delegatingInputTypes = {
		checkbox: 1,
		radio: 1,
		button: 1
	},
	hasGridCellClass = /\bdgrid-cell\b/,
	hasGridRowClass = /\bdgrid-row\b/;

var Keyboard = declare(null, {
	// summary:
	//		Adds keyboard navigation capability to a list or grid.
	
	// pageSkip: Number
	//		Number of rows to jump by when page up or page down is pressed.
	pageSkip: 10,
	
	tabIndex: 0,
	
	// keyMap: Object
	//		Hash which maps key codes to functions to be executed (in the context
	//		of the instance) for key events within the grid's body.
	keyMap: null,
	
	// headerKeyMap: Object
	//		Hash which maps key codes to functions to be executed (in the context
	//		of the instance) for key events within the grid's header row.
	headerKeyMap: null,
	
	postMixInProperties: function(){
		this.inherited(arguments);
		
		if(!this.keyMap){
			this.keyMap = lang.mixin({}, Keyboard.defaultKeyMap);
		}
		if(!this.headerKeyMap){
			this.headerKeyMap = lang.mixin({}, Keyboard.defaultHeaderKeyMap);
		}
	},
	
	postCreate: function(){
		this.inherited(arguments);
		var grid = this;
		
		function handledEvent(event){
			// text boxes and other inputs that can use direction keys should be ignored and not affect cell/row navigation
			var target = event.target;
			return target.type && (!delegatingInputTypes[target.type] || event.keyCode == 32);
		}
		
		function enableNavigation(areaNode){
			var cellNavigation = grid.cellNavigation,
				isFocusableClass = cellNavigation ? hasGridCellClass : hasGridRowClass,
				isHeader = areaNode === grid.headerNode,
				initialNode = areaNode;
			
			function initHeader(){
				if(grid._focusedHeaderNode){
					// Remove the tab index for the node that previously had it.
					grid._focusedHeaderNode.tabIndex = -1;
				}
				if(grid.showHeader){
					if(cellNavigation){
						// Get the focused element. Ensure that the focused element
						// is actually a grid cell, not a column-set-cell or some
						// other cell that should not be focused
						for(var i = 0, element, elements = grid.headerNode.getElementsByTagName("th"); (element = elements[i]); ++i){
							if(isFocusableClass.test(element.className)){
								grid._focusedHeaderNode = initialNode = element;
								break;
							}
						}
					}
					else{
						grid._focusedHeaderNode = initialNode = grid.headerNode;
					}

					// Set the tab index only if the header is visible.
					if(initialNode){
						initialNode.tabIndex = grid.tabIndex;
					}
				}
			}
			
			if(isHeader){
				// Initialize header now (since it's already been rendered),
				// and aspect after future renderHeader calls to reset focus.
				initHeader();
				aspect.after(grid, "renderHeader", initHeader, true);
			}else{
				aspect.after(grid, "renderArray", function(ret){
					// summary:
					//		Ensures the first element of a grid is always keyboard selectable after data has been
					//		retrieved if there is not already a valid focused element.
					
					return Deferred.when(ret, function(ret){
						var focusedNode = grid._focusedNode || initialNode;
						
						// do not update the focused element if we already have a valid one
						if(isFocusableClass.test(focusedNode.className) && miscUtil.contains(areaNode, focusedNode)){
							return ret;
						}
						
						// ensure that the focused element is actually a grid cell, not a
						// dgrid-preload or dgrid-content element, which should not be focusable,
						// even when data is loaded asynchronously
						for(var i = 0, elements = areaNode.getElementsByTagName("*"), element; (element = elements[i]); ++i){
							if(isFocusableClass.test(element.className)){
								focusedNode = grid._focusedNode = element;
								break;
							}
						}
						
						focusedNode.tabIndex = grid.tabIndex;
						return ret;
					});
				});
			}
			
			grid._listeners.push(on(areaNode, "mousedown", function(event){
				if(!handledEvent(event)){
					grid._focusOnNode(event.target, isHeader, event);
				}
			}));
			
			grid._listeners.push(on(areaNode, "keydown", function(event){
				// For now, don't squash browser-specific functionalities by letting
				// ALT and META function as they would natively
				if(event.metaKey || event.altKey) {
					return;
				}
				
				var handler = grid[isHeader ? "headerKeyMap" : "keyMap"][event.keyCode];
				
				// Text boxes and other inputs that can use direction keys should be ignored and not affect cell/row navigation
				if(handler && !handledEvent(event)){
					handler.call(grid, event);
				}
			}));
		}
		
		if(this.tabableHeader){
			enableNavigation(this.headerNode);
			on(this.headerNode, "dgrid-cellfocusin", function(){
				grid.scrollTo({ x: this.scrollLeft });
			});
		}
		enableNavigation(this.contentNode);
		
		this._debouncedEnsureRowScroll = miscUtil.debounce(this._ensureRowScroll, this);
	},
	
	removeRow: function(rowElement){
		if(!this._focusedNode){
			// Nothing special to do if we have no record of anything focused
			return this.inherited(arguments);
		}
		
		var self = this,
			isActive = document.activeElement === this._focusedNode,
			focusedTarget = this[this.cellNavigation ? "cell" : "row"](this._focusedNode),
			focusedRow = focusedTarget.row || focusedTarget,
			sibling;
		rowElement = rowElement.element || rowElement;
		
		// If removed row previously had focus, temporarily store information
		// to be handled in an immediately-following insertRow call, or next turn
		if(rowElement === focusedRow.element){
			sibling = this.down(focusedRow, true);
			
			// Check whether down call returned the same row, or failed to return
			// any (e.g. during a partial unrendering)
			if (!sibling || sibling.element === rowElement) {
				sibling = this.up(focusedRow, true);
			}
			
			this._removedFocus = {
				active: isActive,
				rowId: focusedRow.id,
				columnId: focusedTarget.column && focusedTarget.column.id,
				siblingId: !sibling || sibling.element === rowElement ? undefined : sibling.id
			};
			
			// Call _restoreFocus on next turn, to restore focus to sibling
			// if no replacement row was immediately inserted.
			// Pass original row's id in case it was re-inserted in a renderArray
			// call (and thus was found, but couldn't be focused immediately)
			setTimeout(function() {
				if(self._removedFocus){
					self._restoreFocus(focusedRow.id);
				}
			}, 0);
			
			// Clear _focusedNode until _restoreFocus is called, to avoid
			// needlessly re-running this logic
			this._focusedNode = null;
		}
		
		this.inherited(arguments);
	},
	
	insertRow: function(object){
		var rowElement = this.inherited(arguments);
		if(this._removedFocus && !this._removedFocus.wait){
			this._restoreFocus(rowElement);
		}
		return rowElement;
	},
	
	_restoreFocus: function(row) {
		// summary:
		//		Restores focus to the newly inserted row if it matches the
		//		previously removed row, or to the nearest sibling otherwise.
		
		var focusInfo = this._removedFocus,
			newTarget,
			cell;
		
		row = row && this.row(row);
		newTarget = row && row.element && row.id === focusInfo.rowId ? row :
			typeof focusInfo.siblingId !== "undefined" && this.row(focusInfo.siblingId);
		
		if(newTarget && newTarget.element){
			if(!newTarget.element.parentNode.parentNode){
				// This was called from renderArray, so the row hasn't
				// actually been placed in the DOM yet; handle it on the next
				// turn (called from removeRow).
				focusInfo.wait = true;
				return;
			}
			// Should focus be on a cell?
			if(typeof focusInfo.columnId !== "undefined"){
				cell = this.cell(newTarget, focusInfo.columnId);
				if(cell && cell.element){
					newTarget = cell;
				}
			}
			if(focusInfo.active && newTarget.element.offsetHeight !== 0){
				// Row/cell was previously focused and is visible, so focus the new one immediately
				this._focusOnNode(newTarget, false, null);
			}else{
				// Row/cell was not focused or is not visible, but we still need to
				// update _focusedNode and the element's tabIndex/class
				put(newTarget.element, ".dgrid-focus");
				newTarget.element.tabIndex = this.tabIndex;
				this._focusedNode = newTarget.element;
			}
		}
		
		delete this._removedFocus;
	},
	
	addKeyHandler: function(key, callback, isHeader){
		// summary:
		//		Adds a handler to the keyMap on the instance.
		//		Supports binding additional handlers to already-mapped keys.
		// key: Number
		//		Key code representing the key to be handled.
		// callback: Function
		//		Callback to be executed (in instance context) when the key is pressed.
		// isHeader: Boolean
		//		Whether the handler is to be added for the grid body (false, default)
		//		or the header (true).
		
		// Aspects may be about 10% slower than using an array-based appraoch,
		// but there is significantly less code involved (here and above).
		return aspect.after( // Handle
			this[isHeader ? "headerKeyMap" : "keyMap"], key, callback, true);
	},
	
	_ensureRowScroll: function(rowElement){
		// summary:
		//		Ensures that the entire row is visible within the viewport.
		//		Called for cell navigation in complex structures.

		var scrollY = this.getScrollPosition().y;
		if(scrollY > rowElement.offsetTop){
			// Row starts above the viewport
			this.scrollTo({ y: rowElement.offsetTop });
		}
		else if(scrollY + this.contentNode.offsetHeight < rowElement.offsetTop + rowElement.offsetHeight){
			// Row ends below the viewport
			this.scrollTo({ y: rowElement.offsetTop - this.contentNode.offsetHeight + rowElement.offsetHeight });
		}
	},
	
	_focusOnNode: function(element, isHeader, event){
		var focusedNodeProperty = "_focused" + (isHeader ? "Header" : "") + "Node",
			focusedNode = this[focusedNodeProperty],
			cellOrRowType = this.cellNavigation ? "cell" : "row",
			cell = this[cellOrRowType](element),
			inputs,
			input,
			numInputs,
			inputFocused,
			i;
		
		element = cell && cell.element;
		if(!element){ return; }
		
		if(this.cellNavigation){
			inputs = element.getElementsByTagName("input");
			for(i = 0, numInputs = inputs.length; i < numInputs; i++){
				input = inputs[i];
				if((input.tabIndex != -1 || "_dgridLastValue" in input) && !input.disabled){
					// Employ workaround for focus rectangle in IE < 8
					if(has("ie") < 8){ input.style.position = "relative"; }
					input.focus();
					if(has("ie") < 8){ input.style.position = ""; }
					inputFocused = true;
					break;
				}
			}
		}
		
		// Set up event information for dgrid-cellfocusout/in events.
		// Note that these events are not fired for _restoreFocus.
		if(event !== null){
			event = lang.mixin({ grid: this }, event);
			if(event.type){
				event.parentType = event.type;
			}
			if(!event.bubbles){
				// IE doesn't always have a bubbles property already true.
				// Opera throws if you try to set it to true if it is already true.
				event.bubbles = true;
			}
		}
		
		if(focusedNode){
			// Clean up previously-focused element
			// Remove the class name and the tabIndex attribute
			put(focusedNode, "!dgrid-focus[!tabIndex]");
			if(has("ie") < 8){
				// Clean up after workaround below (for non-input cases)
				focusedNode.style.position = "";
			}
			
			// Expose object representing focused cell or row losing focus, via
			// event.cell or event.row; which is set depends on cellNavigation.
			if(event){
				event[cellOrRowType] = this[cellOrRowType](focusedNode);
				on.emit(focusedNode, "dgrid-cellfocusout", event);
			}
		}
		focusedNode = this[focusedNodeProperty] = element;
		
		if(event){
			// Expose object representing focused cell or row gaining focus, via
			// event.cell or event.row; which is set depends on cellNavigation.
			// Note that yes, the same event object is being reused; on.emit
			// performs a shallow copy of properties into a new event object.
			event[cellOrRowType] = cell;
		}
		
		var isFocusableClass = this.cellNavigation ? hasGridCellClass : hasGridRowClass;
		if(!inputFocused && isFocusableClass.test(element.className)){
			if(has("ie") < 8){
				// setting the position to relative magically makes the outline
				// work properly for focusing later on with old IE.
				// (can't be done a priori with CSS or screws up the entire table)
				element.style.position = "relative";
			}
			element.tabIndex = this.tabIndex;
			element.focus();
		}
		put(element, ".dgrid-focus");
		
		if(event){
			on.emit(focusedNode, "dgrid-cellfocusin", event);
		}
		
		if(this.cellNavigation && (this.columnSets || this.subRows.length > 1) && !isHeader){
			this._debouncedEnsureRowScroll(cell.row.element);
		}
	},
	
	focusHeader: function(element){
		this._focusOnNode(element || this._focusedHeaderNode, true);
	},
	
	focus: function(element){
		var node = element || this._focusedNode;
		if(node){
			this._focusOnNode(node, false);
		}else{
			this.contentNode.focus();
		}
	}
});

// Common functions used in default keyMap (called in instance context)

var moveFocusVertical = Keyboard.moveFocusVertical = function(event, steps){
	var cellNavigation = this.cellNavigation,
		target = this[cellNavigation ? "cell" : "row"](event),
		columnId = cellNavigation && target.column.id,
		next = this.down(this._focusedNode, steps, true);
	
	// Navigate within same column if cell navigation is enabled
	if(cellNavigation){ next = this.cell(next, columnId); }
	this._focusOnNode(next, false, event);
	
	event.preventDefault();
};

var moveFocusUp = Keyboard.moveFocusUp = function(event){
	moveFocusVertical.call(this, event, -1);
};

var moveFocusDown = Keyboard.moveFocusDown = function(event){
	moveFocusVertical.call(this, event, 1);
};

var moveFocusPageUp = Keyboard.moveFocusPageUp = function(event){
	moveFocusVertical.call(this, event, -this.pageSkip);
};

var moveFocusPageDown = Keyboard.moveFocusPageDown = function(event){
	moveFocusVertical.call(this, event, this.pageSkip);
};

var moveFocusHorizontal = Keyboard.moveFocusHorizontal = function(event, steps){
	if(!this.cellNavigation){ return; }
	var isHeader = !this.row(event), // header reports row as undefined
		currentNode = this["_focused" + (isHeader ? "Header" : "") + "Node"];
	
	this._focusOnNode(this.right(currentNode, steps), isHeader, event);
	event.preventDefault();
};

var moveFocusLeft = Keyboard.moveFocusLeft = function(event){
	moveFocusHorizontal.call(this, event, -1);
};

var moveFocusRight = Keyboard.moveFocusRight = function(event){
	moveFocusHorizontal.call(this, event, 1);
};

var moveHeaderFocusEnd = Keyboard.moveHeaderFocusEnd = function(event, scrollToBeginning){
	// Header case is always simple, since all rows/cells are present
	var nodes;
	if(this.cellNavigation){
		nodes = this.headerNode.getElementsByTagName("th");
		this._focusOnNode(nodes[scrollToBeginning ? 0 : nodes.length - 1], true, event);
	}
	// In row-navigation mode, there's nothing to do - only one row in header
	
	// Prevent browser from scrolling entire page
	event.preventDefault();
};

var moveHeaderFocusHome = Keyboard.moveHeaderFocusHome = function(event){
	moveHeaderFocusEnd.call(this, event, true);
};

var moveFocusEnd = Keyboard.moveFocusEnd = function(event, scrollToTop){
	// summary:
	//		Handles requests to scroll to the beginning or end of the grid.
	
	// Assume scrolling to top unless event is specifically for End key
	var self = this,
		cellNavigation = this.cellNavigation,
		contentNode = this.contentNode,
		contentPos = scrollToTop ? 0 : contentNode.scrollHeight,
		scrollPos = contentNode.scrollTop + contentPos,
		endChild = contentNode[scrollToTop ? "firstChild" : "lastChild"],
		hasPreload = endChild.className.indexOf("dgrid-preload") > -1,
		endTarget = hasPreload ? endChild[(scrollToTop ? "next" : "previous") + "Sibling"] : endChild,
		endPos = endTarget.offsetTop + (scrollToTop ? 0 : endTarget.offsetHeight),
		handle;
	
	if(hasPreload){
		// Find the nearest dgrid-row to the relevant end of the grid
		while(endTarget && endTarget.className.indexOf("dgrid-row") < 0){
			endTarget = endTarget[(scrollToTop ? "next" : "previous") + "Sibling"];
		}
		// If none is found, there are no rows, and nothing to navigate
		if(!endTarget){ return; }
	}
	
	// Grid content may be lazy-loaded, so check if content needs to be
	// loaded first
	if(!hasPreload || endChild.offsetHeight < 1){
		// End row is loaded; focus the first/last row/cell now
		if(cellNavigation){
			// Preserve column that was currently focused
			endTarget = this.cell(endTarget, this.cell(event).column.id);
		}
		this._focusOnNode(endTarget, false, event);
	}else{
		// In IE < 9, the event member references will become invalid by the time
		// _focusOnNode is called, so make a (shallow) copy up-front
		if(!has("dom-addeventlistener")){
			event = lang.mixin({}, event);
		}
		
		// If the topmost/bottommost row rendered doesn't reach the top/bottom of
		// the contentNode, we are using OnDemandList and need to wait for more
		// data to render, then focus the first/last row in the new content.
		handle = aspect.after(this, "renderArray", function(rows){
			handle.remove();
			return Deferred.when(rows, function(rows){
				var target = rows[scrollToTop ? 0 : rows.length - 1];
				if(cellNavigation){
					// Preserve column that was currently focused
					target = self.cell(target, self.cell(event).column.id);
				}
				self._focusOnNode(target, false, event);
			});
		});
	}
	
	if(scrollPos === endPos){
		// Grid body is already scrolled to end; prevent browser from scrolling
		// entire page instead
		event.preventDefault();
	}
};

var moveFocusHome = Keyboard.moveFocusHome = function(event){
	moveFocusEnd.call(this, event, true);
};

function preventDefault(event){
	event.preventDefault();
}

Keyboard.defaultKeyMap = {
	32: preventDefault, // space
	33: moveFocusPageUp, // page up
	34: moveFocusPageDown, // page down
	35: moveFocusEnd, // end
	36: moveFocusHome, // home
	37: moveFocusLeft, // left
	38: moveFocusUp, // up
	39: moveFocusRight, // right
	40: moveFocusDown // down
};

// Header needs fewer default bindings (no vertical), so bind it separately
Keyboard.defaultHeaderKeyMap = {
	32: preventDefault, // space
	35: moveHeaderFocusEnd, // end
	36: moveHeaderFocusHome, // home
	37: moveFocusLeft, // left
	39: moveFocusRight // right
};

return Keyboard;
});
},
'dgrid/editor':function(){
define([
	"dojo/_base/kernel",
	"dojo/_base/lang",
	"dojo/_base/array",
	"dojo/_base/Deferred",
	"dojo/on",
	"dojo/aspect",
	"dojo/has",
	"dojo/query",
	"dojo/when",
	"./Grid",
	"put-selector/put",
	"dojo/_base/sniff"
], function(kernel, lang, arrayUtil, Deferred, on, aspect, has, query, when, Grid, put){

function updateInputValue(input, value){
	// common code for updating value of a standard input
	input.value = value;
	if(input.type == "radio" || input.type == "checkbox"){
		input.checked = input.defaultChecked = !!value;
	}
}

function dataFromValue(cmp) {
    var newValue = cmp.get("item");
    var value = cmp.get("value");
    var oldValue = cmp._dgridLastValue;

    // Default logic for translating values from editors;
    // tries to preserve type if possible.
    if(typeof oldValue == "number"){
        value = isNaN(value) ? value : parseFloat(value);
    }else if(typeof oldValue == "boolean"){
        value = value == "true" ? true : value == "false" ? false : value;
    }else if(oldValue instanceof Date){
        var asDate = new Date(value);
        value = isNaN(asDate.getTime()) ? value : asDate;
    } else if (typeof oldValue === 'object') {
        if (newValue){
            value = newValue;
        }
    }
    return value;
}

// intermediary frontend to dataFromValue for HTML and widget editors
function dataFromEditor(column, cmp){
	if(typeof cmp.get == "function"){ // widget
		return dataFromValue(cmp);
	}else{ // HTML input
		return dataFromValue(
			cmp[cmp.type == "checkbox" || cmp.type == "radio"  ? "checked" : "value"]);
	}
}

function setProperty(grid, cell, oldValue, value, triggerEvent){
	// Updates dirty hash and fires dgrid-datachange event for a changed value.
	var cellElement, row, column, eventObject;
	// test whether old and new values are inequal, with coercion (e.g. for Dates)
	if((oldValue && oldValue.valueOf()) != (value && value.valueOf())){
		cellElement = cell.element;
		row = cell.row;
		column = cell.column;
		if(column.field && row){
			// TODO: remove rowId in lieu of cell (or grid.row/grid.cell)
			// (keeping for the moment for back-compat, but will note in changes)
			eventObject = {
				grid: grid,
				cell: cell,
				rowId: row.id,
				oldValue: oldValue,
				value: value,
				bubbles: true,
				cancelable: true
			};
			if(triggerEvent && triggerEvent.type){
				eventObject.parentType = triggerEvent.type;
			}
			
			if(on.emit(cellElement, "dgrid-datachange", eventObject)){
				if(grid.updateDirty){
					// for OnDemandGrid: update dirty data, and save if autoSave is true
					grid.updateDirty(row.id, column.field, value);
					// perform auto-save (if applicable) in next tick to avoid
					// unintentional mishaps due to order of handler execution
					column.autoSave && setTimeout(function(){ grid._trackError("save"); }, 0);
				}else{
					// update store-less grid
					row.data[column.field] = value;
				}
			}else{
				// Otherwise keep the value the same
				// For the sake of always-on editors, need to manually reset the value
				var cmp;
				if((cmp = cellElement.widget)){
					// set _dgridIgnoreChange to prevent an infinite loop in the
					// onChange handler and prevent dgrid-datachange from firing
					// a second time
					cmp._dgridIgnoreChange = true;
					cmp.set("value", oldValue);
					setTimeout(function(){ cmp._dgridIgnoreChange = false; }, 0);
				}else if((cmp = cellElement.input)){
					updateInputValue(cmp, oldValue);
				}
				
				return oldValue;
			}
		}
	}
	return value;
}

// intermediary frontend to setProperty for HTML and widget editors
function setPropertyFromEditor(grid, cmp, triggerEvent) {
	var cell = grid.cell(cmp.domNode || cmp),
		column = cell.column,
		value,
		id,
		editedRow,
		activeCell = grid._activeCell;
	
	if(!cmp.isValid || cmp.isValid()){
		value = setProperty(grid, cell,
			activeCell ? grid._activeValue : cmp._dgridLastValue,
			dataFromEditor(column, cmp), triggerEvent);
		
		if(activeCell){ // for editors with editOn defined
			grid._activeValue = value;
		}else{ // for always-on editors, update _dgridLastValue immediately
			cmp._dgridLastValue = value;
		}

		if(cmp.type === "radio" && cmp.name && !column.editOn && column.field){
			editedRow = grid.row(cmp);
			
			// Update all other rendered radio buttons in the group
			query("input[type=radio][name=" + cmp.name + "]", grid.contentNode).forEach(function(radioBtn){
				var row = grid.row(radioBtn);
				// Only update _dgridLastValue and the dirty data if it exists
				// and is not already false
				if(radioBtn !== cmp && radioBtn._dgridLastValue){
					radioBtn._dgridLastValue = false;
					if(grid.updateDirty){
						grid.updateDirty(row.id, column.field, false);
					}else{
						// update store-less grid
						row.data[column.field] = false;
					}
				}
			});
			
			// Also update dirty data for rows that are not currently rendered
			for(id in grid.dirty){
				if(editedRow.id !== id && grid.dirty[id][column.field]){
					grid.updateDirty(id, column.field, false);
				}
			}
		}
	}
}

// editor creation/hookup/placement logic

function createEditor(column){
	// Creates an editor instance based on column definition properties,
	// and hooks up events.
	var editor = column.editor,
		editOn = column.editOn,
		grid = column.grid,
		isWidget = typeof editor != "string", // string == standard HTML input
		args, cmp, node, putstr, handleChange;
	
	args = column.editorArgs || {};
	if(typeof args == "function"){ args = args.call(grid, column); }
	
	if(isWidget){
		cmp = new editor(args);
		node = cmp.focusNode || cmp.domNode;
		
		// Add dgrid-input to className to make consistent with HTML inputs.
		node.className += " dgrid-input";
		
		// For editOn editors, connect to onBlur rather than onChange, since
		// the latter is delayed by setTimeouts in Dijit and will fire too late.
		cmp.connect(cmp, editOn ? "onBlur" : "onChange", function(){
			if(!cmp._dgridIgnoreChange){
				setPropertyFromEditor(grid, this, {type: "widget"});
			}
		});
	}else{
		handleChange = function(evt){
			var target = evt.target;
			if("_dgridLastValue" in target && target.className.indexOf("dgrid-input") > -1){
				setPropertyFromEditor(grid, target, evt);
			}
		};

		// considerations for standard HTML form elements
		if(!column.grid._hasInputListener){
			// register one listener at the top level that receives events delegated
			grid._hasInputListener = true;
			grid.on("change", function(evt){ handleChange(evt); });
			// also register a focus listener
		}
		
		putstr = editor == "textarea" ? "textarea" :
			"input[type=" + editor + "]";
		cmp = node = put(putstr + ".dgrid-input", lang.mixin({
			name: column.field,
			tabIndex: isNaN(column.tabIndex) ? -1 : column.tabIndex
		}, args));
		
		if(has("ie") < 9 || (has("ie") && has("quirks"))){
			// IE<9 / quirks doesn't fire change events for all the right things,
			// and it doesn't bubble.
			if(editor == "radio" || editor == "checkbox"){
				// listen for clicks since IE doesn't fire change events properly for checks/radios
				on(cmp, "click", function(evt){ handleChange(evt); });
			}else{
				on(cmp, "change", function(evt){ handleChange(evt); });
			}
		}
	}
	
	return cmp;
}

function createSharedEditor(column, originalRenderCell){
	// Creates an editor instance with additional considerations for
	// shared usage across an entire column (for columns with editOn specified).
	
	var cmp = createEditor(column),
		grid = column.grid,
		isWidget = cmp.domNode,
		node = cmp.domNode || cmp,
		focusNode = cmp.focusNode || node,
		reset = isWidget ?
			function(){ cmp.set("value", cmp._dgridLastValue); } :
			function(){
				updateInputValue(cmp, cmp._dgridLastValue);
				// call setProperty again in case we need to revert a previous change
				setPropertyFromEditor(column.grid, cmp);
			},
		keyHandle;
	
	function blur(){
		var element = grid._activeCell;
		focusNode.blur();
		
		if(typeof grid.focus === "function"){
			// Dijit form widgets don't end up dismissed until the next turn,
			// so wait before calling focus (otherwise Keyboard will focus the
			// input again).  IE<9 needs to wait longer, otherwise the cell loses
			// focus after we've set it.
			setTimeout(function(){
				grid.focus(element);
			}, isWidget && has("ie") < 9 ? 15 : 0);
		}
	}
	
	function onblur(){
		var parentNode = node.parentNode,
			i = parentNode.children.length - 1,
			options = { alreadyHooked: true },
			cell = grid.cell(node);
		
		// emit an event immediately prior to removing an editOn editor
		on.emit(cell.element, "dgrid-editor-hide", {
			grid: grid,
			cell: cell,
			column: column,
			editor: cmp,
			bubbles: true,
			cancelable: false
		});
		column._editorBlurHandle.pause();
		// Remove the editor from the cell, to be reused later.
		parentNode.removeChild(node);
		
		if(cell.row){
			// If the row is still present (i.e. we didn't blur due to removal),
			// clear out the rest of the cell's contents, then re-render with new value.
			put(cell.element, "!dgrid-cell-editing");
			while(i--){ put(parentNode.firstChild, "!"); }
			Grid.appendIfNode(parentNode, column.renderCell(
				column.grid.row(parentNode).data, grid._activeValue, parentNode,
				grid._activeOptions ? lang.delegate(options, grid._activeOptions) : options));
		}
		
		// Reset state now that editor is deactivated;
		// reset focusedCell as well since some browsers will not trigger the
		// focusout event handler in this case
		grid._focusedEditorCell = grid._activeCell = grid._activeValue = grid._activeOptions = null;
	}
	
	function dismissOnKey(evt){
		// Contains logic for reacting to enter/escape keypresses to save/cancel edits.
		// Calls `focusNode.blur()` in cases where field should be dismissed.
		var key = evt.keyCode || evt.which;
		
		if(key == 27){ // escape: revert + dismiss
			reset();
			grid._activeValue = cmp._dgridLastValue;
			blur();
		}else if(key == 13 && column.dismissOnEnter !== false){ // enter: dismiss
			// FIXME: Opera is "reverting" even in this case
			blur();
		}
	}
	
	// hook up enter/esc key handling
	keyHandle = on(focusNode, "keydown", dismissOnKey);
	
	// hook up blur handler, but don't activate until widget is activated
	(column._editorBlurHandle = on.pausable(cmp, "blur", onblur)).pause();
	
	return cmp;
}

function showEditor(cmp, column, cellElement, value, row) {
    // Places a shared editor into the newly-active cell in the column.
	// Also called when rendering an editor in an "always-on" editor column.
	
	var isWidget = cmp.domNode;
	
	// for regular inputs, we can update the value before even showing it
	if(!isWidget){
		updateInputValue(cmp, value);
	}
	
	cellElement.innerHTML = "";
	put(cellElement, ".dgrid-cell-editing");
	put(cellElement, cmp.domNode || cmp);
	
	if(isWidget && !column.editOn){
		// Queue arguments to be run once editor is in DOM
		column.grid._editorsPendingStartup.push([cmp, column, cellElement, value]);
	}else{
	    startupEditor(cmp, column, cellElement, value, row);
	}
}

function startupEditor(cmp, column, cellElement, value, row) {
    // Handles editor widget startup logic and updates the editor's value.
	
	var grid = column.grid;
	
	if(cmp.domNode){
		// For widgets, ensure startup is called before setting value,
		// to maximize compatibility with flaky widgets like dijit/form/Select.
	    if (!cmp._started) { cmp.startup({ row: row }); }

		// Set value, but ensure it isn't processed as a user-generated change.
		// (Clear flag on a timeout to wait for delayed onChange to fire first)
		cmp._dgridIgnoreChange = true;
		cmp.set("value", value);
		setTimeout(function(){ cmp._dgridIgnoreChange = false; }, 0);
	}
	
	// track previous value for short-circuiting or in case we need to revert
	cmp._dgridLastValue = value;
	// if this is an editor with editOn, also update activeValue
	// (activeOptions will have been updated previously)
	if(grid._activeCell){
		grid._activeValue = value;
		// emit an event immediately prior to placing a shared editor
		on.emit(cellElement, "dgrid-editor-show", {
			grid: grid,
			cell: grid.cell(cellElement),
			column: column,
			editor: cmp,
			bubbles: true,
			cancelable: false
		});
	}
}

function startupPendingEditors(grid){
	var args = grid._editorsPendingStartup;
	for(var i = args.length; i--;){
		startupEditor.apply(null, args[i]);
	}
	grid._editorsPendingStartup = [];
}

function edit(cell) {
	// summary:
	//		Method to be mixed into grid instances, which will show/focus the
	//		editor for a given grid cell.  Also used by renderCell.
	// cell: Object
	//		Cell (or something resolvable by grid.cell) to activate editor on.
	// returns:
	//		If the cell is editable, returns a promise resolving to the editor
	//		input/widget when the cell editor is focused.
	//		If the cell is not editable, returns null.
	
	var row, column, cellElement, dirty, field, value, cmp, dfd, node,
		self = this;
	
	function show(dfd, row) {
	    column.grid._activeCell = cellElement;
		showEditor(column.editorInstance, column, cellElement, value, row);

		// focus / blur-handler-resume logic is surrounded in a setTimeout
		// to play nice with Keyboard's dgrid-cellfocusin as an editOn event
		column._editTimer = setTimeout(function(){
			// focus the newly-placed control (supported by form widgets and HTML inputs)
			if(cmp.focus){ cmp.focus(); }
			// resume blur handler once editor is focused
			if(column._editorBlurHandle){ column._editorBlurHandle.resume(); }
			column._editTimer = null;
			dfd.resolve(cmp);
		}, 0);
	}
	
	if(!cell.column){ cell = this.cell(cell); }
	if(!cell || !cell.element){ return null; }
	
	column = cell.column;
	field = column.field;
	cellElement = cell.element.contents || cell.element;
	
	if((cmp = column.editorInstance)){ // shared editor (editOn used)
		if(column.grid._activeCell != cellElement){
			// get the cell value
			row = cell.row;
			dirty = this.dirty && this.dirty[row.id];
			value = (dirty && field in dirty) ? dirty[field] :
				column.get ? column.get(row.data) : row.data[field];
			// check to see if the cell can be edited
			if(!column.canEdit || column.canEdit(cell.row.data, value)){
				dfd = new Deferred();
				
				// In some browsers, moving a DOM node causes a blur event to fire which is not
				// the best time for the blur handler to fire.  Force the issue by blurring the
				// editor now.
				node = cmp.domNode || cmp;
				if(node.offsetWidth){
					// The editor is visible.  Blur it.
					node.blur();
					// In IE, the blur does not complete immediately.
					// Push showing of the editor to the next turn.
					setTimeout(function () {
					    show(dfd, row);
					}, 0);
				}else{
				    show(dfd, row);
				}
				
				return dfd.promise;
			}
		}
	}else if(column.editor){ // editor but not shared; always-on
		cmp = cellElement.widget || cellElement.input;
		if(cmp){
			dfd = new Deferred();
			if(cmp.focus){ cmp.focus(); }
			dfd.resolve(cmp);
			return dfd.promise;
		}
	}
	return null;
}

// editor column plugin function

return function(column, editor, editOn){
	// summary:
	//		Adds editing capability to a column's cells.
	
	var originalRenderCell = column.renderCell || Grid.defaultRenderCell,
		listeners = [],
		isWidget;
	
	function commonInit(column) {
		// Common initialization logic for both editOn and always-on editors
		var grid = column.grid,
			focusoutHandle,
			previouslyFocusedCell;
		
		if(!grid.edit){
			// Only perform this logic once on a given grid
			grid.edit = edit;
			grid._editorsPendingStartup = [];
			
			listeners.push(on(grid.domNode, '.dgrid-input:focusin', function () {
				grid._focusedEditorCell = grid.cell(this);
			}));
			focusoutHandle = grid._editorFocusoutHandle =
				on.pausable(grid.domNode, '.dgrid-input:focusout', function () {
					grid._focusedEditorCell = null;
				});
			listeners.push(focusoutHandle);
			
			listeners.push(aspect.before(grid, 'removeRow', function (row) {
				var focusedCell = grid._focusedEditorCell;
				row = grid.row(row);
				if (focusedCell && focusedCell.row.id === row.id) {
					previouslyFocusedCell = focusedCell;
					
					// Pause the focusout handler until after this row has had
					// time to re-render, if this removal is part of an update.
					// A setTimeout is used here instead of resuming in the
					// insertRow aspect below, since if a row were actually
					// removed (not updated) while editing, the handler would
					// not be properly hooked up again for future occurrences.
					focusoutHandle.pause();
					setTimeout(function () {
						focusoutHandle.resume();
						previouslyFocusedCell = null;
					}, 0);
				}
			}));
			listeners.push(aspect.after(grid, 'insertRow', function (rowElement) {
				var row = grid.row(rowElement);
				if (previouslyFocusedCell && previouslyFocusedCell.row.id === row.id) {
					grid.edit(grid.cell(row, previouslyFocusedCell.column.id));
				}
				return rowElement;
			}));
			listeners.push(aspect.after(grid, 'renderArray', function (rows) {
				when(rows, function (resolvedRows) {
					// Finish processing any pending editors that are now displayed
					if(resolvedRows.length){
						startupPendingEditors(grid);
					}else{
						grid._editorsPendingStartup = [];
					}
				});
				return rows;
			}));
			listeners.push(aspect.after(grid, '_onNotification', function () {
				startupPendingEditors(grid);
			}));
		}
	}

	if(!column){ column = {}; }
	
	// accept arguments as parameters to editor function, or from column def,
	// but normalize to column def.
	column.editor = editor = editor || column.editor || "text";
	column.editOn = editOn = editOn || column.editOn;
	
	isWidget = typeof editor != "string";
	
	// warn for widgetArgs -> editorArgs; TODO: remove @ 0.4
	if(column.widgetArgs){
		kernel.deprecated("column.widgetArgs", "use column.editorArgs instead",
			"dgrid 0.4");
		column.editorArgs = column.widgetArgs;
	}
	
	aspect.after(column, "init", editOn ? function(){
		commonInit(column);
		// Create one shared widget/input to be swapped into the active cell.
		column.editorInstance = createSharedEditor(column, originalRenderCell);
	} : function(){
		var grid = column.grid;
		commonInit(column);
		
		if(isWidget){
			// add advice for cleaning up widgets in this column
			listeners.push(aspect.before(grid, "removeRow", function(rowElement){
				// destroy our widget during the row removal operation,
				// but don't trip over loading nodes from incomplete requests
				var cellElement = grid.cell(rowElement, column.id).element,
					widget = cellElement && (cellElement.contents || cellElement).widget;
				if(widget){
					grid._editorFocusoutHandle.pause();
					widget.destroyRecursive();
				}
			}));
		}
	});
	
	aspect.after(column, "destroy", function(){
		arrayUtil.forEach(listeners, function(l){ l.remove(); });
		if(column._editorBlurHandle){ column._editorBlurHandle.remove(); }
		if(column._editTimer){ clearTimeout(column._editTimer); }
		
		if(editOn && isWidget){ column.editorInstance.destroyRecursive(); }
		
		// Remove the edit function, so that it (and other one-time listeners)
		// will be re-added if editor columns are re-initialized
		column.grid.edit = null;
		column.grid._editorsPendingStartup = null;
	});
	
	column.renderCell = editOn ? function(object, value, cell, options){
		// TODO: Consider using event delegation
		// (Would require using dgrid's focus events for activating on focus,
		// which we already advocate in README for optimal use)
		var grid = column.grid;
		if(!options || !options.alreadyHooked){
			// in IE<8, cell is the child of the td due to the extra padding node
			on(cell.tagName == "TD" ? cell : cell.parentNode, editOn, function(){
				grid._activeOptions = options;
				grid.edit(this);
			});
		}
		
		// initially render content in non-edit mode
		return originalRenderCell.call(column, object, value, cell, options);
		
	} : function(object, value, cell, options){
		// always-on: create editor immediately upon rendering each cell
		if(!column.canEdit || column.canEdit(object, value)){
			var cmp = createEditor(column);
			showEditor(cmp, column, cell, value);
			// Maintain reference for later use.
			cell[isWidget ? "widget" : "input"] = cmp;
		}else{
			return originalRenderCell.call(column, object, value, cell, options);
		}
	};
	
	return column;
};
});

},
'dgrid/selector':function(){
define(["dojo/_base/kernel", "dojo/_base/array", "dojo/on", "dojo/aspect", "dojo/_base/sniff", "put-selector/put"],
function(kernel, arrayUtil, on, aspect, has, put){
	return function(column, type){
		
		var listeners = [],
			grid, headerCheckbox;
		
		if(!column){ column = {}; }
		
		if(column.type){
			column.selectorType = column.type;
			kernel.deprecated("columndef.type", "use columndef.selectorType instead", "dgrid 0.4");
		}
		// accept type as argument to Selector function, or from column def
		column.selectorType = type = type || column.selectorType || "checkbox";
		column.sortable = false;

		function disabled(item) {
			return !grid.allowSelect(grid.row(item));
		}
		
		function changeInput(value){
			// creates a function that modifies the input on an event
			return function(event){
				var rows = event.rows,
					len = rows.length,
					state = "false",
					selection, mixed, i;
				
				for(i = 0; i < len; i++){
					var element = grid.cell(rows[i], column.id).element;
					if(!element){ continue; } // skip if row has been entirely removed
					element = (element.contents || element).input;
					if(element && !element.disabled){
						// only change the value if it is not disabled
						element.checked = value;
						element.setAttribute("aria-checked", value);
					}
				}
				if(headerCheckbox.type == "checkbox"){
					selection = grid.selection;
					mixed = false;
					// see if the header checkbox needs to be indeterminate
					for(i in selection){
						// if there is anything in the selection, than it is indeterminate
						if(selection[i] != grid.allSelected){
							mixed = true;
							break;
						}
					}
					headerCheckbox.indeterminate = mixed;
					headerCheckbox.checked = grid.allSelected;
					if (mixed) {
						state = "mixed";
					} else if (grid.allSelected) {
						state = "true";
					}
					headerCheckbox.setAttribute("aria-checked", state);
				}
			};
		}
		
		function onSelect(event){
			// we would really only care about click, since other input sources, like spacebar
			// trigger a click, but the click event doesn't provide access to the shift key in firefox, so
			// listen for keydown's as well to get an event in firefox that we can properly retrieve
			// the shiftKey property from
			if(event.type == "click" || event.keyCode == 32 || (!has("opera") && event.keyCode == 13) || event.keyCode === 0){
				var row = grid.row(event);
				grid._selectionTriggerEvent = event;
				
				if(row){
					if(grid.allowSelect(row)){
						var lastRow = grid._lastSelected && grid.row(grid._lastSelected);
						
						if (type == "radio" || grid.selectionMode === "single") {
							if(!lastRow || lastRow.id != row.id){
								grid.clearSelection();
								grid.select(row, null, true);
								grid._lastSelected = row.element;
							}
						}else{
							if(row){
								if(event.shiftKey){
									// make sure the last input always ends up checked for shift key
									changeInput(true)({rows: [row]});
								}else{
									// no shift key, so no range selection
									lastRow = null;
								}
								lastRow = event.shiftKey ? lastRow : null;
								grid.select(lastRow || row, row, lastRow ? undefined : null);
								grid._lastSelected = row.element;
							}
						}
					}
				}else{
					// No row resolved; must be the select-all checkbox.
					put(this, (grid.allSelected ? "!" : ".") + "dgrid-select-all");
					grid[grid.allSelected ? "clearSelection" : "selectAll"]();
				}
				grid._selectionTriggerEvent = null;
			}
		}
		
		function setupSelectionEvents(){
			// register one listener at the top level that receives events delegated
			grid._hasSelectorInputListener = true;
			listeners.push(grid.on(".dgrid-selector:click,.dgrid-selector:keydown", onSelect));
			var handleSelect = grid._handleSelect;
			grid._handleSelect = function(event){
				// ignore the default select handler for events that originate from the selector column
				if(this.cell(event).column != column){
					handleSelect.apply(this, arguments);
				}
			};
			
			// Set up disabled and grid.allowSelect to match each other's behaviors
			if(typeof column.disabled == "function"){
				var originalAllowSelect = grid.allowSelect,
					originalDisabled = column.disabled;

				// Wrap allowSelect to consult both the original allowSelect and disabled
				grid.allowSelect = function(row){
					var allow = originalAllowSelect.call(this, row);

					if (originalDisabled === disabled) {
						return allow;
					} else {
						return allow && !originalDisabled.call(column, row.data);
					}
				};

				// Then wrap disabled to simply call the new allowSelect
				column.disabled = disabled;
			}else{
				// If no disabled function was specified, institute a default one
				// which honors allowSelect
				column.disabled = disabled;
			}
			// register listeners to the select and deselect events to change the input checked value
			listeners.push(grid.on("dgrid-select", changeInput(true)));
			listeners.push(grid.on("dgrid-deselect", changeInput(false)));
		}
		
		var renderInput = typeof type == "function" ? type : function(value, cell, object){
			var parent = cell.parentNode,
				disabled;
			
			if(!grid._hasSelectorInputListener){
				setupSelectionEvents();
			}
			
			// column.disabled gets initialized or wrapped in setupSelectionEvents
			disabled = column.disabled;

			// must set the class name on the outer cell in IE for keystrokes to be intercepted
			put(parent && parent.contents ? parent : cell, ".dgrid-selector");
			var input = cell.input || (cell.input = put(cell, "input[type="+type + "]", {
				tabIndex: isNaN(column.tabIndex) ? -1 : column.tabIndex,
				disabled: disabled && (typeof disabled == "function" ?
					disabled.call(column, object) : disabled),
				checked: value
			}));
			input.setAttribute("aria-checked", !!value);
			
			return input;
		};
		
		aspect.after(column, "init", function(){
			grid = column.grid;
		});
		
		aspect.after(column, "destroy", function(){
			arrayUtil.forEach(listeners, function(l){ l.remove(); });
			grid._hasSelectorInputListener = false;
		});
		
		column.renderCell = function(object, value, cell, options, header){
			var row = object && grid.row(object);
			value = row && grid.selection[row.id];
			renderInput(value, cell, object);
		};
		column.renderHeaderCell = function(th){
			var label = "label" in column ? column.label :
				column.field || "";
			
			if(type == "radio" || !grid.allowSelectAll){
				th.appendChild(document.createTextNode(label));
				if(!grid._hasSelectorInputListener){
					setupSelectionEvents();
				}
			}else{
				renderInput(false, th, {});
			}
			headerCheckbox = th.lastChild;
		};
		
		return column;
	};
});

},
'dgrid/extensions/ColumnHider':function(){
define(["dojo/_base/declare", "dojo/has", "dojo/on", "../util/misc", "put-selector/put", "dojo/i18n!./nls/columnHider", "xstyle/css!../css/extensions/ColumnHider.css"],
function(declare, has, listen, miscUtil, put, i18n){
/*
 *	Column Hider plugin for dgrid
 *	Originally contributed by TRT 2011-09-28
 *
 *	A dGrid plugin that attaches a menu to a dgrid, along with a way of opening it,
 *	that will allow you to show and hide columns.  A few caveats:
 *
 *	1. Menu placement is entirely based on CSS definitions.
 *	2. If you want columns initially hidden, you must add "hidden: true" to your
 *		column definition.
 *	3. This implementation does NOT support ColumnSet, and has not been tested
 *		with multi-subrow records.
 *	4. Column show/hide is controlled via straight up HTML checkboxes.  If you
 *		are looking for something more fancy, you'll probably need to use this
 *		definition as a template to write your own plugin.
 *
 */
	
	var activeGrid, // references grid for which the menu is currently open
		bodyListener, // references pausable event handler for body mousedown
		// Need to handle old IE specially for checkbox listener and for attribute.
		hasIE = has("ie"),
		hasIEQuirks = hasIE && has("quirks"),
		forAttr = hasIE < 8 || hasIEQuirks ? "htmlFor" : "for";
	
	function getColumnIdFromCheckbox(cb, grid){
		// Given one of the checkboxes from the hider menu,
		// return the id of the corresponding column.
		// (e.g. gridIDhere-hider-menu-check-colIDhere -> colIDhere)
		return cb.id.substr(grid.id.length + 18);
	}
	
	return declare(null, {
		// hiderMenuNode: DOMNode
		//		The node for the menu to show/hide columns.
		hiderMenuNode: null,
		
		// hiderToggleNode: DOMNode
		//		The node for the toggler to open the menu.
		hiderToggleNode: null,
		
		// i18nColumnHider: Object
		//		This object contains all of the internationalized strings for
		//		the ColumnHider extension as key/value pairs.
		i18nColumnHider: i18n,
		
		// _hiderMenuOpened: Boolean
		//		Records the current open/closed state of the menu.
		_hiderMenuOpened: false,
		
		// _columnHiderRules: Object
		//		Hash containing handles returned from addCssRule.
		_columnHiderRules: null,
		
		// _columnHiderCheckboxes: Object
		//		Hash containing checkboxes generated for menu items.
		_columnHiderCheckboxes: null,
		
		_renderHiderMenuEntries: function(){
			// summary:
			//		Iterates over subRows for the sake of adding items to the
			//		column hider menu.
			
			var subRows = this.subRows,
				first = true,
				srLength, cLength, sr, c;
			
			delete this._columnHiderFirstCheckbox;
			
			for(sr = 0, srLength = subRows.length; sr < srLength; sr++){
				for(c = 0, cLength = subRows[sr].length; c < cLength; c++){
					this._renderHiderMenuEntry(subRows[sr][c]);
					if(first){
						first = false;
						this._columnHiderFirstCheckbox =
							this._columnHiderCheckboxes[subRows[sr][c].id];
					}
				}
			}
		},
		
		_renderHiderMenuEntry: function(col){
			var id = col.id,
				replacedId = miscUtil.escapeCssIdentifier(id, "-"),
				div,
				checkId,
				checkbox,
				label;
			
			if(col.hidden){
				// Hide the column (reset first to avoid short-circuiting logic)
				col.hidden = false;
				this._hideColumn(id);
				col.hidden = true;
			}
			
			// Allow cols to opt out of the hider (e.g. for selector column).
			if(col.unhidable){ return; }
			
			// Create the checkbox and label for each column selector.
			div = put("div.dgrid-hider-menu-row");
			checkId = this.domNode.id + "-hider-menu-check-" + replacedId;
			
			// put-selector can't handle invalid selector characters, and the
			// ID could have some, so add it directly
			checkbox = this._columnHiderCheckboxes[id] =
				put(div, "input.dgrid-hider-menu-check.hider-menu-check-" + replacedId + "[type=checkbox]");
			checkbox.id = checkId;
			
			label = put(div, "label.dgrid-hider-menu-label.hider-menu-label-" + replacedId +
				"[" + forAttr + "=" + checkId + "]",
				col.label || col.field || "");
			
			put(this.hiderMenuNode, div);
			
			if(!col.hidden){
				// Hidden state is false; checkbox should be initially checked.
				// (Need to do this after adding to DOM to avoid IE6 clobbering it.)
				checkbox.checked = true;
			}
		},
		
		renderHeader: function(){
			var grid = this,
				hiderMenuNode = this.hiderMenuNode,
				hiderToggleNode = this.hiderToggleNode,
				id;
			
			function stopPropagation(event){
				event.stopPropagation();
			}
			
			this.inherited(arguments);
			
			if(!hiderMenuNode){ // first run
				// Assume that if this plugin is used, then columns are hidable.
				// Create the toggle node.
				hiderToggleNode = this.hiderToggleNode =
					put(this.domNode, "button.ui-icon.dgrid-hider-toggle[type=button][aria-label=" +
						this.i18nColumnHider.popupTriggerLabel + "]");
				
				this._listeners.push(listen(hiderToggleNode, "click", function(e){
					grid._toggleColumnHiderMenu(e);
				}));
	
				// Create the column list, with checkboxes.
				hiderMenuNode = this.hiderMenuNode =
					put("div.dgrid-hider-menu[role=dialog][aria-label=" +
						this.i18nColumnHider.popupLabel + "]");
				hiderMenuNode.id = this.id + "-hider-menu";

				this._listeners.push(listen(hiderMenuNode, "keyup", function (e) {
					var charOrCode = e.charCode || e.keyCode;
					if(charOrCode === /*ESCAPE*/ 27){
						grid._toggleColumnHiderMenu(e);
						hiderToggleNode.focus();
					}
				}));
				
				// Make sure our menu is initially hidden, then attach to the document.
				hiderMenuNode.style.display = "none";
				put(this.domNode, hiderMenuNode);
				
				// Hook up delegated listener for modifications to checkboxes.
				this._listeners.push(listen(hiderMenuNode,
						".dgrid-hider-menu-check:" + (hasIE < 9 || hasIEQuirks ? "click" : "change"),
					function(e){
						grid._updateColumnHiddenState(
							getColumnIdFromCheckbox(e.target, grid), !e.target.checked);
					}
				));
				
				// Stop click events from propagating from menu or trigger nodes,
				// so that we can simply track body clicks for hide without
				// having to drill-up to check.
				this._listeners.push(
					listen(hiderMenuNode, "mousedown", stopPropagation),
					listen(hiderToggleNode, "mousedown", stopPropagation)
				);
				
				// Hook up top-level mousedown listener if it hasn't been yet.
				if(!bodyListener){
					bodyListener = listen.pausable(document, "mousedown", function(e){
						// If an event reaches this listener, the menu is open,
						// but a click occurred outside, so close the dropdown.
						activeGrid && activeGrid._toggleColumnHiderMenu(e);
					});
					bodyListener.pause(); // pause initially; will resume when menu opens
				}
			}else{ // subsequent run
				// Remove active rules, and clear out the menu (to be repopulated).
				for(id in this._columnHiderRules){
					this._columnHiderRules[id].remove();
				}
				hiderMenuNode.innerHTML = "";
			}
			
			this._columnHiderCheckboxes = {};
			this._columnHiderRules = {};

			// Populate menu with checkboxes/labels based on current columns.
			this._renderHiderMenuEntries();
		},
		
		destroy: function(){
			this.inherited(arguments);
			// Remove any remaining rules applied to hidden columns.
			for(var id in this._columnHiderRules){
				this._columnHiderRules[id].remove();
			}
		},
		
		left: function(cell, steps){
			return this.right(cell, -steps);
		},
		
		right: function(cell, steps){
			if(!cell.element){
				cell = this.cell(cell);
			}
			var nextCell = this.inherited(arguments),
				prevCell = cell;
			
			// Skip over hidden cells
			while(nextCell.column.hidden){
				nextCell = this.inherited(arguments, [nextCell, steps > 0 ? 1 : -1]);
				if(prevCell.element === nextCell.element){
					// No further visible cell found - return original
					return cell;
				}
				prevCell = nextCell;
			}
			return nextCell;
		},
		
		isColumnHidden: function(id){
			// summary:
			//		Convenience method to determine current hidden state of a column
			return !!this._columnHiderRules[id];
		},
		
		_toggleColumnHiderMenu: function(){
			var hidden = this._hiderMenuOpened, // reflects hidden state after toggle
				hiderMenuNode = this.hiderMenuNode,
				domNode = this.domNode,
				firstCheckbox;

			// Show or hide the hider menu
			hiderMenuNode.style.display = (hidden ? "none" : "");

			// Adjust height of menu
			if (hidden) {
				// Clear the set size
				hiderMenuNode.style.height = "";
			} else {
				// Adjust height of the menu if necessary
				// Why 12? Based on menu default paddings and border, we need
				// to adjust to be 12 pixels shorter. Given the infrequency of
				// this style changing, we're assuming it will remain this
				// static value of 12 for now, to avoid pulling in any sort of
				// computed styles.
				if (hiderMenuNode.offsetHeight > domNode.offsetHeight - 12) {
					hiderMenuNode.style.height = (domNode.offsetHeight - 12) + "px";
				}
				// focus on the first checkbox
				(firstCheckbox = this._columnHiderFirstCheckbox) && firstCheckbox.focus();
			}

			// Pause or resume the listener for clicks outside the menu
			bodyListener[hidden ? "pause" : "resume"]();

			// Update activeGrid appropriately
			activeGrid = hidden ? null : this;

			// Toggle the instance property
			this._hiderMenuOpened = !hidden;
		},
		
		_hideColumn: function(id){
			// summary:
			//		Hides the column indicated by the given id.
			
			// Use miscUtil function directly, since we clean these up ourselves anyway
			var grid = this,
				selectorPrefix = "#" + miscUtil.escapeCssIdentifier(this.domNode.id) + " .dgrid-column-",
				tableRule; // used in IE8 code path

			if (this._columnHiderRules[id]) {
				return;
			}

			this._columnHiderRules[id] =
				miscUtil.addCssRule(selectorPrefix + miscUtil.escapeCssIdentifier(id, "-"),
					"display: none;");

			if((has("ie") === 8 || has("ie") === 10) && !has("quirks")){
				tableRule = miscUtil.addCssRule(".dgrid-row-table", "display: inline-table;");

				window.setTimeout(function(){
					tableRule.remove();
					grid.resize();
				}, 0);
			}
		},
		
		_showColumn: function(id){
			// summary:
			//		Shows the column indicated by the given id
			//		(by removing the rule responsible for hiding it).
			
			if(this._columnHiderRules[id]){
				this._columnHiderRules[id].remove();
				delete this._columnHiderRules[id];
			}
		},
		
		_updateColumnHiddenState: function(id, hidden){
			// summary:
			//		Performs internal work for toggleColumnHiddenState; see the public
			//		method for more information.
			
			this[hidden ? '_hideColumn' : '_showColumn'](id);
			
			// Update hidden state in actual column definition,
			// in case columns are re-rendered.
			this.columns[id].hidden = hidden;
			
			// Emit event to notify of column state change.
			listen.emit(this.domNode, "dgrid-columnstatechange", {
				grid: this,
				column: this.columns[id],
				hidden: hidden,
				bubbles: true
			});

			// Adjust the size of the header.
			this.resize();
		},
		
		toggleColumnHiddenState: function(id, hidden){
			// summary:
			//		Shows or hides the column with the given id.
			// id: String
			//		ID of column to show/hide.
			// hide: Boolean?
			//		If specified, explicitly sets the hidden state of the specified
			//		column.  If unspecified, toggles the column from the current state.
			
			if(typeof hidden === "undefined"){ hidden = !this._columnHiderRules[id]; }
			this._updateColumnHiddenState(id, hidden);
			
			// Since this can be called directly, re-sync the appropriate checkbox.
			this._columnHiderCheckboxes[id].checked = !hidden;
		}
	});
});

},
'dgrid/extensions/ColumnReorder':function(){
define([
	"dojo/_base/lang",
	"dojo/_base/declare",
	"dojo/_base/array",
	"dojo/on",
	"dojo/query",
	"dojo/dnd/Source",
	"put-selector/put",
	"xstyle/css!../css/extensions/ColumnReorder.css"
], function(lang, declare, arrayUtil, on, query, DndSource, put){
	var dndTypeRx = /(\d+)(?:-(\d+))?$/; // used to determine subrow from dndType
	
	// The following 2 functions are used by onDropInternal logic for
	// retrieving/modifying a given subRow.  The `match` variable in each is
	// expected to be the result of executing dndTypeRx on a subRow ID.
	
	function getMatchingSubRow(grid, match) {
		var hasColumnSets = match[2],
			rowOrSet = grid[hasColumnSets ? "columnSets" : "subRows"][match[1]];
		
		return hasColumnSets ? rowOrSet[match[2]] : rowOrSet;
	}
	
	function setMatchingSubRow(grid, match, subRow) {
		if(match[2]){
			grid.columnSets[match[1]][match[2]] = subRow;
		}else{
			grid.subRows[match[1]] = subRow;
		}
	}

	// Builds a prefix for a dndtype value based on a grid id.
	function makeDndTypePrefix(gridId) {
		return "dgrid-" + gridId + '-';
	}

	// Removes the grid id prefix from a dndtype value.  This allows the grid id to contain
	// a dash-number suffix.  This works only if a column is dropped on the grid from which it
	// originated.  Otherwise, a dash-number suffix will cause the regex to match on the wrong values.
	function stripIdPrefix(gridId, dndtype) {
		return dndtype.slice(makeDndTypePrefix(gridId).length);
	}
	
	var ColumnDndSource = declare(DndSource, {
		// summary:
		//		Custom dojo/dnd source extension configured specifically for
		//		dgrid column reordering.
		
		copyState: function(){ return false; }, // never copy
		
		checkAcceptance: function(source, nodes){
			return source == this; // self-accept only
		},
		
		_legalMouseDown: function(evt){
			// Overridden to prevent blocking ColumnResizer resize handles.
			return evt.target.className.indexOf("dgrid-resize-handle") > -1 ? false :
				this.inherited(arguments);
		},
		
		onDropInternal: function(nodes){
			var grid = this.grid,
				match = dndTypeRx.exec(stripIdPrefix(grid.id, nodes[0].getAttribute("dndType"))),
				structureProperty = match[2] ? "columnSets" : "subRows",
				oldSubRow = getMatchingSubRow(grid, match),
				columns = grid.columns;
			
			// First, allow original DnD logic to place node in new location.
			this.inherited(arguments);
			
			if(!match){ return; }
			
			// Then, iterate through the header cells in their new order,
			// to populate a new row array to assign as a new sub-row to the grid.
			// (Wait until the next turn to avoid errors in Opera.)
			setTimeout(function(){
				var newSubRow = arrayUtil.map(nodes[0].parentNode.childNodes, function(col) {
						return columns[col.columnId];
					}),
					eventObject;
				
				setMatchingSubRow(grid, match, newSubRow);
				
				eventObject = {
					grid: grid,
					subRow: newSubRow,
					column: columns[nodes[0].columnId],
					bubbles: true,
					cancelable: true,
					// Set parentType to indicate this is the result of user interaction.
					parentType: "dnd"
				};
				// Set columnSets or subRows depending on which the grid is using.
				eventObject[structureProperty] = grid[structureProperty];
				
				// Emit a custom event which passes the new structure.
				// Allow calling preventDefault() to cancel the reorder operation.
				if(on.emit(grid.domNode, "dgrid-columnreorder", eventObject)){
					// Event was not canceled - force processing of modified structure.
					grid.set(structureProperty, grid[structureProperty]);
				}else{
					// Event was canceled - revert the structure and re-render the header
					// (since the inherited logic invoked above will have shifted cells).
					setMatchingSubRow(grid, match, oldSubRow);
					grid.renderHeader();
					// After re-rendering the header, re-apply the sort arrow if needed.
					if (this._sort && this._sort.length){
						this.updateSortArrow(this._sort);
					}
				}
			}, 0);
		}
	});
	
	var ColumnReorder = declare(null, {
		// summary:
		//		Extension allowing reordering of columns in a grid via drag'n'drop.
		//		Reordering of columns within the same subrow or columnset is also
		//		supported; between different ones is not.
		
		// columnDndConstructor: Function
		//		Constructor to call for instantiating DnD sources within the grid's
		//		header.
		columnDndConstructor: ColumnDndSource,
		
		_initSubRowDnd: function(subRow, dndType){
			// summary:
			//		Initializes a dojo/dnd source for one subrow of a grid;
			//		this could be its only subrow, one of several, or a subrow within a
			//		columnset.
			
			var dndParent, c, len, col, th;
			
			for(c = 0, len = subRow.length; c < len; c++){
				col = subRow[c];
				if(col.reorderable === false){ continue; }
				
				th = col.headerNode;
				if(th.tagName != "TH"){ th = th.parentNode; } // from IE < 8 padding
				// Add dojoDndItem class, and a dndType unique to this subrow.
				put(th, ".dojoDndItem[dndType=" + dndType + "]");
				
				if(!dndParent){ dndParent = th.parentNode; }
			}
			
			if(dndParent){ // (if dndParent wasn't set, no columns are draggable!)
				this._columnDndSources.push(new this.columnDndConstructor(dndParent, {
					horizontal: true,
					grid: this
				}));
			}
		},
		
		renderHeader: function(){
			var dndTypePrefix = makeDndTypePrefix(this.id),
				csLength, cs;
			
			this.inherited(arguments);
			
			// After header is rendered, set up a dnd source on each of its subrows.
			
			this._columnDndSources = [];
			
			if(this.columnSets){
				// Iterate columnsets->subrows->columns.
				for(cs = 0, csLength = this.columnSets.length; cs < csLength; cs++){
					arrayUtil.forEach(this.columnSets[cs], function(subRow, sr){
						this._initSubRowDnd(subRow, dndTypePrefix + cs + "-" + sr);
					}, this);
				}
			}else{
				// Iterate subrows->columns.
				arrayUtil.forEach(this.subRows, function(subRow, sr){
					this._initSubRowDnd(subRow, dndTypePrefix + sr);
				}, this);
			}
		},
		
		_destroyColumns: function(){
			if(this._columnDndSources){
				// Destroy old dnd sources.
				arrayUtil.forEach(this._columnDndSources, function(source){
					source.destroy();
				});
			}
			
			this.inherited(arguments);
		}
	});
	
	ColumnReorder.ColumnDndSource = ColumnDndSource;
	return ColumnReorder;
});

},
'dgrid/extensions/ColumnResizer':function(){
define(["dojo/_base/declare", "dojo/on", "dojo/query", "dojo/_base/lang", "dojo/dom", "dojo/dom-geometry", "dojo/has", "../util/misc", "put-selector/put", "dojo/_base/html", "xstyle/css!../css/extensions/ColumnResizer.css"],
function(declare, listen, query, lang, dom, geom, has, miscUtil, put){

function addRowSpan(table, span, startRow, column, id){
	// loop through the rows of the table and add this column's id to
	// the rows' column
	for(var i=1; i<span; i++){
		table[startRow+i][column] = id;
	}
}
function subRowAssoc(subRows){
	// Take a sub-row structure and output an object with key=>value pairs
	// The keys will be the column id's; the values will be the first-row column
	// that column's resizer should be associated with.

	var i = subRows.length,
		l = i,
		numCols = subRows[0].length,
		table = new Array(i);

	// create table-like structure in an array so it can be populated
	// with row-spans and col-spans
	while(i--){
		table[i] = new Array(numCols);
	}

	var associations = {};

	for(i=0; i<l; i++){
		var row = table[i],
			subRow = subRows[i];

		// j: counter for table columns
		// js: counter for subrow structure columns
		for(var j=0, js=0; j<numCols; j++){
			var cell = subRow[js], k;

			// if something already exists in the table (row-span), skip this
			// spot and go to the next
			if(typeof row[j] != "undefined"){
				continue;
			}
			row[j] = cell.id;

			if(cell.rowSpan && cell.rowSpan > 1){
				addRowSpan(table, cell.rowSpan, i, j, cell.id);
			}

			// colSpans are only applicable in the second or greater rows
			// and only if the colSpan is greater than 1
			if(i>0 && cell.colSpan && cell.colSpan > 1){
				for(k=1; k<cell.colSpan; k++){
					// increment j and assign the id since this is a span
					row[++j] = cell.id;
					if(cell.rowSpan && cell.rowSpan > 1){
						addRowSpan(table, cell.rowSpan, i, j, cell.id);
					}
				}
			}
			associations[cell.id] = subRows[0][j].id;
			js++;
		}
	}

	return associations;
}

function resizeColumnWidth(grid, colId, width, parentType, doResize){
	// don't react to widths <= 0, e.g. for hidden columns
	if(width <= 0){ return; }

	var column = grid.columns[colId],
		event,
		rule;
	
	if(!column){
		return;
	}
	
	event = {
		grid: grid,
		columnId: colId,
		width: width,
		bubbles: true,
		cancelable: true
	};
	
	if(parentType){
		event.parentType = parentType;
	}
	
	if(!grid._resizedColumns || listen.emit(grid.headerNode, "dgrid-columnresize", event)){
		// Update width on column object, then convert value for CSS
		if(width === "auto"){
			delete column.width;
		}else{
			column.width = width;
			width += "px";
		}
		
		rule = grid._columnSizes[colId];
		
		if(rule){
			// Modify existing, rather than deleting + adding
			rule.set("width", width);
		}else{
			// Use miscUtil function directly, since we clean these up ourselves anyway
			rule = miscUtil.addCssRule("#" + miscUtil.escapeCssIdentifier(grid.domNode.id) +
				" .dgrid-column-" + miscUtil.escapeCssIdentifier(colId, "-"),
				"width: " + width + ";");
		}

		// keep a reference for future removal
		grid._columnSizes[colId] = rule;
		
		if(doResize !== false){
			grid.resize();
		}
		
		return true;
	}
}

// Functions for shared resizer node

var resizerNode, // DOM node for resize indicator, reused between instances
	resizableCount = 0; // Number of ColumnResizer-enabled grid instances
var resizer = {
	// This object contains functions for manipulating the shared resizerNode
	create: function(){
		resizerNode = put("div.dgrid-column-resizer");
	},
	destroy: function(){
		put(resizerNode, "!");
		resizerNode = null;
	},
	show: function(grid){
		var pos = geom.position(grid.domNode, true);
		resizerNode.style.top = pos.y + "px";
		resizerNode.style.height = pos.h + "px";
		put(document.body, resizerNode);
	},
	move: function(x){
		resizerNode.style.left = x + "px";
	},
	hide: function(){
		resizerNode.parentNode.removeChild(resizerNode);
	}
};

return declare(null, {
	resizeNode: null,
	
	// minWidth: Number
	//		Minimum column width, in px.
	minWidth: 40,
	
	// adjustLastColumn: Boolean
	//		If true, adjusts the last column's width to "auto" at times where the
	//		browser would otherwise stretch all columns to span the grid.
	adjustLastColumn: true,
	
	_resizedColumns: false, // flag indicating if resizer has converted column widths to px
	
	buildRendering: function(){
		this.inherited(arguments);
		
		// Create resizerNode when first grid w/ ColumnResizer is created
		if(!resizableCount++){
			resizer.create();
		}
	},
	
	destroy: function(){
		this.inherited(arguments);
		
		// Remove any applied column size styles since we're tracking them directly
		for(var name in this._columnSizes){
			this._columnSizes[name].remove();
		}
		
		// If this is the last grid on the page with ColumnResizer, destroy the
		// shared resizerNode
		if(!--resizableCount){
			resizer.destroy();
		}
	},
	
	resizeColumnWidth: function(colId, width){
		// Summary:
		//      calls grid's styleColumn function to add a style for the column
		// colId: String
		//      column id
		// width: Integer
		//      new width of the column
		return resizeColumnWidth(this, colId, width);
	},
	
	configStructure: function(){
		var oldSizes = this._oldColumnSizes = lang.mixin({}, this._columnSizes), // shallow clone
			k;
		
		this._resizedColumns = false;
		this._columnSizes = {};
		
		this.inherited(arguments);
		
		// Remove old column styles that are no longer relevant; this is specifically
		// done *after* calling inherited so that _columnSizes will contain keys
		// for all columns in the new structure that were assigned widths.
		for(k in oldSizes){
			if(!(k in this._columnSizes)){
				oldSizes[k].remove();
			}
		}
		delete this._oldColumnSizes;
	},
	
	_configColumn: function(column){
		this.inherited(arguments);
		
		var colId = column.id,
			rule;
		
		if("width" in column){
			// Update or add a style rule for the specified width
			if((rule = this._oldColumnSizes[colId])){
				rule.set("width", column.width + "px");
			}else{
				rule = miscUtil.addCssRule("#" + miscUtil.escapeCssIdentifier(this.domNode.id) +
					" .dgrid-column-" + miscUtil.escapeCssIdentifier(colId, "-"),
					"width: " + column.width + "px;");
			}
			this._columnSizes[colId] = rule;
		}
	},
	
	renderHeader: function(){
		this.inherited(arguments);
		
		var grid = this;
		
		var assoc;
		if(this.columnSets && this.columnSets.length){
			var csi = this.columnSets.length;
			while(csi--){
				assoc = lang.mixin(assoc||{}, subRowAssoc(this.columnSets[csi]));
			}
		}else if(this.subRows && this.subRows.length > 1){
			assoc = subRowAssoc(this.subRows);
		}

		var colNodes = query(".dgrid-cell", grid.headerNode),
			i = colNodes.length;
		while(i--){
			var colNode = colNodes[i],
				id = colNode.columnId,
				col = grid.columns[id],
				childNodes = colNode.childNodes,
				resizeHandle;

			if(!col || col.resizable === false){ continue; }

			var headerTextNode = put("div.dgrid-resize-header-container");
			colNode.contents = headerTextNode;

			// move all the children to the header text node
			while(childNodes.length > 0){
				put(headerTextNode, childNodes[0]);
			}

			resizeHandle = put(colNode, headerTextNode, "div.dgrid-resize-handle.resizeNode-" +
				miscUtil.escapeCssIdentifier(id, "-"));
			resizeHandle.columnId = assoc && assoc[id] || id;
		}

		if(!grid.mouseMoveListen){
			// establish listeners for initiating, dragging, and finishing resize
			listen(grid.headerNode,
				".dgrid-resize-handle:mousedown" +
					(has("touch") ? ",.dgrid-resize-handle:touchstart" : ""),
				function(e){
					grid._resizeMouseDown(e, this);
					grid.mouseMoveListen.resume();
					grid.mouseUpListen.resume();
				}
			);
			grid._listeners.push(grid.mouseMoveListen = listen.pausable(document,
				"mousemove" + (has("touch") ? ",touchmove" : ""),
				miscUtil.throttleDelayed(function(e){ grid._updateResizerPosition(e); })
			));
			grid._listeners.push(grid.mouseUpListen = listen.pausable(document,
				"mouseup" + (has("touch") ? ",touchend" : ""),
				function(e){
					grid._resizeMouseUp(e);
					grid.mouseMoveListen.pause();
					grid.mouseUpListen.pause();
				}
			));
			// initially pause the move/up listeners until a drag happens
			grid.mouseMoveListen.pause();
			grid.mouseUpListen.pause();
		}
	}, // end renderHeader

	_resizeMouseDown: function(e, target){
		// Summary:
		//      called when mouse button is pressed on the header
		// e: Object
		//      mousedown event object
		
		// preventDefault actually seems to be enough to prevent browser selection
		// in all but IE < 9.  setSelectable works for those.
		e.preventDefault();
		dom.setSelectable(this.domNode, false);
		this._startX = this._getResizeMouseLocation(e); //position of the target
		
		this._targetCell = query(".dgrid-column-" + miscUtil.escapeCssIdentifier(target.columnId, "-"),
			this.headerNode)[0];

		// Show resizerNode after initializing its x position
		this._updateResizerPosition(e);
		resizer.show(this);
	},
	_resizeMouseUp: function(e){
		// Summary:
		//      called when mouse button is released
		// e: Object
		//      mouseup event object
		
		var columnSizes = this._columnSizes,
			colNodes, colWidths, gridWidth;
		
		if(this.adjustLastColumn){
			// For some reason, total column width needs to be 1 less than this
			gridWidth = this.headerNode.clientWidth - 1;
		}
		
		//This is used to set all the column widths to a static size
		if(!this._resizedColumns){
			colNodes = query(".dgrid-cell", this.headerNode);
			
			if(this.columnSets && this.columnSets.length){
				colNodes = colNodes.filter(function(node){
					var idx = node.columnId.split("-");
					return idx[0] == "0" && !(node.columnId in columnSizes);
				});
			}else if(this.subRows && this.subRows.length > 1){
				colNodes = colNodes.filter(function(node){
					return node.columnId.charAt(0) == "0" && !(node.columnId in columnSizes);
				});
			}
			
			// Get a set of sizes before we start mutating, to avoid
			// weird disproportionate measures if the grid has set
			// column widths, but no full grid width set
			colWidths = colNodes.map(function(colNode){
				return colNode.offsetWidth;
			});
			
			// Set a baseline size for each column based on
			// its original measure
			colNodes.forEach(function(colNode, i){
				resizeColumnWidth(this, colNode.columnId, colWidths[i], null, false);
			}, this);
			
			this._resizedColumns = true;
		}
		dom.setSelectable(this.domNode, true);
		
		var cell = this._targetCell,
			delta = this._getResizeMouseLocation(e) - this._startX, //final change in position of resizer
			newWidth = cell.offsetWidth + delta, //the new width after resize
			obj = this._getResizedColumnWidths(),//get current total column widths before resize
			totalWidth = obj.totalWidth,
			lastCol = obj.lastColId,
			lastColWidth = query(".dgrid-column-" + miscUtil.escapeCssIdentifier(lastCol, "-"),
				this.headerNode)[0].offsetWidth;
		
		if(newWidth < this.minWidth){
			//enforce minimum widths
			newWidth = this.minWidth;
		}
		
		if(resizeColumnWidth(this, cell.columnId, newWidth, e.type)){
			if(cell.columnId != lastCol && this.adjustLastColumn){
				if(totalWidth + delta < gridWidth) {
					//need to set last column's width to auto
					resizeColumnWidth(this, lastCol, "auto", e.type);
				}else if(lastColWidth-delta <= this.minWidth) {
					//change last col width back to px, unless it is the last column itself being resized...
					resizeColumnWidth(this, lastCol, this.minWidth, e.type);
				}
			}
		}
		resizer.hide();
		
		// Clean up after the resize operation
		delete this._startX;
		delete this._targetCell;
	},
	
	_updateResizerPosition: function(e){
		// Summary:
		//      updates position of resizer bar as mouse moves
		// e: Object
		//      mousemove event object

		if(!this._targetCell){ return; } // Release event was already processed
		
		var mousePos = this._getResizeMouseLocation(e),
			delta = mousePos - this._startX, //change from where user clicked to where they drag
			width = this._targetCell.offsetWidth,
			left = mousePos;
		if(width + delta < this.minWidth){ 
			left = this._startX - (width - this.minWidth); 
		}
		resizer.move(left);
	},

	_getResizeMouseLocation: function(e){
		//Summary:
		//      returns position of mouse relative to the left edge
		// e: event object
		//      mouse move event object
		var posX = 0;
		if(e.pageX){
			posX = e.pageX;
		}else if(e.clientX){
			posX = e.clientX + document.body.scrollLeft +
				document.documentElement.scrollLeft;
		}
		return posX;
	},
	_getResizedColumnWidths: function (){
		//Summary:
		//      returns object containing new column width and column id
		var totalWidth = 0,
			colNodes = query(
				(this.columnSets ? ".dgrid-column-set-cell " : "") + "tr:first-child .dgrid-cell",
				this.headerNode);

		var i = colNodes.length;
		if(!i){ return {}; }

		var lastColId = colNodes[i-1].columnId;

		while(i--){
			totalWidth += colNodes[i].offsetWidth;
		}
		return {totalWidth: totalWidth, lastColId: lastColId};
	}
});
});

},
'dgrid/extensions/Pagination':function(){
define(["../_StoreMixin", "dojo/_base/declare", "dojo/_base/array", "dojo/_base/lang", "dojo/_base/Deferred",
	"dojo/on", "dojo/query", "dojo/string", "dojo/has", "put-selector/put", "../util/misc", "dojo/i18n!./nls/pagination",
	"dojo/_base/sniff", "xstyle/css!../css/extensions/Pagination.css"],
function(_StoreMixin, declare, arrayUtil, lang, Deferred, on, query, string, has, put, miscUtil, i18n){
	function cleanupContent(grid){
		// Remove any currently-rendered rows, or noDataMessage
		if(grid.noDataNode){
			put(grid.noDataNode, "!");
			delete grid.noDataNode;
		}else{
			grid.cleanup();
		}
		grid.contentNode.innerHTML = "";
	}
	function cleanupLoading(grid){
		if(grid.loadingNode){
			put(grid.loadingNode, "!");
			delete grid.loadingNode;
		}else if(grid._oldPageNodes){
			// If cleaning up after a load w/ showLoadingMessage: false,
			// be careful to only clean up rows from the old page, not the new one
			for(var id in grid._oldPageNodes){
				grid.removeRow(grid._oldPageNodes[id]);
			}
			delete grid._oldPageNodes;
			// Also remove the observer from the previous page, if there is one
			if(grid._oldPageObserver){
				grid._oldPageObserver.cancel();
				grid._numObservers--;
				delete grid._oldPageObserver;
			}
		}
		delete grid._isLoading;
	}
	
	return declare(_StoreMixin, {
		// summary:
		//		An extension for adding discrete pagination to a List or Grid.
		
		// rowsPerPage: Number
		//		Number of rows (items) to show on a given page.
		rowsPerPage: 10,
		
		// pagingTextBox: Boolean
		//		Indicates whether or not to show a textbox for paging.
		pagingTextBox: false,
		// previousNextArrows: Boolean
		//		Indicates whether or not to show the previous and next arrow links.
		previousNextArrows: true,
		// firstLastArrows: Boolean
		//		Indicates whether or not to show the first and last arrow links.
		firstLastArrows: false,
		
		// pagingLinks: Number
		//		The number of page links to show on each side of the current page
		//		Set to 0 (or false) to disable page links.
		pagingLinks: 2,
		// pageSizeOptions: Array[Number]
		//		This provides options for different page sizes in a drop-down.
		//		If it is empty (default), no page size drop-down will be displayed.
		pageSizeOptions: null,
		
		// showLoadingMessage: Boolean
		//		If true, clears previous data and displays loading node when requesting
		//		another page; if false, leaves previous data in place until new data
		//		arrives, then replaces it immediately.
		showLoadingMessage: true,
		
		// i18nPagination: Object
		//		This object contains all of the internationalized strings as
		//		key/value pairs.
		i18nPagination: i18n,
		
		showFooter: true,
		_currentPage: 1,
		_total: 0,
		
		buildRendering: function(){
			this.inherited(arguments);
			
			// add pagination to footer
			var grid = this,
				paginationNode = this.paginationNode =
					put(this.footerNode, "div.dgrid-pagination"),
				statusNode = this.paginationStatusNode =
					put(paginationNode, "div.dgrid-status"),
				i18n = this.i18nPagination,
				navigationNode,
				node,
				i;
			
			statusNode.tabIndex = 0;
			
			// Initialize UI based on pageSizeOptions and rowsPerPage
			this._updatePaginationSizeSelect();
			this._updateRowsPerPageOption();
			
			// initialize some content into paginationStatusNode, to ensure
			// accurate results on initial resize call
			statusNode.innerHTML = string.substitute(i18n.status,
				{ start: 1, end: 1, total: 0 });
			
			navigationNode = this.paginationNavigationNode =
				put(paginationNode, "div.dgrid-navigation");
			
			if(this.firstLastArrows){
				// create a first-page link
				node = this.paginationFirstNode =
					put(navigationNode,  "span.dgrid-first.dgrid-page-link", "");
				node.setAttribute("aria-label", i18n.gotoFirst);
				node.tabIndex = 0;
			}
			if(this.previousNextArrows){
				// create a previous link
				node = this.paginationPreviousNode =
					put(navigationNode,  "span.dgrid-previous.dgrid-page-link", "");
				node.setAttribute("aria-label", i18n.gotoPrev);
				node.tabIndex = 0;
			}
			
			this.paginationLinksNode = put(navigationNode, "span.dgrid-pagination-links");
			if(this.previousNextArrows){
				// create a next link
				node = this.paginationNextNode =
					put(navigationNode, "span.dgrid-next.dgrid-page-link", "");
				node.setAttribute("aria-label", i18n.gotoNext);
				node.tabIndex = 0;
			}
			if(this.firstLastArrows){
				// create a last-page link
				node = this.paginationLastNode =
					put(navigationNode,  "span.dgrid-last.dgrid-page-link", "");
				node.setAttribute("aria-label", i18n.gotoLast);
				node.tabIndex = 0;
			}
			
			this._listeners.push(on(navigationNode, ".dgrid-page-link:click,.dgrid-page-link:keydown", function(event){
				// For keyboard events, only respond to enter
				if(event.type === "keydown" && event.keyCode !== 13){
					return;
				}
				
				var cls = this.className,
					curr, max;
				
				if(grid._isLoading || cls.indexOf("dgrid-page-disabled") > -1){
					return;
				}
				
				curr = grid._currentPage;
				max = Math.ceil(grid._total / grid.rowsPerPage);
				
				// determine navigation target based on clicked link's class
				if(this === grid.paginationPreviousNode){
					grid.gotoPage(curr - 1);
				}else if(this === grid.paginationNextNode){
					grid.gotoPage(curr + 1);
				}else if(this === grid.paginationFirstNode){
					grid.gotoPage(1);
				}else if(this === grid.paginationLastNode){
					grid.gotoPage(max);
				}else if(cls === "dgrid-page-link"){
					grid.gotoPage(+this.innerHTML); // the innerHTML has the page number
				}
			}));
		},
		
		destroy: function(){
			this.inherited(arguments);
			if(this._pagingTextBoxHandle){
				this._pagingTextBoxHandle.remove();
			}
		},

		_updatePaginationSizeSelect: function(){
			// summary:
			//		Creates or repopulates the pagination size selector based on
			//		the values in pageSizeOptions. Called from buildRendering
			//		and _setPageSizeOptions.
			
			var pageSizeOptions = this.pageSizeOptions,
				paginationSizeSelect = this.paginationSizeSelect,
				handle;
			
			if(pageSizeOptions && pageSizeOptions.length){
				if(!paginationSizeSelect){
					// First time setting page options; create the select
					paginationSizeSelect = this.paginationSizeSelect =
						put(this.paginationNode, "select.dgrid-page-size[aria-label=" +
							this.i18nPagination.rowsPerPage + "]");
					
					handle = this._paginationSizeChangeHandle =
						on(paginationSizeSelect, "change", lang.hitch(this, function(){
							this.set("rowsPerPage", +this.paginationSizeSelect.value);
						}));
					this._listeners.push(handle);
				}
				
				// Repopulate options
				paginationSizeSelect.options.length = 0;
				for(var i = 0; i < pageSizeOptions.length; i++){
					put(paginationSizeSelect, "option", pageSizeOptions[i], {
						value: pageSizeOptions[i],
						selected: this.rowsPerPage === pageSizeOptions[i]
					});
				}
				// Ensure current rowsPerPage value is in options
				this._updateRowsPerPageOption();
			}else if(!(pageSizeOptions && pageSizeOptions.length) && paginationSizeSelect){
				// pageSizeOptions was removed; remove/unhook the drop-down
				put(paginationSizeSelect, "!");
				this.paginationSizeSelect = null;
				this._paginationSizeChangeHandle.remove();
			}
		},

		_setPageSizeOptions: function(pageSizeOptions){
			this.pageSizeOptions = pageSizeOptions && pageSizeOptions.sort(function(a, b){
				return a - b;
			});
			this._updatePaginationSizeSelect();
		},

		_updateRowsPerPageOption: function(){
			// summary:
			//		Ensures that an option for rowsPerPage's value exists in the
			//		paginationSizeSelect drop-down (if one is rendered).
			//		Called from buildRendering and _setRowsPerPage.
			
			var rowsPerPage = this.rowsPerPage,
				pageSizeOptions = this.pageSizeOptions,
				paginationSizeSelect = this.paginationSizeSelect;
			
			if(paginationSizeSelect){
				if(arrayUtil.indexOf(pageSizeOptions, rowsPerPage) < 0){
					this._setPageSizeOptions(pageSizeOptions.concat([rowsPerPage])); 
				}else{
					paginationSizeSelect.value = "" + rowsPerPage;
				}
			}
		},
		
		_setRowsPerPage: function(rowsPerPage){
			this.rowsPerPage = rowsPerPage;
			this._updateRowsPerPageOption();
			this.gotoPage(1);
		},

		_updateNavigation: function(){
			// summary:
			//		Update status and navigation controls based on total count from query
			
			var grid = this,
				i18n = this.i18nPagination,
				linksNode = this.paginationLinksNode,
				currentPage = this._currentPage,
				pagingLinks = this.pagingLinks,
				paginationNavigationNode = this.paginationNavigationNode,
				end = Math.ceil(this._total / this.rowsPerPage),
				pagingTextBoxHandle = this._pagingTextBoxHandle,
				focused = document.activeElement,
				focusedPage,
				lastFocusablePageLink,
				focusableNodes;
			
			function pageLink(page, addSpace){
				var link;
				var disabled;
				if(grid.pagingTextBox && page == currentPage && end > 1){
					// use a paging text box if enabled instead of just a number
					link = put(linksNode, 'input.dgrid-page-input[type=text][value=$]', currentPage);
					link.setAttribute("aria-label", i18n.jumpPage);
					grid._pagingTextBoxHandle = on(link, "change", function(){
						var value = +this.value;
						if(!isNaN(value) && value > 0 && value <= end){
							grid.gotoPage(+this.value);
						}
					});
					if(focused && focused.tagName === "INPUT"){
						link.focus();
					}
				}else{
					// normal link
					disabled = page === currentPage;
					link = put(linksNode,
						'span' + (disabled ? '.dgrid-page-disabled' : '') + '.dgrid-page-link',
						page + (addSpace ? " " : ""));
					link.setAttribute("aria-label", i18n.gotoPage);
					link.tabIndex = disabled ? -1 : 0;
					
					// Try to restore focus if applicable;
					// if we need to but can't, try on the previous or next page,
					// depending on whether we're at the end
					if(focusedPage === page){
						if(!disabled){
							link.focus();
						}else if(page < end){
							focusedPage++;
						}else{
							lastFocusablePageLink.focus();
						}
					}
					
					if(!disabled){
						lastFocusablePageLink = link;
					}
				}
			}
			
			function setDisabled(link, disabled){
				put(link, (disabled ? "." : "!") + "dgrid-page-disabled");
				link.tabIndex = disabled ? -1 : 0;
			}
			
			if(!focused || !miscUtil.contains(this.paginationNavigationNode, focused)){
				focused = null;
			}else if(focused.className === "dgrid-page-link"){
				focusedPage = +focused.innerHTML;
			}
			
			if(pagingTextBoxHandle){ pagingTextBoxHandle.remove(); }
			linksNode.innerHTML = "";
			query(".dgrid-first, .dgrid-previous", paginationNavigationNode).forEach(function(link){
				setDisabled(link, currentPage === 1);
			});
			query(".dgrid-last, .dgrid-next", paginationNavigationNode).forEach(function(link){
				setDisabled(link, currentPage >= end);
			});
			
			if(pagingLinks && end > 0){
				// always include the first page (back to the beginning)
				pageLink(1, true);
				var start = currentPage - pagingLinks;
				if(start > 2) {
					// visual indication of skipped page links
					put(linksNode, "span.dgrid-page-skip", "...");
				}else{
					start = 2;
				}
				// now iterate through all the page links we should show
				for(var i = start; i < Math.min(currentPage + pagingLinks + 1, end); i++){
					pageLink(i, true);
				}
				if(currentPage + pagingLinks + 1 < end){
					put(linksNode, "span.dgrid-page-skip", "...");
				}
				// last link
				if(end > 1){
					pageLink(end);
				}
			}else if(grid.pagingTextBox){
				// The pageLink function is also used to create the paging textbox.
				pageLink(currentPage);
			}
			
			if (focused && focused.tabIndex === -1) {
				// One of the first/last or prev/next links was focused but
				// is now disabled, so find something focusable
				focusableNodes = query("[tabindex='0']", this.paginationNavigationNode);
				if(focused === this.paginationPreviousNode || focused === this.paginationFirstNode){
					focused = focusableNodes[0];
				}else if(focusableNodes.length){
					focused = focusableNodes[focusableNodes.length - 1];
				}
				if(focused){
					focused.focus();
				}
			}
		},
		
		refresh: function(){
			var self = this;
			
			this.inherited(arguments);
			
			if(!this.store){
				console.warn("Pagination requires a store to operate.");
				return;
			}
			
			// Reset to first page and return promise from gotoPage
			return this.gotoPage(1).then(function(results){
				// Emit on a separate turn to enable event to be used consistently for
				// initial render, regardless of whether the backing store is async
				setTimeout(function() {
					on.emit(self.domNode, "dgrid-refresh-complete", {
						bubbles: true,
						cancelable: false,
						grid: self,
						results: results // QueryResults object (may be a wrapped promise)
					});
				}, 0);
				
				return results;
			});
		},
		
		_onNotification: function(rows){
			if(rows.length !== this._rowsOnPage){
				// Refresh the current page to maintain correct number of rows on page
				this.gotoPage(this._currentPage);
			}
		},
		
		renderArray: function(results, beforeNode){
			var grid = this,
				rows = this.inherited(arguments);
			
			// Make sure _lastCollection is cleared (due to logic in List)
			this._lastCollection = null;
			
			if(!beforeNode){
				if(this._topLevelRequest && this._topLevelRequest !== results){
					// Cancel previous async request that didn't finish
					this._topLevelRequest.cancel();
					delete this._topLevelRequest;
				}
				
				if (typeof results.cancel === "function") {
					// Store reference to new async request in progress
					this._topLevelRequest = results;
				}
				
				Deferred.when(results, function(){
					if(grid._topLevelRequest){
						// Remove reference to request now that it's finished
						delete grid._topLevelRequest;
					}
				});
			}
			
			return rows;
		},
		
		insertRow: function(){
			var oldNodes = this._oldPageNodes,
				row = this.inherited(arguments);
			
			if(oldNodes && row === oldNodes[row.id]){
				// If the previous row was reused, avoid removing it in cleanup
				delete oldNodes[row.id];
			}
			
			return row;
		},
		
		gotoPage: function(page){
			// summary:
			//		Loads the given page.  Note that page numbers start at 1.
			var grid = this,
				dfd = new Deferred();
			
			var result = this._trackError(function(){
				var count = grid.rowsPerPage,
					start = (page - 1) * count,
					options = lang.mixin(grid.get("queryOptions"), {
						start: start,
						count: count
						// current sort is also included by get("queryOptions")
					}),
					results,
					contentNode = grid.contentNode,
					loadingNode,
					oldNodes,
					children,
					i,
					len;
				
				if(grid.showLoadingMessage){
					cleanupContent(grid);
					loadingNode = grid.loadingNode = put(contentNode, "div.dgrid-loading");
					loadingNode.innerHTML = grid.loadingMessage;
				}else{
					// Reference nodes to be cleared later, rather than now;
					// iterate manually since IE < 9 doesn't like slicing HTMLCollections
					grid._oldPageNodes = oldNodes = {};
					children = contentNode.children;
					for(i = 0, len = children.length; i < len; i++){
						oldNodes[children[i].id] = children[i];
					}
					// Also reference the current page's observer (if any)
					grid._oldPageObserver = grid.observers.pop();
				}
				
				// set flag to deactivate pagination event handlers until loaded
				grid._isLoading = true;
				
				// Run new query and pass it into renderArray
				results = grid.store.query(grid.query, options);
				
				Deferred.when(grid.renderArray(results, null, options), function(rows){
					cleanupLoading(grid);
					// Reset scroll Y-position now that new page is loaded.
					grid.scrollTo({ y: 0 });
					
					Deferred.when(results.total, function(total){
						if(!total){
							if(grid.noDataNode){
								put(grid.noDataNode, "!");
								delete grid.noDataNode;
							}
							// If there are no results, display the no data message.
							grid.noDataNode = put(grid.contentNode, "div.dgrid-no-data");
							grid.noDataNode.innerHTML = grid.noDataMessage;
						}
						
						// Update status text based on now-current page and total.
						grid.paginationStatusNode.innerHTML = string.substitute(grid.i18nPagination.status, {
							start: Math.min(start + 1, total),
							end: Math.min(total, start + count),
							total: total
						});
						grid._total = total;
						grid._currentPage = page;
						grid._rowsOnPage = rows.length;
						
						// It's especially important that _updateNavigation is called only
						// after renderArray is resolved as well (to prevent jumping).
						grid._updateNavigation();
					});
					
					if (has("ie") < 7 || (has("ie") && has("quirks"))) {
						// call resize in old IE in case grid is set to height: auto
						grid.resize();
					}
					
					dfd.resolve(results);
				}, function(error){
					cleanupLoading(grid);
					dfd.reject(error);
				});
				
				return dfd.promise;
			});
			
			if (!result) {
				// A synchronous error occurred; reject the promise.
				dfd.reject();
			}
			return dfd.promise;
		}
	});
});

},
'dgrid/extensions/DnD':function(){
define([
	"dojo/_base/declare",
	"dojo/_base/lang",
	"dojo/_base/array",
	"dojo/_base/Deferred",
	"dojo/aspect",
	"dojo/on",
	"dojo/topic",
	"dojo/has",
	"dojo/dnd/Source",
	"dojo/dnd/Manager",
	"dojo/_base/NodeList",
	"put-selector/put",
	"../Selection",
	"dojo/has!touch?../util/touch",
	"dojo/has!touch?./_DnD-touch-autoscroll",
	"xstyle/css!dojo/resources/dnd.css"
], function(declare, lang, arrayUtil, Deferred, aspect, on, topic, has, DnDSource, DnDManager, NodeList, put, Selection, touchUtil){
	// Requirements
	// * requires a store (sounds obvious, but not all Lists/Grids have stores...)
	// * must support options.before in put calls
	//   (if undefined, put at end)
	// * should support copy
	//   (copy should also support options.before as above)
	
	// TODOs
	// * consider sending items rather than nodes to onDropExternal/Internal
	// * consider emitting store errors via OnDemandList._trackError
	
	var GridDnDSource = declare(DnDSource, {
		grid: null,
		
		getObject: function(node){
			// summary:
			//		getObject is a method which should be defined on any source intending
			//		on interfacing with dgrid DnD.
			
			var grid = this.grid;
			// Extract item id from row node id (gridID-row-*).
			return grid.store.get(node.id.slice(grid.id.length + 5));
		},
		_legalMouseDown: function(evt){
			// Fix _legalMouseDown to only allow starting drag from an item
			// (not from bodyNode outside contentNode).
			var legal = this.inherited(arguments);
			return legal && evt.target != this.grid.bodyNode;
		},

		// DnD method overrides
		onDrop: function(sourceSource, nodes, copy){
			var targetSource = this,
				targetRow = this._targetAnchor = this.targetAnchor, // save for Internal
				grid = this.grid,
				store = grid.store;
			
			if(!this.before && targetRow){
				// target before next node if dropped within bottom half of this node
				// (unless there's no node to target at all)
				targetRow = targetRow.nextSibling;
			}
			targetRow = targetRow && grid.row(targetRow);
			
			Deferred.when(targetRow && store.get(targetRow.id), function(target){
				// Note: if dropping after the last row, or into an empty grid,
				// target will be undefined.  Thus, it is important for store to place
				// item last in order if options.before is undefined.
				
				// Delegate to onDropInternal or onDropExternal for rest of logic.
				// These are passed the target item as an additional argument.
				if(targetSource != sourceSource){
					targetSource.onDropExternal(sourceSource, nodes, copy, target);
				}else{
					targetSource.onDropInternal(nodes, copy, target);
				}
			});
		},
		onDropInternal: function(nodes, copy, targetItem){
			var grid = this.grid,
				store = grid.store,
				targetSource = this,
				anchor = targetSource._targetAnchor,
				targetRow,
				nodeRow;
			
			if(anchor){ // (falsy if drop occurred in empty space after rows)
				targetRow = this.before ? anchor.previousSibling : anchor.nextSibling;
			}
			
			// Don't bother continuing if the drop is really not moving anything.
			// (Don't need to worry about edge first/last cases since dropping
			// directly on self doesn't fire onDrop, but we do have to worry about
			// dropping last node into empty space beyond rendered rows.)
			nodeRow = grid.row(nodes[0]);
			if(!copy && (targetRow === nodes[0] ||
					(!targetItem && nodeRow && grid.down(nodeRow).element == nodes[0]))){
				return;
			}
			
			nodes.forEach(function(node){
				Deferred.when(targetSource.getObject(node), function(object){
					var id = store.getIdentity(object);
					
					// For copy DnD operations, copy object, if supported by store;
					// otherwise settle for put anyway.
					// (put will relocate an existing item with the same id, i.e. move).
					store[copy && store.copy ? "copy" : "put"](object, {
						before: targetItem
					});
					
					// Self-drops won't cause the dgrid-select handler to re-fire,
					// so update the cached node manually
					if(targetSource._selectedNodes[id]){
						targetSource._selectedNodes[id] = grid.row(id).element;
					}
				});
			});
		},
		onDropExternal: function(sourceSource, nodes, copy, targetItem){
			// Note: this default implementation expects that two grids do not
			// share the same store.  There may be more ideal implementations in the
			// case of two grids using the same store (perhaps differentiated by
			// query), dragging to each other.
			var store = this.grid.store,
				sourceGrid = sourceSource.grid;
			
			// TODO: bail out if sourceSource.getObject isn't defined?
			nodes.forEach(function(node, i){
				Deferred.when(sourceSource.getObject(node), function(object){
					if(!copy){
						if(sourceGrid){
							// Remove original in the case of inter-grid move.
							// (Also ensure dnd source is cleaned up properly)
							Deferred.when(sourceGrid.store.getIdentity(object), function(id){
								!i && sourceSource.selectNone(); // deselect all, one time
								sourceSource.delItem(node.id);
								sourceGrid.store.remove(id);
							});
						}else{
							sourceSource.deleteSelectedNodes();
						}
					}
					// Copy object, if supported by store; otherwise settle for put
					// (put will relocate an existing item with the same id).
					// Note that we use store.copy if available even for non-copy dnd:
					// since this coming from another dnd source, always behave as if
					// it is a new store item if possible, rather than replacing existing.
					store[store.copy ? "copy" : "put"](object, {
						before: targetItem
					});
				});
			});
		},
		
		onDndStart: function(source, nodes, copy){
			// Listen for start events to apply style change to avatar.
			
			this.inherited(arguments); // DnDSource.prototype.onDndStart.apply(this, arguments);
			if(source == this){
				// If TouchScroll is in use, cancel any pending scroll operation.
				if(this.grid.cancelTouchScroll){ this.grid.cancelTouchScroll(); }
				
				// Set avatar width to half the grid's width.
				// Kind of a naive default, but prevents ridiculously wide avatars.
				DnDManager.manager().avatar.node.style.width =
					this.grid.domNode.offsetWidth / 2 + "px";
			}
		},
		
		onMouseDown: function(evt){
			// Cancel the drag operation on presence of more than one contact point.
			// (This check will evaluate to false under non-touch circumstances.)
			if(has("touch") && this.isDragging &&
					touchUtil.countCurrentTouches(evt, this.grid.touchNode) > 1){
				topic.publish("/dnd/cancel");
				DnDManager.manager().stopDrag();
			}else{
				this.inherited(arguments);
			}
		},
		
		onMouseMove: function(evt){
			// If we're handling touchmove, only respond to single-contact events.
			if(!has("touch") || touchUtil.countCurrentTouches(evt, this.grid.touchNode) <= 1){
				this.inherited(arguments);
			}
		},
		
		checkAcceptance: function(source, nodes){
			// Augment checkAcceptance to block drops from sources without getObject.
			return source.getObject &&
				DnDSource.prototype.checkAcceptance.apply(this, arguments);
		},
		getSelectedNodes: function(){
			// If dgrid's Selection mixin is in use, synchronize with it, using a
			// map of node references (updated on dgrid-[de]select events).
			
			if(!this.grid.selection){
				return this.inherited(arguments);
			}
			var t = new NodeList(),
				id;
			for(id in this.grid.selection){
				t.push(this._selectedNodes[id]);
			}
			return t;	// NodeList
		}
		// TODO: could potentially also implement copyState to jive with default
		// onDrop* implementations (checking whether store.copy is available);
		// not doing that just yet until we're sure about default impl.
	});
	
	// Mix in Selection for more resilient dnd handling, particularly when part
	// of the selection is scrolled out of view and unrendered (which we
	// handle below).
	var DnD = declare(Selection, {
		// dndSourceType: String
		//		Specifies the type which will be set for DnD items in the grid,
		//		as well as what will be accepted by it by default.
		dndSourceType: "dgrid-row",
		
		// dndParams: Object
		//		Object containing params to be passed to the DnD Source constructor.
		dndParams: null,
		
		// dndConstructor: Function
		//		Constructor from which to instantiate the DnD Source.
		//		Defaults to the GridSource constructor defined/exposed by this module.
		dndConstructor: GridDnDSource,
		
		postMixInProperties: function(){
			this.inherited(arguments);
			// ensure dndParams is initialized
			this.dndParams = lang.mixin({ accept: [this.dndSourceType] }, this.dndParams);
		},
		
		postCreate: function(){
			this.inherited(arguments);
			
			// Make the grid's content a DnD source/target.
			this.dndSource = new (this.dndConstructor || GridDnDSource)(
				this.bodyNode,
				lang.mixin(this.dndParams, {
					// add cross-reference to grid for potential use in inter-grid drop logic
					grid: this,
					dropParent: this.contentNode
				})
			);
			
			// Set up select/deselect handlers to maintain references, in case selected
			// rows are scrolled out of view and unrendered, but then dragged.
			var selectedNodes = this.dndSource._selectedNodes = {};
			
			function selectRow(row){
				selectedNodes[row.id] = row.element;
			}
			function deselectRow(row){
				delete selectedNodes[row.id];
				// Re-sync dojo/dnd UI classes based on deselection
				// (unfortunately there is no good programmatic hook for this)
				put(row.element, '!dojoDndItemSelected!dojoDndItemAnchor');
			}
			
			this.on("dgrid-select", function(event){
				arrayUtil.forEach(event.rows, selectRow);
			});
			this.on("dgrid-deselect", function(event){
				arrayUtil.forEach(event.rows, deselectRow);
			});
			
			aspect.after(this, "destroy", function(){
				delete this.dndSource._selectedNodes;
				selectedNodes = null;
				this.dndSource.destroy();
			}, true);
		},
		
		insertRow: function(object){
			// override to add dojoDndItem class to make the rows draggable
			var row = this.inherited(arguments),
				type = typeof this.getObjectDndType == "function" ?
					this.getObjectDndType(object) : [this.dndSourceType];
			
			put(row, ".dojoDndItem");
			this.dndSource.setItem(row.id, {
				data: object,
				type: type instanceof Array ? type : [type]
			});
			return row;
		},
		
		removeRow: function (rowElement) {
			this.dndSource.delItem(this.row(rowElement));
			this.inherited(arguments);
		}
	});
	DnD.GridSource = GridDnDSource;
	
	return DnD;
});

},
'dgrid/util/mouse':function(){
define(["dojo/on", "dojo/dom", "dojo/query"], function(on, dom){
	function handler(selector, type){
		// summary:
		//		Creates a handler function usable as a simulated event to dojo/on,
		//		which fires only if the mouse is moving into or out of the node of
		//		interest indicated by the selector.
		//		This is similar, but not identical, to what dojo/mouse does.
		// selector: String
		//		Query selector for event delegation.
		// type: String
		//		Event to delegate on (mouseover or mouseout).
		
		return function(node, listener){
			return on(node, selector + ":" + type, function(evt){
				if(!dom.isDescendant(evt.relatedTarget, this)){
					return listener.call(this, evt);
				}
			});
		};
	}
	
	return {
		// Provide enter/leave events for rows, cells, and header cells.
		// (Header row is trivial since there's only one.)
		enterRow: handler(".dgrid-content .dgrid-row", "mouseover"),
		enterCell: handler(".dgrid-content .dgrid-cell", "mouseover"),
		enterHeaderCell: handler(".dgrid-header .dgrid-cell", "mouseover"),
		leaveRow: handler(".dgrid-content .dgrid-row", "mouseout"),
		leaveCell: handler(".dgrid-content .dgrid-cell", "mouseout"),
		leaveHeaderCell: handler(".dgrid-header .dgrid-cell", "mouseout"),
		
		// Also expose the handler function, so people can do what they want.
		createDelegatingHandler: handler
	};
});
},
'Sage/Utility/_LocalStorageMixin':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
        'dojo/_base/declare',
        'dojox/storage/LocalStorageProvider'
], function (
        declare,
        LocalStorageProvider
) {
    return declare('Sage.Utility._LocalStorageMixin', null, {
        localStorageProvider: null,
        _setLocalStorageProviderAttr: function (provider) {
            this.localStorageProvider = provider;
        },
        _getLocalStorageProviderAttr: function () {
            this._ensureProvider();
            return this.localStorageProvider;
        },
        _ensureProvider: function () {
            var localStore;
            if (!this.localStorageProvider) {
                localStore = new LocalStorageProvider();
                localStore.initialize();
                this._setLocalStorageProviderAttr(localStore);
            }
        },
        saveToLocalStorage: function (key, value, ns) {
            var localStore = this._getLocalStorageProviderAttr(),
                validNS = ns,
                validKey = key;
            
            if (!localStore.isValidKey(key)) {
                //console.warn('Invalid key supplied to local storage provider. Key: ' + key);
                validKey = this._stripBadValues(key);
            }
            
            if (!localStore.isValidNamespace(ns)) {
                //console.warn('Invalid namespace supplied to local storage provider. Namespace: ' + ns);
                validNS = this._stripBadValues(ns);
            }
            
            localStore.put(validKey, value, function(status, key, message) {
                if(status === localStore.FAILED) {
                    console.error('Failed writing key: ' + key + ' in local storage. Message: ' + message);
                }
            }, validNS);


            // Update the modified_at flag for the item
            var mod = new Date(Date.now());
            localStore.put(validKey + '_modified_at', mod, function(status, key, message) {
                if(status === localStore.FAILED) {
                    console.error('Failed writing key: ' + key + ' in local storage. Message: ' + message);
                }
            }, validNS);

            // Update a modified_at flag so we know when the last time this namespace was updated 
            localStore.put('modified_at', mod, function(status, key, message) {
                if(status === localStore.FAILED) {
                    console.error('Failed writing key: ' + key + ' in local storage. Message: ' + message);
                }
            }, validNS);
        },
        getFromLocalStorage: function (key, ns) {
            var localStore = this._getLocalStorageProviderAttr(),
                validNS = ns,
                validKey = key;
                
            if (!localStore.isValidKey(key)) {
                //console.warn('Invalid key supplied to local storage provider. Key: ' + key);
                validKey = this._stripBadValues(key);
            }
            
            if (!localStore.isValidNamespace(ns)) {
                //console.warn('Invalid namespace supplied to local storage provider. Namespace: ' + ns);
                validNS = this._stripBadValues(ns);
            }
            
            return localStore.get(validKey, validNS);// returns null if key does not exist. 
        },
        getKeys: function (ns) {
            var localStore = this._getLocalStorageProviderAttr();
            return localStore.getKeys(ns);
        },
        clear: function (ns /* optional */) {
            var localStore = this._getLocalStorageProviderAttr();
            if (ns) {
                localStore.clear(ns);
            } else {
                localStore.clear();
            }
        },
        _stripBadValues: function (key) {
            // This is going to blow up for unicode.
            return key.replace(/[^A-Za-z0-9]/g, '-');
        }
    });
});
},
'Sage/UI/Controls/GridParts/Columns/DataType':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
        'dojo/string',
        'dojo/_base/declare',
        'Sage/Utility/Filters'
],
function (dString, declare, Filters) {
    var widget = declare('Sage.UI.Controls.GridParts.Columns.DataType', null, {
        constructor: function(){
            this.inherited(arguments);
        },
        format: function(val, index) {
            var t = Filters.resolveDataTypeQB(val),
                results = 'string';
            switch (t){
                case 'Integer':
                    results = 'int';
                    break;
                case 'Decimal':
                    results = 'float';
                    break;
                case 'Date/Time':
                    results = 'date';
                    break;
                case 'Memo/Blob':
                    results = 'blob';
                    break;
                default:
                    results = 'string';
                    break;
                    
            }
            return  dString.substitute('<img src="images/ft_${0}.gif" class="dataTypeColumnDimensions" />', [results]);
        }
    });

    return widget;
});

},
'Sage/Utility/Filters':function(){
/*globals Sage, window, define, sessionStorage */
define([
        'dojo/_base/lang',
        'Sage/Data/SDataServiceRegistry',
        'dojo/json',
		'Sage/Utility'
],
function (lang, SDataServiceRegistry, json, utility) {
    Sage.namespace('Utility.Filters');
    lang.mixin(Sage.Utility.Filters, {
        getHiddenFiltersKey: function () {
            // Compatible with 7.5.4 keys..
            var service = Sage.Services.getService("ClientGroupContext"),
                context = service && service.getContext(),
                keyPart = 'hidden_filters_',
                groupId = context && context.CurrentGroupID,
                key = '';
            if (groupId) {
                groupId = groupId.toLowerCase();
                groupId = groupId.replace(/ /g, '_').replace(/'/g, '_');
                key = keyPart + groupId;
            }

            return key;
        },
        setHiddenFilters: function (key, value) {
            var service, entry, request;

            service = SDataServiceRegistry.getSDataService('system');
            entry = {
                '$name': 'setHiddenFilters',
                'request': {
                    'key': key,
                    'value': value
                }
            };
            request = new Sage.SData.Client.SDataServiceOperationRequest(service);

            request.setOperationName('setHiddenFilters');
            request.execute(entry, {});

            // Invalidate the session storage cache
            sessionStorage.removeItem(key);
        },
        getHiddenFilters: function (key, success, failure) {
            var service, request, entry, data;
			var encKey = utility.htmlEncode(key);
            data = sessionStorage.getItem(encKey);

            if (data === null) {
                service = SDataServiceRegistry.getSDataService('system');
                entry = {
                    '$name': 'getHiddenFilters',
                    'request': {
                        'key': encKey
                    }
                };

                request = new Sage.SData.Client.SDataServiceOperationRequest(service)
                    .setOperationName('getHiddenFilters');

                request.execute(entry, {
                    success: lang.hitch(this, this._getHiddenFiltersSuccess, success, key),
                    failure: failure
                });
            } else {
                // Cached data is stored as json string, parse it back out, and return to the caller
                success.call(this, json.parse(data));
            }

        },
        _getHiddenFiltersSuccess: function (onSuccess, key, data) {
            if (onSuccess) {
                // Cache as json string
                sessionStorage.setItem(key, json.stringify(data));
                onSuccess.call(this, data);
            }
        },
        resolveDataType: function (dataTypeId) {
            //console.log(dataTypeId);
            switch (dataTypeId) {
                case '47f90249-e4c8-4564-9ae6-e1fa9904f8b8': // Integer
                case '6b0b3d51-0728-4b67-9473-52836a81da53': // Short Integer
                case '2596d57d-89d6-4b72-9036-b18c64c5324c': // Decimal
                case 'f37c635c-9fbf-40d8-98d5-750a54a3cca1': // Double
                case '44bc190a-99f3-4fa9-98a3-d5b2336d6e7c': // Calculated Number
                    return 'numeric';
                case 'ccc0f01d-7ba5-408e-8526-a3f942354b3a': // Text
                case '76c537a8-8b08-4b35-84cf-fa95c6c133b0': // Unicode Text
                case 'b71918bf-fac1-4b62-9ed5-0b0294bc9900': // PickList
                case '517d5e69-9efa-4d0a-8e7a-1c7691f921ba': // Dependency Lookup
                case 'f750817f-73ad-4bf3-b2de-bd0f5cc47dfd': // Calculated String
                case '85f2bba5-1fb7-4ecf-941a-d98d4739c305': // Phone		
                    return 'string';
                case '8edd8fce-2be5-4d3d-bedd-ea667e78a8af': // Enum
                    return 'enum';
                case '1f08f2eb-87c8-443b-a7c2-a51f590923f5': // DateTime
                    return 'date';
                case '30053f5a-8d40-4db1-b185-1e4128eb26cc': // Standard Id
                    return 'key';
                case '92432b4d-8206-4a96-ba7b-e4cbd374f148': // True/False
                case '95ca9d52-6f0b-4a96-bd40-43583f41faf8': // Yes/No
                    return 'boolean';
                case 'f4ca6023-9f5f-4e41-8571-50ba94e8f233': // blob
                    return 'binary';
                default:
                    return 'unknown';
            }
        },
        resolveDataTypeQB: function (dataTypeId) {
            var results;
            switch (dataTypeId) {
                case '47f90249-e4c8-4564-9ae6-e1fa9904f8b8': // Integer
                case '6b0b3d51-0728-4b67-9473-52836a81da53': // Short Integer
                    results = 'Integer';
                    break;
                case '2596d57d-89d6-4b72-9036-b18c64c5324c': // Decimal
                case 'f37c635c-9fbf-40d8-98d5-750a54a3cca1': // Double
                case '44bc190a-99f3-4fa9-98a3-d5b2336d6e7c': // Calculated Number
                    results = 'Decimal';
                    break;
                case 'ccc0f01d-7ba5-408e-8526-a3f942354b3a': // Text
                case '76c537a8-8b08-4b35-84cf-fa95c6c133b0': // Unicode Text
                case 'b71918bf-fac1-4b62-9ed5-0b0294bc9900': // PickList
                case '517d5e69-9efa-4d0a-8e7a-1c7691f921ba': // Dependency Lookup
                case 'f750817f-73ad-4bf3-b2de-bd0f5cc47dfd': // Calculated String
                    results = 'String';
                    break;
                case '1f08f2eb-87c8-443b-a7c2-a51f590923f5': // DateTime
                    results = 'Date/Time';
                    break;
                case 'f4ca6023-9f5f-4e41-8571-50ba94e8f233': //blob
                    results = 'Memo/Blob';
                    break;
                default:
                    results = 'String';
            }

            return results;
        }
    });

    return Sage.Utility.Filters;
});

},
'Sage/UI/Controls/DateTimePicker':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define, sessionStorage */
define([
       'dijit/_TemplatedMixin',
       'dijit/_WidgetsInTemplateMixin',
       'dojo/fx',
       'dojo/date/locale',
       'dijit/_Widget',
       'dijit/form/TimeTextBox',
       'Sage/UI/Calendar',
       'Sage/Utility',
       'dijit/TooltipDialog',
       'dijit/_base/popup',
       'dijit/form/ComboBox',
       'dijit/focus',
       'dojo/data/ItemFileReadStore',
       'dojo/i18n!./nls/DateTimePicker',
       'dojo/json',
       'dojo/_base/lang',
       'dojo/_base/array',
       'dojo/_base/config',
       'dojo/_base/declare',
       'dojo/dom-construct',
       'Sage/Utility/_LocalStorageMixin',
       'dojo/text!./templates/DateTimePicker.html'
],
function (_TemplatedMixin,
    _WidgetsInTemplateMixin,
    fx,
    locale,
    _Widget,
    timeTextBox,
    calendar,
    utility,
    tooltipDialog,
    popup,
    comboBox,
    focusUtil,
    itemFileReadStore,
    nlsStrings,
    json,
    lang,
    array,
    dojoConfig,
    declare,
    domConstruct,
    _localStorageMixin,
    template) {

    var _menu, datePicker, tzDataLoader;

    tzDataLoader = declare('Sage.UI.Controls.DateTimePicker.TimeZoneDataLoader', _localStorageMixin, {
        _requests: [],
        _requestingData: false,
        _tzData: false,
        _storageNamespace: 'DateTimePickerTZ',
        constructor: function () {
            this._requests = [];
            this._requestingData = false;
            this._tzData = false;
        },
        requestTimeZones: function (callback, scope) {
            if (!this._tzData) {
                var data = this.getFromLocalStorage(this._storageNamespace, this._storageNamespace);
                if (data) {
                    this._tzData = json.parse(data);
                } else {
                    this._requests.push({
                        fn: callback,
                        scope: scope || this
                    });
                    if (!this._requestingData) {
                        dojo.xhrGet({
                            url: 'slxdata.ashx/slx/crm/-/timezones/p',
                            handleAs: 'json',
                            load: lang.hitch(this, this._receiveData),
                            error: function (err) {
                            }
                        });
                        this._requestingData = true;
                    }
                    return;
                }
            }
            callback.call(scope || this, this._tzData);
        },
        _receiveData: function (data) {
            this.saveToLocalStorage(this._storageNamespace, json.stringify(data), this._storageNamespace);
            this._tzData = data;
            var len = this._requests.length;
            for (var i = 0; i < len; i++) {
                var clbk = this._requests.pop();
                clbk.fn.call(clbk.scope, data);
            }
        }
    });

    _menu = declare('Sage.UI.Controls._DateTimePickerMenu', [_Widget, _TemplatedMixin, _WidgetsInTemplateMixin], {
        // Display properties
        templateString: template,
        widgetsInTemplate: true,
        textAlign: 'left',
        // localized strings
        okText: '',
        cancelText: '',
        convertText: '',
        calculatorText: '',
        timeZoneSourceText: '',
        timeZoneDestText: '',
        // end localize
        id: 'dateTimePickerMenu',
        dir: '',
        _messages: null,
        _started: false,
        _timezonesLoaded: false,
        _timezonesVisible: false,
        displayTime: false,

        constructor: function (options) {
            lang.mixin(this, nlsStrings);
            this.inherited(arguments);
        },
        startup: function () {
            this._started = true;
            this._messages = [];
            if (typeof this.focus === 'function') {
                this.focus();
            }
            this.inherited(arguments);
        },
        uninitialize: function () {
            this.dateNode.destroy(false);
            this.timeZoneSourceComboNode.destroy(false);
            this.timeZoneDestComboNode.destroy(false);
            this.timeZoneConvertButtonNode.destroy(false);
            this.timeNode.destroy(false);
            this.OKButtonNode.destroy(false);
            this.CancelButtonNode.destroy(false);

            this.inherited(arguments);
        },
        _getUTCDate: function (date) {
            return new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
        },
        _okClicked: function (options) {
            this.onExecute();
            this.onOKClicked();
        },
        onOKClicked: function () {
        },
        _onCalendarBlur: function () {
            this.calendarBlur();
        },
        calendarBlur: function () {

        },
        _onValueSelected: function () {
            if (!this.displayTime) {
                this.calendarDateSelected();
                this.onExecute();
            }
        },
        calendarDateSelected: function () {
        },
        _cancelClicked: function () {
            this.onCancel();
            this.onCancelClicked();
        },
        onFocusOut: function () {
            this.onExecute();
        },
        onCancelClicked: function () {
        },
        onCancel: function () {
        },
        onExecute: function () {
        },
        _hideTimeNode: function () {
            //  this._hideNode(this.timeContainer);
            this._hideNode(this.timeZoneContainer);
        },
        _hideDateNode: function () {
            this._hideNode(this.dateContainer);
        },
        _showTimeNode: function () {
            //this._showNode(this.timeContainer);
            this._showNode(this.timeZoneContainer);
        },
        _showDateNode: function () {
            this._showNode(this.dateContainer);
        },
        _hideNode: function (id) {
            dojo.style(id, 'visibility', 'hidden');
            dojo.style(id, 'display', 'none');
        },
        _showNode: function (id) {
            dojo.style(id, 'visibility', 'visible');
            dojo.style(id, 'display', 'block');
        },
        _convertClicked: function () {
            if (!this._timezonesLoaded) {
                return;
            }

            var self = this,
                selectedDate = this.dateNode.get('value'),
                selectedTime = this.timeNode.get('value'),
                selectedSource = this.timeZoneSourceComboNode.get('value'),
                selectedDest = this.timeZoneDestComboNode.get('value'),
                dateString = '',
                returnedDate = null,
                url = 'slxdata.ashx/slx/crm/-/timezones/convertTimeFormatted?timezoneNameSource=${0}&timezoneNameDest=${1}&date=${2}&getFormatted=${3}';

            // Combine date/time into selectedDate
            selectedDate.setHours(selectedTime.getHours());
            selectedDate.setMinutes(selectedTime.getMinutes());
            dateString = selectedDate.toLocaleString();

            if(selectedSource && selectedDest) {
                dojo.xhrGet({
                    url: dojo.string.substitute(url, [escape(selectedSource), escape(selectedDest), dateString, "false"]),
                    handleAs: 'json',
                    load: function (convertedDateString) {
                        self.convertResultsNode.innerHTML = convertedDateString;
                    },
                    error: function (err) {
                        console.error(err);
                    }
                });
            }
        },
        processTimeZones: function (data) {
            var items = [];
            var initialValue = utility.getClientContextByKey('userTimeZone');
            array.forEach(data, function (item) {
                if (!item.Displayname || !item.Keyname) {
                    return;
                }
                items.push({
                    id: item.Keyname,
                    text: item.Displayname,
                    offsetHours: item.OffsetHours,
                    offsetMinutes: item.OffsetMinutes
                });
            });

            this.storeData = {
                label: 'text',
                identifier: 'id',
                items: items
            };

            this.timeZoneStore = new itemFileReadStore({
                data: this.storeData
            });

            var self = this;
            this.timeZoneSourceComboNode.set('store', this.timeZoneStore);
            this.timeZoneSourceComboNode.set('searchAttr', 'text');
            //Preselect the current time zone on source combo
            this.timeZoneSourceComboNode.store.fetch(
                {
                    query: { text: initialValue },
                    onComplete: function (items) {
                        self.timeZoneSourceComboNode.setAttribute('item', items[0]);
                    }
                });


            this.timeZoneDestComboNode.set('store', this.timeZoneStore);
            this.timeZoneDestComboNode.set('searchAttr', 'text');
        },
        loadTimeZones: function () {
            if (this._timezonesLoaded) {
                return;
            }
            this._timezonesLoaded = true;
            var loader = new tzDataLoader();
            loader.requestTimeZones(this.processTimeZones, this);
        }
    });

    datePicker = declare('Sage.UI.Controls.DateTimePicker', [comboBox], {
        id: 'dateTimePicker',

        buttonToolTip: 'Calendar',
        toolTip: '',

        // TODO: Add get/set attr
        displayDate: true,
        displayTime: true,

        initialDate: null,
        initialTime: null,
        initialTextValue: '',

        dateFormat: '', // Used for ASP.NET control

        timeZoneStore: null,
        storeData: null,

        dropDown: false,
        _opened: false,

        readOnly: false,
        enabled: true,
        required: false,

        renderAsHyperlink: false,
        shouldPublishMarkDirty: true,
        handles: null,
        store: null,
        dateOnlyHanlde: null,
        documentClickHandle: null,
        dropdownIconClicked: false,
        popupElements: null,
        minDate: null,
        cssClass: "",
        constructor: function (options) {
            //console.log("datetimepicker :: construct"); 
            this.buttonToolTip = nlsStrings.buttonToolTip;

            this.handles = [];
            this.documentClickHandle = [];
            this.dateOnlyHanlde = [];
            this.store = {}; // required by ComboBox - do not remove or IE8 error will occur.
            if (options.cssClass) {
                this.cssClass = options.cssClass;
            }

            this.inherited(arguments);
        },
        postCreate: function () {
            if (this.cssClass && this.cssClass.length > 0) {
                this.domNode.className = this.cssClass + ' ' + this.domNode.className;
            }
        },
        _onChanged: function (e) {
            if (this.shouldPublishMarkDirty) {
                dojo.publish("Sage/events/markDirty");
            }

            this._updateHiddenFields();
        },
        _onFocusChange: function() {
            this._updateHiddenFields();
        },
        _updateHiddenFields: function() {
            var thisDom, hiddenField, hiddenTextField, valueForASPNet;
            thisDom = dojo.byId(this.id);
            if (thisDom) {
                // This first two dom nodes are the hidden text field and the hidden field
                hiddenTextField = thisDom.children[0];
                hiddenField = thisDom.children[1];
                if (hiddenTextField && hiddenField) {
                    valueForASPNet = this.getValueForASPNET();
                    hiddenField.value = valueForASPNet;
                    if (valueForASPNet === '') {
                        hiddenTextField.value = '';
                    }
                    if (hiddenField.onchange) {
                        hiddenField.onchange();
                    }
                }
            }
        },
        uninitialize: function () {
            //console.log('DateTimePicker :: uninitialize');
            this.inherited(arguments);
        },
        startup: function () {
            //console.log("datetimepicker :: startup"); 
            this.inherited(arguments);
            this.dropDown = new _menu({ id: this.id + '_Popout', displayTime: this.displayTime });
            this.handles.push(this.connect(this, 'onChange', this._onChanged));
            this.handles.push(dojo.connect(this.dropDown, 'onOKClicked', this, '_displayCurrentValue'));
            this.handles.push(dojo.connect(this.focusNode, 'onkeyup', this, '_onFocusKeyUp', true));
            this.handles.push(dojo.connect(this.focusNode, 'onblur', this, '_onFocusBlur', true));
            this.handles.push(dojo.connect(this.focusNode, 'onchange', this, '_onFocusChange', true));

            this.focusNode.value = this.initialTextValue;

            var date = utility.Convert.toDateFromString(this.initialDate) || new Date();
            var time = utility.Convert.toDateFromString(this.initialTime) || new Date();

            this.dropDown.dateNode.set('value', date.toDateString());
            this.dropDown.timeNode.set('value', time);

            if (this.displayDate) {
                this.dropDown._showDateNode();
            } else {
                this.dropDown._hideDateNode();
            }

            if (this.displayTime) {
                this.dropDown._showTimeNode();
            } else {
                //Attach event to calendar date select event and assign the date in combobox
                this.dateOnlyHanlde.push(dojo.connect(this.dropDown, 'calendarDateSelected', this, '_displayCurrentValue'));
                this.dropDown._hideTimeNode();
            }

            var nodesList = [];
            //Recursive function to get all child nodes of passed in node
            var getChildElements = function (node) {
                if (node && node.children && node.children.length > 0) {
                    for (var i = 0; i < node.children.length; i++) {
                        if (node.children[i])
                            nodesList.push(node.children[i]);
                        getChildElements(node.children[i]);
                    }
                }
                return nodesList;
            };
            //Get the list of all child elements of popup window
            this.popupElements = getChildElements(this.dropDown.domNode);
            this.popupElements.push(this.dropDown.domNode);
            this.popupElements.push(this._buttonNode.parentNode);

            //handle closing the popup
            this.documentClickHandle.push(dojo.connect(document, 'onclick', this, '_documentOnClick'));

            this._setupRenderAsHyperlink();
            this._setupDropDownIcon();
        },
        _documentOnClick: function (evt) {
            // summary:
            //  Handles popup window close on clicking outside popup window
            // description:
            //  Listen to document click event and close popup if clicked out side
            var e = evt || window.event;
            var element = e.target || e.srcElement;
            // Firefox can send text objects, which are too deep in DOM. 
            // If that's the event target, we need the parentNode instead.
            if (e.target.nodeType == 3) {
                element = e.target.parentNode;
            }

            //If clicked node is in the list child  nodes, return true
            //Else if there is a parent node, check the parent node(recursive)
            //Else return false
            var isPresent = function (popupElements, node) {
                if (dojo.indexOf(popupElements, node) > -1) {
                    return true;
                } else if (node.parentNode) {
                    return isPresent(popupElements, node.parentNode);
                } else {
                    return false;
                }
            };
            //Timepicker elements and Calendar month labels are dynamic, checking by their class name
            if ((element && element.className &&
                (element.className.indexOf('dijitTimePickerItemInner') > -1 ||
                            element.className.indexOf('dijitCalendarMonthLabel') > -1)) ||
                (element && element.id &&
                        (element.id.indexOf("_Popout-TzSelectSource_popup") > -1 ||
                         element.id.indexOf("_Popout-TzSelectDest_popup") > -1))) {
                //If clicked element is on popup window, stop event
                e.cancelBubble = true;
                if (e.stopPropagation) {
                    e.stopPropagation();
                }
                e.preventDefault = true;
            } else {
                //TimeNode popup won't be available during startup
                if (this.dropDown && this.dropDown.timeNode && this.dropDown.timeNode.dropDown) {
                    if (dojo.indexOf(this.popupElements, this.dropDown.timeNode.dropDown.domNode) == -1) {
                        this.popupElements.push(this.dropDown.timeNode.dropDown.domNode);
                    }
                }

                //Check if the clicked node is part of pop up window
                if (!isPresent(this.popupElements, element)) {
                    this.closeDropDown();
                } else {
                    e.cancelBubble = true;
                    if (e.stopPropagation) {
                        e.stopPropagation();
                    }
                    e.preventDefault = true;
                }
            }
        },
        _setupDropDownIcon: function () {
            if (this.renderAsHyperlink) {
                return;
            }

            domConstruct.create('div', {
                'class': 'Global_Images icon16x16 icon_Calendar_16x16',
                title: this.buttonToolTip,
                tabIndex: 0
            }, this._buttonNode, 'only');

            dojo.addClass(this._buttonNode, "smCalendarIconTxtBox");

            this.handles.push(this.connect(this._buttonNode, 'ondijitclick', function () {

                if (!this.displayTime) {
                    dojo.style(this.dropDown.domNode, "height", "226px");
                } else {
                    dojo.style(this.dropDown.domNode, "height", "266px");
                }

                if (!this.dropdownIconClicked) {
                    this.openDropDown();
                    this.dropdownIconClicked = true;
                }

            }));
        },
        _displayCurrentValue: function () {
            if (!this._started) {
                return;
            }
            var selectedDate = this.getDateValue(),
                selectedTime = this.getTimeValue(),
                results,
                options = { fullYear: true };

            if (!selectedDate) {
                return;
            }

            selectedDate.setHours(selectedTime.getHours());
            selectedDate.setMinutes(selectedTime.getMinutes());
            selectedDate.setSeconds(selectedTime.getSeconds());

            if (this.displayDate && this.displayTime) {
                options.selector = 'date and time';
            } else if (this.displayDate) {
                options.selector = 'date';
            } else if (this.displayTime) {
                options.selector = 'time';
            }

            options.locale = Sys.CultureInfo.CurrentCulture.name;

            results = locale.format(selectedDate, options);

            if (this.renderAsHyperlink) {
                var node = dojo.byId(this.id + '-Link');
                node.innerHTML = results;
            } else {
                this.focusNode.value = results;
            }

            if ((!this.value.getTime) || this.value.getTime() !== selectedDate.getTime()) {
                this.value = selectedDate;
                this.onChange(selectedDate);
            }
        },
        _setupRenderAsHyperlink: function () {
            if (!this.renderAsHyperlink) {
                return;
            }

            // Insert a hyperlink as a replace for the focusNode, make sure it fires open on the dropdown when clicked. Hide other combobox visuals
            // by replacing them.
            dojo.style(this.domNode, 'border', 'none');
            var node = dojo.create('a', { id: this.id + '-Link', innerHTML: this.focusNode.value }, this.domNode, 'only');

            dojo.style(node, 'cursor', 'pointer');
            this.handles.push(dojo.connect(node, 'onclick', this, function () {

                if (!this.displayTime) {
                    dojo.style(this.dropDown.domNode, "height", "226px");
                } else {
                    dojo.style(this.dropDown.domNode, "height", "266px");
                }

                this.openDropDown();
            }));
        },
        loadDropDown: function () {
            // overrides ComboBox
        },
        isLoaded: function () {
            // overrides ComboBox
            return true;
        },
        _setBlurValue: function () {
            // overrides ComboBox
            //console.log('DateTimePicker :: _setBlurValue hit');
        },
        closeDropDown: function () {
            // overrides ComboBox
            popup.close(this.dropDown);
            this._opened = false;
            this.dropdownIconClicked = false;

            //Detach document click event handler when closing window
            dojo.forEach(this.documentClickHandle, function (handle) {
                dojo.disconnect(handle);
            });

        },
        _openResultList: function () {
            // overrides ComboBox
            //console.log('DateTimePicker :: _openResultList hit');
        },
        _showResultList: function () {
            // overrides ComboBox
            //console.log('DateTimePicker :: _showResultList hit');
        },
        _onBlur: function () {
            // TODO: Why is this firing when clicking nodes in the dropdown?
        },
        triggerOnFocusBlur: function (currentLocale) {
            //For unit testing - date input value formatting
            //dojoConfig.locale = currentLocale;
            this._validateInputDate(currentLocale);
        },
        _validateInputDate: function (currentLocale) {
            if (!this._opened && !this.readOnly && this.dropDown && this.focusNode.value !== '') {
                // Combo is not opened, fire okClicked so any connections to it can be notified.

                var text = this.focusNode.value;
                if (text === this.initialTextValue) {
                    return;
                }

                //code = e.charOrCode;
                var parsedDate = null;
                var selectorString = "date";
                if (text.indexOf(":") > 0) {
                    selectorString = "datetime";
					text=new Date(text).toLocaleString().replace(/:\d{2}\s/,' '); // NOTE THE COMMA -Assign comma for DateTime calendar 
                }
                currentLocale = currentLocale || (Sys.CultureInfo.CurrentCulture.name || dojoConfig.locale);
                parsedDate = dojo.date.locale.parse(text, { selector: selectorString, locale: currentLocale });
                //console.log("minDate: %o,text: %o,parsedDate : %o,selectorString : %o, locale:%o", this.minDate, text, parsedDate, selectorString, dojoConfig.locale);

                // Only set if we have a valid dropdown and the date is parsed correctly.
                // invalidDate.getDate() will return NaN if invalid.
                if (this.dropDown && parsedDate !== null && isNaN(parsedDate.getDate()) === false) {
                    if (parsedDate.getFullYear() >= (new Date().getFullYear() - 259)) {
                        this.dropDown.dateNode.set('value', parsedDate);
                        this.dropDown.timeNode.set('value', parsedDate);
                    }
                }

                this.dropDown.onOKClicked();
            }
        },
        _onFocusBlur: function () {
            // Focus node onblur event
            //console.log("this._opened :%o,this.MCDropDown :%o,this.focusNode.value:%o", this._opened, this.dropDown, this.focusNode.value);
            this._validateInputDate();

            if (this._opened) {
                focusUtil.focus(dojo.query('.dijitCalendarContainer', this.dropDown.dateContainer)[0]);
            }
        },
        _onFocusKeyUp: function (e) {

        },
        _onKey: function (e) {
            // overrides ComboBox
        },
        openDropDown: function () {
            // overrides ComboBox
            this._opened = true;
            var self = this;
            popup.open({
                popup: this.dropDown,
                around: this.domNode,
                onExecute: function () {
                    self.closeDropDown();
                    focusUtil.focus(self.focusNode);
                },
                onCancel: function () {
                    self.closeDropDown();
                    focusUtil.focus(self.focusNode);
                },
                onClose: function () {
                }
            });
            this.documentClickHandle.push(dojo.connect(document, 'onclick', this, '_documentOnClick'));

            if (this.displayTime) {
                this.dropDown.loadTimeZones();
            }

            if (this.dropDown.dateNode._selectedCells !== 'undefined' && this.dropDown.dateNode._selectedCells.length === 0)
            {
                var value = this.getDateValue();
                this.dropDown.dateNode._markSelectedDates([value]);
            }

            focusUtil.focus(dojo.query('.dijitCalendarContainer', this.dropDown.dateContainer)[0]);
            popup._stack[0].handlers[0].remove();
        },
        _getUTCDate: function (date) {
            return this.dropDown._getUTCDate(date);
        },
        getDateValue: function () {
            return this.dropDown.dateNode.get('value');
        },
        getTimeValue: function () {
            var timeVal = this.dropDown.timeNode.get('value') || new Date(Date.now());
            if (timeVal) {
                timeVal.setSeconds(this.dropDown.timeNode['seconds'] || 0);
            }

            return timeVal;
        },
        getMinDate: function () {
            this.minDate = Sage.Utility.Activity.formatDateAdd(new Date(), 'year', -259);
            return this.minDate;
        },
        _getValueAttr: function () {
            var d = this.getDateValue();
            var t = this.getTimeValue();
            d.setHours(t.getHours());
            d.setMinutes(t.getMinutes());
            d.setSeconds(t.getSeconds());
            return d;
        },
        _setValueAttr: function (val) {
            if (val && val.toDateString) {
                if (this.dropDown) {
                    this.dropDown.dateNode.set('value', val);
                    this.dropDown.timeNode.set('value', val);
                    this.dropDown.timeNode['seconds'] = val.getSeconds();
                    this._displayCurrentValue();
                }
                if ((!this.value.getTime) || this.value.getTime() !== val.getTime()) {
                    this.value = val;
                    this.onChange(val);
                }
            }
        },
        _setDisplayDateAttr: function (displayDate) {
            this.displayDate = displayDate;
            this._displayCurrentValue();
            if (this.dropDown) {
                if (this.displayDate) {
                    this.dropDown._showDateNode();
                } else {
                    this.dropDown._hideDateNode();
                }
            }
        },
        _getDisplayDateAttr: function () {
            return this.displayDate;
        },
        _setToolTipAttr: function (toolTip) {
            if (toolTip && toolTip !== '') {
                this.set('title', toolTip);
            }
        },
        _getToolTipAttr: function () {
            return this.toolTip;
        },
        _setDisabledAttr: function (disabled) {
            if (disabled) {
                dojo.style(this._buttonNode, 'visibility', 'hidden');
                dojo.style(this._buttonNode, 'display', 'none');
            } else {
                dojo.style(this._buttonNode, 'visibility', '');
                dojo.style(this._buttonNode, 'display', '');
            }
            this.inherited(arguments);
        },
        _setReadOnlyAttr: function (readOnly) {
            if (readOnly) {
                dojo.style(this._buttonNode, 'visibility', 'hidden');
                dojo.style(this._buttonNode, 'display', 'none');
            }
            this.inherited(arguments);
        },
        _setDisplayTimeAttr: function (displayTime) {
            this.displayTime = displayTime;
            this._displayCurrentValue();
            if (this.dropDown) {
                if (this.displayDate) {
                    this.dropDown._showDateNode();
                } else {
                    this.dropDown._hideDateNode();
                }

                //Detach event which sets the selected date when clicking any date in calendar
                dojo.forEach(this.dateOnlyHanlde, function (handle) {
                    dojo.disconnect(handle);
                });

                if (this.displayTime) {
                    this.dropDown.displayTime = true;
                    this.dropDown._showTimeNode();
                } else {
                    this.dropDown.displayTime = false;
                    //Attach event to onclick of any date in calendar to set the date in combo box 
                    this.dateOnlyHanlde.push(dojo.connect(this.dropDown, 'calendarDateSelected', this, '_displayCurrentValue'));
                    //this.dateOnlyHanlde.push(dojo.connect(this.dropDown, 'calendarBlur', this, '_closeDropDownOnDateOnly'));
                    this.dropDown._hideTimeNode();
                }
            }

        },
        _getDisplayTimeAttr: function () {
            return this.displayTime;
        },
        getValueForASPNET: function () {
            // ASP.NET control puts this value into a hidden input
            // format: "Year,Month,Day,Hours,Min"
            if (this.focusNode.value === '') {
                return '';
            }
            var values = [];
            var date = this.getDateValue();
            values.push(date.getFullYear());
            values.push(date.getMonth() + 1);
            values.push(date.getDate());

            var time = this.getTimeValue();
            values.push(time.getHours());
            values.push(time.getMinutes());

            return values.join(',');
        },
        destroy: function () {
            //console.log("datetimepicker :: destroy");
            dojo.forEach(dijit.findWidgets(this.domNode), function (wid) {
                wid.destroy(false);
            });

            dojo.forEach(this.handles, function (handle) {
                dojo.disconnect(handle);
            });

            this.inherited(arguments);
        },

        // OLD script functions
        fmtDateForASPNET: function () {
            var date = this.getDateValue();
            var time = this.getTimeValue();
            var year = date.getFullYear();
            var month = date.getMonth() + 1;
            var day = date.getDate();
            var hours = time.getHours();
            var minutes = time.getMinutes();

            var result = '';

            if (this.displayDate) {
                var divChar = this.getDivChar();
                var strMon = month;
                var strDat = day;

                if (this.dateFormat.substring(0, 1).toUpperCase() == 'MM') {
                    strMon = (strMon < 10) ? '0' + strMon : strMon;
                }
                if (this.dateFormat.substring(0, 1).toUpperCase == 'DD') {
                    strDat = (strDat < 10) ? '0' + strDat : strDat;
                }

                if (this.dateFormat.substring(0, 1) == 'M' || this.dateFormat.substring(0, 1) == 'm') {
                    result = strMon + divChar + strDat + divChar + date.getFullYear();
                }
                if (this.dateFormat.substring(0, 1) == 'D' || this.dateFormat.substring(0, 1) == 'd') {
                    result = strDat + divChar + strMon + divChar + date.getFullYear();
                }
                if (this.dateFormat.substring(0, 1) == 'Y' || this.dateFormat.substring(0, 1) == 'y') {
                    result = date.getFullYear() + divChar + strMon + divChar + strDat;
                }
                if (this.displayTime) {
                    result += " ";
                }
            }

            if (this.displayTime) {
                var timeDivStr = this.getTimeDivChar();
                var strHour = hours;
                var strMin = minutes;
                if (strMin < 10) { strMin = '0' + strMin; }
                if (this.dateFormat.indexOf('H') > -1) {
                    result += strHour + timeDivStr + strMin;
                } else if (this.dateFormat.indexOf('h') > -1) {
                    var str12Hour = hours;
                    if (this.Hours === 0) {
                        str12Hour = '12';
                    }

                    var strMeridian = 'AM';
                    if (hours >= 12) {
                        if (hours > 12) {
                            str12Hour = (hours - 12);
                        }

                        strMeridian = 'PM';
                    }

                    result += str12Hour + timeDivStr + strMin + " " + strMeridian;
                } else {
                    result += time.toLocaleTimeString();
                }
            }

            return result;
        },
        getDivChar: function () {
            /* this function determines date separator for the date format supplied  */
            var divChar = '';
            for (var i = 0; i < this.dateFormat.length; i++) {
                if (isNaN(this.dateFormat.charAt(i))) {
                    if ((this.dateFormat.charAt(i) < 'A' || this.dateFormat.charAt(i) > 'Z') && (this.dateFormat.charAt(i) < 'a' || this.dateFormat.charAt(i) > 'z')) {
                        divChar = this.dateFormat.charAt(i);
                        break;
                    }
                }
            }
            return divChar;
        },
        getTimeDivChar: function () {
            /* this function determines time separator for the date format supplied  */
            if (this.displayTime) {
                var fmtParts = this.dateFormat.split(" ");
                if (fmtParts.length > 1) {
                    var timeFmt = fmtParts[1];
                    for (var i = 0; i < timeFmt.length; i++) {
                        if (isNaN(timeFmt.charAt(i))) {
                            if ((timeFmt.charAt(i) < 'A' || timeFmt.charAt(i) > 'Z') && (timeFmt.charAt(i) < 'a' || timeFmt.charAt(i) > 'z')) {
                                return timeFmt.charAt(i);
                            }
                        }
                    }
                }
            }
            return ":";
        }
    });


    return datePicker;
});

},
'dijit/_WidgetsInTemplateMixin':function(){
define([
	"dojo/_base/array", // forEach()
	"dojo/aspect", // after()
	"dojo/_base/declare", // declare()
	"dojo/_base/lang",	// hitch()
	"dojo/parser" // parse()
], function(array, aspect, declare, lang, parser){

	// module:
	//		dijit/_WidgetsInTemplateMixin

	return declare("dijit._WidgetsInTemplateMixin", null, {
		// summary:
		//		Mixin to supplement _TemplatedMixin when template contains widgets

		// _earlyTemplatedStartup: Boolean
		//		A fallback to preserve the 1.0 - 1.3 behavior of children in
		//		templates having their startup called before the parent widget
		//		fires postCreate. Defaults to 'false', causing child widgets to
		//		have their .startup() called immediately before a parent widget
		//		.startup(), but always after the parent .postCreate(). Set to
		//		'true' to re-enable to previous, arguably broken, behavior.
		_earlyTemplatedStartup: false,

		// widgetsInTemplate: [protected] Boolean
		//		Should we parse the template to find widgets that might be
		//		declared in markup inside it?  (Remove for 2.0 and assume true)
		widgetsInTemplate: true,

		// contextRequire: Function
		//		Used to provide a context require to the dojo/parser in order to be
		//		able to use relative MIDs (e.g. `./Widget`) in the widget's template.
		contextRequire: null,

		_beforeFillContent: function(){
			if(this.widgetsInTemplate){
				// Before copying over content, instantiate widgets in template
				var node = this.domNode;

				if(this.containerNode && !this.searchContainerNode){
					// Tell parse call below not to look for widgets inside of this.containerNode
					this.containerNode.stopParser = true;
				}

				parser.parse(node, {
					noStart: !this._earlyTemplatedStartup,
					template: true,
					inherited: {dir: this.dir, lang: this.lang, textDir: this.textDir},
					propsThis: this,	// so data-dojo-props of widgets in the template can reference "this" to refer to me
					contextRequire: this.contextRequire,
					scope: "dojo"	// even in multi-version mode templates use dojoType/data-dojo-type
				}).then(lang.hitch(this, function(widgets){
					this._startupWidgets = widgets;

					// _WidgetBase::destroy() will destroy any supporting widgets under this.domNode.
					// If we wanted to, we could call this.own() on anything in this._startupWidgets that was moved outside
					// of this.domNode (like Dialog, which is moved to <body>).

					// Hook up attach points and events for nodes that were converted to widgets
					for(var i = 0; i < widgets.length; i++){
						this._processTemplateNode(widgets[i], function(n,p){
							// callback to get a property of a widget
							return n[p];
						}, function(widget, type, callback){
							// callback to do data-dojo-attach-event to a widget
							if(type in widget){
								// back-compat, remove for 2.0
								return widget.connect(widget, type, callback);
							}else{
								// 1.x may never hit this branch, but it's the default for 2.0
								return widget.on(type, callback, true);
							}
						});
					}

					// Cleanup flag set above, just in case
					if(this.containerNode && this.containerNode.stopParser){
						delete this.containerNode.stopParser;
					}
				}));

				if(!this._startupWidgets){
					throw new Error(this.declaredClass + ": parser returned unfilled promise (probably waiting for module auto-load), " +
						"unsupported by _WidgetsInTemplateMixin.   Must pre-load all supporting widgets before instantiation.");
				}
			}
		},

		_processTemplateNode: function(/*DOMNode|Widget*/ baseNode, getAttrFunc, attachFunc){
			// Override _AttachMixin._processNode to skip DOMNodes with data-dojo-type set.   They are handled separately
			// in the _beforeFillContent() code above.

			if(getAttrFunc(baseNode, "dojoType") || getAttrFunc(baseNode, "data-dojo-type")){
				return true;
			}

			return this.inherited(arguments);
		},

		startup: function(){
			array.forEach(this._startupWidgets, function(w){
				if(w && !w._started && w.startup){
					w.startup();
				}
			});
			this._startupWidgets = null;
			this.inherited(arguments);
		}
	});
});

},
'dijit/form/TimeTextBox':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/keys", // keys.DOWN_ARROW keys.ENTER keys.ESCAPE keys.TAB keys.UP_ARROW
	"dojo/_base/lang", // lang.hitch
	"../_TimePicker",
	"./_DateTimeTextBox"
], function(declare, keys, lang, _TimePicker, _DateTimeTextBox){

	// module:
	//		dijit/form/TimeTextBox


	/*=====
	var __Constraints = declare([_DateTimeTextBox.__Constraints, _TimePicker.__Constraints], {
	});
	=====*/

	return declare("dijit.form.TimeTextBox", _DateTimeTextBox, {
		// summary:
		//		A validating, serializable, range-bound time text box with a drop down time picker

		baseClass: "dijitTextBox dijitComboBox dijitTimeTextBox",
		popupClass: _TimePicker,
		_selector: "time",

/*=====
		// constraints: __Constraints
		constraints:{},
=====*/

		// value: Date
		//		The value of this widget as a JavaScript Date object.  Note that the date portion implies time zone and daylight savings rules.
		//
		//		Example:
		// |	new dijit/form/TimeTextBox({value: stamp.fromISOString("T12:59:59", new Date())})
		//
		//		When passed to the parser in markup, must be specified according to locale-independent
		//		`stamp.fromISOString` format.
		//
		//		Example:
		// |	<input data-dojo-type='dijit/form/TimeTextBox' value='T12:34:00'>
		value: new Date(""),		// value.toString()="NaN"
		//FIXME: in markup, you have no control over daylight savings

		// Add scrollbars if necessary so that dropdown doesn't cover the <input>
		maxHeight: -1,

		_onKey: function(evt){
			if(this.disabled || this.readOnly){ return; }
			this.inherited(arguments);

			// If the user has backspaced or typed some numbers, then filter the result list
			// by what they typed.  Maybe there's a better way to detect this, like _handleOnChange()?
			switch(evt.keyCode){
				case keys.ENTER:
				case keys.TAB:
				case keys.ESCAPE:
				case keys.DOWN_ARROW:
				case keys.UP_ARROW:
					// these keys have special meaning
					break;
				default:
					// defer() because the keystroke hasn't yet appeared in the <input>,
					// so the get('displayedValue') call below won't give the result we want.
					this.defer(function(){
						// set this.filterString to the filter to apply to the drop down list;
						// it will be used in openDropDown()
						var val = this.get('displayedValue');
						this.filterString = (val && !this.parse(val, this.constraints)) ? val.toLowerCase() : "";

						// close the drop down and reopen it, in order to filter the items shown in the list
						// and also since the drop down may need to be repositioned if the number of list items has changed
						// and it's being displayed above the <input>
						if(this._opened){
							this.closeDropDown();
						}
						this.openDropDown();
					});
			}
		}
	});
});

},
'dijit/_TimePicker':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/date", // date.compare
	"dojo/date/locale", // locale.format
	"dojo/date/stamp", // stamp.fromISOString stamp.toISOString
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.contains domClass.toggle
	"dojo/dom-construct", // domConstruct.create
	"dojo/_base/kernel", // deprecated
	"dojo/keys", // keys
	"dojo/_base/lang", // lang.mixin
	"dojo/sniff", // has(...)
	"dojo/query", // query
	"dojo/mouse", // mouse.wheel
	"dojo/on",
	"./_WidgetBase",
	"./form/_ListMouseMixin"
], function(array, ddate, locale, stamp, declare, domClass, domConstruct, kernel, keys, lang, has, query, mouse, on,
			_WidgetBase, _ListMouseMixin){

	// module:
	//		dijit/_TimePicker


	var TimePicker = declare("dijit._TimePicker", [_WidgetBase, _ListMouseMixin], {
		// summary:
		//		A time picker dropdown, used by dijit/form/TimeTextBox.
		//		This widget is not available as a standalone widget due to lack of accessibility support.

		// baseClass: [protected] String
		//		The root className to use for the various states of this widget
		baseClass: "dijitTimePicker",

		// pickerMin: String
		//		ISO-8601 string representing the time of the first
		//		visible element in the time picker.
		//		Set in local time, without a time zone.
		pickerMin: "T00:00:00",

		// pickerMax: String
		//		ISO-8601 string representing the last (possible) time
		//		added to the time picker.
		//		Set in local time, without a time zone.
		pickerMax: "T23:59:59",

		// clickableIncrement: String
		//		ISO-8601 string representing the interval between choices in the time picker.
		//		Set in local time, without a time zone.
		//		Example: `T00:15:00` creates 15 minute increments
		//		Must divide dijit/_TimePicker.visibleIncrement evenly
		clickableIncrement: "T00:15:00",

		// visibleIncrement: String
		//		ISO-8601 string representing the interval between "major" choices in the time picker.
		//		Each theme will highlight the major choices with a larger font / different color / etc.
		//		Set in local time, without a time zone.
		//		Example: `T01:00:00` creates text in every 1 hour increment
		visibleIncrement: "T01:00:00",

		// value: String
		//		Time to display.
		//		Defaults to current time.
		//		Can be a Date object or an ISO-8601 string.
		//		If you specify the GMT time zone (`-01:00`),
		//		the time will be converted to the local time in the local time zone.
		//		Otherwise, the time is considered to be in the local time zone.
		//		If you specify the date and isDate is true, the date is used.
		//		Example: if your local time zone is `GMT -05:00`,
		//		`T10:00:00` becomes `T10:00:00-05:00` (considered to be local time),
		//		`T10:00:00-01:00` becomes `T06:00:00-05:00` (4 hour difference),
		//		`T10:00:00Z` becomes `T05:00:00-05:00` (5 hour difference between Zulu and local time)
		//		`yyyy-mm-ddThh:mm:ss` is the format to set the date and time
		//		Example: `2007-06-01T09:00:00`
		value: new Date(),

		_visibleIncrement: 2,
		_clickableIncrement: 1,
		_totalIncrements: 10,

		// constraints: TimePicker.__Constraints
		//		Specifies valid range of times (start time, end time), and also used by TimeTextBox to pass other
		//		options to the TimePicker: pickerMin, pickerMax, clickableIncrement, and visibleIncrement.
		constraints: {},

		/*=====
		 serialize: function(val, options){
			 // summary:
			 //		User overridable function used to convert the attr('value') result to a String
			 // val: Date
			 //		The current value
			 // options: Object?
			 // tags:
			 //		protected
		 },
		 =====*/
		serialize: stamp.toISOString,

		/*=====
		 // filterString: string
		 //		The string to filter by
		 filterString: "",
		 =====*/

		buildRendering: function(){
			this.inherited(arguments);
			this.containerNode = this.domNode;	// expected by _ListBase
			this.timeMenu = this.domNode;	// for back-compat
		},

		setValue: function(/*Date*/ value){
			// summary:
			//		Deprecated.  Used set('value') instead.
			// tags:
			//		deprecated
			kernel.deprecated("dijit._TimePicker:setValue() is deprecated.  Use set('value', ...) instead.", "", "2.0");
			this.set('value', value);
		},

		_setValueAttr: function(/*Date*/ date){
			// summary:
			//		Hook so set('value', ...) works.
			// description:
			//		Set the value of the TimePicker.
			//		Redraws the TimePicker around the new date.
			// tags:
			//		protected
			this._set("value", date);
			this._showText();
		},

		_setFilterStringAttr: function(val){
			// summary:
			//		Called by TimeTextBox to filter the values shown in my list
			this._set("filterString", val);
			this._showText();
		},

		isDisabledDate: function(/*===== dateObject, locale =====*/){
			// summary:
			//		May be overridden to disable certain dates in the TimePicker e.g. `isDisabledDate=locale.isWeekend`
			// dateObject: Date
			// locale: String?
			// type:
			//		extension
			return false; // Boolean
		},

		_getFilteredNodes: function(/*number*/ start, /*number*/ maxNum, /*Boolean*/ before, /*DOMNode*/ lastNode){
			// summary:
			//		Returns an array of nodes with the filter applied.  At most maxNum nodes
			//		will be returned - but fewer may be returned as well.  If the
			//		before parameter is set to true, then it will return the elements
			//		before the given index
			// tags:
			//		private

			var nodes = [];

			for(var i = 0 ; i < this._maxIncrement; i++){
				var n = this._createOption(i);
				if(n){
					nodes.push(n);
				}
			}
			return nodes;
		},

		_showText: function(){
			// summary:
			//		Displays the relevant choices in the drop down list
			// tags:
			//		private
			var fromIso = stamp.fromISOString;
			this.domNode.innerHTML = "";
			this._clickableIncrementDate = fromIso(this.clickableIncrement);
			this._visibleIncrementDate = fromIso(this.visibleIncrement);
			// get the value of the increments to find out how many divs to create
			var
				sinceMidnight = function(/*Date*/ date){
					return date.getHours() * 60 * 60 + date.getMinutes() * 60 + date.getSeconds();
				},
				clickableIncrementSeconds = sinceMidnight(this._clickableIncrementDate),
				visibleIncrementSeconds = sinceMidnight(this._visibleIncrementDate),
				// round reference date to previous visible increment
				time = (this.value || this.currentFocus).getTime();

			this._refDate = fromIso(this.pickerMin);
			this._refDate.setFullYear(1970, 0, 1); // match parse defaults

			// assume clickable increment is the smallest unit
			this._clickableIncrement = 1;
			// divide the visible range by the clickable increment to get the number of divs to create
			// example: 10:00:00/00:15:00 -> display 40 divs
			// divide the visible increments by the clickable increments to get how often to display the time inline
			// example: 01:00:00/00:15:00 -> display the time every 4 divs
			this._visibleIncrement = visibleIncrementSeconds / clickableIncrementSeconds;

			// get the number of increments (i.e. number of entries in the picker)
			var endDate = fromIso(this.pickerMax);
			endDate.setFullYear(1970, 0, 1);
			var visibleRange = (endDate.getTime() - this._refDate.getTime()) * 0.001;
			this._maxIncrement = Math.ceil((visibleRange + 1) / clickableIncrementSeconds);

			var nodes  = this._getFilteredNodes();
			array.forEach(nodes, function(n){
				this.domNode.appendChild(n);
			}, this);

			// never show empty due to a bad filter
			if(!nodes.length && this.filterString){
				this.filterString = '';
				this._showText();
			}
		},

		constructor: function(/*===== params, srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree

			this.constraints = {};
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			this._setConstraintsAttr(this.constraints); // this needs to happen now (and later) due to codependency on _set*Attr calls
		},

		// For historical reasons TimeTextBox sends all the options for the _TimePicker inside of a constraints{} object
		_setConstraintsAttr: function(/* Object */ constraints){
			// brings in increments, etc.
			for (var key in { clickableIncrement: 1, visibleIncrement: 1, pickerMin: 1, pickerMax: 1 }) {
				if (key in constraints) {
					this[key] = constraints[key];
				}
			}

			// locale needs the lang in the constraints as locale
			if(!constraints.locale){
				constraints.locale = this.lang;
			}
		},

		_createOption: function(/*Number*/ index){
			// summary:
			//		Creates a clickable time option, or returns null if the specified index doesn't match the filter
			// tags:
			//		private
			var date = new Date(this._refDate);
			var incrementDate = this._clickableIncrementDate;
			date.setHours(date.getHours() + incrementDate.getHours() * index,
				date.getMinutes() + incrementDate.getMinutes() * index,
				date.getSeconds() + incrementDate.getSeconds() * index);
			if(this.constraints.selector == "time"){
				date.setFullYear(1970, 0, 1); // make sure each time is for the same date
			}
			var dateString = locale.format(date, this.constraints);
			if(this.filterString && dateString.toLowerCase().indexOf(this.filterString) !== 0){
				// Doesn't match the filter - return null
				return null;
			}

			var div = this.ownerDocument.createElement("div");
			div.className = this.baseClass + "Item";
			div.date = date;
			div.idx = index;
			domConstruct.create('div', {
				"class": this.baseClass + "ItemInner",
				innerHTML: dateString
			}, div);

			if(index % this._visibleIncrement < 1 && index % this._visibleIncrement > -1){
				domClass.add(div, this.baseClass + "Marker");
			}else if(!(index % this._clickableIncrement)){
				domClass.add(div, this.baseClass + "Tick");
			}

			if(this.isDisabledDate(date)){
				// set disabled
				domClass.add(div, this.baseClass + "ItemDisabled");
			}
			if(this.value && !ddate.compare(this.value, date, this.constraints.selector)){
				div.selected = true;
				domClass.add(div, this.baseClass + "ItemSelected");
				this._selectedDiv = div;
				if(domClass.contains(div, this.baseClass + "Marker")){
					domClass.add(div, this.baseClass + "MarkerSelected");
				}else{
					domClass.add(div, this.baseClass + "TickSelected");
				}

				// Initially highlight the current value.   User can change highlight by up/down arrow keys
				// or mouse movement.
				this._highlightOption(div, true);
			}
			return div;
		},

		onOpen: function(){
			this.inherited(arguments);

			// Since _ListBase::_setSelectedAttr() calls scrollIntoView(), shouldn't call it until list is visible.
			this.set("selected", this._selectedDiv);
		},

		_onOptionSelected: function(/*Object*/ tgt){
			// summary:
			//		Called when user clicks an option in the drop down list
			// tags:
			//		private
			var tdate = tgt.target.date || tgt.target.parentNode.date;
			if(!tdate || this.isDisabledDate(tdate)){
				return;
			}
			this._highlighted_option = null;
			this.set('value', tdate);
			this.onChange(tdate);
		},

		onChange: function(/*Date*/ /*===== time =====*/){
			// summary:
			//		Notification that a time was selected.  It may be the same as the previous value.
			// tags:
			//		public
		},

		_highlightOption: function(/*node*/ node, /*Boolean*/ highlight){
			// summary:
			//		Turns on/off highlight effect on a node based on mouse out/over event
			// tags:
			//		private
			if(!node){
				return;
			}
			if(highlight){
				if(this._highlighted_option){
					this._highlightOption(this._highlighted_option, false);
				}
				this._highlighted_option = node;
			}else if(this._highlighted_option !== node){
				return;
			}else{
				this._highlighted_option = null;
			}
			domClass.toggle(node, this.baseClass + "ItemHover", highlight);
			if(domClass.contains(node, this.baseClass + "Marker")){
				domClass.toggle(node, this.baseClass + "MarkerHover", highlight);
			}else{
				domClass.toggle(node, this.baseClass + "TickHover", highlight);
			}
		},

		handleKey: function(/*Event*/ e){
			// summary:
			//		Called from `dijit/form/_DateTimeTextBox` to pass a keypress event
			//		from the `dijit/form/TimeTextBox` to be handled in this widget
			// tags:
			//		protected
			if(e.keyCode == keys.DOWN_ARROW){
				this.selectNextNode();
				e.stopPropagation();
				e.preventDefault();
				return false;
			}else if(e.keyCode == keys.UP_ARROW){
				this.selectPreviousNode();
				e.stopPropagation();
				e.preventDefault();
				return false;
			}else if(e.keyCode == keys.ENTER || e.keyCode === keys.TAB){
				// mouse hover followed by TAB is NO selection
				if(!this._keyboardSelected && e.keyCode === keys.TAB){
					return true;	// true means don't call stopEvent()
				}

				// Accept the currently-highlighted option as the value
				if(this._highlighted_option){
					this._onOptionSelected({target: this._highlighted_option});
				}

				// Call stopEvent() for ENTER key so that form doesn't submit,
				// but not for TAB, so that TAB does switch focus
				return e.keyCode === keys.TAB;
			}
			return undefined;
		},

		// Implement abstract methods for _ListBase
		onHover: function(/*DomNode*/ node){
			this._highlightOption(node, true);
		},

		onUnhover: function(/*DomNode*/ node){
			this._highlightOption(node, false);
		},

		onSelect: function(/*DomNode*/ node){
			this._highlightOption(node, true);
		},

		onDeselect: function(/*DomNode*/ node){
			this._highlightOption(node, false);
		},

		onClick: function(/*DomNode*/ node){
			this._onOptionSelected({target: node});
		}
	});

	/*=====
	 TimePicker.__Constraints = declare(locale.__FormatOptions, {
		 // clickableIncrement: String
		 //		See `dijit/_TimePicker.clickableIncrement`
		 clickableIncrement: "T00:15:00"
	 });
	 =====*/

	return TimePicker;
});

},
'dijit/form/_ListMouseMixin':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/on",
	"dojo/touch",
	"./_ListBase"
], function(declare, on, touch, _ListBase){

	// module:
	//		dijit/form/_ListMouseMixin

	return declare("dijit.form._ListMouseMixin", _ListBase, {
		// summary:
		//		A mixin to handle mouse or touch events for a focus-less menu
		//		Abstract methods that must be defined externally:
		//
		//		- onClick: item was chosen (mousedown somewhere on the menu and mouseup somewhere on the menu)
		// tags:
		//		private

		postCreate: function(){
			this.inherited(arguments);

			// Add flag to use normalized click handling from dojo/touch
			this.domNode.dojoClick = true;

			this._listConnect("click", "_onClick");
			this._listConnect("mousedown", "_onMouseDown");
			this._listConnect("mouseup", "_onMouseUp");
			this._listConnect("mouseover", "_onMouseOver");
			this._listConnect("mouseout", "_onMouseOut");
		},

		_onClick: function(/*Event*/ evt, /*DomNode*/ target){
			this._setSelectedAttr(target, false);
			if(this._deferredClick){
				this._deferredClick.remove();
			}
			this._deferredClick = this.defer(function(){
				this._deferredClick = null;
				this.onClick(target);
			});
		},

		_onMouseDown: function(/*Event*/ evt, /*DomNode*/ target){
			if(this._hoveredNode){
				this.onUnhover(this._hoveredNode);
				this._hoveredNode = null;
			}
			this._isDragging = true;
			this._setSelectedAttr(target, false);
		},

		_onMouseUp: function(/*Event*/ evt, /*DomNode*/ target){
			this._isDragging = false;
			var selectedNode = this.selected;
			var hoveredNode = this._hoveredNode;
			if(selectedNode && target == selectedNode){
				this.defer(function(){
					this._onClick(evt, selectedNode);
				});
			}else if(hoveredNode){ // drag to select
				this.defer(function(){
					this._onClick(evt, hoveredNode);
				});
			}
		},

		_onMouseOut: function(/*Event*/ evt, /*DomNode*/ target){
			if(this._hoveredNode){
				this.onUnhover(this._hoveredNode);
				this._hoveredNode = null;
			}
			if(this._isDragging){
				this._cancelDrag = (new Date()).getTime() + 1000; // cancel in 1 second if no _onMouseOver fires
			}
		},

		_onMouseOver: function(/*Event*/ evt, /*DomNode*/ target){
			if(this._cancelDrag){
				var time = (new Date()).getTime();
				if(time > this._cancelDrag){
					this._isDragging = false;
				}
				this._cancelDrag = null;
			}
			this._hoveredNode = target;
			this.onHover(target);
			if(this._isDragging){
				this._setSelectedAttr(target, false);
			}
		}
	});
});

},
'dijit/form/_ListBase':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/on",
	"dojo/window" // winUtils.scrollIntoView
], function(declare, on, winUtils){

	// module:
	//		dijit/form/_ListBase

	return declare("dijit.form._ListBase", null, {
		// summary:
		//		Focus-less menu to handle UI events consistently.
		//		Abstract methods that must be defined externally:
		//
		//		- onSelect: item is active (mousedown but not yet mouseup, or keyboard arrow selected but no Enter)
		//		- onDeselect:  cancels onSelect
		// tags:
		//		private

		// selected: DOMNode
		//		currently selected node
		selected: null,

		_listConnect: function(/*String|Function*/ eventType, /*String*/ callbackFuncName){
			// summary:
			//		Connects 'containerNode' to specified method of this object
			//		and automatically registers for 'disconnect' on widget destroy.
			// description:
			//		Provide widget-specific analog to 'connect'.
			//		The callback function is called with the normal event object,
			//		but also a second parameter is passed that indicates which list item
			//		actually received the event.
			// returns:
			//		A handle that can be passed to `disconnect` in order to disconnect
			//		before the widget is destroyed.
			// tags:
			//		private

			var self = this;
			return self.own(on(self.containerNode,
				on.selector(
					function(eventTarget, selector, target){
						return eventTarget.parentNode == target;
					},
					eventType
				),
				function(evt){
					self[callbackFuncName](evt, this);
				}
			));
		},

		selectFirstNode: function(){
			// summary:
			//		Select the first displayed item in the list.
			var first = this.containerNode.firstChild;
			while(first && first.style.display == "none"){
				first = first.nextSibling;
			}
			this._setSelectedAttr(first, true);
		},

		selectLastNode: function(){
			// summary:
			//		Select the last displayed item in the list
			var last = this.containerNode.lastChild;
			while(last && last.style.display == "none"){
				last = last.previousSibling;
			}
			this._setSelectedAttr(last, true);
		},

		selectNextNode: function(){
			// summary:
			//		Select the item just below the current selection.
			//		If nothing selected, select first node.
			var selectedNode = this.selected;
			if(!selectedNode){
				this.selectFirstNode();
			}else{
				var next = selectedNode.nextSibling;
				while(next && next.style.display == "none"){
					next = next.nextSibling;
				}
				if(!next){
					this.selectFirstNode();
				}else{
					this._setSelectedAttr(next, true);
				}
			}
		},

		selectPreviousNode: function(){
			// summary:
			//		Select the item just above the current selection.
			//		If nothing selected, select last node (if
			//		you select Previous and try to keep scrolling up the list).
			var selectedNode = this.selected;
			if(!selectedNode){
				this.selectLastNode();
			}else{
				var prev = selectedNode.previousSibling;
				while(prev && prev.style.display == "none"){
					prev = prev.previousSibling;
				}
				if(!prev){
					this.selectLastNode();
				}else{
					this._setSelectedAttr(prev, true);
				}
			}
		},

		_setSelectedAttr: function(/*DomNode*/ node, /*Boolean*/ scroll){
			// summary:
			//		Does the actual select.
			// node:
			//		The option to select
			// scroll:
			//		If necessary, scroll node into view.  Set to false for mouse/touch to
			//		avoid jumping problems on mobile/RTL, see https://bugs.dojotoolkit.org/ticket/17739.
			if(this.selected != node){
				var selectedNode = this.selected;
				if(selectedNode){
					this.onDeselect(selectedNode);
				}
				if(node){
					if(scroll){
						winUtils.scrollIntoView(node);
					}
					this.onSelect(node);
				}
				this._set("selected", node);
			}else if(node){
				this.onSelect(node);
			}
		}
	});
});

},
'dijit/form/_DateTimeTextBox':function(){
define([
	"dojo/date", // date date.compare
	"dojo/date/locale", // locale.regexp
	"dojo/date/stamp", // stamp.fromISOString stamp.toISOString
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.getObject
	"./RangeBoundTextBox",
	"../_HasDropDown",
	"dojo/text!./templates/DropDownBox.html"
], function(date, locale, stamp, declare, lang, RangeBoundTextBox, _HasDropDown, template){

	// module:
	//		dijit/form/_DateTimeTextBox

	new Date("X"); // workaround for #11279, new Date("") == NaN

	var _DateTimeTextBox = declare("dijit.form._DateTimeTextBox", [RangeBoundTextBox, _HasDropDown], {
		// summary:
		//		Base class for validating, serializable, range-bound date or time text box.

		templateString: template,

		// hasDownArrow: [const] Boolean
		//		Set this textbox to display a down arrow button, to open the drop down list.
		hasDownArrow: true,

		// Set classes like dijitDownArrowButtonHover depending on mouse action over button node
		cssStateNodes: {
			"_buttonNode": "dijitDownArrowButton"
		},

		/*=====
		// constraints: _DateTimeTextBox.__Constraints
		//		Despite the name, this parameter specifies both constraints on the input
		//		(including starting/ending dates/times allowed) as well as
		//		formatting options like whether the date is displayed in long (ex: December 25, 2005)
		//		or short (ex: 12/25/2005) format.  See `dijit/form/_DateTimeTextBox.__Constraints` for details.
		constraints: {},
		======*/

		// The constraints without the min/max properties. Used by the compare() method
		_unboundedConstraints: {},

		// Override ValidationTextBox.pattern.... we use a reg-ex generating function rather
		// than a straight regexp to deal with locale  (plus formatting options too?)
		pattern: locale.regexp,

		// datePackage: String
		//		JavaScript namespace to find calendar routines.	 If unspecified, uses Gregorian calendar routines
		//		at dojo/date and dojo/date/locale.
		datePackage: "",
		//		TODO: for 2.0, replace datePackage with dateModule and dateLocalModule attributes specifying MIDs,
		//		or alternately just get rid of this completely and tell user to use module ID remapping
		//		via require

		postMixInProperties: function(){
			this.inherited(arguments);
			this._set("type", "text"); // in case type="date"|"time" was specified which messes up parse/format
		},

		// Override _FormWidget.compare() to work for dates/times
		compare: function(/*Date*/ val1, /*Date*/ val2){
			var isInvalid1 = this._isInvalidDate(val1);
			var isInvalid2 = this._isInvalidDate(val2);
			if (isInvalid1 || isInvalid2){
				return (isInvalid1 && isInvalid2) ? 0 : (!isInvalid1 ? 1 : -1);
			}
			// Format and parse the values before comparing them to make sure that only the parts of the
			// date that will make the "round trip" get compared.
			var fval1 = this.format(val1, this._unboundedConstraints),
				fval2 = this.format(val2, this._unboundedConstraints),
				pval1 = this.parse(fval1, this._unboundedConstraints),
				pval2 = this.parse(fval2, this._unboundedConstraints);

			return fval1 == fval2 ? 0 : date.compare(pval1, pval2, this._selector);
		},

		// flag to _HasDropDown to make drop down Calendar width == <input> width
		autoWidth: true,

		format: function(/*Date*/ value, /*locale.__FormatOptions*/ constraints){
			// summary:
			//		Formats the value as a Date, according to specified locale (second argument)
			// tags:
			//		protected
			if(!value){ return ''; }
			return this.dateLocaleModule.format(value, constraints);
		},

		"parse": function(/*String*/ value, /*locale.__FormatOptions*/ constraints){
			// summary:
			//		Parses as string as a Date, according to constraints
			// tags:
			//		protected

			return this.dateLocaleModule.parse(value, constraints) || (this._isEmpty(value) ? null : undefined);	 // Date
		},

		// Overrides ValidationTextBox.serialize() to serialize a date in canonical ISO format.
		serialize: function(/*anything*/ val, /*Object?*/ options){
			if(val.toGregorian){
				val = val.toGregorian();
			}
			return stamp.toISOString(val, options);
		},

		// dropDownDefaultValue: Date
		//		The default value to focus in the popupClass widget when the textbox value is empty.
		dropDownDefaultValue : new Date(),

		// value: Date
		//		The value of this widget as a JavaScript Date object.  Use get("value") / set("value", val) to manipulate.
		//		When passed to the parser in markup, must be specified according to `dojo/date/stamp.fromISOString()`
		value: new Date(""),	// value.toString()="NaN"

		_blankValue: null,	// used by filter() when the textbox is blank

		// popupClass: [protected extension] String
		//		Name of the popup widget class used to select a date/time.
		//		Subclasses should specify this.
		popupClass: "", // default is no popup = text only


		// _selector: [protected extension] String
		//		Specifies constraints.selector passed to dojo.date functions, should be either
		//		"date" or "time".
		//		Subclass must specify this.
		_selector: "",

		constructor: function(params /*===== , srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree

			params = params || {};
			this.dateModule = params.datePackage ? lang.getObject(params.datePackage, false) : date;
			this.dateClassObj = this.dateModule.Date || Date;
			if(!(this.dateClassObj instanceof Date)){
				this.value = new this.dateClassObj(this.value);
			}
			this.dateLocaleModule = params.datePackage ? lang.getObject(params.datePackage+".locale", false) : locale;
			this._set('pattern', this.dateLocaleModule.regexp);
			this._invalidDate = this.constructor.prototype.value.toString();
		},

		buildRendering: function(){
			this.inherited(arguments);

			if(!this.hasDownArrow){
				this._buttonNode.style.display = "none";
			}

			// If hasDownArrow is false, we basically just want to treat the whole widget as the
			// button.
			if(!this.hasDownArrow){
				this._buttonNode = this.domNode;
				this.baseClass += " dijitComboBoxOpenOnClick";
			}
		},

		_setConstraintsAttr: function(/*Object*/ constraints){
			constraints.selector = this._selector;
			constraints.fullYear = true; // see #5465 - always format with 4-digit years
			var fromISO = stamp.fromISOString;
			if(typeof constraints.min == "string"){
				constraints.min = fromISO(constraints.min);
				if(!(this.dateClassObj instanceof Date)){
					constraints.min = new this.dateClassObj(constraints.min);
				}
			}
			if(typeof constraints.max == "string"){
				constraints.max = fromISO(constraints.max);
				if(!(this.dateClassObj instanceof Date)){
					constraints.max = new this.dateClassObj(constraints.max);
				}
			}
			this.inherited(arguments);
			this._unboundedConstraints = lang.mixin({}, this.constraints, {min: null, max: null});
		},

		_isInvalidDate: function(/*Date*/ value){
			// summary:
			//		Runs various tests on the value, checking for invalid conditions
			// tags:
			//		private
			return !value || isNaN(value) || typeof value != "object" || value.toString() == this._invalidDate;
		},

		_setValueAttr: function(/*Date|String*/ value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			// summary:
			//		Sets the date on this textbox. Note: value can be a JavaScript Date literal or a string to be parsed.
			if(value !== undefined){
				if(typeof value == "string"){
					value = stamp.fromISOString(value);
				}
				if(this._isInvalidDate(value)){
					value = null;
				}
				if(value instanceof Date && !(this.dateClassObj instanceof Date)){
					value = new this.dateClassObj(value);
				}
			}
			this.inherited(arguments, [value, priorityChange, formattedValue]);
			if(this.value instanceof Date){
				this.filterString = "";
			}
			if(this.dropDown){
				this.dropDown.set('value', value, false);
			}
		},

		_set: function(attr, value){
			// Avoid spurious watch() notifications when value is changed to new Date object w/the same value
			if(attr == "value"){
				if(value instanceof Date && !(this.dateClassObj instanceof Date)){
					value = new this.dateClassObj(value);
				}
				var oldValue = this._get("value");
				if(oldValue instanceof this.dateClassObj && this.compare(value, oldValue) == 0){
					return;
				}
			}
			this.inherited(arguments);
		},

		_setDropDownDefaultValueAttr: function(/*Date*/ val){
			if(this._isInvalidDate(val)){
				// convert null setting into today's date, since there needs to be *some* default at all times.
				 val = new this.dateClassObj();
			}
			this._set("dropDownDefaultValue", val);
		},

		openDropDown: function(/*Function*/ callback){
			// rebuild drop down every time, so that constraints get copied (#6002)
			if(this.dropDown){
				this.dropDown.destroy();
			}
			var PopupProto = lang.isString(this.popupClass) ? lang.getObject(this.popupClass, false) : this.popupClass,
				textBox = this,
				value = this.get("value");
			this.dropDown = new PopupProto({
				onChange: function(value){
					// this will cause InlineEditBox and other handlers to do stuff so make sure it's last
					textBox.set('value', value, true);
				},
				id: this.id + "_popup",
				dir: textBox.dir,
				lang: textBox.lang,
				value: value,
				textDir: textBox.textDir,
				currentFocus: !this._isInvalidDate(value) ? value : this.dropDownDefaultValue,
				constraints: textBox.constraints,
				filterString: textBox.filterString, // for TimeTextBox, to filter times shown
				datePackage: textBox.datePackage,
				isDisabledDate: function(/*Date*/ date){
					// summary:
					//		disables dates outside of the min/max of the _DateTimeTextBox
					return !textBox.rangeCheck(date, textBox.constraints);
				}
			});

			this.inherited(arguments);
		},

		_getDisplayedValueAttr: function(){
			return this.textbox.value;
		},

		_setDisplayedValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange){
			this._setValueAttr(this.parse(value, this.constraints), priorityChange, value);
		}
	});


	/*=====
	 _DateTimeTextBox.__Constraints = declare([RangeBoundTextBox.__Constraints, locale.__FormatOptions], {
		 // summary:
		 //		Specifies both the rules on valid/invalid values (first/last date/time allowed),
		 //		and also formatting options for how the date/time is displayed.
		 // example:
		 //		To restrict to dates within 2004, displayed in a long format like "December 25, 2005":
		 //	|		{min:'2004-01-01',max:'2004-12-31', formatLength:'long'}
	 });
	 =====*/

	return _DateTimeTextBox;
});

},
'dijit/form/RangeBoundTextBox':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/i18n", // i18n.getLocalization
	"./MappedTextBox",
	"dojo/i18n!./nls/validate"
], function(declare, i18n, MappedTextBox){

	// module:
	//		dijit/form/RangeBoundTextBox


	var RangeBoundTextBox = declare("dijit.form.RangeBoundTextBox", MappedTextBox, {
		// summary:
		//		Base class for textbox form widgets which defines a range of valid values.

		// rangeMessage: String
		//		The message to display if value is out-of-range
		rangeMessage: "",

		/*=====
		// constraints: RangeBoundTextBox.__Constraints
		constraints: {},
		======*/

		rangeCheck: function(/*Number*/ primitive, /*dijit/form/RangeBoundTextBox.__Constraints*/ constraints){
			// summary:
			//		Overridable function used to validate the range of the numeric input value.
			// tags:
			//		protected
			return	("min" in constraints? (this.compare(primitive,constraints.min) >= 0) : true) &&
				("max" in constraints? (this.compare(primitive,constraints.max) <= 0) : true); // Boolean
		},

		isInRange: function(/*Boolean*/ /*===== isFocused =====*/){
			// summary:
			//		Tests if the value is in the min/max range specified in constraints
			// tags:
			//		protected
			return this.rangeCheck(this.get('value'), this.constraints);
		},

		_isDefinitelyOutOfRange: function(){
			// summary:
			//		Returns true if the value is out of range and will remain
			//		out of range even if the user types more characters
			var val = this.get('value');
			if(val == null){ return false; } // not yet valid enough to compare to
			var outOfRange = false;
			if("min" in this.constraints){
				var min = this.constraints.min;
				outOfRange = this.compare(val, ((typeof min == "number") && min >= 0 && val != 0) ? 0 : min) < 0;
			}
			if(!outOfRange && ("max" in this.constraints)){
				var max = this.constraints.max;
				outOfRange = this.compare(val, ((typeof max != "number") || max > 0) ? max : 0) > 0;
			}
			return outOfRange;
		},

		_isValidSubset: function(){
			// summary:
			//		Overrides `dijit/form/ValidationTextBox._isValidSubset()`.
			//		Returns true if the input is syntactically valid, and either within
			//		range or could be made in range by more typing.
			return this.inherited(arguments) && !this._isDefinitelyOutOfRange();
		},

		isValid: function(/*Boolean*/ isFocused){
			// Overrides dijit/form/ValidationTextBox.isValid() to check that the value is also in range.
			return this.inherited(arguments) &&
				((this._isEmpty(this.textbox.value) && !this.required) || this.isInRange(isFocused)); // Boolean
		},

		getErrorMessage: function(/*Boolean*/ isFocused){
			// Overrides dijit/form/ValidationTextBox.getErrorMessage() to print "out of range" message if appropriate
			var v = this.get('value');
			if(v != null /* and !undefined */ && v !== '' && (typeof v != "number" || !isNaN(v)) && !this.isInRange(isFocused)){ // don't check isInRange w/o a real value
				return this.rangeMessage; // String
			}
			return this.inherited(arguments);
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			if(!this.rangeMessage){
				this.messages = i18n.getLocalization("dijit.form", "validate", this.lang);
				this.rangeMessage = this.messages.rangeMessage;
			}
		}
	});
	/*=====
	RangeBoundTextBox.__Constraints = declare(null, {
		// min: Number
		//		Minimum signed value.  Default is -Infinity
		// max: Number
		//		Maximum signed value.  Default is +Infinity
	});
	=====*/
	return RangeBoundTextBox;
});

},
'dijit/form/MappedTextBox':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/sniff", // has("msapp")
	"dojo/dom-construct", // domConstruct.place
	"./ValidationTextBox"
], function(declare, has, domConstruct, ValidationTextBox){

	// module:
	//		dijit/form/MappedTextBox

	return declare("dijit.form.MappedTextBox", ValidationTextBox, {
		// summary:
		//		A dijit/form/ValidationTextBox subclass which provides a base class for widgets that have
		//		a visible formatted display value, and a serializable
		//		value in a hidden input field which is actually sent to the server.
		// description:
		//		The visible display may
		//		be locale-dependent and interactive.  The value sent to the server is stored in a hidden
		//		input field which uses the `name` attribute declared by the original widget.  That value sent
		//		to the server is defined by the dijit/form/MappedTextBox.serialize() method and is typically
		//		locale-neutral.
		// tags:
		//		protected

		postMixInProperties: function(){
			this.inherited(arguments);

			// We want the name attribute to go to the hidden <input>, not the displayed <input>,
			// so override _FormWidget.postMixInProperties() setting of nameAttrSetting for IE.
			this.nameAttrSetting = "";
		},

		// Remap name attribute to be mapped to hidden node created in buildRendering(), rather than this.focusNode
		_setNameAttr: "valueNode",

		serialize: function(val /*=====, options =====*/){
			// summary:
			//		Overridable function used to convert the get('value') result to a canonical
			//		(non-localized) string.  For example, will print dates in ISO format, and
			//		numbers the same way as they are represented in javascript.
			// val: anything
			// options: Object?
			// tags:
			//		protected extension
			return val.toString ? val.toString() : ""; // String
		},

		toString: function(){
			// summary:
			//		Returns widget as a printable string using the widget's value
			// tags:
			//		protected
			var val = this.filter(this.get('value')); // call filter in case value is nonstring and filter has been customized
			return val != null ? (typeof val == "string" ? val : this.serialize(val, this.constraints)) : ""; // String
		},

		validate: function(){
			// Overrides `dijit/form/TextBox.validate`
			this.valueNode.value = this.toString();
			return this.inherited(arguments);
		},

		buildRendering: function(){
			// Overrides `dijit/_TemplatedMixin/buildRendering`

			this.inherited(arguments);

			// Create a hidden <input> node with the serialized value used for submit
			// (as opposed to the displayed value).
			// Passing in name as markup rather than relying on _setNameAttr custom setter above
			// to make query(input[name=...]) work on IE. (see #8660).
			// But not doing that for Windows 8 Store apps because it causes a security exception (see #16452).
			this.valueNode = domConstruct.place("<input type='hidden'" +
				((this.name && !has("msapp")) ? ' name="' + this.name.replace(/"/g, "&quot;") + '"' : "") + "/>",
				this.textbox, "after");
		},

		reset: function(){
			// Overrides `dijit/form/ValidationTextBox.reset` to
			// reset the hidden textbox value to ''
			this.valueNode.value = '';
			this.inherited(arguments);
		}
	});
});

},
'dijit/TooltipDialog':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.replace
	"dojo/has",
	"dojo/keys", // keys
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"./focus",
	"./layout/ContentPane",
	"./_DialogMixin",
	"./form/_FormMixin",
	"./_TemplatedMixin",
	"dojo/text!./templates/TooltipDialog.html",
	"./main"        // exports methods to dijit global
], function(declare, domClass, has, keys, lang, on, focus, ContentPane, _DialogMixin, _FormMixin, _TemplatedMixin, template, dijit){

	// module:
	//		dijit/TooltipDialog


	var TooltipDialog = declare("dijit.TooltipDialog",
		[ContentPane, _TemplatedMixin, _FormMixin, _DialogMixin], {
			// summary:
			//		Pops up a dialog that appears like a Tooltip

			// title: String
			//		Description of tooltip dialog (required for a11y)
			title: "",

			// doLayout: [protected] Boolean
			//		Don't change this parameter from the default value.
			//		This ContentPane parameter doesn't make sense for TooltipDialog, since TooltipDialog
			//		is never a child of a layout container, nor can you specify the size of
			//		TooltipDialog in order to control the size of an inner widget.
			doLayout: false,

			// autofocus: Boolean
			//		A Toggle to modify the default focus behavior of a Dialog, which
			//		is to focus on the first dialog element after opening the dialog.
			//		False will disable autofocusing.  Default: true.
			autofocus: true,

			// baseClass: [protected] String
			//		The root className to use for the various states of this widget
			baseClass: "dijitTooltipDialog",

			// _firstFocusItem: [private readonly] DomNode
			//		The pointer to the first focusable node in the dialog.
			//		Set by `dijit/_DialogMixin._getFocusItems()`.
			_firstFocusItem: null,

			// _lastFocusItem: [private readonly] DomNode
			//		The pointer to which node has focus prior to our dialog.
			//		Set by `dijit/_DialogMixin._getFocusItems()`.
			_lastFocusItem: null,

			templateString: template,

			_setTitleAttr: "containerNode",

			postCreate: function(){
				this.inherited(arguments);
				this.own(on(this.domNode, "keydown", lang.hitch(this, "_onKey")));
			},

			orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ tooltipCorner){
				// summary:
				//		Configure widget to be displayed in given position relative to the button.
				//		This is called from the dijit.popup code, and should not be called
				//		directly.
				// tags:
				//		protected

				// Note: intentionally not using dijitTooltip class since that sets position:absolute, which
				// confuses dijit/popup trying to get the size of the tooltip.
				var newC = {
					// Real around node
					"MR-ML": "dijitTooltipRight",
					"ML-MR": "dijitTooltipLeft",
					"TM-BM": "dijitTooltipAbove",
					"BM-TM": "dijitTooltipBelow",
					"BL-TL": "dijitTooltipBelow dijitTooltipABLeft",
					"TL-BL": "dijitTooltipAbove dijitTooltipABLeft",
					"BR-TR": "dijitTooltipBelow dijitTooltipABRight",
					"TR-BR": "dijitTooltipAbove dijitTooltipABRight",
					"BR-BL": "dijitTooltipRight",
					"BL-BR": "dijitTooltipLeft",

					// Positioning "around" a point, ex: mouse position
					"BR-TL": "dijitTooltipBelow dijitTooltipABLeft",
					"BL-TR": "dijitTooltipBelow dijitTooltipABRight",
					"TL-BR": "dijitTooltipAbove dijitTooltipABRight",
					"TR-BL": "dijitTooltipAbove dijitTooltipABLeft"
				}[aroundCorner + "-" + tooltipCorner];

				domClass.replace(this.domNode, newC, this._currentOrientClass || "");
				this._currentOrientClass = newC;

				// Tooltip.orient() has code to reposition connector for when Tooltip is before/after anchor.
				// Not putting here to avoid code bloat, and since TooltipDialogs are generally above/below.
				// Should combine code from Tooltip and TooltipDialog.
			},

			focus: function(){
				// summary:
				//		Focus on first field
				this._getFocusItems();
				focus.focus(this._firstFocusItem);
			},

			onOpen: function(/*Object*/ pos){
				// summary:
				//		Called when dialog is displayed.
				//		This is called from the dijit.popup code, and should not be called directly.
				// tags:
				//		protected

				this.orient(this.domNode, pos.aroundCorner, pos.corner);

				// Position the tooltip connector for middle alignment.
				// This could not have been done in orient() since the tooltip wasn't positioned at that time.
				var aroundNodeCoords = pos.aroundNodePos;
				if(pos.corner.charAt(0) == 'M' && pos.aroundCorner.charAt(0) == 'M'){
					this.connectorNode.style.top = aroundNodeCoords.y + ((aroundNodeCoords.h - this.connectorNode.offsetHeight) >> 1) - pos.y + "px";
					this.connectorNode.style.left = "";
				}else if(pos.corner.charAt(1) == 'M' && pos.aroundCorner.charAt(1) == 'M'){
					this.connectorNode.style.left = aroundNodeCoords.x + ((aroundNodeCoords.w - this.connectorNode.offsetWidth) >> 1) - pos.x + "px";
				}

				this._onShow(); // lazy load trigger  (TODO: shouldn't we load before positioning?)
			},

			onClose: function(){
				// summary:
				//		Called when dialog is hidden.
				//		This is called from the dijit.popup code, and should not be called directly.
				// tags:
				//		protected
				this.onHide();
			},

			_onKey: function(/*Event*/ evt){
				// summary:
				//		Handler for keydown events
				// description:
				//		Keep keyboard focus in dialog; close dialog on escape key
				// tags:
				//		private

				if(evt.keyCode == keys.ESCAPE){
					// Use defer to avoid crash on IE, see #10396.  Not sure if this is still needed or not.
					// If this if() wasn't here, presumably dijit/popup would catch the ESCAPE key and close the popup.
					this.defer("onCancel");
					evt.stopPropagation();
					evt.preventDefault();
				}else if(evt.keyCode == keys.TAB){
					var node = evt.target;
					this._getFocusItems();
					if(this._firstFocusItem == this._lastFocusItem){
						evt.stopPropagation();
						evt.preventDefault();
					}else if(node == this._firstFocusItem && evt.shiftKey){
						focus.focus(this._lastFocusItem); // send focus to last item in dialog
						evt.stopPropagation();
						evt.preventDefault();
					}else if(node == this._lastFocusItem && !evt.shiftKey){
						focus.focus(this._firstFocusItem); // send focus to first item in dialog
						evt.stopPropagation();
						evt.preventDefault();
					}else{
						// we want the browser's default tab handling to move focus
						// but we don't want the tab to propagate upwards
						evt.stopPropagation();
					}
				}
			}
		});

	if(has("dojo-bidi")){
		TooltipDialog.extend({
			_setTitleAttr: function(/*String*/ title){
				this.containerNode.title = (this.textDir && this.enforceTextDirWithUcc) ? this.enforceTextDirWithUcc(null, title) : title;
				this._set("title", title);
			},

			_setTextDirAttr: function(/*String*/ textDir){
				if(!this._created || this.textDir != textDir){
					this._set("textDir", textDir);
					if(this.textDir && this.title){
						this.containerNode.title = this.enforceTextDirWithUcc(null, this.title);
					}
				}
			}
		});
	}

	return TooltipDialog;
});

},
'dijit/_base/popup':function(){
define([
	"dojo/dom-class", // domClass.contains
	"dojo/_base/window",
	"../popup",
	"../BackgroundIframe"	// just loading for back-compat, in case client code is referencing it
], function(domClass, win, popup){

// module:
//		dijit/_base/popup

/*=====
return {
	// summary:
	//		Deprecated.   Old module for popups, new code should use dijit/popup directly.
};
=====*/


// Hack support for old API passing in node instead of a widget (to various methods)
var origCreateWrapper = popup._createWrapper;
popup._createWrapper = function(widget){
	if(!widget.declaredClass){
		// make fake widget to pass to new API
		widget = {
			_popupWrapper: (widget.parentNode && domClass.contains(widget.parentNode, "dijitPopup")) ?
				widget.parentNode : null,
			domNode: widget,
			destroy: function(){},
			ownerDocument: widget.ownerDocument,
			ownerDocumentBody: win.body(widget.ownerDocument)
		};
	}
	return origCreateWrapper.call(this, widget);
};

// Support old format of orient parameter
var origOpen = popup.open;
popup.open = function(/*__OpenArgs*/ args){
	// Convert old hash structure (ex: {"BL": "TL", ...}) of orient to format compatible w/new popup.open() API.
	// Don't do conversion for:
	//		- null parameter (that means to use the default positioning)
	//		- "R" or "L" strings used to indicate positioning for context menus (when there is no around node)
	//		- new format, ex: ["below", "above"]
	//		- return value from deprecated dijit.getPopupAroundAlignment() method,
	//			ex: ["below", "above"]
	if(args.orient && typeof args.orient != "string" && !("length" in args.orient)){
		var ary = [];
		for(var key in args.orient){
			ary.push({aroundCorner: key, corner: args.orient[key]});
		}
		args.orient = ary;
	}

	return origOpen.call(this, args);
};

return popup;
});

},
'dijit/form/ComboBox':function(){
define([
	"dojo/_base/declare", // declare
	"./ValidationTextBox",
	"./ComboBoxMixin"
], function(declare, ValidationTextBox, ComboBoxMixin){

	// module:
	//		dijit/form/ComboBox

	return declare("dijit.form.ComboBox", [ValidationTextBox, ComboBoxMixin], {
		// summary:
		//		Auto-completing text box
		//
		// description:
		//		The drop down box's values are populated from an class called
		//		a data provider, which returns a list of values based on the characters
		//		that the user has typed into the input box.
		//		If OPTION tags are used as the data provider via markup,
		//		then the OPTION tag's child text node is used as the widget value
		//		when selected.  The OPTION tag's value attribute is ignored.
		//		To set the default value when using OPTION tags, specify the selected
		//		attribute on 1 of the child OPTION tags.
		//
		//		Some of the options to the ComboBox are actually arguments to the data
		//		provider.
	});
});

},
'dijit/form/ComboBoxMixin':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/Deferred",
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.mixin
	"dojo/store/util/QueryResults",
	"./_AutoCompleterMixin",
	"./_ComboBoxMenu",
	"../_HasDropDown",
	"dojo/text!./templates/DropDownBox.html"
], function(declare, Deferred, kernel, lang, QueryResults, _AutoCompleterMixin, _ComboBoxMenu, _HasDropDown, template){


	// module:
	//		dijit/form/ComboBoxMixin

	return declare("dijit.form.ComboBoxMixin", [_HasDropDown, _AutoCompleterMixin], {
		// summary:
		//		Provides main functionality of ComboBox widget

		// dropDownClass: [protected extension] Function String
		//		Dropdown widget class used to select a date/time.
		//		Subclasses should specify this.
		dropDownClass: _ComboBoxMenu,

		// hasDownArrow: Boolean
		//		Set this textbox to have a down arrow button, to display the drop down list.
		//		Defaults to true.
		hasDownArrow: true,

		templateString: template,

		baseClass: "dijitTextBox dijitComboBox",

		/*=====
		// store: [const] dojo/store/api/Store|dojo/data/api/Read
		//		Reference to data provider object used by this ComboBox.
		//
		//		Should be dojo/store/api/Store, but dojo/data/api/Read supported
		//		for backwards compatibility.
		store: null,
		=====*/

		// Set classes like dijitDownArrowButtonHover depending on
		// mouse action over button node
		cssStateNodes: {
			"_buttonNode": "dijitDownArrowButton"
		},

		_setHasDownArrowAttr: function(/*Boolean*/ val){
			this._set("hasDownArrow", val);
			this._buttonNode.style.display = val ? "" : "none";
		},

		_showResultList: function(){
			// hide the tooltip
			this.displayMessage("");
			this.inherited(arguments);
		},

		_setStoreAttr: function(store){
			// For backwards-compatibility, accept dojo.data store in addition to dojo/store/api/Store.  Remove in 2.0.
			if(!store.get){
				lang.mixin(store, {
					_oldAPI: true,
					get: function(id){
						// summary:
						//		Retrieves an object by it's identity. This will trigger a fetchItemByIdentity.
						//		Like dojo/store/DataStore.get() except returns native item.
						var deferred = new Deferred();
						this.fetchItemByIdentity({
							identity: id,
							onItem: function(object){
								deferred.resolve(object);
							},
							onError: function(error){
								deferred.reject(error);
							}
						});
						return deferred.promise;
					},
					query: function(query, options){
						// summary:
						//		Queries the store for objects.   Like dojo/store/DataStore.query()
						//		except returned Deferred contains array of native items.
						var deferred = new Deferred(function(){ fetchHandle.abort && fetchHandle.abort(); });
						deferred.total = new Deferred();
						var fetchHandle = this.fetch(lang.mixin({
							query: query,
							onBegin: function(count){
								deferred.total.resolve(count);
							},
							onComplete: function(results){
								deferred.resolve(results);
							},
							onError: function(error){
								deferred.reject(error);
							}
						}, options));
						return QueryResults(deferred);
					}
				});
			}
			this._set("store", store);
		},

		postMixInProperties: function(){
			// Since _setValueAttr() depends on this.store, _setStoreAttr() needs to execute first.
			// Unfortunately, without special code, it ends up executing second.
			var store = this.params.store || this.store;
			if(store){
				this._setStoreAttr(store);
			}

			this.inherited(arguments);

			// User may try to access this.store.getValue() etc.  in a custom labelFunc() function.
			// It's not available with the new data store for handling inline <option> tags, so add it.
			if(!this.params.store && this.store && !this.store._oldAPI){
				var clazz = this.declaredClass;
				lang.mixin(this.store, {
					getValue: function(item, attr){
						kernel.deprecated(clazz + ".store.getValue(item, attr) is deprecated for builtin store.  Use item.attr directly", "", "2.0");
						return item[attr];
					},
					getLabel: function(item){
						kernel.deprecated(clazz + ".store.getLabel(item) is deprecated for builtin store.  Use item.label directly", "", "2.0");
						return item.name;
					},
					fetch: function(args){
						kernel.deprecated(clazz + ".store.fetch() is deprecated for builtin store.", "Use store.query()", "2.0");
						var shim = ["dojo/data/ObjectStore"];	// indirection so it doesn't get rolled into a build
						require(shim, lang.hitch(this, function(ObjectStore){
							new ObjectStore({objectStore: this}).fetch(args);
						}));
					}
				});
			}
		},

		buildRendering: function(){
			this.inherited(arguments);

			this.focusNode.setAttribute("aria-autocomplete", this.autoComplete ? "both" : "list");
		}
	});
});

},
'dijit/form/_AutoCompleterMixin':function(){
define([
	"dojo/aspect",
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.get
	"dojo/keys",
	"dojo/_base/lang", // lang.clone lang.hitch
	"dojo/query", // query
	"dojo/regexp", // regexp.escapeString
	"dojo/sniff", // has("ie")
	"./DataList",
	"./_TextBoxMixin", // defines _TextBoxMixin.selectInputText
	"./_SearchMixin"
], function(aspect, declare, domAttr, keys, lang, query, regexp, has, DataList, _TextBoxMixin, SearchMixin){

	// module:
	//		dijit/form/_AutoCompleterMixin

	var AutoCompleterMixin = declare("dijit.form._AutoCompleterMixin", SearchMixin, {
		// summary:
		//		A mixin that implements the base functionality for `dijit/form/ComboBox`/`dijit/form/FilteringSelect`
		// description:
		//		All widgets that mix in dijit/form/_AutoCompleterMixin must extend `dijit/form/_FormValueWidget`.
		// tags:
		//		protected

		// item: Object
		//		This is the item returned by the dojo/store/api/Store implementation that
		//		provides the data for this ComboBox, it's the currently selected item.
		item: null,

		// autoComplete: Boolean
		//		If user types in a partial string, and then tab out of the `<input>` box,
		//		automatically copy the first entry displayed in the drop down list to
		//		the `<input>` field
		autoComplete: true,

		// highlightMatch: String
		//		One of: "first", "all" or "none".
		//
		//		If the ComboBox/FilteringSelect opens with the search results and the searched
		//		string can be found, it will be highlighted.  If set to "all"
		//		then will probably want to change `queryExpr` parameter to '*${0}*'
		//
		//		Highlighting is only performed when `labelType` is "text", so as to not
		//		interfere with any HTML markup an HTML label might contain.
		highlightMatch: "first",

		// labelAttr: String?
		//		The entries in the drop down list come from this attribute in the
		//		dojo.data items.
		//		If not specified, the searchAttr attribute is used instead.
		labelAttr: "",

		// labelType: String
		//		Specifies how to interpret the labelAttr in the data store items.
		//		Can be "html" or "text".
		labelType: "text",

		// Flags to _HasDropDown to limit height of drop down to make it fit in viewport
		maxHeight: -1,

		// For backwards compatibility let onClick events propagate, even clicks on the down arrow button
		_stopClickEvents: false,

		_getCaretPos: function(/*DomNode*/ element){
			// khtml 3.5.2 has selection* methods as does webkit nightlies from 2005-06-22
			var pos = 0;
			if(typeof(element.selectionStart) == "number"){
				// FIXME: this is totally borked on Moz < 1.3. Any recourse?
				pos = element.selectionStart;
			}else if(has("ie")){
				// in the case of a mouse click in a popup being handled,
				// then the document.selection is not the textarea, but the popup
				// var r = document.selection.createRange();
				// hack to get IE 6 to play nice. What a POS browser.
				var tr = element.ownerDocument.selection.createRange().duplicate();
				var ntr = element.createTextRange();
				tr.move("character", 0);
				ntr.move("character", 0);
				try{
					// If control doesn't have focus, you get an exception.
					// Seems to happen on reverse-tab, but can also happen on tab (seems to be a race condition - only happens sometimes).
					// There appears to be no workaround for this - googled for quite a while.
					ntr.setEndPoint("EndToEnd", tr);
					pos = String(ntr.text).replace(/\r/g, "").length;
				}catch(e){
					// If focus has shifted, 0 is fine for caret pos.
				}
			}
			return pos;
		},

		_setCaretPos: function(/*DomNode*/ element, /*Number*/ location){
			location = parseInt(location);
			_TextBoxMixin.selectInputText(element, location, location);
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			// Additional code to set disabled state of ComboBox node.
			// Overrides _FormValueWidget._setDisabledAttr() or ValidationTextBox._setDisabledAttr().
			this.inherited(arguments);
			this.domNode.setAttribute("aria-disabled", value ? "true" : "false");
		},

		_onKey: function(/*Event*/ evt){
			// summary:
			//		Handles keyboard events

			if(evt.charCode >= 32){
				return;
			} // alphanumeric reserved for searching

			var key = evt.charCode || evt.keyCode;

			// except for cutting/pasting case - ctrl + x/v
			if(key == keys.ALT || key == keys.CTRL || key == keys.META || key == keys.SHIFT){
				return; // throw out spurious events
			}

			var pw = this.dropDown;
			var highlighted = null;
			this._abortQuery();

			// _HasDropDown will do some of the work:
			//
			//	1. when drop down is not yet shown:
			//		- if user presses the down arrow key, call loadDropDown()
			//	2. when drop down is already displayed:
			//		- on ESC key, call closeDropDown()
			//		- otherwise, call dropDown.handleKey() to process the keystroke
			this.inherited(arguments);

			if(evt.altKey || evt.ctrlKey || evt.metaKey){
				return;
			} // don't process keys with modifiers  - but we want shift+TAB

			if(this._opened){
				highlighted = pw.getHighlightedOption();
			}
			switch(key){
				case keys.PAGE_DOWN:
				case keys.DOWN_ARROW:
				case keys.PAGE_UP:
				case keys.UP_ARROW:
					// Keystroke caused ComboBox_menu to move to a different item.
					// Copy new item to <input> box.
					if(this._opened){
						this._announceOption(highlighted);
					}
					evt.stopPropagation();
					evt.preventDefault();
					break;

				case keys.ENTER:
					// prevent submitting form if user presses enter. Also
					// prevent accepting the value if either Next or Previous
					// are selected
					if(highlighted){
						// only stop event on prev/next
						if(highlighted == pw.nextButton){
							this._nextSearch(1);
							// prevent submit
							evt.stopPropagation();
							evt.preventDefault();
							break;
						}else if(highlighted == pw.previousButton){
							this._nextSearch(-1);
							// prevent submit
							evt.stopPropagation();
							evt.preventDefault();
							break;
						}
						// prevent submit if ENTER was to choose an item
						evt.stopPropagation();
						evt.preventDefault();
					}else{
						// Update 'value' (ex: KY) according to currently displayed text
						this._setBlurValue(); // set value if needed
						this._setCaretPos(this.focusNode, this.focusNode.value.length); // move cursor to end and cancel highlighting
					}
				// fall through

				case keys.TAB:
					var newvalue = this.get('displayedValue');
					//	if the user had More Choices selected fall into the
					//	_onBlur handler
					if(pw && (newvalue == pw._messages["previousMessage"] || newvalue == pw._messages["nextMessage"])){
						break;
					}
					if(highlighted){
					    this._selectOption(highlighted);
                        // do selection of item without tabbing to the next field as well
					    evt.stopPropagation();
					    evt.preventDefault();
					}
				// fall through

				case keys.ESCAPE:
					if(this._opened){
						this._lastQuery = null; // in case results come back later
						this.closeDropDown();
					}
					break;
			}
		},

		_autoCompleteText: function(/*String*/ text){
			// summary:
			//		Fill in the textbox with the first item from the drop down
			//		list, and highlight the characters that were
			//		auto-completed. For example, if user typed "CA" and the
			//		drop down list appeared, the textbox would be changed to
			//		"California" and "ifornia" would be highlighted.

			var fn = this.focusNode;

			// IE7: clear selection so next highlight works all the time
			_TextBoxMixin.selectInputText(fn, fn.value.length);
			// does text autoComplete the value in the textbox?
			var caseFilter = this.ignoreCase ? 'toLowerCase' : 'substr';
			if(text[caseFilter](0).indexOf(this.focusNode.value[caseFilter](0)) == 0){
				var cpos = this.autoComplete ? this._getCaretPos(fn) : fn.value.length;
				// only try to extend if we added the last character at the end of the input
				if((cpos + 1) > fn.value.length){
					// only add to input node as we would overwrite Capitalisation of chars
					// actually, that is ok
					fn.value = text;//.substr(cpos);
					// visually highlight the autocompleted characters
					_TextBoxMixin.selectInputText(fn, cpos);
				}
			}else{
				// text does not autoComplete; replace the whole value and highlight
				fn.value = text;
				_TextBoxMixin.selectInputText(fn);
			}
		},

		_openResultList: function(/*Object*/ results, /*Object*/ query, /*Object*/ options){
			// summary:
			//		Callback when a search completes.
			// description:
			//		1. generates drop-down list and calls _showResultList() to display it
			//		2. if this result list is from user pressing "more choices"/"previous choices"
			//			then tell screen reader to announce new option
			var wasSelected = this.dropDown.getHighlightedOption();
			this.dropDown.clearResultList();
			if(!results.length && options.start == 0){ // if no results and not just the previous choices button
				this.closeDropDown();
				return;
			}
			this._nextSearch = this.dropDown.onPage = lang.hitch(this, function(direction){
				results.nextPage(direction !== -1);
				this.focus();
			});

			// Fill in the textbox with the first item from the drop down list,
			// and highlight the characters that were auto-completed. For
			// example, if user typed "CA" and the drop down list appeared, the
			// textbox would be changed to "California" and "ifornia" would be
			// highlighted.

			this.dropDown.createOptions(
				results,
				options,
				lang.hitch(this, "_getMenuLabelFromItem")
			);

			// show our list (only if we have content, else nothing)
			this._showResultList();

			// #4091:
			//		tell the screen reader that the paging callback finished by
			//		shouting the next choice
			if("direction" in options){
				if(options.direction){
					this.dropDown.highlightFirstOption();
				}else if(!options.direction){
					this.dropDown.highlightLastOption();
				}
				if(wasSelected){
					this._announceOption(this.dropDown.getHighlightedOption());
				}
			}else if(this.autoComplete && !this._prev_key_backspace
				// when the user clicks the arrow button to show the full list,
				// startSearch looks for "*".
				// it does not make sense to autocomplete
				// if they are just previewing the options available.
				&& !/^[*]+$/.test(query[this.searchAttr].toString())){
				this._announceOption(this.dropDown.containerNode.firstChild.nextSibling); // 1st real item
			}
		},

		_showResultList: function(){
			// summary:
			//		Display the drop down if not already displayed, or if it is displayed, then
			//		reposition it if necessary (reposition may be necessary if drop down's height changed).
			this.closeDropDown(true);
			this.openDropDown();
			// start with the first option highlighted, so that keyboard selection using ENTER or TAB works
            // appropriately.
			this.dropDown.highlightFirstOption();
			this.domNode.setAttribute("aria-expanded", "true");
		},

		loadDropDown: function(/*Function*/ /*===== callback =====*/){
			// Overrides _HasDropDown.loadDropDown().
			// This is called when user has pressed button icon or pressed the down arrow key
			// to open the drop down.
			this._startSearchAll();
		},

		isLoaded: function(){
			// signal to _HasDropDown that it needs to call loadDropDown() to load the
			// drop down asynchronously before displaying it
			return false;
		},

		closeDropDown: function(){
			// Overrides _HasDropDown.closeDropDown().  Closes the drop down (assuming that it's open).
			// This method is the callback when the user types ESC or clicking
			// the button icon while the drop down is open.  It's also called by other code.
			this._abortQuery();
			if(this._opened){
				this.inherited(arguments);
				this.domNode.setAttribute("aria-expanded", "false");
			}
		},

		_setBlurValue: function(){
			// if the user clicks away from the textbox OR tabs away, set the
			// value to the textbox value
			// #4617:
			//		if value is now more choices or previous choices, revert
			//		the value
			var newvalue = this.get('displayedValue');
			var pw = this.dropDown;
			if(pw && (newvalue == pw._messages["previousMessage"] || newvalue == pw._messages["nextMessage"])){
				this._setValueAttr(this._lastValueReported, true);
			}else if(typeof this.item == "undefined"){
				// Update 'value' (ex: KY) according to currently displayed text
				this.item = null;
				this.set('displayedValue', newvalue);
			}else{
				if(this.value != this._lastValueReported){
					this._handleOnChange(this.value, true);
				}
				this._refreshState();
			}
			// Remove aria-activedescendant since it may not be removed if they select with arrows then blur with mouse
			this.focusNode.removeAttribute("aria-activedescendant");
		},

		_setItemAttr: function(/*item*/ item, /*Boolean?*/ priorityChange, /*String?*/ displayedValue){
			// summary:
			//		Set the displayed valued in the input box, and the hidden value
			//		that gets submitted, based on a dojo.data store item.
			// description:
			//		Users shouldn't call this function; they should be calling
			//		set('item', value)
			// tags:
			//		private
			var value = '';
			if(item){
				if(!displayedValue){
					displayedValue = this.store._oldAPI ? // remove getValue() for 2.0 (old dojo.data API)
						this.store.getValue(item, this.searchAttr) : item[this.searchAttr];
				}
				value = this._getValueField() != this.searchAttr ? this.store.getIdentity(item) : displayedValue;
			}
			this.set('value', value, priorityChange, displayedValue, item);
		},

		_announceOption: function(/*Node*/ node){
			// summary:
			//		a11y code that puts the highlighted option in the textbox.
			//		This way screen readers will know what is happening in the
			//		menu.

			if(!node){
				return;
			}
			// pull the text value from the item attached to the DOM node
			var newValue;
			if(node == this.dropDown.nextButton ||
				node == this.dropDown.previousButton){
				newValue = node.innerHTML;
				this.item = undefined;
				this.value = '';
			}else{
				var item = this.dropDown.items[node.getAttribute("item")];
				newValue = (this.store._oldAPI ? // remove getValue() for 2.0 (old dojo.data API)
					this.store.getValue(item, this.searchAttr) : item[this.searchAttr]).toString();
				this.set('item', item, false, newValue);
			}
			// get the text that the user manually entered (cut off autocompleted text)
			this.focusNode.value = this.focusNode.value.substring(0, this._lastInput.length);
			// set up ARIA activedescendant
			this.focusNode.setAttribute("aria-activedescendant", domAttr.get(node, "id"));
			// autocomplete the rest of the option to announce change
			this._autoCompleteText(newValue);
		},

		_selectOption: function(/*DomNode*/ target){
			// summary:
			//		Menu callback function, called when an item in the menu is selected.
			this.closeDropDown();
			if(target){
				this._announceOption(target);
			}
			this._setCaretPos(this.focusNode, this.focusNode.value.length);
			this._handleOnChange(this.value, true);
			// Remove aria-activedescendant since the drop down is no loner visible
			// after closeDropDown() but _announceOption() adds it back in
			this.focusNode.removeAttribute("aria-activedescendant");
		},

		_startSearchAll: function(){
			this._startSearch('');
		},

		_startSearchFromInput: function(){
			this.item = undefined; // undefined means item needs to be set
			this.inherited(arguments);
		},

		_startSearch: function(/*String*/ key){
			// summary:
			//		Starts a search for elements matching key (key=="" means to return all items),
			//		and calls _openResultList() when the search completes, to display the results.
			if(!this.dropDown){
				var popupId = this.id + "_popup",
					dropDownConstructor = lang.isString(this.dropDownClass) ?
						lang.getObject(this.dropDownClass, false) : this.dropDownClass;
				this.dropDown = new dropDownConstructor({
					onChange: lang.hitch(this, this._selectOption),
					id: popupId,
					dir: this.dir,
					textDir: this.textDir
				});
			}
			this._lastInput = key; // Store exactly what was entered by the user.
			this.inherited(arguments);
		},

		_getValueField: function(){
			// summary:
			//		Helper for postMixInProperties() to set this.value based on data inlined into the markup.
			//		Returns the attribute name in the item (in dijit/form/_ComboBoxDataStore) to use as the value.
			return this.searchAttr;
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		postMixInProperties: function(){
			this.inherited(arguments);
			if(!this.store && this.srcNodeRef){
				var srcNodeRef = this.srcNodeRef;
				// if user didn't specify store, then assume there are option tags
				this.store = new DataList({}, srcNodeRef);

				// if there is no value set and there is an option list, set
				// the value to the first value to be consistent with native Select
				// Firefox and Safari set value
				// IE6 and Opera set selectedIndex, which is automatically set
				// by the selected attribute of an option tag
				// IE6 does not set value, Opera sets value = selectedIndex
				if(!("value" in this.params)){
					var item = (this.item = this.store.fetchSelectedItem());
					if(item){
						var valueField = this._getValueField();
						// remove getValue() for 2.0 (old dojo.data API)
						this.value = this.store._oldAPI ? this.store.getValue(item, valueField) : item[valueField];
					}
				}
			}
		},

		postCreate: function(){
			// summary:
			//		Subclasses must call this method from their postCreate() methods
			// tags:
			//		protected

			// find any associated label element and add to ComboBox node.
			var label = query('label[for="' + this.id + '"]');
			if(label.length){
				if(!label[0].id){
					label[0].id = this.id + "_label";
				}
				this.domNode.setAttribute("aria-labelledby", label[0].id);

			}
			this.inherited(arguments);
			aspect.after(this, "onSearch", lang.hitch(this, "_openResultList"), true);
		},

		_getMenuLabelFromItem: function(/*Item*/ item){
			var label = this.labelFunc(item, this.store),
				labelType = this.labelType;
			// If labelType is not "text" we don't want to screw any markup ot whatever.
			if(this.highlightMatch != "none" && this.labelType == "text" && this._lastInput){
				label = this.doHighlight(label, this._lastInput);
				labelType = "html";
			}
			return {html: labelType == "html", label: label};
		},

		doHighlight: function(/*String*/ label, /*String*/ find){
			// summary:
			//		Highlights the string entered by the user in the menu.  By default this
			//		highlights the first occurrence found. Override this method
			//		to implement your custom highlighting.
			// tags:
			//		protected

			var
			// Add (g)lobal modifier when this.highlightMatch == "all" and (i)gnorecase when this.ignoreCase == true
				modifiers = (this.ignoreCase ? "i" : "") + (this.highlightMatch == "all" ? "g" : ""),
				i = this.queryExpr.indexOf("${0}");
			find = regexp.escapeString(find); // escape regexp special chars
			//If < appears in label, and user presses t, we don't want to highlight the t in the escaped "&lt;"
			//first find out every occurrences of "find", wrap each occurrence in a pair of "\uFFFF" characters (which
			//should not appear in any string). then html escape the whole string, and replace '\uFFFF" with the
			//HTML highlight markup.
			return this._escapeHtml(label.replace(
				new RegExp((i == 0 ? "^" : "") + "(" + find + ")" + (i == (this.queryExpr.length - 4) ? "$" : ""), modifiers),
				'\uFFFF$1\uFFFF')).replace(
				/\uFFFF([^\uFFFF]+)\uFFFF/g, '<span class="dijitComboBoxHighlightMatch">$1</span>'
			); // returns String, (almost) valid HTML (entities encoded)
		},

		_escapeHtml: function(/*String*/ str){
			// TODO Should become dojo.html.entities(), when exists use instead
			// summary:
			//		Adds escape sequences for special characters in XML: `&<>"'`
			str = String(str).replace(/&/gm, "&amp;").replace(/</gm, "&lt;")
				.replace(/>/gm, "&gt;").replace(/"/gm, "&quot;"); //balance"
			return str; // string
		},

		reset: function(){
			// Overrides the _FormWidget.reset().
			// Additionally reset the .item (to clean up).
			this.item = null;
			this.inherited(arguments);
		},

		labelFunc: function(item, store){
			// summary:
			//		Computes the label to display based on the dojo.data store item.
			// item: Object
			//		The item from the store
			// store: dojo/store/api/Store
			//		The store.
			// returns:
			//		The label that the ComboBox should display
			// tags:
			//		private

			// Use toString() because XMLStore returns an XMLItem whereas this
			// method is expected to return a String (#9354).
			// Remove getValue() for 2.0 (old dojo.data API)
			return (store._oldAPI ? store.getValue(item, this.labelAttr || this.searchAttr) :
				item[this.labelAttr || this.searchAttr]).toString(); // String
		},

		_setValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange, /*String?*/ displayedValue, /*item?*/ item){
			// summary:
			//		Hook so set('value', value) works.
			// description:
			//		Sets the value of the select.
			this._set("item", item || null); // value not looked up in store
			if(value == null /* or undefined */){
				value = '';
			} // null translates to blank
			this.inherited(arguments);
		}
	});

	if(has("dojo-bidi")){
		AutoCompleterMixin.extend({
			_setTextDirAttr: function(/*String*/ textDir){
				// summary:
				//		Setter for textDir, needed for the dropDown's textDir update.
				// description:
				//		Users shouldn't call this function; they should be calling
				//		set('textDir', value)
				// tags:
				//		private
				this.inherited(arguments);
				// update the drop down also (_ComboBoxMenuMixin)
				if(this.dropDown){
					this.dropDown._set("textDir", textDir);
				}
			}
		});
	}

	return AutoCompleterMixin;
});

},
'dijit/form/DataList':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.byId
	"dojo/_base/lang", // lang.trim
	"dojo/query", // query
	"dojo/store/Memory",
	"../registry"	// registry.add registry.remove
], function(declare, dom, lang, query, MemoryStore, registry){

	// module:
	//		dijit/form/DataList

	function toItem(/*DOMNode*/ option){
		// summary:
		//		Convert `<option>` node to hash
		return {
			id: option.value,
			value: option.value,
			name: lang.trim(option.innerText || option.textContent || '')
		};
	}

	return declare("dijit.form.DataList", MemoryStore, {
		// summary:
		//		Inefficient but small data store specialized for inlined data via OPTION tags
		//
		// description:
		//		Provides a store for inlined data like:
		//
		//	|	<datalist>
		//	|		<option value="AL">Alabama</option>
		//	|		...

		constructor: function(params, srcNodeRef){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String
			//		Attach widget to this DOM node.

			// store pointer to original DOM tree
			this.domNode = dom.byId(srcNodeRef);

			lang.mixin(this, params);
			if(this.id){
				registry.add(this); // add to registry so it can be easily found by id
			}
			this.domNode.style.display = "none";

			this.inherited(arguments, [{
				data: query("option", this.domNode).map(toItem)
			}]);
		},

		destroy: function(){
			registry.remove(this.id);
		},

		fetchSelectedItem: function(){
			// summary:
			//		Get the option marked as selected, like `<option selected>`.
			//		Not part of dojo.data API.
			var option = query("> option[selected]", this.domNode)[0] || query("> option", this.domNode)[0];
			return option && toItem(option);
		}
	});
});

},
'dijit/form/_SearchMixin':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/keys", // keys
	"dojo/_base/lang", // lang.clone lang.hitch
	"dojo/query", // query
	"dojo/string", // string.substitute
	"dojo/when",
	"../registry"	// registry.byId
], function(declare, keys, lang, query, string, when, registry){

	// module:
	//		dijit/form/_SearchMixin


	return declare("dijit.form._SearchMixin", null, {
		// summary:
		//		A mixin that implements the base functionality to search a store based upon user-entered text such as
		//		with `dijit/form/ComboBox` or `dijit/form/FilteringSelect`
		// tags:
		//		protected

		// pageSize: Integer
		//		Argument to data provider.
		//		Specifies maximum number of search results to return per query
		pageSize: Infinity,

		// store: [const] dojo/store/api/Store
		//		Reference to data provider object used by this ComboBox.
		//		The store must accept an object hash of properties for its query. See `query` and `queryExpr` for details.
		store: null,

		// fetchProperties: Object
		//		Mixin to the store's fetch.
		//		For example, to set the sort order of the ComboBox menu, pass:
		//	|	{ sort: [{attribute:"name",descending: true}] }
		//		To override the default queryOptions so that deep=false, do:
		//	|	{ queryOptions: {ignoreCase: true, deep: false} }
		fetchProperties:{},

		// query: Object
		//		A query that can be passed to `store` to initially filter the items.
		//		ComboBox overwrites any reference to the `searchAttr` and sets it to the `queryExpr` with the user's input substituted.
		query: {},

		// list: [const] String
		//		Alternate to specifying a store.  Id of a dijit/form/DataList widget.
		list: "",
		_setListAttr: function(list){
			// Avoid having list applied to the DOM node, since it has native meaning in modern browsers
			this._set("list", list);
		},

		// searchDelay: Integer
		//		Delay in milliseconds between when user types something and we start
		//		searching based on that value
		searchDelay: 200,

		// searchAttr: String
		//		Search for items in the data store where this attribute (in the item)
		//		matches what the user typed
		searchAttr: "name",

		// queryExpr: String
		//		This specifies what query is sent to the data store,
		//		based on what the user has typed.  Changing this expression will modify
		//		whether the results are only exact matches, a "starting with" match,
		//		etc.
		//		`${0}` will be substituted for the user text.
		//		`*` is used for wildcards.
		//		`${0}*` means "starts with", `*${0}*` means "contains", `${0}` means "is"
		queryExpr: "${0}*",

		// ignoreCase: Boolean
		//		Set true if the query should ignore case when matching possible items
		ignoreCase: true,

		_patternToRegExp: function(pattern){
			// summary:
			//		Helper function to convert a simple pattern to a regular expression for matching.
			// description:
			//		Returns a regular expression object that conforms to the defined conversion rules.
			//		For example:
			//
			//		- ca*   -> /^ca.*$/
			//		- *ca*  -> /^.*ca.*$/
			//		- *c\*a*  -> /^.*c\*a.*$/
			//		- *c\*a?*  -> /^.*c\*a..*$/
			//
			//		and so on.
			// pattern: string
			//		A simple matching pattern to convert that follows basic rules:
			//
			//		- * Means match anything, so ca* means match anything starting with ca
			//		- ? Means match single character.  So, b?b will match to bob and bab, and so on.
			//		- \ is an escape character.  So for example, \* means do not treat * as a match, but literal character *.
			//
			//		To use a \ as a character in the string, it must be escaped.  So in the pattern it should be
			//		represented by \\ to be treated as an ordinary \ character instead of an escape.

			return new RegExp("^" + pattern.replace(/(\\.)|(\*)|(\?)|\W/g, function(str, literal, star, question){
				return star ? ".*" : question ? "." : literal ? literal : "\\" + str;
			}) + "$", this.ignoreCase ? "mi" : "m");
		},

		_abortQuery: function(){
			// stop in-progress query
			if(this.searchTimer){
				this.searchTimer = this.searchTimer.remove();
			}
			if(this._queryDeferHandle){
				this._queryDeferHandle = this._queryDeferHandle.remove();
			}
			if(this._fetchHandle){
				if(this._fetchHandle.abort){
					this._cancelingQuery = true;
					this._fetchHandle.abort();
					this._cancelingQuery = false;
				}
				if(this._fetchHandle.cancel){
					this._cancelingQuery = true;
					this._fetchHandle.cancel();
					this._cancelingQuery = false;
				}
				this._fetchHandle = null;
			}
		},

		_processInput: function(/*Event*/ evt){
			// summary:
			//		Handles input (keyboard/paste) events
			if(this.disabled || this.readOnly){ return; }
			var key = evt.charOrCode;

			// except for cutting/pasting case - ctrl + x/v
			if("type" in evt && evt.type.substring(0,3) == "key" && (evt.altKey || ((evt.ctrlKey || evt.metaKey) && (key != 'x' && key != 'v')) || key == keys.SHIFT)){
				return; // throw out weird key combinations and spurious events
			}

			var doSearch = false;
			this._prev_key_backspace = false;

			switch(key){
				case keys.DELETE:
				case keys.BACKSPACE:
					this._prev_key_backspace = true;
					this._maskValidSubsetError = true;
					doSearch = true;
					break;

				default:
					// Non char keys (F1-F12 etc..) shouldn't start a search..
					// Ascii characters and IME input (Chinese, Japanese etc.) should.
					//IME input produces keycode == 229.
					doSearch = typeof key == 'string' || key == 229;
			}
			if(doSearch){
				// need to wait a tad before start search so that the event
				// bubbles through DOM and we have value visible
				if(!this.store){
					this.onSearch();
				}else{
					this.searchTimer = this.defer("_startSearchFromInput", 1);
				}
			}
		},

		onSearch: function(/*===== results, query, options =====*/){
			// summary:
			//		Callback when a search completes.
			//
			// results: Object
			//		An array of items from the originating _SearchMixin's store.
			//
			// query: Object
			//		A copy of the originating _SearchMixin's query property.
			//
			// options: Object
			//		The additional parameters sent to the originating _SearchMixin's store, including: start, count, queryOptions.
			//
			// tags:
			//		callback
		},

		_startSearchFromInput: function(){
			this._startSearch(this.focusNode.value);
		},

		_startSearch: function(/*String*/ text){
			// summary:
			//		Starts a search for elements matching text (text=="" means to return all items),
			//		and calls onSearch(...) when the search completes, to display the results.

			this._abortQuery();
			var
				_this = this,
				// Setup parameters to be passed to store.query().
				// Create a new query to prevent accidentally querying for a hidden
				// value from FilteringSelect's keyField
				query = lang.clone(this.query), // #5970
				options = {
					start: 0,
					count: this.pageSize,
					queryOptions: {		// remove for 2.0
						ignoreCase: this.ignoreCase,
						deep: true
					}
				},
				qs = string.substitute(this.queryExpr, [text.replace(/([\\\*\?])/g, "\\$1")]),
				q,
				startQuery = function(){
					var resPromise = _this._fetchHandle = _this.store.query(query, options);
					if(_this.disabled || _this.readOnly || (q !== _this._lastQuery)){
						return;
					} // avoid getting unwanted notify
					when(resPromise, function(res){
						_this._fetchHandle = null;
						if(!_this.disabled && !_this.readOnly && (q === _this._lastQuery)){ // avoid getting unwanted notify
							when(resPromise.total, function(total){
								res.total = total;
								var pageSize = _this.pageSize;
								if(isNaN(pageSize) || pageSize > res.total){ pageSize = res.total; }
								// Setup method to fetching the next page of results
								res.nextPage = function(direction){
									//	tell callback the direction of the paging so the screen
									//	reader knows which menu option to shout
									options.direction = direction = direction !== false;
									options.count = pageSize;
									if(direction){
										options.start += res.length;
										if(options.start >= res.total){
											options.count = 0;
										}
									}else{
										options.start -= pageSize;
										if(options.start < 0){
											options.count = Math.max(pageSize + options.start, 0);
											options.start = 0;
										}
									}
									if(options.count <= 0){
										res.length = 0;
										_this.onSearch(res, query, options);
									}else{
										startQuery();
									}
								};
								_this.onSearch(res, query, options);
							});
						}
					}, function(err){
						_this._fetchHandle = null;
						if(!_this._cancelingQuery){	// don't treat canceled query as an error
							console.error(_this.declaredClass + ' ' + err.toString());
						}
					});
				};

			lang.mixin(options, this.fetchProperties);

			// Generate query
			if(this.store._oldAPI){
				// remove this branch for 2.0
				q = qs;
			}else{
				// Query on searchAttr is a regex for benefit of dojo/store/Memory,
				// but with a toString() method to help dojo/store/JsonRest.
				// Search string like "Co*" converted to regex like /^Co.*$/i.
				q = this._patternToRegExp(qs);
				q.toString = function(){ return qs; };
			}

			// set _lastQuery, *then* start the timeout
			// otherwise, if the user types and the last query returns before the timeout,
			// _lastQuery won't be set and their input gets rewritten
			this._lastQuery = query[this.searchAttr] = q;
			this._queryDeferHandle = this.defer(startQuery, this.searchDelay);
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		constructor: function(){
			this.query={};
			this.fetchProperties={};
		},

		postMixInProperties: function(){
			if(!this.store){
				var list = this.list;
				if(list){
					this.store = registry.byId(list);
				}
			}
			this.inherited(arguments);
		}
	});
});

},
'dijit/form/_ComboBoxMenu':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.remove
	"dojo/dom-style", // domStyle.get
	"dojo/keys", // keys.DOWN_ARROW keys.PAGE_DOWN keys.PAGE_UP keys.UP_ARROW
	"../_WidgetBase",
	"../_TemplatedMixin",
	"./_ComboBoxMenuMixin",
	"./_ListMouseMixin"
], function(declare, domClass, domStyle, keys,
			_WidgetBase, _TemplatedMixin, _ComboBoxMenuMixin, _ListMouseMixin){


	// module:
	//		dijit/form/_ComboBoxMenu

	return declare("dijit.form._ComboBoxMenu",[_WidgetBase, _TemplatedMixin, _ListMouseMixin, _ComboBoxMenuMixin], {
		// summary:
		//		Focus-less menu for internal use in `dijit/form/ComboBox`
		//		Abstract methods that must be defined externally:
		//
		//		- onChange: item was explicitly chosen (mousedown somewhere on the menu and mouseup somewhere on the menu)
		//		- onPage: next(1) or previous(-1) button pressed
		// tags:
		//		private

		// TODO for 2.0 or earlier: stop putting stuff inside this.containerNode.   Switch to using this.domNode
		// or a different attach point.    See _TemplatedMixin::searchContainerNode.
		templateString: "<div class='dijitReset dijitMenu' data-dojo-attach-point='containerNode' style='overflow: auto; overflow-x: hidden;' role='listbox'>"
				+"<div class='dijitMenuItem dijitMenuPreviousButton' data-dojo-attach-point='previousButton' role='option'></div>"
				+"<div class='dijitMenuItem dijitMenuNextButton' data-dojo-attach-point='nextButton' role='option'></div>"
				+"</div>",

		baseClass: "dijitComboBoxMenu",

		postCreate: function(){
			this.inherited(arguments);
			if(!this.isLeftToRight()){
				domClass.add(this.previousButton, "dijitMenuItemRtl");
				domClass.add(this.nextButton, "dijitMenuItemRtl");
			}
			this.containerNode.setAttribute("role","listbox");
		},

		_createMenuItem: function(){
			// note: not using domConstruct.create() because need to specify document
			var item = this.ownerDocument.createElement("div");
			item.className = "dijitReset dijitMenuItem" +(this.isLeftToRight() ? "" : " dijitMenuItemRtl");
			item.setAttribute("role", "option");
			return item;
		},

		onHover: function(/*DomNode*/ node){
			// summary:
			//		Add hover CSS
			domClass.add(node, "dijitMenuItemHover");
		},

		onUnhover: function(/*DomNode*/ node){
			// summary:
			//		Remove hover CSS
			domClass.remove(node, "dijitMenuItemHover");
		},

		onSelect: function(/*DomNode*/ node){
			// summary:
			//		Add selected CSS
			domClass.add(node, "dijitMenuItemSelected");
		},

		onDeselect: function(/*DomNode*/ node){
			// summary:
			//		Remove selected CSS
			domClass.remove(node, "dijitMenuItemSelected");
		},

		_page: function(/*Boolean*/ up){
			// summary:
			//		Handles page-up and page-down keypresses

			var scrollamount = 0;
			var oldscroll = this.domNode.scrollTop;
			var height = domStyle.get(this.domNode, "height");
			// if no item is highlighted, highlight the first option
			if(!this.getHighlightedOption()){
				this.selectNextNode();
			}
			while(scrollamount<height){
				var highlighted_option = this.getHighlightedOption();
				if(up){
					// stop at option 1
					if(!highlighted_option.previousSibling ||
						highlighted_option.previousSibling.style.display == "none"){
						break;
					}
					this.selectPreviousNode();
				}else{
					// stop at last option
					if(!highlighted_option.nextSibling ||
						highlighted_option.nextSibling.style.display == "none"){
						break;
					}
					this.selectNextNode();
				}
				// going backwards
				var newscroll = this.domNode.scrollTop;
				scrollamount += (newscroll-oldscroll)*(up ? -1:1);
				oldscroll = newscroll;
			}
		},

		handleKey: function(evt){
			// summary:
			//		Handle keystroke event forwarded from ComboBox, returning false if it's
			//		a keystroke I recognize and process, true otherwise.
			switch(evt.keyCode){
				case keys.DOWN_ARROW:
					this.selectNextNode();
					return false;
				case keys.PAGE_DOWN:
					this._page(false);
					return false;
				case keys.UP_ARROW:
					this.selectPreviousNode();
					return false;
				case keys.PAGE_UP:
					this._page(true);
					return false;
				default:
					return true;
			}
		}
	});
});

},
'dijit/form/_ComboBoxMenuMixin':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/has",
	"dojo/i18n", // i18n.getLocalization
	"dojo/i18n!./nls/ComboBox"
], function(array, declare, domAttr, has, i18n){

	// module:
	//		dijit/form/_ComboBoxMenuMixin

	var ComboBoxMenuMixin = declare("dijit.form._ComboBoxMenuMixin" + (has("dojo-bidi") ? "_NoBidi" : ""), null, {
		// summary:
		//		Focus-less menu for internal use in `dijit/form/ComboBox`
		// tags:
		//		private

		// _messages: Object
		//		Holds "next" and "previous" text for paging buttons on drop down
		_messages: null,

		postMixInProperties: function(){
			this.inherited(arguments);
			this._messages = i18n.getLocalization("dijit.form", "ComboBox", this.lang);
		},

		buildRendering: function(){
			this.inherited(arguments);

			// fill in template with i18n messages
			this.previousButton.innerHTML = this._messages["previousMessage"];
			this.nextButton.innerHTML = this._messages["nextMessage"];
		},

		_setValueAttr: function(/*Object*/ value){
			this._set("value", value);
			this.onChange(value);
		},

		onClick: function(/*DomNode*/ node){
			if(node == this.previousButton){
				this._setSelectedAttr(null);
				this.onPage(-1);
			}else if(node == this.nextButton){
				this._setSelectedAttr(null);
				this.onPage(1);
			}else{
				this.onChange(node);
			}
		},

		// stubs
		onChange: function(/*Number*/ /*===== direction =====*/){
			// summary:
			//		Notifies ComboBox/FilteringSelect that user selected an option.
			// tags:
			//		callback
		},

		onPage: function(/*Number*/ /*===== direction =====*/){
			// summary:
			//		Notifies ComboBox/FilteringSelect that user clicked to advance to next/previous page.
			// tags:
			//		callback
		},

		onClose: function(){
			// summary:
			//		Callback from dijit.popup code to this widget, notifying it that it closed
			// tags:
			//		private
			this._setSelectedAttr(null);
		},

		_createOption: function(/*Object*/ item, labelFunc){
			// summary:
			//		Creates an option to appear on the popup menu subclassed by
			//		`dijit/form/FilteringSelect`.

			var menuitem = this._createMenuItem();
			var labelObject = labelFunc(item);
			if(labelObject.html){
				menuitem.innerHTML = labelObject.label;
			}else{
				menuitem.appendChild(
					menuitem.ownerDocument.createTextNode(labelObject.label)
				);
			}
			// #3250: in blank options, assign a normal height
			if(menuitem.innerHTML == ""){
				menuitem.innerHTML = "&#160;";	// &nbsp;
			}

			return menuitem;
		},

		createOptions: function(results, options, labelFunc){
			// summary:
			//		Fills in the items in the drop down list
			// results:
			//		Array of items
			// options:
			//		The options to the query function of the store
			//
			// labelFunc:
			//		Function to produce a label in the drop down list from a dojo.data item

			this.items = results;

			// display "Previous . . ." button
			this.previousButton.style.display = (options.start == 0) ? "none" : "";
			domAttr.set(this.previousButton, "id", this.id + "_prev");
			// create options using _createOption function defined by parent
			// ComboBox (or FilteringSelect) class
			// #2309:
			//		iterate over cache nondestructively
			array.forEach(results, function(item, i){
				var menuitem = this._createOption(item, labelFunc);
				menuitem.setAttribute("item", i);	// index to this.items; use indirection to avoid mem leak
				domAttr.set(menuitem, "id", this.id + i);
				this.nextButton.parentNode.insertBefore(menuitem, this.nextButton);
			}, this);
			// display "Next . . ." button
			var displayMore = false;
			// Try to determine if we should show 'more'...
			if(results.total && !results.total.then && results.total != -1){
				if((options.start + options.count) < results.total){
					displayMore = true;
				}else if((options.start + options.count) > results.total && options.count == results.length){
					// Weird return from a data store, where a start + count > maxOptions
					// implies maxOptions isn't really valid and we have to go into faking it.
					// And more or less assume more if count == results.length
					displayMore = true;
				}
			}else if(options.count == results.length){
				//Don't know the size, so we do the best we can based off count alone.
				//So, if we have an exact match to count, assume more.
				displayMore = true;
			}

			this.nextButton.style.display = displayMore ? "" : "none";
			domAttr.set(this.nextButton, "id", this.id + "_next");
		},

		clearResultList: function(){
			// summary:
			//		Clears the entries in the drop down list, but of course keeps the previous and next buttons.
			var container = this.containerNode;
			while(container.childNodes.length > 2){
				container.removeChild(container.childNodes[container.childNodes.length - 2]);
			}
			this._setSelectedAttr(null);
		},

		highlightFirstOption: function(){
			// summary:
			//		Highlight the first real item in the list (not Previous Choices).
			this.selectFirstNode();
		},

		highlightLastOption: function(){
			// summary:
			//		Highlight the last real item in the list (not More Choices).
			this.selectLastNode();
		},

		selectFirstNode: function(){
			this.inherited(arguments);
			if(this.getHighlightedOption() == this.previousButton){
				this.selectNextNode();
			}
		},

		selectLastNode: function(){
			this.inherited(arguments);
			if(this.getHighlightedOption() == this.nextButton){
				this.selectPreviousNode();
			}
		},

		getHighlightedOption: function(){
			return this.selected;
		}
	});

	if(has("dojo-bidi")){
		ComboBoxMenuMixin = declare("dijit.form._ComboBoxMenuMixin", ComboBoxMenuMixin, {
			_createOption: function(){
				var menuitem = this.inherited(arguments);

				// update menuitem.dir if BidiSupport was required
				this.applyTextDir(menuitem);

				return menuitem;
			}
		});
	}

	return ComboBoxMenuMixin;
});

},
'Sage/Utility/Sql':function(){
/*globals Sage, dojo*/
define([
        'dojo/_base/array',
        'dojo/_base/declare',
        'dojo/_base/lang',
        'dojo/i18n!./nls/Sql'  
    ],
    function (array, declare, lang, nls) {
        var oSqlUtility = declare('Sage.Utility.Sql', null, {
            _allQuotesReg: null,
            _badQuotesReg: null,
            _closingQuotesReg: null,
            _normalQuotesReg: null,
            _openingQuotesReg: null,
            _selectInClauseReg: null,
            _closingQuotes: ["'", '', '', '\u2019'],
            _openingQuotes: ["'", '`', '', '\u2018'],
            resources: nls,
            quoteType: {
                apostrophe: 0,
                accent: 1,
                curly: 2,
                unicode: 3
            },
            constructor: function () {
                this.inherited(arguments);
                this._allQuotesReg = new RegExp('[\'`\u2018\u2019]');
                this._badQuotesReg = new RegExp('[`\u2018\u2019]');
                this._closingQuotesReg = new RegExp('[\'\u2019]');
                this._normalQuotesReg = new RegExp('\'');
                this._openingQuotesReg = new RegExp('[\'`\u2018]');
            },
            fixQuoted: function (value) {
                var temp = value;
                if (value && lang.isString(value) && value.length > 0) {
                    if (this._badQuotesReg.test(temp)) {
                        temp = this.removeBadOuterQuotes(temp);
                    }
                    if (this._normalQuotesReg.test(temp)) {
                        // Check if there is an opening quote.
                        var ch = temp.charAt(0);
                        if (this._normalQuotesReg.test(ch)) {
                            // Remove the opening quote.
                            temp = temp.substr(1, temp.length - 1);
                        }
                        if (temp === '') return '';
                        // Check if there is a closing quote.
                        ch = temp.charAt(temp.length - 1);
                        if (this._normalQuotesReg.test(ch)) {
                            // Remove the closing quote.
                            temp = temp.substr(0, temp.length - 1);
                        }
                    }
                } else {
                    return "''";
                }
                return "'" + temp + "'";
            },
            fixQuotes: function (values) {
                if (values && lang.isArray(values)) {
                    array.forEach(values, function (value, idx) {
                        values[idx] = this.fixQuoted(value);
                    }, this);
                    return values.join(',');
                }
                return false;
            },
            fixInClause: function (inClause) {
                var empty = "('')";
                if (inClause && typeof inClause !== 'undefined' && lang.isString(inClause) === false) {
                    if (lang.isArray(inClause)) {
                        inClause = "'" + inClause.toString().replace(/,/g, "','") + "'";
                    } else {
                        inClause = "'" + inClause.toString() + "'";
                    }
                }
                var temp;
                if (inClause && lang.isString(inClause) && lang.trim(inClause).length > 0) {
                    if (this.hasValidApostropheQuoteCount(inClause) === false) {
                        throw new Error(this.resources.InvalidApostropheCount);
                    }
                    temp = inClause
                        .replace(/\r\n/g, ' ')
                        .replace(/\n/g, ' ')
                        .replace(/\r/g, ' ')
                        .trim();
                    if (temp === '') return empty;
                    if (this._badQuotesReg.test(temp)) {
                        if (temp.charAt(0) === '(' && temp.charAt(temp.length - 1) === ')') {
                            temp = temp.substr(1, temp.length - 1);
                            temp = temp.substr(0, temp.length - 1);
                        }
                        if (temp === '') return empty;
                        var isSelect = temp.toUpperCase().indexOf('SELECT') === 0;
                        if (isSelect) {
                            var inQuote = false;
                            var currentOpenQuoteType = -1;
                            var replacePositions = [];
                            for (var i = 0; i < temp.length; i++) {
                                var ch = temp.charAt(i);
                                if (inQuote === false) {
                                    // Look for an opening quote
                                    if (this._openingQuotesReg.test(ch)) {
                                        inQuote = true;
                                        switch (ch) {
                                            case "'":
                                                currentOpenQuoteType = this.quoteType.apostrophe;
                                                break;
                                            case '`':
                                                currentOpenQuoteType = this.quoteType.accent;
                                                replacePositions.push(i);
                                                break;
                                            case '':
                                                currentOpenQuoteType = this.quoteType.curly;
                                                replacePositions.push(i);
                                                break;
                                            case '\u2018':
                                                currentOpenQuoteType = this.quoteType.unicode;
                                                replacePositions.push(i);
                                                break;
                                        }
                                    }
                                } else {
                                    // We're in a quote, so find a closing quote
                                    if (this._closingQuotesReg.test(ch)) {
                                        var closingQuoteType = this.translateQuoteType(ch);
                                        if (closingQuoteType == -1) continue;
                                        if (currentOpenQuoteType == closingQuoteType) {
                                            inQuote = false;
                                            switch (currentOpenQuoteType) {
                                                case this.quoteType.accent:
                                                case this.quoteType.curly:
                                                case this.quoteType.unicode:
                                                    replacePositions.push(i);
                                                    break;
                                            }
                                            currentOpenQuoteType = -1;
                                        }
                                    }
                                }
                            }
                            // Replace any bad quotes with apostrophes
                            if (replacePositions && lang.isArray(replacePositions) && replacePositions.length > 0) {
                                array.forEach(replacePositions, function (position) {
                                    temp = temp.substr(0, position) + "'" + temp.substr(position + 1);
                                });
                            }
                            if (typeof console !== 'undefined') {
                                console.debug('fixInClause #1');
                            }
                            if (this.hasValidApostropheQuoteCount(temp) === false) {
                                throw new Error(this.resources.InvalidApostropheCount);
                            }                            
                            return '(' + temp + ')';

                        } else {
                            // We have a single string value, that is not a SELECT, or we have a delimited list of string values.
                            var values = temp.split(',');
                            array.forEach(values, function (value, idx) {
                                values[idx] = value.trim();
                            });
                            var fixed = this.fixQuotes(values);
                            if (fixed) {
                                if (typeof console !== 'undefined') {
                                    console.debug('fixInClause #2');
                                }
                                if (this.hasValidApostropheQuoteCount(fixed) === false) {
                                    throw new Error(this.resources.InvalidApostropheCount);
                                }                                 
                                return '(' + fixed + ')';
                            }
                            if (typeof console !== 'undefined') {
                                console.debug('fixInClause #3');
                            }
                            return empty;
                        }
                    } else {
                        if (temp.charAt(0) != '(') {
                            if (typeof console !== 'undefined') {
                                console.debug('fixInClause #4');
                            }
                            return '(' + temp + ')';
                        }
                        if (typeof console !== 'undefined') {
                            console.debug('fixInClause #5');
                        }
                        return temp;
                    }
                } else {
                    if (inClause && lang.isString(inClause)) {
                        // The inClause is composed entirely of empty spaces or CrLf.
                        temp = inClause
                            .replace(/\r\n/g, '')
                            .replace(/\n/g, '')
                            .replace(/\r/g, ''); // Do [not] trim; since we must allow search for spaces.
                        if (temp.length > 0) {
                            if (typeof console !== 'undefined') {
                                console.debug('fixInClause #6');
                            }
                            return '(\'' + temp + '\')';
                        }
                        if (typeof console !== 'undefined') {
                            console.debug('fixInClause #7');
                        }
                        return empty;
                    }
                }
                // Return null or undefined
                if (typeof console !== 'undefined') {
                    console.debug('fixInClause #8');
                }
                return inClause;
            },
            hasBadOuterQuotes: function (value) {
                if (value && lang.isString(value) && value.length > 0) {
                    if (this._badQuotesReg.test(value)) {
                        var ch = value.charAt(0);
                        if (this._badQuotesReg.test(ch)) {
                            return true;
                        }
                        ch = value.charAt(value.length - 1);
                        if (this._badQuotesReg.test(ch)) {
                            return true;
                        }
                    }
                }
                return false;
            },
            hasValidApostropheQuoteCount: function (value) {
                if (value && lang.isString(value) && value.length > 0) {
                    if (this._normalQuotesReg.test(value)) {
                        var matches = value.match(/'/g);
                        if (matches && lang.isArray(matches) && matches.length > 0) {
                            return (matches.length % 2) === 0;
                        }
                    }
                }
                // 0 is a valid count
                return true;
            },
            removeBadOuterQuotes: function (value) {
                if (this.hasBadOuterQuotes(value)) {
                    var temp = value;
                    // Check if there is an opening bad quote.
                    var ch = temp.charAt(0);
                    if (this._badQuotesReg.test(ch)) {
                        // Remove the opening bad quote.
                        temp = temp.substr(1, temp.length - 1);
                    }
                    if (temp === '') return '';
                    // Check if there is a closing bad quote.
                    ch = temp.charAt(temp.length - 1);
                    if (this._badQuotesReg.test(ch)) {
                        // Remove the closing bad quote.
                        temp = temp.substr(0, temp.length - 1);
                    }
                    return temp;
                }
                return value;
            },
            replaceQuotesAroundValues: function (value) {
                if (value && lang.isString(value) && value.length > 0) {
                    var temp = value;
                    array.forEach([/`(.*?)/g, /(.*?)/g, /\u2018(.*?)\u2019/g], function (reg) {
                        var matches = temp.match(reg);
                        array.forEach(matches, function (match) {
                            if (match.length == 2) {
                                temp = temp.replace(match, "''");
                            } else {
                                var replacement = match.substr(1, match.length - 1);
                                replacement = replacement.substr(0, replacement.length - 1);
                                temp = temp.replace(match, "'" + replacement + "'");
                            }
                        });
                        return temp;
                    });
                }
                return value;
            },
            translateQuoteType: function (ch) {
                if (ch && lang.isString(ch) && ch.length == 1 && this._allQuotesReg.test(ch)) {
                    switch (ch) {
                        case "'":
                            return this.quoteType.apostrophe;
                        case '`':
                        case '':
                            return this.quoteType.accent;
                        case '':
                        case '':
                            return this.quoteType.curly;
                        case '\u2018':
                        case '\u2019':
                            return this.quoteType.unicode;
                    }
                }
                return -1;
            }
        });

        return oSqlUtility;
    });


},
'dijit/CheckedMenuItem':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.toggle
	"./MenuItem",
	"dojo/text!./templates/CheckedMenuItem.html",
	"./hccss"
], function(declare, domClass, MenuItem, template){

	// module:
	//		dijit/CheckedMenuItem

	return declare("dijit.CheckedMenuItem", MenuItem, {
		// summary:
		//		A checkbox-like menu item for toggling on and off

		// Use both base classes so we get styles like dijitMenuItemDisabled
		baseClass: "dijitMenuItem dijitCheckedMenuItem",

		templateString: template,

		// checked: Boolean
		//		Our checked state
		checked: false,
		_setCheckedAttr: function(/*Boolean*/ checked){
			this.domNode.setAttribute("aria-checked", checked ? "true" : "false");
			this._set("checked", checked);	// triggers CSS update via _CssStateMixin
		},

		iconClass: "",	// override dijitNoIcon

		role: "menuitemcheckbox",

		// checkedChar: String
		//		Character (or string) used in place of checkbox icon when display in high contrast mode
		checkedChar: "&#10003;",

		onChange: function(/*Boolean*/ /*===== checked =====*/){
			// summary:
			//		User defined function to handle check/uncheck events
			// tags:
			//		callback
		},

		_onClick: function(evt){
			// summary:
			//		Clicking this item just toggles its state
			// tags:
			//		private
			if(!this.disabled){
				this.set("checked", !this.checked);
				this.onChange(this.checked);
			}
			this.onClick(evt);
		}
	});
});

},
'dijit/MenuItem':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-class", // domClass.toggle
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/sniff", // has("ie")
	"dojo/_base/lang", // lang.hitch
	"./_Widget",
	"./_TemplatedMixin",
	"./_Contained",
	"./_CssStateMixin",
	"dojo/text!./templates/MenuItem.html"
], function(declare, dom, domAttr, domClass, kernel, has, lang,
			_Widget, _TemplatedMixin, _Contained, _CssStateMixin, template){

	// module:
	//		dijit/MenuItem

	var MenuItem = declare("dijit.MenuItem" + (has("dojo-bidi") ? "_NoBidi" : ""),
		[_Widget, _TemplatedMixin, _Contained, _CssStateMixin], {
		// summary:
		//		A line item in a Menu Widget

		// Make 3 columns
		// icon, label, and expand arrow (BiDi-dependent) indicating sub-menu
		templateString: template,

		baseClass: "dijitMenuItem",

		// label: String
		//		Menu text as HTML
		label: "",
		_setLabelAttr: function(val){
			this._set("label", val);
			var shortcutKey = "";
			var text;
			var ndx = val.search(/{\S}/);
			if(ndx >= 0){
				shortcutKey = val.charAt(ndx + 1);
				var prefix = val.substr(0, ndx);
				var suffix = val.substr(ndx + 3);
				text = prefix + shortcutKey + suffix;
				val = prefix + '<span class="dijitMenuItemShortcutKey">' + shortcutKey + '</span>' + suffix;
			}else{
				text = val;
			}
			this.domNode.setAttribute("aria-label", text + " " + this.accelKey);
			this.containerNode.innerHTML = val;
			this._set('shortcutKey', shortcutKey);
		},

		/*=====
		// shortcutKey: [readonly] String
		//		Single character (underlined when the parent Menu is focused) used to navigate directly to this widget,
		//		also known as [a mnemonic](http://en.wikipedia.org/wiki/Mnemonics_(keyboard%29).
		//		This is denoted in the label by surrounding the single character with {}.
		//		For example, if label="{F}ile", then shortcutKey="F".
		shortcutKey: "",
		=====*/

		// iconClass: String
		//		Class to apply to DOMNode to make it display an icon.
		iconClass: "dijitNoIcon",
		_setIconClassAttr: { node: "iconNode", type: "class" },

		// accelKey: String
		//		Text for the accelerator (shortcut) key combination, a control, alt, etc. modified keystroke meant to
		//		execute the menu item regardless of where the focus is on the page.
		//
		//		Note that although Menu can display accelerator keys, there is no infrastructure to actually catch and
		//		execute those accelerators.
		accelKey: "",

		// disabled: Boolean
		//		If true, the menu item is disabled.
		//		If false, the menu item is enabled.
		disabled: false,

		_fillContent: function(/*DomNode*/ source){
			// If button label is specified as srcNodeRef.innerHTML rather than
			// this.params.label, handle it here.
			if(source && !("label" in this.params)){
				this._set('label', source.innerHTML);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);
			var label = this.id + "_text";
			domAttr.set(this.containerNode, "id", label); // only needed for backward compat
			if(this.accelKeyNode){
				domAttr.set(this.accelKeyNode, "id", this.id + "_accel"); // only needed for backward compat
			}
			dom.setSelectable(this.domNode, false);
		},

		onClick: function(/*Event*/){
			// summary:
			//		User defined function to handle clicks
			// tags:
			//		callback
		},

		focus: function(){
			// summary:
			//		Focus on this MenuItem
			try{
				if(has("ie") == 8){
					// needed for IE8 which won't scroll TR tags into view on focus yet calling scrollIntoView creates flicker (#10275)
					this.containerNode.focus();
				}
				this.focusNode.focus();
			}catch(e){
				// this throws on IE (at least) in some scenarios
			}
		},

		_setSelected: function(selected){
			// summary:
			//		Indicate that this node is the currently selected one
			// tags:
			//		private

			domClass.toggle(this.domNode, "dijitMenuItemSelected", selected);
		},

		setLabel: function(/*String*/ content){
			// summary:
			//		Deprecated.   Use set('label', ...) instead.
			// tags:
			//		deprecated
			kernel.deprecated("dijit.MenuItem.setLabel() is deprecated.  Use set('label', ...) instead.", "", "2.0");
			this.set("label", content);
		},

		setDisabled: function(/*Boolean*/ disabled){
			// summary:
			//		Deprecated.   Use set('disabled', bool) instead.
			// tags:
			//		deprecated
			kernel.deprecated("dijit.Menu.setDisabled() is deprecated.  Use set('disabled', bool) instead.", "", "2.0");
			this.set('disabled', disabled);
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			// summary:
			//		Hook for attr('disabled', ...) to work.
			//		Enable or disable this menu item.

			this.focusNode.setAttribute('aria-disabled', value ? 'true' : 'false');
			this._set("disabled", value);
		},

		_setAccelKeyAttr: function(/*String*/ value){
			// summary:
			//		Hook for attr('accelKey', ...) to work.
			//		Set accelKey on this menu item.

			if(this.accelKeyNode){
				this.accelKeyNode.style.display = value ? "" : "none";
				this.accelKeyNode.innerHTML = value;
				//have to use colSpan to make it work in IE
				domAttr.set(this.containerNode, 'colSpan', value ? "1" : "2");
			}
			this._set("accelKey", value);
		}
	});

	if(has("dojo-bidi")){
		MenuItem = declare("dijit.MenuItem", MenuItem, {
			_setLabelAttr: function(val){
				this.inherited(arguments);
				if(this.textDir === "auto"){
					this.applyTextDir(this.textDirNode);
				}
			}
		});
	}

	return MenuItem;
});

},
'dijit/_Contained':function(){
define([
	"dojo/_base/declare", // declare
	"./registry"	// registry.getEnclosingWidget(), registry.byNode()
], function(declare, registry){

	// module:
	//		dijit/_Contained

	return declare("dijit._Contained", null, {
		// summary:
		//		Mixin for widgets that are children of a container widget
		// example:
		//	|	// make a basic custom widget that knows about its parents
		//	|	declare("my.customClass",[dijit._WidgetBase, dijit._Contained],{});

		_getSibling: function(/*String*/ which){
			// summary:
			//		Returns next or previous sibling
			// which:
			//		Either "next" or "previous"
			// tags:
			//		private
			var node = this.domNode;
			do{
				node = node[which+"Sibling"];
			}while(node && node.nodeType != 1);
			return node && registry.byNode(node);	// dijit/_WidgetBase
		},

		getPreviousSibling: function(){
			// summary:
			//		Returns null if this is the first child of the parent,
			//		otherwise returns the next element sibling to the "left".

			return this._getSibling("previous"); // dijit/_WidgetBase
		},

		getNextSibling: function(){
			// summary:
			//		Returns null if this is the last child of the parent,
			//		otherwise returns the next element sibling to the "right".

			return this._getSibling("next"); // dijit/_WidgetBase
		},

		getIndexInParent: function(){
			// summary:
			//		Returns the index of this widget within its container parent.
			//		It returns -1 if the parent does not exist, or if the parent
			//		is not a dijit/_Container

			var p = this.getParent();
			if(!p || !p.getIndexOfChild){
				return -1; // int
			}
			return p.getIndexOfChild(this); // int
		}
	});
});

},
'dijit/MenuSeparator':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"./_WidgetBase",
	"./_TemplatedMixin",
	"./_Contained",
	"dojo/text!./templates/MenuSeparator.html"
], function(declare, dom, _WidgetBase, _TemplatedMixin, _Contained, template){

	// module:
	//		dijit/MenuSeparator

	return declare("dijit.MenuSeparator", [_WidgetBase, _TemplatedMixin, _Contained], {
		// summary:
		//		A line between two menu items

		templateString: template,

		buildRendering: function(){
			this.inherited(arguments);
			dom.setSelectable(this.domNode, false);
		},

		isFocusable: function(){
			// summary:
			//		Override to always return false
			// tags:
			//		protected

			return false; // Boolean
		}
	});
});

},
'dijit/PopupMenuItem':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-style", // domStyle.set
	"dojo/_base/lang",
	"dojo/query", // query
	"./popup",
	"./registry",	// registry.byNode
	"./MenuItem",
	"./hccss"
], function(declare, domStyle, lang, query, pm, registry, MenuItem){

	// module:
	//		dijit/PopupMenuItem

	return declare("dijit.PopupMenuItem", MenuItem, {
		// summary:
		//		An item in a Menu that spawn a drop down (usually a drop down menu)

		baseClass: "dijitMenuItem dijitPopupMenuItem",

		_fillContent: function(){
			// summary:
			//		When Menu is declared in markup, this code gets the menu label and
			//		the popup widget from the srcNodeRef.
			// description:
			//		srcNodeRef.innerHTML contains both the menu item text and a popup widget
			//		The first part holds the menu item text and the second part is the popup
			// example:
			// |	<div data-dojo-type="dijit/PopupMenuItem">
			// |		<span>pick me</span>
			// |		<popup> ... </popup>
			// |	</div>
			// tags:
			//		protected

			if(this.srcNodeRef){
				var nodes = query("*", this.srcNodeRef);
				this.inherited(arguments, [nodes[0]]);

				// save pointer to srcNode so we can grab the drop down widget after it's instantiated
				this.dropDownContainer = this.srcNodeRef;
			}
		},

		_openPopup: function(/*Object*/ params, /*Boolean*/ focus){
			// summary:
			//		Open the popup to the side of/underneath this MenuItem, and optionally focus first item
			// tags:
			//		protected

			var popup = this.popup;

			pm.open(lang.delegate(params, {
				popup: this.popup,
				around: this.domNode
			}));

			if(focus && popup.focus){
				popup.focus();
			}
		},

		_closePopup: function(){
			pm.close(this.popup);
			this.popup.parentMenu = null;
		},

		startup: function(){
			if(this._started){ return; }
			this.inherited(arguments);

			// We didn't copy the dropdown widget from the this.srcNodeRef, so it's in no-man's
			// land now.  Move it to <body>.
			if(!this.popup){
				var node = query("[widgetId]", this.dropDownContainer)[0];
				this.popup = registry.byNode(node);
			}
			this.ownerDocumentBody.appendChild(this.popup.domNode);
			this.popup.domNode.setAttribute("aria-labelledby", this.containerNode.id);
			this.popup.startup();

			this.popup.domNode.style.display="none";
			if(this.arrowWrapper){
				domStyle.set(this.arrowWrapper, "visibility", "");
			}
			this.focusNode.setAttribute("aria-haspopup", "true");
		},

		destroyDescendants: function(/*Boolean*/ preserveDom){
			if(this.popup){
				// Destroy the popup, unless it's already been destroyed.  This can happen because
				// the popup is a direct child of <body> even though it's logically my child.
				if(!this.popup._destroyed){
					this.popup.destroyRecursive(preserveDom);
				}
				delete this.popup;
			}
			this.inherited(arguments);
		}
	});
});

},
'dijit/Tree':function(){
define([
	"dojo/_base/array", // array.filter array.forEach array.map
	"dojo/aspect",
	"dojo/cookie", // cookie
	"dojo/_base/declare", // declare
	"dojo/Deferred", // Deferred
	"dojo/promise/all",
	"dojo/dom", // dom.isDescendant
	"dojo/dom-class", // domClass.add domClass.remove domClass.replace domClass.toggle
	"dojo/dom-geometry", // domGeometry.setMarginBox domGeometry.position
	"dojo/dom-style", // domStyle.set
	"dojo/errors/create", // createError
	"dojo/fx", // fxUtils.wipeIn fxUtils.wipeOut
	"dojo/has",
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/keys", // arrows etc.
	"dojo/_base/lang", // lang.getObject lang.mixin lang.hitch
	"dojo/on", // on(), on.selector()
	"dojo/topic",
	"dojo/touch",
	"dojo/when",
	"./a11yclick",
	"./focus",
	"./registry", // registry.byNode(), registry.getEnclosingWidget()
	"./_base/manager", // manager.defaultDuration
	"./_Widget",
	"./_TemplatedMixin",
	"./_Container",
	"./_Contained",
	"./_CssStateMixin",
	"./_KeyNavMixin",
	"dojo/text!./templates/TreeNode.html",
	"dojo/text!./templates/Tree.html",
	"./tree/TreeStoreModel",
	"./tree/ForestStoreModel",
	"./tree/_dndSelector",
	"dojo/query!css2"	// needed when on.selector() used with a string for the selector
], function(array, aspect, cookie, declare, Deferred, all,
			dom, domClass, domGeometry, domStyle, createError, fxUtils, has, kernel, keys, lang, on, topic, touch, when,
			a11yclick, focus, registry, manager, _Widget, _TemplatedMixin, _Container, _Contained, _CssStateMixin, _KeyNavMixin,
			treeNodeTemplate, treeTemplate, TreeStoreModel, ForestStoreModel, _dndSelector){

	// module:
	//		dijit/Tree

	function shimmedPromise(/*Deferred|Promise*/ d){
		// summary:
		//		Return a Promise based on given Deferred or Promise, with back-compat addCallback() and addErrback() shims
		//		added (TODO: remove those back-compat shims, and this method, for 2.0)

		return lang.delegate(d.promise || d, {
			addCallback: function(callback){
				this.then(callback);
			},
			addErrback: function(errback){
				this.otherwise(errback);
			}
		});
	}

	var TreeNode = declare("dijit._TreeNode", [_Widget, _TemplatedMixin, _Container, _Contained, _CssStateMixin], {
		// summary:
		//		Single node within a tree.   This class is used internally
		//		by Tree and should not be accessed directly.
		// tags:
		//		private

		// item: [const] Item
		//		the dojo.data entry this tree represents
		item: null,

		// isTreeNode: [protected] Boolean
		//		Indicates that this is a TreeNode.   Used by `dijit.Tree` only,
		//		should not be accessed directly.
		isTreeNode: true,

		// label: String
		//		Text of this tree node
		label: "",
		_setLabelAttr: function(val){
			this.labelNode[this.labelType == "html" ? "innerHTML" : "innerText" in this.labelNode ?
				"innerText" : "textContent"] = val;
			this._set("label", val);
		},

		// labelType: [const] String
		//		Specifies how to interpret the label.  Can be "html" or "text".
		labelType: "text",

		// isExpandable: [private] Boolean
		//		This node has children, so show the expando node (+ sign)
		isExpandable: null,

		// isExpanded: [readonly] Boolean
		//		This node is currently expanded (ie, opened)
		isExpanded: false,

		// state: [private] String
		//		Dynamic loading-related stuff.
		//		When an empty folder node appears, it is "NotLoaded" first,
		//		then after dojo.data query it becomes "Loading" and, finally "Loaded"
		state: "NotLoaded",

		templateString: treeNodeTemplate,

		baseClass: "dijitTreeNode",

		// For hover effect for tree node, and focus effect for label
		cssStateNodes: {
			rowNode: "dijitTreeRow"
		},

		// Tooltip is defined in _WidgetBase but we need to handle the mapping to DOM here
		_setTooltipAttr: {node: "rowNode", type: "attribute", attribute: "title"},

		buildRendering: function(){
			this.inherited(arguments);

			// set expand icon for leaf
			this._setExpando();

			// set icon and label class based on item
			this._updateItemClasses(this.item);

			if(this.isExpandable){
				this.labelNode.setAttribute("aria-expanded", this.isExpanded);
			}

			//aria-selected should be false on all selectable elements.
			this.setSelected(false);
		},

		_setIndentAttr: function(indent){
			// summary:
			//		Tell this node how many levels it should be indented
			// description:
			//		0 for top level nodes, 1 for their children, 2 for their
			//		grandchildren, etc.

			// Math.max() is to prevent negative padding on hidden root node (when indent == -1)
			var pixels = (Math.max(indent, 0) * this.tree._nodePixelIndent) + "px";

			domStyle.set(this.domNode, "backgroundPosition", pixels + " 0px");	// TODOC: what is this for???
			domStyle.set(this.rowNode, this.isLeftToRight() ? "paddingLeft" : "paddingRight", pixels);

			array.forEach(this.getChildren(), function(child){
				child.set("indent", indent + 1);
			});

			this._set("indent", indent);
		},

		markProcessing: function(){
			// summary:
			//		Visually denote that tree is loading data, etc.
			// tags:
			//		private
			this.state = "Loading";
			this._setExpando(true);
		},

		unmarkProcessing: function(){
			// summary:
			//		Clear markup from markProcessing() call
			// tags:
			//		private
			this._setExpando(false);
		},

		_updateItemClasses: function(item){
			// summary:
			//		Set appropriate CSS classes for icon and label dom node
			//		(used to allow for item updates to change respective CSS)
			// tags:
			//		private
			var tree = this.tree, model = tree.model;
			if(tree._v10Compat && item === model.root){
				// For back-compat with 1.0, need to use null to specify root item (TODO: remove in 2.0)
				item = null;
			}
			this._applyClassAndStyle(item, "icon", "Icon");
			this._applyClassAndStyle(item, "label", "Label");
			this._applyClassAndStyle(item, "row", "Row");

			this.tree._startPaint(true);		// signifies paint started and finished (synchronously)
		},

		_applyClassAndStyle: function(item, lower, upper){
			// summary:
			//		Set the appropriate CSS classes and styles for labels, icons and rows.
			//
			// item:
			//		The data item.
			//
			// lower:
			//		The lower case attribute to use, e.g. 'icon', 'label' or 'row'.
			//
			// upper:
			//		The upper case attribute to use, e.g. 'Icon', 'Label' or 'Row'.
			//
			// tags:
			//		private

			var clsName = "_" + lower + "Class";
			var nodeName = lower + "Node";
			var oldCls = this[clsName];

			this[clsName] = this.tree["get" + upper + "Class"](item, this.isExpanded);
			domClass.replace(this[nodeName], this[clsName] || "", oldCls || "");

			domStyle.set(this[nodeName], this.tree["get" + upper + "Style"](item, this.isExpanded) || {});
		},

		_updateLayout: function(){
			// summary:
			//		Set appropriate CSS classes for this.domNode
			// tags:
			//		private

			// if we are hiding the root node then make every first level child look like a root node
			var parent = this.getParent(),
				markAsRoot = !parent || !parent.rowNode || parent.rowNode.style.display == "none";
			domClass.toggle(this.domNode, "dijitTreeIsRoot", markAsRoot);

			domClass.toggle(this.domNode, "dijitTreeIsLast", !markAsRoot && !this.getNextSibling());
		},

		_setExpando: function(/*Boolean*/ processing){
			// summary:
			//		Set the right image for the expando node
			// tags:
			//		private

			var styles = ["dijitTreeExpandoLoading", "dijitTreeExpandoOpened",
					"dijitTreeExpandoClosed", "dijitTreeExpandoLeaf"],
				_a11yStates = ["*", "-", "+", "*"],
				idx = processing ? 0 : (this.isExpandable ? (this.isExpanded ? 1 : 2) : 3);

			// apply the appropriate class to the expando node
			domClass.replace(this.expandoNode, styles[idx], styles);

			// provide a non-image based indicator for images-off mode
			this.expandoNodeText.innerHTML = _a11yStates[idx];

		},

		expand: function(){
			// summary:
			//		Show my children
			// returns:
			//		Promise that resolves when expansion is complete

			// If there's already an expand in progress or we are already expanded, just return
			if(this._expandDeferred){
				return shimmedPromise(this._expandDeferred);		// dojo/promise/Promise
			}

			// cancel in progress collapse operation
			if(this._collapseDeferred){
				this._collapseDeferred.cancel();
				delete this._collapseDeferred;
			}

			// All the state information for when a node is expanded, maybe this should be
			// set when the animation completes instead
			this.isExpanded = true;
			this.labelNode.setAttribute("aria-expanded", "true");
			if(this.tree.showRoot || this !== this.tree.rootNode){
				this.containerNode.setAttribute("role", "group");
			}
			domClass.add(this.contentNode, 'dijitTreeContentExpanded');
			this._setExpando();
			this._updateItemClasses(this.item);

			if(this == this.tree.rootNode && this.tree.showRoot){
				this.tree.domNode.setAttribute("aria-expanded", "true");
			}

			var wipeIn = fxUtils.wipeIn({
				node: this.containerNode,
				duration: manager.defaultDuration
			});

			// Deferred that fires when expand is complete
			var def = (this._expandDeferred = new Deferred(function(){
				// Canceller
				wipeIn.stop();
			}));

			aspect.after(wipeIn, "onEnd", function(){
				def.resolve(true);
			}, true);

			wipeIn.play();

			return shimmedPromise(def);		// dojo/promise/Promise
		},

		collapse: function(){
			// summary:
			//		Collapse this node (if it's expanded)
			// returns:
			//		Promise that resolves when collapse is complete

			if(this._collapseDeferred){
				// Node is already collapsed, or there's a collapse in progress, just return that Deferred
				return shimmedPromise(this._collapseDeferred);
			}

			// cancel in progress expand operation
			if(this._expandDeferred){
				this._expandDeferred.cancel();
				delete this._expandDeferred;
			}

			this.isExpanded = false;
			this.labelNode.setAttribute("aria-expanded", "false");
			if(this == this.tree.rootNode && this.tree.showRoot){
				this.tree.domNode.setAttribute("aria-expanded", "false");
			}
			domClass.remove(this.contentNode, 'dijitTreeContentExpanded');
			this._setExpando();
			this._updateItemClasses(this.item);

			var wipeOut = fxUtils.wipeOut({
				node: this.containerNode,
				duration: manager.defaultDuration
			});

			// Deferred that fires when expand is complete
			var def = (this._collapseDeferred = new Deferred(function(){
				// Canceller
				wipeOut.stop();
			}));

			aspect.after(wipeOut, "onEnd", function(){
				def.resolve(true);
			}, true);

			wipeOut.play();

			return shimmedPromise(def);		// dojo/promise/Promise
		},

		// indent: Integer
		//		Levels from this node to the root node
		indent: 0,

		setChildItems: function(/* Object[] */ items){
			// summary:
			//		Sets the child items of this node, removing/adding nodes
			//		from current children to match specified items[] array.
			//		Also, if this.persist == true, expands any children that were previously
			//		opened.
			// returns:
			//		Promise that resolves after all previously opened children
			//		have been expanded again (or fires instantly if there are no such children).

			var tree = this.tree,
				model = tree.model,
				defs = [];	// list of deferreds that need to fire before I am complete


			var focusedChild = tree.focusedChild;

			// Orphan all my existing children.
			// If items contains some of the same items as before then we will reattach them.
			// Don't call this.removeChild() because that will collapse the tree etc.
			var oldChildren = this.getChildren();
			array.forEach(oldChildren, function(child){
				_Container.prototype.removeChild.call(this, child);
			}, this);

			// All the old children of this TreeNode are subject for destruction if
			//		1) they aren't listed in the new children array (items)
			//		2) they aren't immediately adopted by another node (DnD)
			this.defer(function(){
				array.forEach(oldChildren, function(node){
					if(!node._destroyed && !node.getParent()){
						// If node is in selection then remove it.
						tree.dndController.removeTreeNode(node);

						// Deregister mapping from item id --> this node and its descendants
						function remove(node){
							var id = model.getIdentity(node.item),
								ary = tree._itemNodesMap[id];
							if(ary.length == 1){
								delete tree._itemNodesMap[id];
							}else{
								var index = array.indexOf(ary, node);
								if(index != -1){
									ary.splice(index, 1);
								}
							}
							array.forEach(node.getChildren(), remove);
						}

						remove(node);

						// Remove any entries involving this node from cookie tracking expanded nodes
						if(tree.persist){
							var destroyedPath = array.map(node.getTreePath(),function(item){
								return tree.model.getIdentity(item);
							}).join("/");
							for(var path in tree._openedNodes){
								if(path.substr(0, destroyedPath.length) == destroyedPath){
									delete tree._openedNodes[path];
								}
							}
							tree._saveExpandedNodes();
						}

						// If we've orphaned the focused node then move focus to the root node
						if(tree.lastFocusedChild && !dom.isDescendant(tree.lastFocusedChild, tree.domNode)){
							delete tree.lastFocusedChild;
						}
						if(focusedChild && !dom.isDescendant(focusedChild, tree.domNode)){
							tree.focus();	// could alternately focus this node (parent of the deleted node)
						}

						// And finally we can destroy the node
						node.destroyRecursive();
					}
				});

			});

			this.state = "Loaded";

			if(items && items.length > 0){
				this.isExpandable = true;

				// Create _TreeNode widget for each specified tree node, unless one already
				// exists and isn't being used (presumably it's from a DnD move and was recently
				// released
				array.forEach(items, function(item){    // MARKER: REUSE NODE
					var id = model.getIdentity(item),
						existingNodes = tree._itemNodesMap[id],
						node;
					if(existingNodes){
						for(var i = 0; i < existingNodes.length; i++){
							if(existingNodes[i] && !existingNodes[i].getParent()){
								node = existingNodes[i];
								node.set('indent', this.indent + 1);
								break;
							}
						}
					}
					if(!node){
						node = this.tree._createTreeNode({
							item: item,
							tree: tree,
							isExpandable: model.mayHaveChildren(item),
							label: tree.getLabel(item),
							labelType: (tree.model && tree.model.labelType) || "text",
							tooltip: tree.getTooltip(item),
							ownerDocument: tree.ownerDocument,
							dir: tree.dir,
							lang: tree.lang,
							textDir: tree.textDir,
							indent: this.indent + 1
						});
						if(existingNodes){
							existingNodes.push(node);
						}else{
							tree._itemNodesMap[id] = [node];
						}
					}
					this.addChild(node);

					// If node was previously opened then open it again now (this may trigger
					// more data store accesses, recursively)
					if(this.tree.autoExpand || this.tree._state(node)){
						defs.push(tree._expandNode(node));
					}
				}, this);

				// note that updateLayout() needs to be called on each child after
				// _all_ the children exist
				array.forEach(this.getChildren(), function(child){
					child._updateLayout();
				});
			}else{
				this.isExpandable = false;
			}

			if(this._setExpando){
				// change expando to/from dot or + icon, as appropriate
				this._setExpando(false);
			}

			// Set leaf icon or folder icon, as appropriate
			this._updateItemClasses(this.item);

			var def = all(defs);
			this.tree._startPaint(def);		// to reset TreeNode widths after an item is added/removed from the Tree
			return shimmedPromise(def);		// dojo/promise/Promise
		},

		getTreePath: function(){
			var node = this;
			var path = [];
			while(node && node !== this.tree.rootNode){
				path.unshift(node.item);
				node = node.getParent();
			}
			path.unshift(this.tree.rootNode.item);

			return path;
		},

		getIdentity: function(){
			return this.tree.model.getIdentity(this.item);
		},

		removeChild: function(/* treeNode */ node){
			this.inherited(arguments);

			var children = this.getChildren();
			if(children.length == 0){
				this.isExpandable = false;
				this.collapse();
			}

			array.forEach(children, function(child){
				child._updateLayout();
			});
		},

		makeExpandable: function(){
			// summary:
			//		if this node wasn't already showing the expando node,
			//		turn it into one and call _setExpando()

			// TODO: hmm this isn't called from anywhere, maybe should remove it for 2.0

			this.isExpandable = true;
			this._setExpando(false);
		},

		setSelected: function(/*Boolean*/ selected){
			// summary:
			//		A Tree has a (single) currently selected node.
			//		Mark that this node is/isn't that currently selected node.
			// description:
			//		In particular, setting a node as selected involves setting tabIndex
			//		so that when user tabs to the tree, focus will go to that node (only).
			this.labelNode.setAttribute("aria-selected", selected ? "true" : "false");
			domClass.toggle(this.rowNode, "dijitTreeRowSelected", selected);
		},

		focus: function(){
			focus.focus(this.focusNode);
		}
	});

	if(has("dojo-bidi")){
		TreeNode.extend({
			_setTextDirAttr: function(textDir){
				if(textDir && ((this.textDir != textDir) || !this._created)){
					this._set("textDir", textDir);
					this.applyTextDir(this.labelNode);
					array.forEach(this.getChildren(), function(childNode){
						childNode.set("textDir", textDir);
					}, this);
				}
			}
		});
	}

	var Tree = declare("dijit.Tree", [_Widget, _KeyNavMixin, _TemplatedMixin, _CssStateMixin], {
		// summary:
		//		This widget displays hierarchical data from a store.

		baseClass: "dijitTree",

		// store: [deprecated] String|dojo/data/Store
		//		Deprecated.  Use "model" parameter instead.
		//		The store to get data to display in the tree.
		store: null,

		// model: [const] dijit/tree/model
		//		Interface to read tree data, get notifications of changes to tree data,
		//		and for handling drop operations (i.e drag and drop onto the tree)
		model: null,

		// query: [deprecated] anything
		//		Deprecated.  User should specify query to the model directly instead.
		//		Specifies datastore query to return the root item or top items for the tree.
		query: null,

		// label: [deprecated] String
		//		Deprecated.  Use dijit/tree/ForestStoreModel directly instead.
		//		Used in conjunction with query parameter.
		//		If a query is specified (rather than a root node id), and a label is also specified,
		//		then a fake root node is created and displayed, with this label.
		label: "",

		// showRoot: [const] Boolean
		//		Should the root node be displayed, or hidden?
		showRoot: true,

		// childrenAttr: [deprecated] String[]
		//		Deprecated.   This information should be specified in the model.
		//		One ore more attributes that holds children of a tree node
		childrenAttr: ["children"],

		// paths: String[][] or Item[][]
		//		Full paths from rootNode to selected nodes expressed as array of items or array of ids.
		//		Since setting the paths may be asynchronous (because of waiting on dojo.data), set("paths", ...)
		//		returns a Promise to indicate when the set is complete.
		paths: [],

		// path: String[] or Item[]
		//		Backward compatible singular variant of paths.
		path: [],

		// selectedItems: [readonly] Item[]
		//		The currently selected items in this tree.
		//		This property can only be set (via set('selectedItems', ...)) when that item is already
		//		visible in the tree.   (I.e. the tree has already been expanded to show that node.)
		//		Should generally use `paths` attribute to set the selected items instead.
		selectedItems: null,

		// selectedItem: [readonly] Item
		//		Backward compatible singular variant of selectedItems.
		selectedItem: null,

		// openOnClick: Boolean
		//		If true, clicking a folder node's label will open it, rather than calling onClick()
		openOnClick: false,

		// openOnDblClick: Boolean
		//		If true, double-clicking a folder node's label will open it, rather than calling onDblClick()
		openOnDblClick: false,

		templateString: treeTemplate,

		// persist: Boolean
		//		Enables/disables use of cookies for state saving.
		persist: false,

		// autoExpand: Boolean
		//		Fully expand the tree on load.   Overrides `persist`.
		autoExpand: false,

		// dndController: [protected] Function|String
		//		Class to use as as the dnd controller.  Specifying this class enables DnD.
		//		Generally you should specify this as dijit/tree/dndSource.
		//		Setting of dijit/tree/_dndSelector handles selection only (no actual DnD).
		dndController: _dndSelector,

		// parameters to pull off of the tree and pass on to the dndController as its params
		dndParams: ["onDndDrop", "itemCreator", "onDndCancel", "checkAcceptance", "checkItemAcceptance", "dragThreshold", "betweenThreshold"],

		//declare the above items so they can be pulled from the tree's markup

		// onDndDrop: [protected] Function
		//		Parameter to dndController, see `dijit/tree/dndSource.onDndDrop()`.
		//		Generally this doesn't need to be set.
		onDndDrop: null,

		itemCreator: null,
		/*=====
		itemCreator: function(nodes, target, source){
			// summary:
			//		Returns objects passed to `Tree.model.newItem()` based on DnD nodes
			//		dropped onto the tree.   Developer must override this method to enable
			//		dropping from external sources onto this Tree, unless the Tree.model's items
			//		happen to look like {id: 123, name: "Apple" } with no other attributes.
			//
			//		For each node in nodes[], which came from source, create a hash of name/value
			//		pairs to be passed to Tree.model.newItem().  Returns array of those hashes.
			// nodes: DomNode[]
			//		The DOMNodes dragged from the source container
			// target: DomNode
			//		The target TreeNode.rowNode
			// source: dojo/dnd/Source
			//		The source container the nodes were dragged from, perhaps another Tree or a plain dojo/dnd/Source
			// returns: Object[]
			//		Array of name/value hashes for each new item to be added to the Tree, like:
			// |	[
			// |		{ id: 123, label: "apple", foo: "bar" },
			// |		{ id: 456, label: "pear", zaz: "bam" }
			// |	]
			// tags:
			//		extension
			return [{}];
		},
		=====*/

		// onDndCancel: [protected] Function
		//		Parameter to dndController, see `dijit/tree/dndSource.onDndCancel()`.
		//		Generally this doesn't need to be set.
		onDndCancel: null,

		/*=====
		checkAcceptance: function(source, nodes){
			// summary:
			//		Checks if the Tree itself can accept nodes from this source
			// source: dijit/tree/dndSource
			//		The source which provides items
			// nodes: DOMNode[]
			//		Array of DOM nodes corresponding to nodes being dropped, dijitTreeRow nodes if
			//		source is a dijit/Tree.
			// tags:
			//		extension
			return true;	// Boolean
		},
		=====*/
		checkAcceptance: null,

		/*=====
		checkItemAcceptance: function(target, source, position){
			// summary:
			//		Stub function to be overridden if one wants to check for the ability to drop at the node/item level
			// description:
			//		In the base case, this is called to check if target can become a child of source.
			//		When betweenThreshold is set, position="before" or "after" means that we
			//		are asking if the source node can be dropped before/after the target node.
			// target: DOMNode
			//		The dijitTreeRoot DOM node inside of the TreeNode that we are dropping on to
			//		Use registry.getEnclosingWidget(target) to get the TreeNode.
			// source: dijit/tree/dndSource
			//		The (set of) nodes we are dropping
			// position: String
			//		"over", "before", or "after"
			// tags:
			//		extension
			return true;	// Boolean
		},
		=====*/
		checkItemAcceptance: null,

		// dragThreshold: Integer
		//		Number of pixels mouse moves before it's considered the start of a drag operation
		dragThreshold: 5,

		// betweenThreshold: Integer
		//		Set to a positive value to allow drag and drop "between" nodes.
		//
		//		If during DnD mouse is over a (target) node but less than betweenThreshold
		//		pixels from the bottom edge, dropping the the dragged node will make it
		//		the next sibling of the target node, rather than the child.
		//
		//		Similarly, if mouse is over a target node but less that betweenThreshold
		//		pixels from the top edge, dropping the dragged node will make it
		//		the target node's previous sibling rather than the target node's child.
		betweenThreshold: 0,

		// _nodePixelIndent: Integer
		//		Number of pixels to indent tree nodes (relative to parent node).
		//		Default is 19 but can be overridden by setting CSS class dijitTreeIndent
		//		and calling resize() or startup() on tree after it's in the DOM.
		_nodePixelIndent: 19,

		_publish: function(/*String*/ topicName, /*Object*/ message){
			// summary:
			//		Publish a message for this widget/topic
			topic.publish(this.id, lang.mixin({tree: this, event: topicName}, message || {}));	// publish
		},

		postMixInProperties: function(){
			this.tree = this;

			if(this.autoExpand){
				// There's little point in saving opened/closed state of nodes for a Tree
				// that initially opens all it's nodes.
				this.persist = false;
			}

			this._itemNodesMap = {};

			if(!this.cookieName && this.id){
				this.cookieName = this.id + "SaveStateCookie";
			}

			// Deferred that resolves when all the children have loaded.
			this.expandChildrenDeferred = new Deferred();

			// Promise that resolves when all pending operations complete.
			this.pendingCommandsPromise = this.expandChildrenDeferred.promise;

			this.inherited(arguments);
		},

		postCreate: function(){
			this._initState();

			// Catch events on TreeNodes
			var self = this;
			this.own(
				on(this.containerNode, on.selector(".dijitTreeNode", touch.enter), function(evt){
					self._onNodeMouseEnter(registry.byNode(this), evt);
				}),
				on(this.containerNode, on.selector(".dijitTreeNode", touch.leave), function(evt){
					self._onNodeMouseLeave(registry.byNode(this), evt);
				}),
				on(this.containerNode, on.selector(".dijitTreeRow", a11yclick.press), function(evt){
					self._onNodePress(registry.getEnclosingWidget(this), evt);
				}),
				on(this.containerNode, on.selector(".dijitTreeRow", a11yclick), function(evt){
					self._onClick(registry.getEnclosingWidget(this), evt);
				}),
				on(this.containerNode, on.selector(".dijitTreeRow", "dblclick"), function(evt){
					self._onDblClick(registry.getEnclosingWidget(this), evt);
				})
			);

			// Create glue between store and Tree, if not specified directly by user
			if(!this.model){
				this._store2model();
			}

			// monitor changes to items
			this.own(
				aspect.after(this.model, "onChange", lang.hitch(this, "_onItemChange"), true),
				aspect.after(this.model, "onChildrenChange", lang.hitch(this, "_onItemChildrenChange"), true),
				aspect.after(this.model, "onDelete", lang.hitch(this, "_onItemDelete"), true)
			);

			this.inherited(arguments);

			if(this.dndController){
				// TODO: remove string support in 2.0.
				if(lang.isString(this.dndController)){
					this.dndController = lang.getObject(this.dndController);
				}
				var params = {};
				for(var i = 0; i < this.dndParams.length; i++){
					if(this[this.dndParams[i]]){
						params[this.dndParams[i]] = this[this.dndParams[i]];
					}
				}
				this.dndController = new this.dndController(this, params);
			}

			this._load();

			// onLoadDeferred should fire when all commands that are part of initialization have completed.
			// It will include all the set("paths", ...) commands that happen during initialization.
			this.onLoadDeferred = shimmedPromise(this.pendingCommandsPromise);

			this.onLoadDeferred.then(lang.hitch(this, "onLoad"));
		},

		_store2model: function(){
			// summary:
			//		User specified a store&query rather than model, so create model from store/query
			this._v10Compat = true;
			kernel.deprecated("Tree: from version 2.0, should specify a model object rather than a store/query");

			var modelParams = {
				id: this.id + "_ForestStoreModel",
				store: this.store,
				query: this.query,
				childrenAttrs: this.childrenAttr
			};

			// Only override the model's mayHaveChildren() method if the user has specified an override
			if(this.params.mayHaveChildren){
				modelParams.mayHaveChildren = lang.hitch(this, "mayHaveChildren");
			}

			if(this.params.getItemChildren){
				modelParams.getChildren = lang.hitch(this, function(item, onComplete, onError){
					this.getItemChildren((this._v10Compat && item === this.model.root) ? null : item, onComplete, onError);
				});
			}
			this.model = new ForestStoreModel(modelParams);

			// For backwards compatibility, the visibility of the root node is controlled by
			// whether or not the user has specified a label
			this.showRoot = Boolean(this.label);
		},

		onLoad: function(){
			// summary:
			//		Called when tree finishes loading and expanding.
			// description:
			//		If persist == true the loading may encompass many levels of fetches
			//		from the data store, each asynchronous.   Waits for all to finish.
			// tags:
			//		callback
		},

		_load: function(){
			// summary:
			//		Initial load of the tree.
			//		Load root node (possibly hidden) and it's children.
			this.model.getRoot(
				lang.hitch(this, function(item){
					var rn = (this.rootNode = this.tree._createTreeNode({
						item: item,
						tree: this,
						isExpandable: true,
						label: this.label || this.getLabel(item),
						labelType: this.model.labelType || "text",
						textDir: this.textDir,
						indent: this.showRoot ? 0 : -1
					}));

					if(!this.showRoot){
						rn.rowNode.style.display = "none";
						// if root is not visible, move tree role to the invisible
						// root node's containerNode, see #12135
						this.domNode.setAttribute("role", "presentation");
						this.domNode.removeAttribute("aria-expanded");
						this.domNode.removeAttribute("aria-multiselectable");

						// move the aria-label or aria-labelledby to the element with the role
						if(this["aria-label"]){
							rn.containerNode.setAttribute("aria-label", this["aria-label"]);
							this.domNode.removeAttribute("aria-label");
						}else if(this["aria-labelledby"]){
							rn.containerNode.setAttribute("aria-labelledby", this["aria-labelledby"]);
							this.domNode.removeAttribute("aria-labelledby");
						}
						rn.labelNode.setAttribute("role", "presentation");
						rn.containerNode.setAttribute("role", "tree");
						rn.containerNode.setAttribute("aria-expanded", "true");
						rn.containerNode.setAttribute("aria-multiselectable", !this.dndController.singular);
					}else{
						this.domNode.setAttribute("aria-multiselectable", !this.dndController.singular);
						this.rootLoadingIndicator.style.display = "none";
					}

					this.containerNode.appendChild(rn.domNode);
					var identity = this.model.getIdentity(item);
					if(this._itemNodesMap[identity]){
						this._itemNodesMap[identity].push(rn);
					}else{
						this._itemNodesMap[identity] = [rn];
					}

					rn._updateLayout();		// sets "dijitTreeIsRoot" CSS classname

					// Load top level children, and if persist==true, all nodes that were previously opened
					this._expandNode(rn).then(lang.hitch(this, function(){
						// Then, select the nodes specified by params.paths[], assuming Tree hasn't been deleted.
						if(!this._destroyed){
							this.rootLoadingIndicator.style.display = "none";
							this.expandChildrenDeferred.resolve(true);
						}
					}));
				}),
				lang.hitch(this, function(err){
					console.error(this, ": error loading root: ", err);
				})
			);
		},

		getNodesByItem: function(/*Item or id*/ item){
			// summary:
			//		Returns all tree nodes that refer to an item
			// returns:
			//		Array of tree nodes that refer to passed item

			if(!item){
				return [];
			}
			var identity = lang.isString(item) ? item : this.model.getIdentity(item);
			// return a copy so widget don't get messed up by changes to returned array
			return [].concat(this._itemNodesMap[identity]);
		},

		_setSelectedItemAttr: function(/*Item or id*/ item){
			this.set('selectedItems', [item]);
		},

		_setSelectedItemsAttr: function(/*Items or ids*/ items){
			// summary:
			//		Select tree nodes related to passed items.
			//		WARNING: if model use multi-parented items or desired tree node isn't already loaded
			//		behavior is undefined. Use set('paths', ...) instead.
			var tree = this;
			return this.pendingCommandsPromise = this.pendingCommandsPromise.always(lang.hitch(this, function(){
				var identities = array.map(items, function(item){
					return (!item || lang.isString(item)) ? item : tree.model.getIdentity(item);
				});
				var nodes = [];
				array.forEach(identities, function(id){
					nodes = nodes.concat(tree._itemNodesMap[id] || []);
				});
				this.set('selectedNodes', nodes);
			}));
		},

		_setPathAttr: function(/*Item[]|String[]*/ path){
			// summary:
			//		Singular variant of _setPathsAttr
			if(path.length){
				return shimmedPromise(this.set("paths", [path]).then(function(paths){ return paths[0]; }));
			}else{
				// Empty list is interpreted as "select nothing"
				return shimmedPromise(this.set("paths", []).then(function(paths){ return paths[0]; }));
			}
		},

		_setPathsAttr: function(/*Item[][]|String[][]*/ paths){
			// summary:
			//		Select the tree nodes identified by passed paths.
			// paths:
			//		Array of arrays of items or item id's
			// returns:
			//		Promise to indicate when the set is complete

			var tree = this;

			function selectPath(path, nodes){
				// Traverse path, returning Promise for node at the end of the path.
				// The next path component should be among "nodes".
				var nextPath = path.shift();
				var nextNode = array.filter(nodes, function(node){
					return node.getIdentity() == nextPath;
				})[0];
				if(!!nextNode){
					if(path.length){
						return tree._expandNode(nextNode).then(function(){
							return selectPath(path, nextNode.getChildren());
						});
					}else{
						// Successfully reached the end of this path
						return nextNode;
					}
				}else{
					throw new Tree.PathError("Could not expand path at " + nextPath);
				}
			}

			// Let any previous set("path", ...) commands complete before this one starts.
			// TODO for 2.0: make the user do this wait themselves?
			return shimmedPromise(this.pendingCommandsPromise = this.pendingCommandsPromise.always(function(){
				// We may need to wait for some nodes to expand, so setting
				// each path will involve a Deferred. We bring those deferreds
				// together with a dojo/promise/all.
				return all(array.map(paths, function(path){
					// normalize path to use identity
					path = array.map(path, function(item){
						return lang.isString(item) ? item : tree.model.getIdentity(item);
					});

					if(path.length){
						return selectPath(path, [tree.rootNode]);
					}else{
						throw new Tree.PathError("Empty path");
					}
				}));
			}).then(function setNodes(newNodes){
				// After all expansion is finished, set the selection to last element from each path
				tree.set("selectedNodes", newNodes);
				return tree.paths;
			}));
		},

		_setSelectedNodeAttr: function(node){
			this.set('selectedNodes', [node]);
		},
		_setSelectedNodesAttr: function(nodes){
			// summary:
			//		Marks the specified TreeNodes as selected.
			// nodes: TreeNode[]
			//		TreeNodes to mark.
			this.dndController.setSelection(nodes);
		},


		expandAll: function(){
			// summary:
			//		Expand all nodes in the tree
			// returns:
			//		Promise that resolves when all nodes have expanded

			var _this = this;

			function expand(node){
				// Expand the node
				return _this._expandNode(node).then(function(){
					// When node has expanded, call expand() recursively on each non-leaf child
					var childBranches = array.filter(node.getChildren() || [], function(node){
						return node.isExpandable;
					});

					// And when all those recursive calls finish, signal that I'm finished
					return all(array.map(childBranches, expand));
				});
			}

			return shimmedPromise(expand(this.rootNode));
		},

		collapseAll: function(){
			// summary:
			//		Collapse all nodes in the tree
			// returns:
			//		Promise that resolves when all nodes have collapsed

			var _this = this;

			function collapse(node){
				// Collapse children first
				var childBranches = array.filter(node.getChildren() || [], function(node){
						return node.isExpandable;
					}),
					defs = all(array.map(childBranches, collapse));

				// And when all those recursive calls finish, collapse myself, unless I'm the invisible root node,
				// in which case collapseAll() is finished
				if(!node.isExpanded || (node == _this.rootNode && !_this.showRoot)){
					return defs;
				}else{
					// When node has collapsed, signal that call is finished
					return defs.then(function(){
						return _this._collapseNode(node);
					});
				}
			}

			return shimmedPromise(collapse(this.rootNode));
		},

		////////////// Data store related functions //////////////////////
		// These just get passed to the model; they are here for back-compat

		mayHaveChildren: function(/*dojo/data/Item*/ /*===== item =====*/){
			// summary:
			//		Deprecated.   This should be specified on the model itself.
			//
			//		Overridable function to tell if an item has or may have children.
			//		Controls whether or not +/- expando icon is shown.
			//		(For efficiency reasons we may not want to check if an element actually
			//		has children until user clicks the expando node)
			// tags:
			//		deprecated
		},

		getItemChildren: function(/*===== parentItem, onComplete =====*/){
			// summary:
			//		Deprecated.   This should be specified on the model itself.
			//
			//		Overridable function that return array of child items of given parent item,
			//		or if parentItem==null then return top items in tree
			// tags:
			//		deprecated
		},

		///////////////////////////////////////////////////////
		// Functions for converting an item to a TreeNode
		getLabel: function(/*dojo/data/Item*/ item){
			// summary:
			//		Overridable function to get the label for a tree node (given the item)
			// tags:
			//		extension
			return this.model.getLabel(item);	// String
		},

		getIconClass: function(/*dojo/data/Item*/ item, /*Boolean*/ opened){
			// summary:
			//		Overridable function to return CSS class name to display icon
			// tags:
			//		extension
			return (!item || this.model.mayHaveChildren(item)) ? (opened ? "dijitFolderOpened" : "dijitFolderClosed") : "dijitLeaf"
		},

		getLabelClass: function(/*===== item, opened =====*/){
			// summary:
			//		Overridable function to return CSS class name to display label
			// item: dojo/data/Item
			// opened: Boolean
			// returns: String
			//		CSS class name
			// tags:
			//		extension
		},

		getRowClass: function(/*===== item, opened =====*/){
			// summary:
			//		Overridable function to return CSS class name to display row
			// item: dojo/data/Item
			// opened: Boolean
			// returns: String
			//		CSS class name
			// tags:
			//		extension
		},

		getIconStyle: function(/*===== item, opened =====*/){
			// summary:
			//		Overridable function to return CSS styles to display icon
			// item: dojo/data/Item
			// opened: Boolean
			// returns: Object
			//		Object suitable for input to dojo.style() like {backgroundImage: "url(...)"}
			// tags:
			//		extension
		},

		getLabelStyle: function(/*===== item, opened =====*/){
			// summary:
			//		Overridable function to return CSS styles to display label
			// item: dojo/data/Item
			// opened: Boolean
			// returns:
			//		Object suitable for input to dojo.style() like {color: "red", background: "green"}
			// tags:
			//		extension
		},

		getRowStyle: function(/*===== item, opened =====*/){
			// summary:
			//		Overridable function to return CSS styles to display row
			// item: dojo/data/Item
			// opened: Boolean
			// returns:
			//		Object suitable for input to dojo.style() like {background-color: "#bbb"}
			// tags:
			//		extension
		},

		getTooltip: function(/*dojo/data/Item*/ /*===== item =====*/){
			// summary:
			//		Overridable function to get the tooltip for a tree node (given the item)
			// tags:
			//		extension
			return "";	// String
		},

		/////////// Keyboard and Mouse handlers ////////////////////


		_onDownArrow: function(/*Event*/ evt, /*TreeNode*/ node){
			// summary:
			//		down arrow pressed; get next visible node, set focus there

			var nextNode = this._getNext(node);
			if(nextNode && nextNode.isTreeNode){
				this.focusNode(nextNode);
			}
		},

		_onUpArrow: function(/*Event*/ evt, /*TreeNode*/ node){
			// summary:
			//		Up arrow pressed; move to previous visible node

			// if younger siblings
			var previousSibling = node.getPreviousSibling();
			if(previousSibling){
				node = previousSibling;
				// if the previous node is expanded, dive in deep
				while(node.isExpandable && node.isExpanded && node.hasChildren()){
					// move to the last child
					var children = node.getChildren();
					node = children[children.length - 1];
				}
			}else{
				// if this is the first child, return the parent
				// unless the parent is the root of a tree with a hidden root
				var parent = node.getParent();
				if(!(!this.showRoot && parent === this.rootNode)){
					node = parent;
				}
			}

			if(node && node.isTreeNode){
				this.focusNode(node);
			}
		},

		_onRightArrow: function(/*Event*/ evt, /*TreeNode*/ node){
			// summary:
			//		Right arrow pressed; go to child node

			// if not expanded, expand, else move to 1st child
			if(node.isExpandable && !node.isExpanded){
				this._expandNode(node);
			}else if(node.hasChildren()){
				node = node.getChildren()[0];
				if(node && node.isTreeNode){
					this.focusNode(node);
				}
			}
		},

		_onLeftArrow: function(/*Event*/ evt, /*TreeNode*/ node){
			// summary:
			//		Left arrow pressed.
			//		If not collapsed, collapse, else move to parent.

			if(node.isExpandable && node.isExpanded){
				this._collapseNode(node);
			}else{
				var parent = node.getParent();
				if(parent && parent.isTreeNode && !(!this.showRoot && parent === this.rootNode)){
					this.focusNode(parent);
				}
			}
		},

		focusLastChild: function(){
			// summary:
			//		End key pressed; go to last visible node.

			var node = this._getLast();
			if(node && node.isTreeNode){
				this.focusNode(node);
			}
		},

		_getFirst: function(){
			// summary:
			//		Returns the first child.
			// tags:
			//		abstract extension
			return this.showRoot ? this.rootNode : this.rootNode.getChildren()[0];
		},

		_getLast: function(){
			// summary:
			//		Returns the last descendant.
			// tags:
			//		abstract extension
			var node = this.rootNode;
			while(node.isExpanded){
				var c = node.getChildren();
				if(!c.length){
					break;
				}
				node = c[c.length - 1];
			}
			return node;
		},

		// Tree only searches forward so dir parameter is unused
		_getNext: function(node){
			// summary:
			//		Returns the next descendant, compared to "child".
			// node: Widget
			//		The current widget
			// tags:
			//		abstract extension

			if(node.isExpandable && node.isExpanded && node.hasChildren()){
				// if this is an expanded node, get the first child
				return node.getChildren()[0];		// TreeNode
			}else{
				// find a parent node with a sibling
				while(node && node.isTreeNode){
					var returnNode = node.getNextSibling();
					if(returnNode){
						return returnNode;		// TreeNode
					}
					node = node.getParent();
				}
				return null;
			}
		},

		// Implement _KeyNavContainer.childSelector, to identify which nodes are navigable
		childSelector: ".dijitTreeRow",

		isExpandoNode: function(node, widget){
			// summary:
			//		check whether a dom node is the expandoNode for a particular TreeNode widget
			return dom.isDescendant(node, widget.expandoNode) || dom.isDescendant(node, widget.expandoNodeText);
		},

		_onNodePress: function(/*TreeNode*/ nodeWidget, /*Event*/ e){
			// Touching a node should focus it, even if you touch the expando node or the edges rather than the label.
			// Especially important to avoid _KeyNavMixin._onContainerFocus() causing the previously focused TreeNode
			// to get focus
			this.focusNode(nodeWidget);
		},

		__click: function(/*TreeNode*/ nodeWidget, /*Event*/ e, /*Boolean*/doOpen, /*String*/func){
			var domElement = e.target,
				isExpandoClick = this.isExpandoNode(domElement, nodeWidget);

			if(nodeWidget.isExpandable && (doOpen || isExpandoClick)){
				// expando node was clicked, or label of a folder node was clicked; open it
				this._onExpandoClick({node: nodeWidget});
			}else{
				this._publish("execute", { item: nodeWidget.item, node: nodeWidget, evt: e });
				this[func](nodeWidget.item, nodeWidget, e);
				this.focusNode(nodeWidget);
			}
			e.stopPropagation();
			e.preventDefault();
		},
		_onClick: function(/*TreeNode*/ nodeWidget, /*Event*/ e){
			// summary:
			//		Translates click events into commands for the controller to process
			this.__click(nodeWidget, e, this.openOnClick, 'onClick');
		},
		_onDblClick: function(/*TreeNode*/ nodeWidget, /*Event*/ e){
			// summary:
			//		Translates double-click events into commands for the controller to process
			this.__click(nodeWidget, e, this.openOnDblClick, 'onDblClick');
		},

		_onExpandoClick: function(/*Object*/ message){
			// summary:
			//		User clicked the +/- icon; expand or collapse my children.
			var node = message.node;

			// If we are collapsing, we might be hiding the currently focused node.
			// Also, clicking the expando node might have erased focus from the current node.
			// For simplicity's sake just focus on the node with the expando.
			this.focusNode(node);

			if(node.isExpanded){
				this._collapseNode(node);
			}else{
				this._expandNode(node);
			}
		},

		onClick: function(/*===== item, node, evt =====*/){
			// summary:
			//		Callback when a tree node is clicked
			// item: Object
			//		Object from the dojo/store corresponding to this TreeNode
			// node: TreeNode
			//		The TreeNode itself
			// evt: Event
			//		The event
			// tags:
			//		callback
		},
		onDblClick: function(/*===== item, node, evt =====*/){
			// summary:
			//		Callback when a tree node is double-clicked
			// item: Object
			//		Object from the dojo/store corresponding to this TreeNode
			// node: TreeNode
			//		The TreeNode itself
			// evt: Event
			//		The event
			// tags:
			//		callback
		},
		onOpen: function(/*===== item, node =====*/){
			// summary:
			//		Callback when a node is opened
			// item: dojo/data/Item
			// node: TreeNode
			// tags:
			//		callback
		},
		onClose: function(/*===== item, node =====*/){
			// summary:
			//		Callback when a node is closed
			// item: Object
			//		Object from the dojo/store corresponding to this TreeNode
			// node: TreeNode
			//		The TreeNode itself
			// tags:
			//		callback
		},

		_getNextNode: function(node){
			// summary:
			//		Get next visible node

			kernel.deprecated(this.declaredClass + "::_getNextNode(node) is deprecated. Use _getNext(node) instead.", "", "2.0");
			return this._getNext(node);
		},

		_getRootOrFirstNode: function(){
			// summary:
			//		Get first visible node
			kernel.deprecated(this.declaredClass + "::_getRootOrFirstNode() is deprecated. Use _getFirst() instead.", "", "2.0");
			return this._getFirst();
		},

		_collapseNode: function(/*TreeNode*/ node){
			// summary:
			//		Called when the user has requested to collapse the node
			// returns:
			//		Promise that resolves when the node has finished closing

			if(node._expandNodeDeferred){
				delete node._expandNodeDeferred;
			}

			if(node.state == "Loading"){
				// ignore clicks while we are in the process of loading data
				return;
			}

			if(node.isExpanded){
				var ret = node.collapse();

				this.onClose(node.item, node);
				this._state(node, false);

				this._startPaint(ret);	// after this finishes, need to reset widths of TreeNodes

				return ret;
			}
		},

		_expandNode: function(/*TreeNode*/ node){
			// summary:
			//		Called when the user has requested to expand the node
			// returns:
			//		Promise that resolves when the node is loaded and opened and (if persist=true) all it's descendants
			//		that were previously opened too

			if(node._expandNodeDeferred){
				// there's already an expand in progress, or completed, so just return
				return node._expandNodeDeferred;	// dojo/Deferred
			}

			var model = this.model,
				item = node.item,
				_this = this;

			// Load data if it's not already loaded
			if(!node._loadDeferred){
				// need to load all the children before expanding
				node.markProcessing();

				// Setup deferred to signal when the load and expand are finished.
				// Save that deferred in this._expandDeferred as a flag that operation is in progress.
				node._loadDeferred = new Deferred();

				// Get the children
				model.getChildren(
					item,
					function(items){
						node.unmarkProcessing();

						// Display the children and also start expanding any children that were previously expanded
						// (if this.persist == true).   The returned Deferred will fire when those expansions finish.
						node.setChildItems(items).then(function(){
							node._loadDeferred.resolve(items);
						});
					},
					function(err){
						console.error(_this, ": error loading " + node.label + " children: ", err);
						node._loadDeferred.reject(err);
					}
				);
			}

			// Expand the node after data has loaded
			var def = node._loadDeferred.then(lang.hitch(this, function(){
				var def2 = node.expand();

				// seems like these should delayed until node.expand() completes, but left here for back-compat about
				// when this.isOpen flag gets set (ie, at the beginning of the animation)
				this.onOpen(node.item, node);
				this._state(node, true);

				return def2;
			}));

			this._startPaint(def);	// after this finishes, need to reset widths of TreeNodes

			return def;	// dojo/promise/Promise
		},

		////////////////// Miscellaneous functions ////////////////

		focusNode: function(/* _tree.Node */ node){
			// summary:
			//		Focus on the specified node (which must be visible)
			// tags:
			//		protected

			var scrollLeft = this.domNode.scrollLeft;
			this.focusChild(node);
			this.domNode.scrollLeft = scrollLeft;
		},

		_onNodeMouseEnter: function(/*dijit/_WidgetBase*/ /*===== node =====*/){
			// summary:
			//		Called when mouse is over a node (onmouseenter event),
			//		this is monitored by the DND code
		},

		_onNodeMouseLeave: function(/*dijit/_WidgetBase*/ /*===== node =====*/){
			// summary:
			//		Called when mouse leaves a node (onmouseleave event),
			//		this is monitored by the DND code
		},

		//////////////// Events from the model //////////////////////////

		_onItemChange: function(/*Item*/ item){
			// summary:
			//		Processes notification of a change to an item's scalar values like label
			var model = this.model,
				identity = model.getIdentity(item),
				nodes = this._itemNodesMap[identity];

			if(nodes){
				var label = this.getLabel(item),
					tooltip = this.getTooltip(item);
				array.forEach(nodes, function(node){
					node.set({
						item: item, // theoretically could be new JS Object representing same item
						label: label,
						tooltip: tooltip
					});
					node._updateItemClasses(item);
				});
			}
		},

		_onItemChildrenChange: function(/*dojo/data/Item*/ parent, /*dojo/data/Item[]*/ newChildrenList){
			// summary:
			//		Processes notification of a change to an item's children
			var model = this.model,
				identity = model.getIdentity(parent),
				parentNodes = this._itemNodesMap[identity];

			if(parentNodes){
				array.forEach(parentNodes, function(parentNode){
					parentNode.setChildItems(newChildrenList);
				});
			}
		},

		_onItemDelete: function(/*Item*/ item){
			// summary:
			//		Processes notification of a deletion of an item.
			//		Not called from new dojo.store interface but there's cleanup code in setChildItems() instead.

			var model = this.model,
				identity = model.getIdentity(item),
				nodes = this._itemNodesMap[identity];

			if(nodes){
				array.forEach(nodes, function(node){
					// Remove node from set of selected nodes (if it's selected)
					this.dndController.removeTreeNode(node);

					var parent = node.getParent();
					if(parent){
						// if node has not already been orphaned from a _onSetItem(parent, "children", ..) call...
						parent.removeChild(node);
					}

					// If we've orphaned the focused node then move focus to the root node
					if(this.lastFocusedChild && !dom.isDescendant(this.lastFocusedChild, this.domNode)){
						delete this.lastFocusedChild;
					}
					if(this.focusedChild && !dom.isDescendant(this.focusedChild, this.domNode)){
						this.focus();
					}

					node.destroyRecursive();
				}, this);
				delete this._itemNodesMap[identity];
			}
		},

		/////////////// Miscellaneous funcs

		_initState: function(){
			// summary:
			//		Load in which nodes should be opened automatically
			this._openedNodes = {};
			if(this.persist && this.cookieName){
				var oreo = cookie(this.cookieName);
				if(oreo){
					array.forEach(oreo.split(','), function(item){
						this._openedNodes[item] = true;
					}, this);
				}
			}
		},

		_state: function(node, expanded){
			// summary:
			//		Query or set expanded state for an node
			if(!this.persist){
				return false;
			}
			var path = array.map(node.getTreePath(),function(item){
				return this.model.getIdentity(item);
			}, this).join("/");
			if(arguments.length === 1){
				return this._openedNodes[path];
			}else{
				if(expanded){
					this._openedNodes[path] = true;
				}else{
					delete this._openedNodes[path];
				}
				this._saveExpandedNodes();
			}
		},

		_saveExpandedNodes: function(){
			if(this.persist && this.cookieName){
				var ary = [];
				for(var id in this._openedNodes){
					ary.push(id);
				}
				cookie(this.cookieName, ary.join(","), {expires: 365});
			}
		},

		destroy: function(){
			if(this._curSearch){
				this._curSearch.timer.remove();
				delete this._curSearch;
			}
			if(this.rootNode){
				this.rootNode.destroyRecursive();
			}
			if(this.dndController && !lang.isString(this.dndController)){
				this.dndController.destroy();
			}
			this.rootNode = null;
			this.inherited(arguments);
		},

		destroyRecursive: function(){
			// A tree is treated as a leaf, not as a node with children (like a grid),
			// but defining destroyRecursive for back-compat.
			this.destroy();
		},

		resize: function(changeSize){
			if(changeSize){
				domGeometry.setMarginBox(this.domNode, changeSize);
			}

			// The main JS sizing involved w/tree is the indentation, which is specified
			// in CSS and read in through this dummy indentDetector node (tree must be
			// visible and attached to the DOM to read this).
			// If the Tree is hidden domGeometry.position(this.tree.indentDetector).w will return 0, in which case just
			// keep the default value.
			this._nodePixelIndent = domGeometry.position(this.tree.indentDetector).w || this._nodePixelIndent;

			// resize() may be called before this.rootNode is created, so wait until it's available
			this.expandChildrenDeferred.then(lang.hitch(this, function(){
				// If tree has already loaded, then reset indent for all the nodes
				this.rootNode.set('indent', this.showRoot ? 0 : -1);

				// Also, adjust widths of all rows to match width of Tree
				this._adjustWidths();
			}));
		},

		_outstandingPaintOperations: 0,
		_startPaint: function(/*Promise|Boolean*/ p){
			// summary:
			//		Called at the start of an operation that will change what's displayed.
			// p:
			//		Promise that tells when the operation will complete.  Alternately, if it's just a Boolean, it signifies
			//		that the operation was synchronous, and already completed.

			this._outstandingPaintOperations++;
			if(this._adjustWidthsTimer){
				this._adjustWidthsTimer.remove();
				delete this._adjustWidthsTimer;
			}

			var oc = lang.hitch(this, function(){
				this._outstandingPaintOperations--;

				if(this._outstandingPaintOperations <= 0 && !this._adjustWidthsTimer && this._started){
					// Use defer() to avoid a width adjustment when another operation will immediately follow,
					// such as a sequence of opening a node, then it's children, then it's grandchildren, etc.
					this._adjustWidthsTimer = this.defer("_adjustWidths");
				}
			});
			when(p, oc, oc);
		},

		_adjustWidths: function(){
			// summary:
			//		Size container to match widest TreeNode, so that highlighting with scrolling works (#13141, #16132)

			if(this._adjustWidthsTimer){
				this._adjustWidthsTimer.remove();
				delete this._adjustWidthsTimer;
			}

			this.containerNode.style.width = "auto";
			this.containerNode.style.width = this.domNode.scrollWidth > this.domNode.offsetWidth ? "auto" : "100%";
		},

		_createTreeNode: function(/*Object*/ args){
			// summary:
			//		creates a TreeNode
			// description:
			//		Developers can override this method to define their own TreeNode class;
			//		However it will probably be removed in a future release in favor of a way
			//		of just specifying a widget for the label, rather than one that contains
			//		the children too.
			return new TreeNode(args);
		},

		focus: function(){
			// summary:
			//		Default focus() implementation: focus the previously focused child, or first child.
			//		Some applications may want to change this method to focus the [first] selected child.

			if(this.lastFocusedChild){
				this.focusNode(this.lastFocusedChild);
			}else{
				this.focusFirstChild();
			}
		}
	});

	if(has("dojo-bidi")){
		Tree.extend({
			_setTextDirAttr: function(textDir){
				if(textDir && this.textDir != textDir){
					this._set("textDir", textDir);
					this.rootNode.set("textDir", textDir);
				}
			}
		});
	}

	Tree.PathError = createError("TreePathError");
	Tree._TreeNode = TreeNode;	// for monkey patching or creating subclasses of TreeNode

	return Tree;
});

},
'dijit/_KeyNavMixin':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/keys", // keys.END keys.HOME, keys.LEFT_ARROW etc.
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dijit/registry",
	"dijit/_FocusMixin"        // to make _onBlur() work
], function(array, declare, domAttr, keys, lang, on, registry, _FocusMixin){

	// module:
	//		dijit/_KeyNavMixin

	return declare("dijit._KeyNavMixin", _FocusMixin, {
		// summary:
		//		A mixin to allow arrow key and letter key navigation of child or descendant widgets.
		//		It can be used by dijit/_Container based widgets with a flat list of children,
		//		or more complex widgets like dijit/Tree.
		//
		//		To use this mixin, the subclass must:
		//
		//			- Implement  _getNext(), _getFirst(), _getLast(), _onLeftArrow(), _onRightArrow()
		//			  _onDownArrow(), _onUpArrow() methods to handle home/end/left/right/up/down keystrokes.
		//			  Next and previous in this context refer to a linear ordering of the descendants used
		//			  by letter key search.
		//			- Set all descendants' initial tabIndex to "-1"; both initial descendants and any
		//			  descendants added later, by for example addChild()
		//			- Define childSelector to a function or string that identifies focusable descendant widgets
		//
		//		Also, child widgets must implement a focus() method.

		/*=====
		 // focusedChild: [protected readonly] Widget
		 //		The currently focused child widget, or null if there isn't one
		 focusedChild: null,

		 // _keyNavCodes: Object
		 //		Hash mapping key code (arrow keys and home/end key) to functions to handle those keys.
		 //		Usually not used directly, as subclasses can instead override _onLeftArrow() etc.
		 _keyNavCodes: {},
		 =====*/

		// tabIndex: String
		//		Tab index of the container; same as HTML tabIndex attribute.
		//		Note then when user tabs into the container, focus is immediately
		//		moved to the first item in the container.
		tabIndex: "0",

		// childSelector: [protected abstract] Function||String
		//		Selector (passed to on.selector()) used to identify what to treat as a child widget.   Used to monitor
		//		focus events and set this.focusedChild.   Must be set by implementing class.   If this is a string
		//		(ex: "> *") then the implementing class must require dojo/query.
		childSelector: null,

		postCreate: function(){
			this.inherited(arguments);

			// Set tabIndex on this.domNode.  Will be automatic after #7381 is fixed.
			domAttr.set(this.domNode, "tabIndex", this.tabIndex);

			if(!this._keyNavCodes){
				var keyCodes = this._keyNavCodes = {};
				keyCodes[keys.HOME] = lang.hitch(this, "focusFirstChild");
				keyCodes[keys.END] = lang.hitch(this, "focusLastChild");
				keyCodes[this.isLeftToRight() ? keys.LEFT_ARROW : keys.RIGHT_ARROW] = lang.hitch(this, "_onLeftArrow");
				keyCodes[this.isLeftToRight() ? keys.RIGHT_ARROW : keys.LEFT_ARROW] = lang.hitch(this, "_onRightArrow");
				keyCodes[keys.UP_ARROW] = lang.hitch(this, "_onUpArrow");
				keyCodes[keys.DOWN_ARROW] = lang.hitch(this, "_onDownArrow");
			}

			var self = this,
				childSelector = typeof this.childSelector == "string"
					? this.childSelector
					: lang.hitch(this, "childSelector");
			this.own(
				on(this.domNode, "keypress", lang.hitch(this, "_onContainerKeypress")),
				on(this.domNode, "keydown", lang.hitch(this, "_onContainerKeydown")),
				on(this.domNode, "focus", lang.hitch(this, "_onContainerFocus")),
				on(this.containerNode, on.selector(childSelector, "focusin"), function(evt){
					self._onChildFocus(registry.getEnclosingWidget(this), evt);
				})
			);
		},

		_onLeftArrow: function(){
			// summary:
			//		Called on left arrow key, or right arrow key if widget is in RTL mode.
			//		Should go back to the previous child in horizontal container widgets like Toolbar.
			// tags:
			//		extension
		},

		_onRightArrow: function(){
			// summary:
			//		Called on right arrow key, or left arrow key if widget is in RTL mode.
			//		Should go to the next child in horizontal container widgets like Toolbar.
			// tags:
			//		extension
		},

		_onUpArrow: function(){
			// summary:
			//		Called on up arrow key. Should go to the previous child in vertical container widgets like Menu.
			// tags:
			//		extension
		},

		_onDownArrow: function(){
			// summary:
			//		Called on down arrow key. Should go to the next child in vertical container widgets like Menu.
			// tags:
			//		extension
		},

		focus: function(){
			// summary:
			//		Default focus() implementation: focus the first child.
			this.focusFirstChild();
		},

		_getFirstFocusableChild: function(){
			// summary:
			//		Returns first child that can be focused.

			// Leverage _getNextFocusableChild() to skip disabled children
			return this._getNextFocusableChild(null, 1);	// dijit/_WidgetBase
		},

		_getLastFocusableChild: function(){
			// summary:
			//		Returns last child that can be focused.

			// Leverage _getNextFocusableChild() to skip disabled children
			return this._getNextFocusableChild(null, -1);	// dijit/_WidgetBase
		},

		focusFirstChild: function(){
			// summary:
			//		Focus the first focusable child in the container.
			// tags:
			//		protected

			this.focusChild(this._getFirstFocusableChild());
		},

		focusLastChild: function(){
			// summary:
			//		Focus the last focusable child in the container.
			// tags:
			//		protected

			this.focusChild(this._getLastFocusableChild());
		},

		focusChild: function(/*dijit/_WidgetBase*/ widget, /*Boolean*/ last){
			// summary:
			//		Focus specified child widget.
			// widget:
			//		Reference to container's child widget
			// last:
			//		If true and if widget has multiple focusable nodes, focus the
			//		last one instead of the first one
			// tags:
			//		protected

			if(!widget){
				return;
			}

			if(this.focusedChild && widget !== this.focusedChild){
				this._onChildBlur(this.focusedChild);	// used to be used by _MenuBase
			}
			widget.set("tabIndex", this.tabIndex);	// for IE focus outline to appear, must set tabIndex before focus
			widget.focus(last ? "end" : "start");

			// Don't set focusedChild here, because the focus event should trigger a call to _onChildFocus(), which will
			// set it.   More importantly, _onChildFocus(), which may be executed asynchronously (after this function
			// returns) needs to know the old focusedChild to set its tabIndex to -1.
		},

		_onContainerFocus: function(evt){
			// summary:
			//		Handler for when the container itself gets focus.
			// description:
			//		Initially the container itself has a tabIndex, but when it gets
			//		focus, switch focus to first child.
			//
			//		TODO for 2.0 (or earlier): Instead of having the container tabbable, always maintain a single child
			//		widget as tabbable, Requires code in startup(), addChild(), and removeChild().
			//		That would avoid various issues like #17347.
			// tags:
			//		private

			// Note that we can't use _onFocus() because switching focus from the
			// _onFocus() handler confuses the focus.js code
			// (because it causes _onFocusNode() to be called recursively).
			// Also, _onFocus() would fire when focus went directly to a child widget due to mouse click.

			// Ignore spurious focus events:
			//	1. focus on a child widget bubbles on FF
			//	2. on IE, clicking the scrollbar of a select dropdown moves focus from the focused child item to me
			if(evt.target !== this.domNode || this.focusedChild){
				return;
			}

			this.focus();
		},

		_onFocus: function(){
			// When the container gets focus by being tabbed into, or a descendant gets focus by being clicked,
			// set the container's tabIndex to -1 (don't remove as that breaks Safari 4) so that tab or shift-tab
			// will go to the fields after/before the container, rather than the container itself
			domAttr.set(this.domNode, "tabIndex", "-1");

			this.inherited(arguments);
		},

		_onBlur: function(evt){
			// When focus is moved away the container, and its descendant (popup) widgets,
			// then restore the container's tabIndex so that user can tab to it again.
			// Note that using _onBlur() so that this doesn't happen when focus is shifted
			// to one of my child widgets (typically a popup)

			// TODO: for 2.0 consider changing this to blur whenever the container blurs, to be truthful that there is
			// no focused child at that time.

			domAttr.set(this.domNode, "tabIndex", this.tabIndex);
			if(this.focusedChild){
				this.focusedChild.set("tabIndex", "-1");
				this.lastFocusedChild = this.focusedChild;
				this._set("focusedChild", null);
			}
			this.inherited(arguments);
		},

		_onChildFocus: function(/*dijit/_WidgetBase*/ child){
			// summary:
			//		Called when a child widget gets focus, either by user clicking
			//		it, or programatically by arrow key handling code.
			// description:
			//		It marks that the current node is the selected one, and the previously
			//		selected node no longer is.

			if(child && child != this.focusedChild){
				if(this.focusedChild && !this.focusedChild._destroyed){
					// mark that the previously focusable node is no longer focusable
					this.focusedChild.set("tabIndex", "-1");
				}

				// mark that the new node is the currently selected one
				child.set("tabIndex", this.tabIndex);
				this.lastFocused = child;		// back-compat for Tree, remove for 2.0
				this._set("focusedChild", child);
			}
		},

		_searchString: "",
		// multiCharSearchDuration: Number
		//		If multiple characters are typed where each keystroke happens within
		//		multiCharSearchDuration of the previous keystroke,
		//		search for nodes matching all the keystrokes.
		//
		//		For example, typing "ab" will search for entries starting with
		//		"ab" unless the delay between "a" and "b" is greater than multiCharSearchDuration.
		multiCharSearchDuration: 1000,

		onKeyboardSearch: function(/*dijit/_WidgetBase*/ item, /*Event*/ evt, /*String*/ searchString, /*Number*/ numMatches){
			// summary:
			//		When a key is pressed that matches a child item,
			//		this method is called so that a widget can take appropriate action is necessary.
			// tags:
			//		protected
			if(item){
				this.focusChild(item);
			}
		},

		_keyboardSearchCompare: function(/*dijit/_WidgetBase*/ item, /*String*/ searchString){
			// summary:
			//		Compares the searchString to the widget's text label, returning:
			//
			//			* -1: a high priority match  and stop searching
			//		 	* 0: not a match
			//		 	* 1: a match but keep looking for a higher priority match
			// tags:
			//		private

			var element = item.domNode,
				text = item.label || (element.focusNode ? element.focusNode.label : '') || element.innerText || element.textContent || "",
				currentString = text.replace(/^\s+/, '').substr(0, searchString.length).toLowerCase();

			return (!!searchString.length && currentString == searchString) ? -1 : 0; // stop searching after first match by default
		},

		_onContainerKeydown: function(evt){
			// summary:
			//		When a key is pressed, if it's an arrow key etc. then it's handled here.
			// tags:
			//		private

			var func = this._keyNavCodes[evt.keyCode];
			if(func){
				func(evt, this.focusedChild);
				evt.stopPropagation();
				evt.preventDefault();
				this._searchString = ''; // so a DOWN_ARROW b doesn't search for ab
			}else if(evt.keyCode == keys.SPACE && this._searchTimer && !(evt.ctrlKey || evt.altKey || evt.metaKey)){
				evt.stopImmediatePropagation(); // stop a11yclick and _HasDropdown from seeing SPACE if we're doing keyboard searching
				evt.preventDefault(); // stop IE from scrolling, and most browsers (except FF) from sending keypress
				this._keyboardSearch(evt, ' ');
			}
		},

		_onContainerKeypress: function(evt){
			// summary:
			//		When a printable key is pressed, it's handled here, searching by letter.
			// tags:
			//		private

			// Ignore:
			// 		- duplicate events on firefox (ex: arrow key that will be handled by keydown handler)
			//		- control sequences like CMD-Q.
			//		- the SPACE key (only occurs on FF)
			//
			// Note: if there's no search in progress, then SPACE should be ignored.   If there is a search
			// in progress, then SPACE is handled in _onContainerKeyDown.
			if(evt.charCode <= keys.SPACE || evt.ctrlKey || evt.altKey || evt.metaKey){
				return;
			}

			evt.preventDefault();
			evt.stopPropagation();

			this._keyboardSearch(evt, String.fromCharCode(evt.charCode).toLowerCase());
		},

		_keyboardSearch: function(/*Event*/ evt, /*String*/ keyChar){
			// summary:
			//		Perform a search of the widget's options based on the user's keyboard activity
			// description:
			//		Called on keypress (and sometimes keydown), searches through this widget's children
			//		looking for items that match the user's typed search string.  Multiple characters
			//		typed within 1 sec of each other are combined for multicharacter searching.
			// tags:
			//		private
			var
				matchedItem = null,
				searchString,
				numMatches = 0,
				search = lang.hitch(this, function(){
					if(this._searchTimer){
						this._searchTimer.remove();
					}
					this._searchString += keyChar;
					var allSameLetter = /^(.)\1*$/.test(this._searchString);
					var searchLen = allSameLetter ? 1 : this._searchString.length;
					searchString = this._searchString.substr(0, searchLen);
					// commented out code block to search again if the multichar search fails after a smaller timeout
					//this._searchTimer = this.defer(function(){ // this is the "failure" timeout
					//	this._typingSlowly = true; // if the search fails, then treat as a full timeout
					//	this._searchTimer = this.defer(function(){ // this is the "success" timeout
					//		this._searchTimer = null;
					//		this._searchString = '';
					//	}, this.multiCharSearchDuration >> 1);
					//}, this.multiCharSearchDuration >> 1);
					this._searchTimer = this.defer(function(){ // this is the "success" timeout
						this._searchTimer = null;
						this._searchString = '';
					}, this.multiCharSearchDuration);
					var currentItem = this.focusedChild || null;
					if(searchLen == 1 || !currentItem){
						currentItem = this._getNextFocusableChild(currentItem, 1); // skip current
						if(!currentItem){
							return;
						} // no items
					}
					var stop = currentItem;
					do{
						var rc = this._keyboardSearchCompare(currentItem, searchString);
						if(!!rc && numMatches++ == 0){
							matchedItem = currentItem;
						}
						if(rc == -1){ // priority match
							numMatches = -1;
							break;
						}
						currentItem = this._getNextFocusableChild(currentItem, 1);
					}while(currentItem != stop);
					// commented out code block to search again if the multichar search fails after a smaller timeout
					//if(!numMatches && (this._typingSlowly || searchLen == 1)){
					//	this._searchString = '';
					//	if(searchLen > 1){
					//		// if no matches and they're typing slowly, then go back to first letter searching
					//		search();
					//	}
					//}
				});

			search();
			// commented out code block to search again if the multichar search fails after a smaller timeout
			//this._typingSlowly = false;
			this.onKeyboardSearch(matchedItem, evt, searchString, numMatches);
		},

		_onChildBlur: function(/*dijit/_WidgetBase*/ /*===== widget =====*/){
			// summary:
			//		Called when focus leaves a child widget to go
			//		to a sibling widget.
			//		Used to be used by MenuBase.js (remove for 2.0)
			// tags:
			//		protected
		},

		_getNextFocusableChild: function(child, dir){
			// summary:
			//		Returns the next or previous focusable descendant, compared to "child".
			//		Implements and extends _KeyNavMixin._getNextFocusableChild() for a _Container.
			// child: Widget
			//		The current widget
			// dir: Integer
			//		- 1 = after
			//		- -1 = before
			// tags:
			//		abstract extension

			var wrappedValue = child;
			do{
				if(!child){
					child = this[dir > 0 ? "_getFirst" : "_getLast"]();
					if(!child){ break; }
				}else{
					child = this._getNext(child, dir);
				}
				if(child != null && child != wrappedValue && child.isFocusable()){
					return child;	// dijit/_WidgetBase
				}
			}while(child != wrappedValue);
			// no focusable child found
			return null;	// dijit/_WidgetBase
		},

		_getFirst: function(){
			// summary:
			//		Returns the first child.
			// tags:
			//		abstract extension

			return null;	// dijit/_WidgetBase
		},

		_getLast: function(){
			// summary:
			//		Returns the last descendant.
			// tags:
			//		abstract extension

			return null;	// dijit/_WidgetBase
		},

		_getNext: function(child, dir){
			// summary:
			//		Returns the next descendant, compared to "child".
			// child: Widget
			//		The current widget
			// dir: Integer
			//		- 1 = after
			//		- -1 = before
			// tags:
			//		abstract extension

			if(child){
				child = child.domNode;
				while(child){
					child = child[dir < 0 ? "previousSibling" : "nextSibling"];
					if(child  && "getAttribute" in child){
						var w = registry.byNode(child);
						if(w){
							return w; // dijit/_WidgetBase
						}
					}
				}
			}
			return null;	// dijit/_WidgetBase
		}
	});
});

},
'dijit/tree/_dndSelector':function(){
define([
	"dojo/_base/array", // array.filter array.forEach array.map
	"dojo/_base/declare", // declare
	"dojo/_base/kernel",	// global
	"dojo/_base/lang", // lang.hitch
	"dojo/dnd/common",
	"dojo/dom", // isDescendant
	"dojo/mouse", // mouse.isLeft
	"dojo/on",
	"dojo/touch",
	"../a11yclick",
	"./_dndContainer"
], function(array, declare, kernel, lang, dndCommon, dom, mouse, on, touch, a11yclick, _dndContainer){

	// module:
	//		dijit/tree/_dndSelector

	return declare("dijit.tree._dndSelector", _dndContainer, {
		// summary:
		//		This is a base class for `dijit/tree/dndSource`, and isn't meant to be used directly.
		//		It's based on `dojo/dnd/Selector`.
		// tags:
		//		protected

		/*=====
		// selection: Object
		//		(id to DomNode) map for every TreeNode that's currently selected.
		//		The DOMNode is the TreeNode.rowNode.
		selection: {},
		=====*/

		constructor: function(){
			// summary:
			//		Initialization
			// tags:
			//		private

			this.selection={};
			this.anchor = null;

			this.events.push(
				// listeners setup here but no longer used (left for backwards compatibility
				on(this.tree.domNode, touch.press, lang.hitch(this,"onMouseDown")),
				on(this.tree.domNode, touch.release, lang.hitch(this,"onMouseUp")),

				// listeners used in this module
				on(this.tree.domNode, touch.move, lang.hitch(this,"onMouseMove")),
				on(this.tree.domNode, a11yclick.press, lang.hitch(this,"onClickPress")),
				on(this.tree.domNode, a11yclick.release, lang.hitch(this,"onClickRelease"))
			);
		},

		// singular: Boolean
		//		Allows selection of only one element, if true.
		//		Tree hasn't been tested in singular=true mode, unclear if it works.
		singular: false,

		// methods
		getSelectedTreeNodes: function(){
			// summary:
			//		Returns a list of selected node(s).
			//		Used by dndSource on the start of a drag.
			// tags:
			//		protected
			var nodes=[], sel = this.selection;
			for(var i in sel){
				nodes.push(sel[i]);
			}
			return nodes;
		},

		selectNone: function(){
			// summary:
			//		Unselects all items
			// tags:
			//		private

			this.setSelection([]);
			return this;	// self
		},

		destroy: function(){
			// summary:
			//		Prepares the object to be garbage-collected
			this.inherited(arguments);
			this.selection = this.anchor = null;
		},
		addTreeNode: function(/*dijit/Tree._TreeNode*/ node, /*Boolean?*/isAnchor){
			// summary:
			//		add node to current selection
			// node: Node
			//		node to add
			// isAnchor: Boolean
			//		Whether the node should become anchor.

			this.setSelection(this.getSelectedTreeNodes().concat( [node] ));
			if(isAnchor){ this.anchor = node; }
			return node;
		},
		removeTreeNode: function(/*dijit/Tree._TreeNode*/ node){
			// summary:
			//		remove node and it's descendants from current selection
			// node: Node
			//		node to remove
			var newSelection = array.filter(this.getSelectedTreeNodes(), function(selectedNode){
				return !dom.isDescendant(selectedNode.domNode, node.domNode); // also matches when selectedNode == node
			});
			this.setSelection(newSelection);
			return node;
		},
		isTreeNodeSelected: function(/*dijit/Tree._TreeNode*/ node){
			// summary:
			//		return true if node is currently selected
			// node: Node
			//		the node to check whether it's in the current selection

			return node.id && !!this.selection[node.id];
		},
		setSelection: function(/*dijit/Tree._TreeNode[]*/ newSelection){
			// summary:
			//		set the list of selected nodes to be exactly newSelection. All changes to the
			//		selection should be passed through this function, which ensures that derived
			//		attributes are kept up to date. Anchor will be deleted if it has been removed
			//		from the selection, but no new anchor will be added by this function.
			// newSelection: Node[]
			//		list of tree nodes to make selected
			var oldSelection = this.getSelectedTreeNodes();
			array.forEach(this._setDifference(oldSelection, newSelection), lang.hitch(this, function(node){
				node.setSelected(false);
				if(this.anchor == node){
					delete this.anchor;
				}
				delete this.selection[node.id];
			}));
			array.forEach(this._setDifference(newSelection, oldSelection), lang.hitch(this, function(node){
				node.setSelected(true);
				this.selection[node.id] = node;
			}));
			this._updateSelectionProperties();
		},
		_setDifference: function(xs,ys){
			// summary:
			//		Returns a copy of xs which lacks any objects
			//		occurring in ys. Checks for membership by
			//		modifying and then reading the object, so it will
			//		not properly handle sets of numbers or strings.

			array.forEach(ys, function(y){ y.__exclude__ = true; });
			var ret = array.filter(xs, function(x){ return !x.__exclude__; });

			// clean up after ourselves.
			array.forEach(ys, function(y){ delete y['__exclude__'] });
			return ret;
		},
		_updateSelectionProperties: function(){
			// summary:
			//		Update the following tree properties from the current selection:
			//		path[s], selectedItem[s], selectedNode[s]

			var selected = this.getSelectedTreeNodes();
			var paths = [], nodes = [];
			array.forEach(selected, function(node){
				var ary = node.getTreePath();
				nodes.push(node);
				paths.push(ary);
			}, this);
			var items = array.map(nodes,function(node){ return node.item; });
			this.tree._set("paths", paths);
			this.tree._set("path", paths[0] || []);
			this.tree._set("selectedNodes", nodes);
			this.tree._set("selectedNode", nodes[0] || null);
			this.tree._set("selectedItems", items);
			this.tree._set("selectedItem", items[0] || null);
		},

		// selection related events
		onClickPress: function(e){
			// summary:
			//		Event processor for onmousedown/ontouchstart/onkeydown corresponding to a click event
			// e: Event
			//		onmousedown/ontouchstart/onkeydown event
			// tags:
			//		protected

			// ignore mouse or touch on expando node
			if(this.current && this.current.isExpandable && this.tree.isExpandoNode(e.target, this.current)){ return; }

			if(e.type == "mousedown" && mouse.isLeft(e)){
				// Prevent text selection while dragging on desktop, see #16328.   But don't call preventDefault()
				// for mobile because it will break things completely, see #15838.  Also, don't preventDefault() on
				// MSPointerDown or pointerdown events, because that stops the mousedown event from being generated,
				// see #17709.
				// TODO: remove this completely in 2.0.  It shouldn't be needed since dojo/dnd/Manager already
				// calls preventDefault() for the "selectstart" event.  It can also be achieved via CSS:
				// http://stackoverflow.com/questions/826782/css-rule-to-disable-text-selection-highlighting
				e.preventDefault();
			}

			var treeNode = e.type == "keydown" ? this.tree.focusedChild : this.current;

			if(!treeNode){
				// Click must be on the Tree but not on a TreeNode, happens especially when Tree is stretched to fill
				// a pane of a BorderContainer, etc.
				return;
			}

			var copy = dndCommon.getCopyKeyState(e), id = treeNode.id;

			// if shift key is not pressed, and the node is already in the selection,
			// delay deselection until onmouseup so in the case of DND, deselection
			// will be canceled by onmousemove.
			if(!this.singular && !e.shiftKey && this.selection[id]){
				this._doDeselect = true;
				return;
			}else{
				this._doDeselect = false;
			}
			this.userSelect(treeNode, copy, e.shiftKey);
		},

		onClickRelease: function(e){
			// summary:
			//		Event processor for onmouseup/ontouchend/onkeyup corresponding to a click event
			// e: Event
			//		onmouseup/ontouchend/onkeyup event
			// tags:
			//		protected

			// _doDeselect is the flag to indicate that the user wants to either ctrl+click on
			// an already selected item (to deselect the item), or click on a not-yet selected item
			// (which should remove all current selection, and add the clicked item). This can not
			// be done in onMouseDown, because the user may start a drag after mousedown. By moving
			// the deselection logic here, the user can drag an already selected item.
			if(!this._doDeselect){ return; }
			this._doDeselect = false;
			this.userSelect(e.type == "keyup" ? this.tree.focusedChild : this.current, dndCommon.getCopyKeyState(e), e.shiftKey);
		},
		onMouseMove: function(/*===== e =====*/){
			// summary:
			//		event processor for onmousemove/ontouchmove
			// e: Event
			//		onmousemove/ontouchmove event
			this._doDeselect = false;
		},

		// mouse/touch events that are no longer used
		onMouseDown: function(){
			// summary:
			//		Event processor for onmousedown/ontouchstart
			// e: Event
			//		onmousedown/ontouchstart event
			// tags:
			//		protected
		},
		onMouseUp: function(){
			// summary:
			//		Event processor for onmouseup/ontouchend
			// e: Event
			//		onmouseup/ontouchend event
			// tags:
			//		protected
		},

		_compareNodes: function(n1, n2){
			if(n1 === n2){
				return 0;
			}

			if('sourceIndex' in document.documentElement){ //IE
				//TODO: does not yet work if n1 and/or n2 is a text node
				return n1.sourceIndex - n2.sourceIndex;
			}else if('compareDocumentPosition' in document.documentElement){ //FF, Opera
				return n1.compareDocumentPosition(n2) & 2 ? 1: -1;
			}else if(document.createRange){ //Webkit
				var r1 = doc.createRange();
				r1.setStartBefore(n1);

				var r2 = doc.createRange();
				r2.setStartBefore(n2);

				return r1.compareBoundaryPoints(r1.END_TO_END, r2);
			}else{
				throw Error("dijit.tree._compareNodes don't know how to compare two different nodes in this browser");
			}
		},

		userSelect: function(node, multi, range){
			// summary:
			//		Add or remove the given node from selection, responding
			//		to a user action such as a click or keypress.
			// multi: Boolean
			//		Indicates whether this is meant to be a multi-select action (e.g. ctrl-click)
			// range: Boolean
			//		Indicates whether this is meant to be a ranged action (e.g. shift-click)
			// tags:
			//		protected

			if(this.singular){
				if(this.anchor == node && multi){
					this.selectNone();
				}else{
					this.setSelection([node]);
					this.anchor = node;
				}
			}else{
				if(range && this.anchor){
					var cr = this._compareNodes(this.anchor.rowNode, node.rowNode),
					begin, end, anchor = this.anchor;

					if(cr < 0){ //current is after anchor
						begin = anchor;
						end = node;
					}else{ //current is before anchor
						begin = node;
						end = anchor;
					}
					var nodes = [];
					//add everything betweeen begin and end inclusively
					while(begin != end){
						nodes.push(begin);
						begin = this.tree._getNext(begin);
					}
					nodes.push(end);

					this.setSelection(nodes);
				}else{
					if( this.selection[ node.id ] && multi ){
						this.removeTreeNode( node );
					}else if(multi){
						this.addTreeNode(node, true);
					}else{
						this.setSelection([node]);
						this.anchor = node;
					}
				}
			}
		},

		getItem: function(/*String*/ key){
			// summary:
			//		Returns the dojo/dnd/Container._Item (representing a dragged node) by it's key (id).
			//		Called by dojo/dnd/Source.checkAcceptance().
			// tags:
			//		protected

			var widget = this.selection[key];
			return {
				data: widget,
				type: ["treeNode"]
			}; // dojo/dnd/Container._Item
		},

		forInSelectedItems: function(/*Function*/ f, /*Object?*/ o){
			// summary:
			//		Iterates over selected items;
			//		see `dojo/dnd/Container.forInItems()` for details
			o = o || kernel.global;
			for(var id in this.selection){
				// console.log("selected item id: " + id);
				f.call(o, this.getItem(id), id, this);
			}
		}
	});
});

},
'dijit/tree/_dndContainer':function(){
define([
	"dojo/aspect", // aspect.after
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.remove domClass.replace
	"dojo/_base/lang", // lang.mixin lang.hitch
	"dojo/on",
	"dojo/touch"
], function(aspect, declare, domClass, lang, on, touch){

	// module:
	//		dijit/tree/_dndContainer

	/*=====
	 var __Args = {
	 // summary:
	 //		A dict of parameters for Tree source configuration.
	 // isSource: Boolean?
	 //		Can be used as a DnD source. Defaults to true.
	 // accept: String[]
	 //		List of accepted types (text strings) for a target; defaults to
	 //		["text", "treeNode"]
	 // copyOnly: Boolean?
	 //		Copy items, if true, use a state of Ctrl key otherwise,
	 // dragThreshold: Number
	 //		The move delay in pixels before detecting a drag; 0 by default
	 // betweenThreshold: Integer
	 //		Distance from upper/lower edge of node to allow drop to reorder nodes
	 };
	 =====*/

	return declare("dijit.tree._dndContainer", null, {

		// summary:
		//		This is a base class for `dijit/tree/_dndSelector`, and isn't meant to be used directly.
		//		It's modeled after `dojo/dnd/Container`.
		// tags:
		//		protected

		/*=====
		 // current: TreeNode
		 //		The currently hovered TreeNode.  Not set to anything for keyboard operation.  (TODO: change?)
		 current: null,
		 =====*/

		constructor: function(tree, params){
			// summary:
			//		A constructor of the Container
			// tree: Node
			//		Node or node's id to build the container on
			// params: __Args
			//		A dict of parameters, which gets mixed into the object
			// tags:
			//		private
			this.tree = tree;
			this.node = tree.domNode;	// TODO: rename; it's not a TreeNode but the whole Tree
			lang.mixin(this, params);

			// states
			this.containerState = "";
			domClass.add(this.node, "dojoDndContainer");

			// set up events
			this.events = [
				// Mouse (or touch) enter/leave on Tree itself
				on(this.node, touch.enter, lang.hitch(this, "onOverEvent")),
				on(this.node, touch.leave, lang.hitch(this, "onOutEvent")),

				// switching between TreeNodes
				aspect.after(this.tree, "_onNodeMouseEnter", lang.hitch(this, "onMouseOver"), true),
				aspect.after(this.tree, "_onNodeMouseLeave", lang.hitch(this, "onMouseOut"), true),

				// cancel text selection and text dragging
				on(this.node, "dragstart, selectstart", function(evt){
					evt.preventDefault();
				})
			];
		},

		destroy: function(){
			// summary:
			//		Prepares this object to be garbage-collected

			var h;
			while(h = this.events.pop()){
				h.remove();
			}

			// this.clearItems();
			this.node = this.parent = null;
		},

		// mouse events
		onMouseOver: function(widget /*===== , evt =====*/){
			// summary:
			//		Called when mouse is moved over a TreeNode
			// widget: TreeNode
			// evt: Event
			// tags:
			//		protected
			this.current = widget;
		},

		onMouseOut: function(/*===== widget, evt =====*/){
			// summary:
			//		Called when mouse is moved away from a TreeNode
			// widget: TreeNode
			// evt: Event
			// tags:
			//		protected
			this.current = null;
		},

		_changeState: function(type, newState){
			// summary:
			//		Changes a named state to new state value
			// type: String
			//		A name of the state to change
			// newState: String
			//		new state
			var prefix = "dojoDnd" + type;
			var state = type.toLowerCase() + "State";
			//domClass.replace(this.node, prefix + newState, prefix + this[state]);
			domClass.replace(this.node, prefix + newState, prefix + this[state]);
			this[state] = newState;
		},

		_addItemClass: function(node, type){
			// summary:
			//		Adds a class with prefix "dojoDndItem"
			// node: Node
			//		A node
			// type: String
			//		A variable suffix for a class name
			domClass.add(node, "dojoDndItem" + type);
		},

		_removeItemClass: function(node, type){
			// summary:
			//		Removes a class with prefix "dojoDndItem"
			// node: Node
			//		A node
			// type: String
			//		A variable suffix for a class name
			domClass.remove(node, "dojoDndItem" + type);
		},

		onOverEvent: function(){
			// summary:
			//		This function is called once, when mouse is over our container
			// tags:
			//		protected
			this._changeState("Container", "Over");
		},

		onOutEvent: function(){
			// summary:
			//		This function is called once, when mouse is out of our container
			// tags:
			//		protected
			this._changeState("Container", "");
		}
	});
});

},
'dijit/WidgetSet':function(){
define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/declare", // declare
	"dojo/_base/kernel", // kernel.global
	"./registry"	// to add functions to dijit.registry
], function(array, declare, kernel, registry){

	// module:
	//		dijit/WidgetSet

	var WidgetSet = declare("dijit.WidgetSet", null, {
		// summary:
		//		A set of widgets indexed by id.
		//		Deprecated, will be removed in 2.0.
		//
		// example:
		//		Create a small list of widgets:
		//		|	require(["dijit/WidgetSet", "dijit/registry"],
		//		|		function(WidgetSet, registry){
		//		|		var ws = new WidgetSet();
		//		|		ws.add(registry.byId("one"));
		//		|		ws.add(registry.byId("two"));
		//		|		// destroy both:
		//		|		ws.forEach(function(w){ w.destroy(); });
		//		|	});

		constructor: function(){
			this._hash = {};
			this.length = 0;
		},

		add: function(/*dijit/_WidgetBase*/ widget){
			// summary:
			//		Add a widget to this list. If a duplicate ID is detected, a error is thrown.
			//
			// widget: dijit/_WidgetBase
			//		Any dijit/_WidgetBase subclass.
			if(this._hash[widget.id]){
				throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
			}
			this._hash[widget.id] = widget;
			this.length++;
		},

		remove: function(/*String*/ id){
			// summary:
			//		Remove a widget from this WidgetSet. Does not destroy the widget; simply
			//		removes the reference.
			if(this._hash[id]){
				delete this._hash[id];
				this.length--;
			}
		},

		forEach: function(/*Function*/ func, /* Object? */thisObj){
			// summary:
			//		Call specified function for each widget in this set.
			//
			// func:
			//		A callback function to run for each item. Is passed the widget, the index
			//		in the iteration, and the full hash, similar to `array.forEach`.
			//
			// thisObj:
			//		An optional scope parameter
			//
			// example:
			//		Using the default `dijit.registry` instance:
			//		|	require(["dijit/WidgetSet", "dijit/registry"],
			//		|		function(WidgetSet, registry){
			//		|		registry.forEach(function(widget){
			//		|			console.log(widget.declaredClass);
			//		|		});
			//		|	});
			//
			// returns:
			//		Returns self, in order to allow for further chaining.

			thisObj = thisObj || kernel.global;
			var i = 0, id;
			for(id in this._hash){
				func.call(thisObj, this._hash[id], i++, this._hash);
			}
			return this;	// dijit/WidgetSet
		},

		filter: function(/*Function*/ filter, /* Object? */thisObj){
			// summary:
			//		Filter down this WidgetSet to a smaller new WidgetSet
			//		Works the same as `array.filter` and `NodeList.filter`
			//
			// filter:
			//		Callback function to test truthiness. Is passed the widget
			//		reference and the pseudo-index in the object.
			//
			// thisObj: Object?
			//		Option scope to use for the filter function.
			//
			// example:
			//		Arbitrary: select the odd widgets in this list
			//		|	
			//		|		
			//		|	
			//		|	require(["dijit/WidgetSet", "dijit/registry"],
			//		|		function(WidgetSet, registry){
			//		|		registry.filter(function(w, i){
			//		|			return i % 2 == 0;
			//		|		}).forEach(function(w){ /* odd ones */ });
			//		|	});

			thisObj = thisObj || kernel.global;
			var res = new WidgetSet(), i = 0, id;
			for(id in this._hash){
				var w = this._hash[id];
				if(filter.call(thisObj, w, i++, this._hash)){
					res.add(w);
				}
			}
			return res; // dijit/WidgetSet
		},

		byId: function(/*String*/ id){
			// summary:
			//		Find a widget in this list by it's id.
			// example:
			//		Test if an id is in a particular WidgetSet
			//		|	require(["dijit/WidgetSet", "dijit/registry"],
			//		|		function(WidgetSet, registry){
			//		|		var ws = new WidgetSet();
			//		|		ws.add(registry.byId("bar"));
			//		|		var t = ws.byId("bar") // returns a widget
			//		|		var x = ws.byId("foo"); // returns undefined
			//		|	});

			return this._hash[id];	// dijit/_WidgetBase
		},

		byClass: function(/*String*/ cls){
			// summary:
			//		Reduce this widgetset to a new WidgetSet of a particular `declaredClass`
			//
			// cls: String
			//		The Class to scan for. Full dot-notated string.
			//
			// example:
			//		Find all `dijit.TitlePane`s in a page:
			//		|	require(["dijit/WidgetSet", "dijit/registry"],
			//		|		function(WidgetSet, registry){
			//		|		registry.byClass("dijit.TitlePane").forEach(function(tp){ tp.close(); });
			//		|	});

			var res = new WidgetSet(), id, widget;
			for(id in this._hash){
				widget = this._hash[id];
				if(widget.declaredClass == cls){
					res.add(widget);
				}
			 }
			 return res; // dijit/WidgetSet
		},

		toArray: function(){
			// summary:
			//		Convert this WidgetSet into a true Array
			//
			// example:
			//		Work with the widget .domNodes in a real Array
			//		|	require(["dijit/WidgetSet", "dijit/registry"],
			//		|		function(WidgetSet, registry){
			//		|		array.map(registry.toArray(), function(w){ return w.domNode; });
			//		|	});


			var ar = [];
			for(var id in this._hash){
				ar.push(this._hash[id]);
			}
			return ar;	// dijit/_WidgetBase[]
		},

		map: function(/* Function */func, /* Object? */thisObj){
			// summary:
			//		Create a new Array from this WidgetSet, following the same rules as `array.map`
			// example:
			//		|	require(["dijit/WidgetSet", "dijit/registry"],
			//		|		function(WidgetSet, registry){
			//		|		var nodes = registry.map(function(w){ return w.domNode; });
			//		|	});
			//
			// returns:
			//		A new array of the returned values.
			return array.map(this.toArray(), func, thisObj); // Array
		},

		every: function(func, thisObj){
			// summary:
			//		A synthetic clone of `array.every` acting explicitly on this WidgetSet
			//
			// func: Function
			//		A callback function run for every widget in this list. Exits loop
			//		when the first false return is encountered.
			//
			// thisObj: Object?
			//		Optional scope parameter to use for the callback

			thisObj = thisObj || kernel.global;
			var x = 0, i;
			for(i in this._hash){
				if(!func.call(thisObj, this._hash[i], x++, this._hash)){
					return false; // Boolean
				}
			}
			return true; // Boolean
		},

		some: function(func, thisObj){
			// summary:
			//		A synthetic clone of `array.some` acting explicitly on this WidgetSet
			//
			// func: Function
			//		A callback function run for every widget in this list. Exits loop
			//		when the first true return is encountered.
			//
			// thisObj: Object?
			//		Optional scope parameter to use for the callback

			thisObj = thisObj || kernel.global;
			var x = 0, i;
			for(i in this._hash){
				if(func.call(thisObj, this._hash[i], x++, this._hash)){
					return true; // Boolean
				}
			}
			return false; // Boolean
		}

	});

	// Add in 1.x compatibility methods to dijit/registry.
	// These functions won't show up in the API doc but since they are deprecated anyway,
	// that's probably for the best.
	array.forEach(["forEach", "filter", "byClass", "map", "every", "some"], function(func){
		registry[func] = WidgetSet.prototype[func];
	});


	return WidgetSet;
});

},
'dijit/_base':function(){
define([
	"./main",
	"./a11y",	// used to be in dijit/_base/manager
	"./WidgetSet",	// used to be in dijit/_base/manager
	"./_base/focus",
	"./_base/manager",
	"./_base/place",
	"./_base/popup",
	"./_base/scroll",
	"./_base/sniff",
	"./_base/typematic",
	"./_base/wai",
	"./_base/window"
], function(dijit){

	// module:
	//		dijit/_base

	/*=====
	return {
		// summary:
		//		Includes all the modules in dijit/_base
	};
	=====*/

	return dijit._base;
});

},
'dijit/_base/focus':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/dom", // dom.isDescendant
	"dojo/_base/lang", // lang.isArray
	"dojo/topic", // publish
	"dojo/_base/window", // win.doc win.doc.selection win.global win.global.getSelection win.withGlobal
	"../focus",
	"../selection",
	"../main"	// for exporting symbols to dijit
], function(array, dom, lang, topic, win, focus, selection, dijit){

	// module:
	//		dijit/_base/focus

	var exports = {
		// summary:
		//		Deprecated module to monitor currently focused node and stack of currently focused widgets.
		//		New code should access dijit/focus directly.

		// _curFocus: DomNode
		//		Currently focused item on screen
		_curFocus: null,

		// _prevFocus: DomNode
		//		Previously focused item on screen
		_prevFocus: null,

		isCollapsed: function(){
			// summary:
			//		Returns true if there is no text selected
			return dijit.getBookmark().isCollapsed;
		},

		getBookmark: function(){
			// summary:
			//		Retrieves a bookmark that can be used with moveToBookmark to return to the same range
			var sel = win.global == window ? selection : new selection.SelectionManager(win.global);
			return sel.getBookmark();
		},

		moveToBookmark: function(/*Object*/ bookmark){
			// summary:
			//		Moves current selection to a bookmark
			// bookmark:
			//		This should be a returned object from dijit.getBookmark()

			var sel = win.global == window ? selection : new selection.SelectionManager(win.global);
			return sel.moveToBookmark(bookmark);
		},

		getFocus: function(/*Widget?*/ menu, /*Window?*/ openedForWindow){
			// summary:
			//		Called as getFocus(), this returns an Object showing the current focus
			//		and selected text.
			//
			//		Called as getFocus(widget), where widget is a (widget representing) a button
			//		that was just pressed, it returns where focus was before that button
			//		was pressed.   (Pressing the button may have either shifted focus to the button,
			//		or removed focus altogether.)   In this case the selected text is not returned,
			//		since it can't be accurately determined.
			//
			// menu: dijit/_WidgetBase|{domNode: DomNode} structure
			//		The button that was just pressed.  If focus has disappeared or moved
			//		to this button, returns the previous focus.  In this case the bookmark
			//		information is already lost, and null is returned.
			//
			// openedForWindow:
			//		iframe in which menu was opened
			//
			// returns:
			//		A handle to restore focus/selection, to be passed to `dijit.focus`
			var node = !focus.curNode || (menu && dom.isDescendant(focus.curNode, menu.domNode)) ? dijit._prevFocus : focus.curNode;
			return {
				node: node,
				bookmark: node && (node == focus.curNode) && win.withGlobal(openedForWindow || win.global, dijit.getBookmark),
				openedForWindow: openedForWindow
			}; // Object
		},

		// _activeStack: dijit/_WidgetBase[]
		//		List of currently active widgets (focused widget and it's ancestors)
		_activeStack: [],

		registerIframe: function(/*DomNode*/ iframe){
			// summary:
			//		Registers listeners on the specified iframe so that any click
			//		or focus event on that iframe (or anything in it) is reported
			//		as a focus/click event on the `<iframe>` itself.
			// description:
			//		Currently only used by editor.
			// returns:
			//		Handle to pass to unregisterIframe()
			return focus.registerIframe(iframe);
		},

		unregisterIframe: function(/*Object*/ handle){
			// summary:
			//		Unregisters listeners on the specified iframe created by registerIframe.
			//		After calling be sure to delete or null out the handle itself.
			// handle:
			//		Handle returned by registerIframe()

			handle && handle.remove();
		},

		registerWin: function(/*Window?*/targetWindow, /*DomNode?*/ effectiveNode){
			// summary:
			//		Registers listeners on the specified window (either the main
			//		window or an iframe's window) to detect when the user has clicked somewhere
			//		or focused somewhere.
			// description:
			//		Users should call registerIframe() instead of this method.
			// targetWindow:
			//		If specified this is the window associated with the iframe,
			//		i.e. iframe.contentWindow.
			// effectiveNode:
			//		If specified, report any focus events inside targetWindow as
			//		an event on effectiveNode, rather than on evt.target.
			// returns:
			//		Handle to pass to unregisterWin()

			return focus.registerWin(targetWindow, effectiveNode);
		},

		unregisterWin: function(/*Handle*/ handle){
			// summary:
			//		Unregisters listeners on the specified window (either the main
			//		window or an iframe's window) according to handle returned from registerWin().
			//		After calling be sure to delete or null out the handle itself.

			handle && handle.remove();
		}
	};

	// Override focus singleton's focus function so that dijit.focus()
	// has backwards compatible behavior of restoring selection (although
	// probably no one is using that).
	focus.focus = function(/*Object|DomNode */ handle){
		// summary:
		//		Sets the focused node and the selection according to argument.
		//		To set focus to an iframe's content, pass in the iframe itself.
		// handle:
		//		object returned by get(), or a DomNode

		if(!handle){ return; }

		var node = "node" in handle ? handle.node : handle,		// because handle is either DomNode or a composite object
			bookmark = handle.bookmark,
			openedForWindow = handle.openedForWindow,
			collapsed = bookmark ? bookmark.isCollapsed : false;

		// Set the focus
		// Note that for iframe's we need to use the <iframe> to follow the parentNode chain,
		// but we need to set focus to iframe.contentWindow
		if(node){
			var focusNode = (node.tagName.toLowerCase() == "iframe") ? node.contentWindow : node;
			if(focusNode && focusNode.focus){
				try{
					// Gecko throws sometimes if setting focus is impossible,
					// node not displayed or something like that
					focusNode.focus();
				}catch(e){/*quiet*/}
			}
			focus._onFocusNode(node);
		}

		// set the selection
		// do not need to restore if current selection is not empty
		// (use keyboard to select a menu item) or if previous selection was collapsed
		// as it may cause focus shift (Esp in IE).
		if(bookmark && win.withGlobal(openedForWindow || win.global, dijit.isCollapsed) && !collapsed){
			if(openedForWindow){
				openedForWindow.focus();
			}
			try{
				win.withGlobal(openedForWindow || win.global, dijit.moveToBookmark, null, [bookmark]);
			}catch(e2){
				/*squelch IE internal error, see http://trac.dojotoolkit.org/ticket/1984 */
			}
		}
	};

	// For back compatibility, monitor changes to focused node and active widget stack,
	// publishing events and copying changes from focus manager variables into dijit (top level) variables
	focus.watch("curNode", function(name, oldVal, newVal){
		dijit._curFocus = newVal;
		dijit._prevFocus = oldVal;
		if(newVal){
			topic.publish("focusNode", newVal);	// publish
		}
	});
	focus.watch("activeStack", function(name, oldVal, newVal){
		dijit._activeStack = newVal;
	});

	focus.on("widget-blur", function(widget, by){
		topic.publish("widgetBlur", widget, by);	// publish
	});
	focus.on("widget-focus", function(widget, by){
		topic.publish("widgetFocus", widget, by);	// publish
	});

	lang.mixin(dijit, exports);

	/*===== return exports; =====*/
	return dijit;	// for back compat :-(
});

},
'dijit/selection':function(){
define([
	"dojo/_base/array",
	"dojo/dom", // dom.byId
	"dojo/_base/lang",
	"dojo/sniff", // has("ie") has("opera")
	"dojo/_base/window",
	"dijit/focus"
], function(array, dom, lang, has, baseWindow, focus){

	// module:
	//		dijit/selection

	// Note that this class is using feature detection, but doesn't use has() because sometimes on IE the outer window
	// may be running in standards mode (ie, IE9 mode) but an iframe may be in compatibility mode.   So the code path
	// used will vary based on the window.

	var SelectionManager = function(win){
		// summary:
		//		Class for monitoring / changing the selection (typically highlighted text) in a given window
		// win: Window
		//		The window to monitor/adjust the selection on.

		var doc = win.document;

		this.getType = function(){
			// summary:
			//		Get the selection type (like doc.select.type in IE).
			if(doc.getSelection){
				// W3C path
				var stype = "text";

				// Check if the actual selection is a CONTROL (IMG, TABLE, HR, etc...).
				var oSel;
				try{
					oSel = win.getSelection();
				}catch(e){ /*squelch*/ }

				if(oSel && oSel.rangeCount == 1){
					var oRange = oSel.getRangeAt(0);
					if(	(oRange.startContainer == oRange.endContainer) &&
						((oRange.endOffset - oRange.startOffset) == 1) &&
						(oRange.startContainer.nodeType != 3 /* text node*/)
						){
						stype = "control";
					}
				}
				return stype; //String
			}else{
				// IE6-8
				return doc.selection.type.toLowerCase();
			}
		};

		this.getSelectedText = function(){
			// summary:
			//		Return the text (no html tags) included in the current selection or null if no text is selected
			if(doc.getSelection){
				// W3C path
				var selection = win.getSelection();
				return selection ? selection.toString() : ""; //String
			}else{
				// IE6-8
				if(this.getType() == 'control'){
					return null;
				}
				return doc.selection.createRange().text;
			}
		};

		this.getSelectedHtml = function(){
			// summary:
			//		Return the html text of the current selection or null if unavailable
			if(doc.getSelection){
				// W3C path
				var selection = win.getSelection();
				if(selection && selection.rangeCount){
					var i;
					var html = "";
					for(i = 0; i < selection.rangeCount; i++){
						//Handle selections spanning ranges, such as Opera
						var frag = selection.getRangeAt(i).cloneContents();
						var div = doc.createElement("div");
						div.appendChild(frag);
						html += div.innerHTML;
					}
					return html; //String
				}
				return null;
			}else{
				// IE6-8
				if(this.getType() == 'control'){
					return null;
				}
				return doc.selection.createRange().htmlText;
			}
		};

		this.getSelectedElement = function(){
			// summary:
			//		Retrieves the selected element (if any), just in the case that
			//		a single element (object like and image or a table) is
			//		selected.
			if(this.getType() == "control"){
				if(doc.getSelection){
					// W3C path
					var selection = win.getSelection();
					return selection.anchorNode.childNodes[ selection.anchorOffset ];
				}else{
					// IE6-8
					var range = doc.selection.createRange();
					if(range && range.item){
						return doc.selection.createRange().item(0);
					}
				}
			}
			return null;
		};

		this.getParentElement = function(){
			// summary:
			//		Get the parent element of the current selection
			if(this.getType() == "control"){
				var p = this.getSelectedElement();
				if(p){ return p.parentNode; }
			}else{
				if(doc.getSelection){
					var selection = doc.getSelection();
					if(selection){
						var node = selection.anchorNode;
						while(node && (node.nodeType != 1)){ // not an element
							node = node.parentNode;
						}
						return node;
					}
				}else{
					var r = doc.selection.createRange();
					r.collapse(true);
					return r.parentElement();
				}
			}
			return null;
		};

		this.hasAncestorElement = function(/*String*/ tagName /* ... */){
			// summary:
			//		Check whether current selection has a  parent element which is
			//		of type tagName (or one of the other specified tagName)
			// tagName: String
			//		The tag name to determine if it has an ancestor of.
			return this.getAncestorElement.apply(this, arguments) != null; //Boolean
		};

		this.getAncestorElement = function(/*String*/ tagName /* ... */){
			// summary:
			//		Return the parent element of the current selection which is of
			//		type tagName (or one of the other specified tagName)
			// tagName: String
			//		The tag name to determine if it has an ancestor of.
			var node = this.getSelectedElement() || this.getParentElement();
			return this.getParentOfType(node, arguments); //DOMNode
		};

		this.isTag = function(/*DomNode*/ node, /*String[]*/ tags){
			// summary:
			//		Function to determine if a node is one of an array of tags.
			// node:
			//		The node to inspect.
			// tags:
			//		An array of tag name strings to check to see if the node matches.
			if(node && node.tagName){
				var _nlc = node.tagName.toLowerCase();
				for(var i=0; i<tags.length; i++){
					var _tlc = String(tags[i]).toLowerCase();
					if(_nlc == _tlc){
						return _tlc; // String
					}
				}
			}
			return "";
		};

		this.getParentOfType = function(/*DomNode*/ node, /*String[]*/ tags){
			// summary:
			//		Function to locate a parent node that matches one of a set of tags
			// node:
			//		The node to inspect.
			// tags:
			//		An array of tag name strings to check to see if the node matches.
			while(node){
				if(this.isTag(node, tags).length){
					return node; // DOMNode
				}
				node = node.parentNode;
			}
			return null;
		};

		this.collapse = function(/*Boolean*/ beginning){
			// summary:
			//		Function to collapse (clear), the current selection
			// beginning: Boolean
			//		Indicates whether to collapse the cursor to the beginning of the selection or end.
			if(doc.getSelection){
				// W3C path
				var selection = win.getSelection();
				if(selection.removeAllRanges){ // Mozilla
					if(beginning){
						selection.collapseToStart();
					}else{
						selection.collapseToEnd();
					}
				}else{ // Safari
					// pulled from WebCore/ecma/kjs_window.cpp, line 2536
					selection.collapse(beginning);
				}
			}else{
				// IE6-8
				var range = doc.selection.createRange();
				range.collapse(beginning);
				range.select();
			}
		};

		this.remove = function(){
			// summary:
			//		Function to delete the currently selected content from the document.
			var sel = doc.selection;
			if(doc.getSelection){
				// W3C path
				sel = win.getSelection();
				sel.deleteFromDocument();
				return sel; //Selection
			}else{
				// IE6-8
				if(sel.type.toLowerCase() != "none"){
					sel.clear();
				}
				return sel; //Selection
			}
		};

		this.selectElementChildren = function(/*DomNode*/ element, /*Boolean?*/ nochangefocus){
			// summary:
			//		clear previous selection and select the content of the node
			//		(excluding the node itself)
			// element: DOMNode
			//		The element you wish to select the children content of.
			// nochangefocus: Boolean
			//		Indicates if the focus should change or not.

			var range;
			element = dom.byId(element);
			if(doc.getSelection){
				// W3C
				var selection = win.getSelection();
				if(has("opera")){
					//Opera's selectAllChildren doesn't seem to work right
					//against <body> nodes and possibly others ... so
					//we use the W3C range API
					if(selection.rangeCount){
						range = selection.getRangeAt(0);
					}else{
						range = doc.createRange();
					}
					range.setStart(element, 0);
					range.setEnd(element,(element.nodeType == 3) ? element.length : element.childNodes.length);
					selection.addRange(range);
				}else{
					selection.selectAllChildren(element);
				}
			}else{
				// IE6-8
				range = element.ownerDocument.body.createTextRange();
				range.moveToElementText(element);
				if(!nochangefocus){
					try{
						range.select(); // IE throws an exception here if the widget is hidden.  See #5439
					}catch(e){ /* squelch */}
				}
			}
		};

		this.selectElement = function(/*DomNode*/ element, /*Boolean?*/ nochangefocus){
			// summary:
			//		clear previous selection and select element (including all its children)
			// element: DOMNode
			//		The element to select.
			// nochangefocus: Boolean
			//		Boolean indicating if the focus should be changed.  IE only.
			var range;
			element = dom.byId(element);	// TODO: remove for 2.0 or sooner, spec listed above doesn't allow for string
			if(doc.getSelection){
				// W3C path
				var selection = doc.getSelection();
				range = doc.createRange();
				if(selection.removeAllRanges){ // Mozilla
					// FIXME: does this work on Safari?
					if(has("opera")){
						//Opera works if you use the current range on
						//the selection if present.
						if(selection.getRangeAt(0)){
							range = selection.getRangeAt(0);
						}
					}
					range.selectNode(element);
					selection.removeAllRanges();
					selection.addRange(range);
				}
			}else{
				// IE6-8
				try{
					var tg = element.tagName ? element.tagName.toLowerCase() : "";
					if(tg === "img" || tg === "table"){
						range = baseWindow.body(doc).createControlRange();
					}else{
						range = baseWindow.body(doc).createRange();
					}
					range.addElement(element);
					if(!nochangefocus){
						range.select();
					}
				}catch(e){
					this.selectElementChildren(element, nochangefocus);
				}
			}
		};

		this.inSelection = function(node){
			// summary:
			//		This function determines if 'node' is
			//		in the current selection.
			// tags:
			//		public
			if(node){
				var newRange;
				var range;

				if(doc.getSelection){
					// WC3
					var sel = win.getSelection();
					if(sel && sel.rangeCount > 0){
						range = sel.getRangeAt(0);
					}
					if(range && range.compareBoundaryPoints && doc.createRange){
						try{
							newRange = doc.createRange();
							newRange.setStart(node, 0);
							if(range.compareBoundaryPoints(range.START_TO_END, newRange) === 1){
								return true;
							}
						}catch(e){ /* squelch */}
					}
				}else{
					// IE6-8, so we can't use the range object as the pseudo
					// range doesn't implement the boundary checking, we have to
					// use IE specific crud.
					range = doc.selection.createRange();
					try{
						newRange = node.ownerDocument.body.createTextRange();
						newRange.moveToElementText(node);
					}catch(e2){/* squelch */}
					if(range && newRange){
						// We can finally compare similar to W3C
						if(range.compareEndPoints("EndToStart", newRange) === 1){
							return true;
						}
					}
				}
			}
			return false; // Boolean
		};

		this.getBookmark = function(){
			// summary:
			//		Retrieves a bookmark that can be used with moveToBookmark to reselect the currently selected range.

			// TODO: merge additional code from Editor._getBookmark into this method

			var bm, rg, tg, sel = doc.selection, cf = focus.curNode;

			if(doc.getSelection){
				// W3C Range API for selections.
				sel = win.getSelection();
				if(sel){
					if(sel.isCollapsed){
						tg = cf? cf.tagName : "";
						if(tg){
							// Create a fake rangelike item to restore selections.
							tg = tg.toLowerCase();
							if(tg == "textarea" ||
								(tg == "input" && (!cf.type || cf.type.toLowerCase() == "text"))){
								sel = {
									start: cf.selectionStart,
									end: cf.selectionEnd,
									node: cf,
									pRange: true
								};
								return {isCollapsed: (sel.end <= sel.start), mark: sel}; //Object.
							}
						}
						bm = {isCollapsed:true};
						if(sel.rangeCount){
							bm.mark = sel.getRangeAt(0).cloneRange();
						}
					}else{
						rg = sel.getRangeAt(0);
						bm = {isCollapsed: false, mark: rg.cloneRange()};
					}
				}
			}else if(sel){
				// If the current focus was a input of some sort and no selection, don't bother saving
				// a native bookmark.  This is because it causes issues with dialog/page selection restore.
				// So, we need to create pseudo bookmarks to work with.
				tg = cf ? cf.tagName : "";
				tg = tg.toLowerCase();
				if(cf && tg && (tg == "button" || tg == "textarea" || tg == "input")){
					if(sel.type && sel.type.toLowerCase() == "none"){
						return {
							isCollapsed: true,
							mark: null
						}
					}else{
						rg = sel.createRange();
						return {
							isCollapsed: rg.text && rg.text.length?false:true,
							mark: {
								range: rg,
								pRange: true
							}
						};
					}
				}
				bm = {};

				//'IE' way for selections.
				try{
					// createRange() throws exception when dojo in iframe
					// and nothing selected, see #9632
					rg = sel.createRange();
					bm.isCollapsed = !(sel.type == 'Text' ? rg.htmlText.length : rg.length);
				}catch(e){
					bm.isCollapsed = true;
					return bm;
				}
				if(sel.type.toUpperCase() == 'CONTROL'){
					if(rg.length){
						bm.mark=[];
						var i=0,len=rg.length;
						while(i<len){
							bm.mark.push(rg.item(i++));
						}
					}else{
						bm.isCollapsed = true;
						bm.mark = null;
					}
				}else{
					bm.mark = rg.getBookmark();
				}
			}else{
				console.warn("No idea how to store the current selection for this browser!");
			}
			return bm; // Object
		};

		this.moveToBookmark = function(/*Object*/ bookmark){
			// summary:
			//		Moves current selection to a bookmark.
			// bookmark:
			//		This should be a returned object from getBookmark().

			// TODO: merge additional code from Editor._moveToBookmark into this method

			var mark = bookmark.mark;
			if(mark){
				if(doc.getSelection){
					// W3C Range API (FF, WebKit, Opera, etc)
					var sel = win.getSelection();
					if(sel && sel.removeAllRanges){
						if(mark.pRange){
							var n = mark.node;
							n.selectionStart = mark.start;
							n.selectionEnd = mark.end;
						}else{
							sel.removeAllRanges();
							sel.addRange(mark);
						}
					}else{
						console.warn("No idea how to restore selection for this browser!");
					}
				}else if(doc.selection && mark){
					//'IE' way.
					var rg;
					if(mark.pRange){
						rg = mark.range;
					}else if(lang.isArray(mark)){
						rg = doc.body.createControlRange();
						//rg.addElement does not have call/apply method, so can not call it directly
						//rg is not available in "range.addElement(item)", so can't use that either
						array.forEach(mark, function(n){
							rg.addElement(n);
						});
					}else{
						rg = doc.body.createTextRange();
						rg.moveToBookmark(mark);
					}
					rg.select();
				}
			}
		};

		this.isCollapsed = function(){
			// summary:
			//		Returns true if there is no text selected
			return this.getBookmark().isCollapsed;
		};
	};

	// singleton on the main window
	var selection = new SelectionManager(window);

	// hook for editor to use class
	selection.SelectionManager = SelectionManager;

	return selection;
});

},
'dijit/_base/place':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/lang", // lang.isArray, lang.mixin
	"dojo/window", // windowUtils.getBox
	"../place",
	"../main"	// export to dijit namespace
], function(array, lang, windowUtils, place, dijit){

	// module:
	//		dijit/_base/place


	var exports = {
		// summary:
		//		Deprecated back compatibility module, new code should use dijit/place directly instead of using this module.
	};

	exports.getViewport = function(){
		// summary:
		//		Deprecated method to return the dimensions and scroll position of the viewable area of a browser window.
		//		New code should use windowUtils.getBox()

		return windowUtils.getBox();
	};

	exports.placeOnScreen = place.at;

	exports.placeOnScreenAroundElement = function(node, aroundNode, aroundCorners, layoutNode){
		// summary:
		//		Like dijit.placeOnScreenAroundNode(), except it accepts an arbitrary object
		//		for the "around" argument and finds a proper processor to place a node.
		//		Deprecated, new code should use dijit/place.around() instead.

		// Convert old style {"BL": "TL", "BR": "TR"} type argument
		// to style needed by dijit.place code:
		//		[
		//			{aroundCorner: "BL", corner: "TL" },
		//			{aroundCorner: "BR", corner: "TR" }
		//		]
		var positions;
		if(lang.isArray(aroundCorners)){
			positions = aroundCorners;
		}else{
			positions = [];
			for(var key in aroundCorners){
				positions.push({aroundCorner: key, corner: aroundCorners[key]});
			}
		}

		return place.around(node, aroundNode, positions, true, layoutNode);
	};

	exports.placeOnScreenAroundNode = exports.placeOnScreenAroundElement;
	/*=====
	exports.placeOnScreenAroundNode = function(node, aroundNode, aroundCorners, layoutNode){
		// summary:
		//		Position node adjacent or kitty-corner to aroundNode
		//		such that it's fully visible in viewport.
		//		Deprecated, new code should use dijit/place.around() instead.
	};
	=====*/

	exports.placeOnScreenAroundRectangle = exports.placeOnScreenAroundElement;
	/*=====
	exports.placeOnScreenAroundRectangle = function(node, aroundRect, aroundCorners, layoutNode){
		// summary:
		//		Like dijit.placeOnScreenAroundNode(), except that the "around"
		//		parameter is an arbitrary rectangle on the screen (x, y, width, height)
		//		instead of a dom node.
		//		Deprecated, new code should use dijit/place.around() instead.
	};
	=====*/

	exports.getPopupAroundAlignment = function(/*Array*/ position, /*Boolean*/ leftToRight){
		// summary:
		//		Deprecated method, unneeded when using dijit/place directly.
		//		Transforms the passed array of preferred positions into a format suitable for
		//		passing as the aroundCorners argument to dijit/place.placeOnScreenAroundElement.
		// position: String[]
		//		This variable controls the position of the drop down.
		//		It's an array of strings with the following values:
		//
		//		- before: places drop down to the left of the target node/widget, or to the right in
		//		  the case of RTL scripts like Hebrew and Arabic
		//		- after: places drop down to the right of the target node/widget, or to the left in
		//		  the case of RTL scripts like Hebrew and Arabic
		//		- above: drop down goes above target node
		//		- below: drop down goes below target node
		//
		//		The list is positions is tried, in order, until a position is found where the drop down fits
		//		within the viewport.
		// leftToRight: Boolean
		//		Whether the popup will be displaying in leftToRight mode.

		var align = {};
		array.forEach(position, function(pos){
			var ltr = leftToRight;
			switch(pos){
				case "after":
					align[leftToRight ? "BR" : "BL"] = leftToRight ? "BL" : "BR";
					break;
				case "before":
					align[leftToRight ? "BL" : "BR"] = leftToRight ? "BR" : "BL";
					break;
				case "below-alt":
					ltr = !ltr;
					// fall through
				case "below":
					// first try to align left borders, next try to align right borders (or reverse for RTL mode)
					align[ltr ? "BL" : "BR"] = ltr ? "TL" : "TR";
					align[ltr ? "BR" : "BL"] = ltr ? "TR" : "TL";
					break;
				case "above-alt":
					ltr = !ltr;
					// fall through
				case "above":
				default:
					// first try to align left borders, next try to align right borders (or reverse for RTL mode)
					align[ltr ? "TL" : "TR"] = ltr ? "BL" : "BR";
					align[ltr ? "TR" : "TL"] = ltr ? "BR" : "BL";
					break;
			}
		});
		return align;
	};

	lang.mixin(dijit, exports);

	/*===== return exports; =====*/
	return dijit;	// for back compat :-(
});

},
'dijit/_base/scroll':function(){
define([
	"dojo/window", // windowUtils.scrollIntoView
	"../main"	// export symbol to dijit
], function(windowUtils, dijit){
	// module:
	//		dijit/_base/scroll

	/*=====
	return {
		// summary:
		//		Back compatibility module, new code should use windowUtils directly instead of using this module.
	};
	=====*/

	dijit.scrollIntoView = function(/*DomNode*/ node, /*Object?*/ pos){
		// summary:
		//		Scroll the passed node into view, if it is not already.
		//		Deprecated, use `windowUtils.scrollIntoView` instead.

		windowUtils.scrollIntoView(node, pos);
	};
});

},
'dijit/_base/sniff':function(){
define([ "dojo/uacss" ], function(){

	// module:
	//		dijit/_base/sniff

	/*=====
	return {
		// summary:
		//		Deprecated, back compatibility module, new code should require dojo/uacss directly instead of this module.
	};
	=====*/
});

},
'dijit/_base/typematic':function(){
define(["../typematic"], function(){

	/*=====
	return {
		// summary:
		//		Deprecated, for back-compat, just loads top level module
	};
	=====*/

});

},
'dijit/typematic':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/connect", // connect._keyPress
	"dojo/_base/lang", // lang.mixin, lang.hitch
	"dojo/on",
	"dojo/sniff", // has("ie")
	"./main"        // setting dijit.typematic global
], function(array, connect, lang, on, has, dijit){

	// module:
	//		dijit/typematic

	var typematic = (dijit.typematic = {
		// summary:
		//		These functions are used to repetitively call a user specified callback
		//		method when a specific key or mouse click over a specific DOM node is
		//		held down for a specific amount of time.
		//		Only 1 such event is allowed to occur on the browser page at 1 time.

		_fireEventAndReload: function(){
			this._timer = null;
			this._callback(++this._count, this._node, this._evt);

			// Schedule next event, timer is at most minDelay (default 10ms) to avoid
			// browser overload (particularly avoiding starving DOH robot so it never gets to send a mouseup)
			this._currentTimeout = Math.max(
				this._currentTimeout < 0 ? this._initialDelay :
					(this._subsequentDelay > 1 ? this._subsequentDelay : Math.round(this._currentTimeout * this._subsequentDelay)),
				this._minDelay);
			this._timer = setTimeout(lang.hitch(this, "_fireEventAndReload"), this._currentTimeout);
		},

		trigger: function(/*Event*/ evt, /*Object*/ _this, /*DOMNode*/ node, /*Function*/ callback, /*Object*/ obj, /*Number?*/ subsequentDelay, /*Number?*/ initialDelay, /*Number?*/ minDelay){
			// summary:
			//		Start a timed, repeating callback sequence.
			//		If already started, the function call is ignored.
			//		This method is not normally called by the user but can be
			//		when the normal listener code is insufficient.
			// evt:
			//		key or mouse event object to pass to the user callback
			// _this:
			//		pointer to the user's widget space.
			// node:
			//		the DOM node object to pass the the callback function
			// callback:
			//		function to call until the sequence is stopped called with 3 parameters:
			// count:
			//		integer representing number of repeated calls (0..n) with -1 indicating the iteration has stopped
			// node:
			//		the DOM node object passed in
			// evt:
			//		key or mouse event object
			// obj:
			//		user space object used to uniquely identify each typematic sequence
			// subsequentDelay:
			//		if > 1, the number of milliseconds until the 3->n events occur
			//		or else the fractional time multiplier for the next event's delay, default=0.9
			// initialDelay:
			//		the number of milliseconds until the 2nd event occurs, default=500ms
			// minDelay:
			//		the maximum delay in milliseconds for event to fire, default=10ms
			if(obj != this._obj){
				this.stop();
				this._initialDelay = initialDelay || 500;
				this._subsequentDelay = subsequentDelay || 0.90;
				this._minDelay = minDelay || 10;
				this._obj = obj;
				this._node = node;
				this._currentTimeout = -1;
				this._count = -1;
				this._callback = lang.hitch(_this, callback);
				this._evt = { faux: true };
				for(var attr in evt){
					if(attr != "layerX" && attr != "layerY"){ // prevent WebKit warnings
						var v = evt[attr];
						if(typeof v != "function" && typeof v != "undefined"){
							this._evt[attr] = v
						}
					}
				}
				this._fireEventAndReload();
			}
		},

		stop: function(){
			// summary:
			//		Stop an ongoing timed, repeating callback sequence.
			if(this._timer){
				clearTimeout(this._timer);
				this._timer = null;
			}
			if(this._obj){
				this._callback(-1, this._node, this._evt);
				this._obj = null;
			}
		},

		addKeyListener: function(/*DOMNode*/ node, /*Object*/ keyObject, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){
			// summary:
			//		Start listening for a specific typematic key.
			//		See also the trigger method for other parameters.
			// keyObject:
			//		an object defining the key to listen for:
			//
			//		- keyCode: the keyCode (number) to listen for, used for non-printable keys
			//		- charCode: the charCode (number) to listen for, used for printable keys
			//		- charOrCode: deprecated, use keyCode or charCode
			//		- ctrlKey: desired ctrl key state to initiate the callback sequence:
			//			- pressed (true)
			//			- released (false)
			//			- either (unspecified)
			//		- altKey: same as ctrlKey but for the alt key
			//		- shiftKey: same as ctrlKey but for the shift key
			// returns:
			//		a connection handle

			// Setup keydown or keypress listener depending on whether keyCode or charCode was specified.
			// If charOrCode is specified use deprecated connect._keypress synthetic event (remove for 2.0)
			var type = "keyCode" in keyObject ? "keydown" : "charCode" in keyObject ? "keypress" : connect._keypress,
				attr = "keyCode" in keyObject ? "keyCode" : "charCode" in keyObject ? "charCode" : "charOrCode";

			var handles = [
				on(node, type, lang.hitch(this, function(evt){
					if(evt[attr] == keyObject[attr] &&
						(keyObject.ctrlKey === undefined || keyObject.ctrlKey == evt.ctrlKey) &&
						(keyObject.altKey === undefined || keyObject.altKey == evt.altKey) &&
						(keyObject.metaKey === undefined || keyObject.metaKey == (evt.metaKey || false)) && // IE doesn't even set metaKey
						(keyObject.shiftKey === undefined || keyObject.shiftKey == evt.shiftKey)){
						evt.stopPropagation();
						evt.preventDefault();
						typematic.trigger(evt, _this, node, callback, keyObject, subsequentDelay, initialDelay, minDelay);
					}else if(typematic._obj == keyObject){
						typematic.stop();
					}
				})),
				on(node, "keyup", lang.hitch(this, function(){
					if(typematic._obj == keyObject){
						typematic.stop();
					}
				}))
			];
			return { remove: function(){
				array.forEach(handles, function(h){
					h.remove();
				});
			} };
		},

		addMouseListener: function(/*DOMNode*/ node, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){
			// summary:
			//		Start listening for a typematic mouse click.
			//		See the trigger method for other parameters.
			// returns:
			//		a connection handle
			var handles = [
				on(node, "mousedown", lang.hitch(this, function(evt){
					evt.preventDefault();
					typematic.trigger(evt, _this, node, callback, node, subsequentDelay, initialDelay, minDelay);
				})),
				on(node, "mouseup", lang.hitch(this, function(evt){
					if(this._obj){
						evt.preventDefault();
					}
					typematic.stop();
				})),
				on(node, "mouseout", lang.hitch(this, function(evt){
					if(this._obj){
						evt.preventDefault();
					}
					typematic.stop();
				})),
				on(node, "dblclick", lang.hitch(this, function(evt){
					evt.preventDefault();
					if(has("ie") < 9){
						typematic.trigger(evt, _this, node, callback, node, subsequentDelay, initialDelay, minDelay);
						setTimeout(lang.hitch(this, typematic.stop), 50);
					}
				}))
			];
			return { remove: function(){
				array.forEach(handles, function(h){
					h.remove();
				});
			} };
		},

		addListener: function(/*Node*/ mouseNode, /*Node*/ keyNode, /*Object*/ keyObject, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){
			// summary:
			//		Start listening for a specific typematic key and mouseclick.
			//		This is a thin wrapper to addKeyListener and addMouseListener.
			//		See the addMouseListener and addKeyListener methods for other parameters.
			// mouseNode:
			//		the DOM node object to listen on for mouse events.
			// keyNode:
			//		the DOM node object to listen on for key events.
			// returns:
			//		a connection handle
			var handles = [
				this.addKeyListener(keyNode, keyObject, _this, callback, subsequentDelay, initialDelay, minDelay),
				this.addMouseListener(mouseNode, _this, callback, subsequentDelay, initialDelay, minDelay)
			];
			return { remove: function(){
				array.forEach(handles, function(h){
					h.remove();
				});
			} };
		}
	});

	return typematic;
});

},
'dijit/_base/wai':function(){
define([
	"dojo/dom-attr", // domAttr.attr
	"dojo/_base/lang", // lang.mixin
	"../main",	// export symbols to dijit
	"../hccss"			// not using this module directly, but loading it sets CSS flag on <html>
], function(domAttr, lang, dijit){

	// module:
	//		dijit/_base/wai

	var exports = {
		// summary:
		//		Deprecated methods for setting/getting wai roles and states.
		//		New code should call setAttribute()/getAttribute() directly.
		//
		//		Also loads hccss to apply dj_a11y class to root node if machine is in high-contrast mode.

		hasWaiRole: function(/*Element*/ elem, /*String?*/ role){
			// summary:
			//		Determines if an element has a particular role.
			// returns:
			//		True if elem has the specific role attribute and false if not.
			//		For backwards compatibility if role parameter not provided,
			//		returns true if has a role
			var waiRole = this.getWaiRole(elem);
			return role ? (waiRole.indexOf(role) > -1) : (waiRole.length > 0);
		},

		getWaiRole: function(/*Element*/ elem){
			// summary:
			//		Gets the role for an element (which should be a wai role).
			// returns:
			//		The role of elem or an empty string if elem
			//		does not have a role.
			 return lang.trim((domAttr.get(elem, "role") || "").replace("wairole:",""));
		},

		setWaiRole: function(/*Element*/ elem, /*String*/ role){
			// summary:
			//		Sets the role on an element.
			// description:
			//		Replace existing role attribute with new role.

			domAttr.set(elem, "role", role);
		},

		removeWaiRole: function(/*Element*/ elem, /*String*/ role){
			// summary:
			//		Removes the specified role from an element.
			//		Removes role attribute if no specific role provided (for backwards compat.)

			var roleValue = domAttr.get(elem, "role");
			if(!roleValue){ return; }
			if(role){
				var t = lang.trim((" " + roleValue + " ").replace(" " + role + " ", " "));
				domAttr.set(elem, "role", t);
			}else{
				elem.removeAttribute("role");
			}
		},

		hasWaiState: function(/*Element*/ elem, /*String*/ state){
			// summary:
			//		Determines if an element has a given state.
			// description:
			//		Checks for an attribute called "aria-"+state.
			// returns:
			//		true if elem has a value for the given state and
			//		false if it does not.

			return elem.hasAttribute ? elem.hasAttribute("aria-"+state) : !!elem.getAttribute("aria-"+state);
		},

		getWaiState: function(/*Element*/ elem, /*String*/ state){
			// summary:
			//		Gets the value of a state on an element.
			// description:
			//		Checks for an attribute called "aria-"+state.
			// returns:
			//		The value of the requested state on elem
			//		or an empty string if elem has no value for state.

			return elem.getAttribute("aria-"+state) || "";
		},

		setWaiState: function(/*Element*/ elem, /*String*/ state, /*String*/ value){
			// summary:
			//		Sets a state on an element.
			// description:
			//		Sets an attribute called "aria-"+state.

			elem.setAttribute("aria-"+state, value);
		},

		removeWaiState: function(/*Element*/ elem, /*String*/ state){
			// summary:
			//		Removes a state from an element.
			// description:
			//		Sets an attribute called "aria-"+state.

			elem.removeAttribute("aria-"+state);
		}
	};

	lang.mixin(dijit, exports);

	/*===== return exports; =====*/
	return dijit;	// for back compat :-(
});

},
'dijit/_base/window':function(){
define([
	"dojo/window", // windowUtils.get
	"../main"	// export symbol to dijit
], function(windowUtils, dijit){
	// module:
	//		dijit/_base/window

	/*=====
	return {
		// summary:
		//		Back compatibility module, new code should use windowUtils directly instead of using this module.
	};
	=====*/

	dijit.getDocumentWindow = function(doc){
		return windowUtils.get(doc);
	};
});

},
'dijit/form/ComboButton':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/keys", // keys
	"../focus", // focus.focus()
	"./DropDownButton",
	"dojo/text!./templates/ComboButton.html",
	"../a11yclick"	// template uses ondijitclick
], function(declare, keys, focus, DropDownButton, template){

	// module:
	//		dijit/form/ComboButton

	return declare("dijit.form.ComboButton", DropDownButton, {
		// summary:
		//		A combination button and drop-down button.
		//		Users can click one side to "press" the button, or click an arrow
		//		icon to display the drop down.
		//
		// example:
		// |	<button data-dojo-type="dijit/form/ComboButton" onClick="...">
		// |		<span>Hello world</span>
		// |		<div data-dojo-type="dijit/Menu">...</div>
		// |	</button>
		//
		// example:
		// |	var button1 = new ComboButton({label: "hello world", onClick: foo, dropDown: "myMenu"});
		// |	dojo.body().appendChild(button1.domNode);
		//

		templateString: template,

		// Map widget attributes to DOMNode attributes.
		_setIdAttr: "", // override _FormWidgetMixin which puts id on the focusNode
		_setTabIndexAttr: ["focusNode", "titleNode"],
		_setTitleAttr: "titleNode",

		// optionsTitle: String
		//		Text that describes the options menu (accessibility)
		optionsTitle: "",

		baseClass: "dijitComboButton",

		// Set classes like dijitButtonContentsHover or dijitArrowButtonActive depending on
		// mouse action over specified node
		cssStateNodes: {
			"buttonNode": "dijitButtonNode",
			"titleNode": "dijitButtonContents",
			"_popupStateNode": "dijitDownArrowButton"
		},

		_focusedNode: null,

		_onButtonKeyDown: function(/*Event*/ evt){
			// summary:
			//		Handler for right arrow key when focus is on left part of button
			if(evt.keyCode == keys[this.isLeftToRight() ? "RIGHT_ARROW" : "LEFT_ARROW"]){
				focus.focus(this._popupStateNode);
				evt.stopPropagation();
				evt.preventDefault();
			}
		},

		_onArrowKeyDown: function(/*Event*/ evt){
			// summary:
			//		Handler for left arrow key when focus is on right part of button
			if(evt.keyCode == keys[this.isLeftToRight() ? "LEFT_ARROW" : "RIGHT_ARROW"]){
				focus.focus(this.titleNode);
				evt.stopPropagation();
				evt.preventDefault();
			}
		},

		focus: function(/*String*/ position){
			// summary:
			//		Focuses this widget to according to position, if specified,
			//		otherwise on arrow node
			// position:
			//		"start" or "end"
			if(!this.disabled){
				focus.focus(position == "start" ? this.titleNode : this._popupStateNode);
			}
		}
	});
});

},
'dijit/layout/BorderContainer':function(){
define([
	"dojo/_base/array", // array.filter array.forEach array.map
	"dojo/cookie", // cookie
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.remove domClass.toggle
	"dojo/dom-construct", // domConstruct.destroy domConstruct.place
	"dojo/dom-geometry", // domGeometry.marginBox
	"dojo/dom-style", // domStyle.style
	"dojo/keys",
	"dojo/_base/lang", // getObject() hitch() delegate()
	"dojo/on",
	"dojo/touch",
	"../_WidgetBase",
	"../_Widget",
	"../_TemplatedMixin",
	"./LayoutContainer",
	"./utils"        // layoutUtils.layoutChildren
], function(array, cookie, declare, domClass, domConstruct, domGeometry, domStyle, keys, lang, on, touch,
			_WidgetBase, _Widget, _TemplatedMixin, LayoutContainer, layoutUtils){

	// module:
	//		dijit/layout/BorderContainer

	var _Splitter = declare("dijit.layout._Splitter", [_Widget, _TemplatedMixin ], {
		// summary:
		//		A draggable spacer between two items in a `dijit/layout/BorderContainer`.
		// description:
		//		This is instantiated by `dijit/layout/BorderContainer`.  Users should not
		//		create it directly.
		// tags:
		//		private

		/*=====
		 // container: [const] dijit/layout/BorderContainer
		 //		Pointer to the parent BorderContainer
		 container: null,

		 // child: [const] dijit/layout/_LayoutWidget
		 //		Pointer to the pane associated with this splitter
		 child: null,

		 // region: [const] String
		 //		Region of pane associated with this splitter.
		 //		"top", "bottom", "left", "right".
		 region: null,
		 =====*/

		// live: [const] Boolean
		//		If true, the child's size changes and the child widget is redrawn as you drag the splitter;
		//		otherwise, the size doesn't change until you drop the splitter (by mouse-up)
		live: true,

		templateString: '<div class="dijitSplitter" data-dojo-attach-event="onkeydown:_onKeyDown,press:_startDrag,onmouseenter:_onMouse,onmouseleave:_onMouse" tabIndex="0" role="separator"><div class="dijitSplitterThumb"></div></div>',

		constructor: function(){
			this._handlers = [];
		},

		postMixInProperties: function(){
			this.inherited(arguments);

			this.horizontal = /top|bottom/.test(this.region);
			this._factor = /top|left/.test(this.region) ? 1 : -1;
			this._cookieName = this.container.id + "_" + this.region;
		},

		buildRendering: function(){
			this.inherited(arguments);

			domClass.add(this.domNode, "dijitSplitter" + (this.horizontal ? "H" : "V"));

			if(this.container.persist){
				// restore old size
				var persistSize = cookie(this._cookieName);
				if(persistSize){
					this.child.domNode.style[this.horizontal ? "height" : "width"] = persistSize;
				}
			}
		},

		_computeMaxSize: function(){
			// summary:
			//		Return the maximum size that my corresponding pane can be set to

			var dim = this.horizontal ? 'h' : 'w',
				childSize = domGeometry.getMarginBox(this.child.domNode)[dim],
				center = array.filter(this.container.getChildren(), function(child){
					return child.region == "center";
				})[0];

			// Can expand until center is crushed.  But always leave room for center's padding + border,
			//  otherwise on the next call domGeometry methods start to lie about size.
			var spaceAvailable = domGeometry.getContentBox(center.domNode)[dim] - 10;

			return Math.min(this.child.maxSize, childSize + spaceAvailable);
		},

		_startDrag: function(e){
			if(!this.cover){
				this.cover = domConstruct.place("<div class=dijitSplitterCover></div>", this.child.domNode, "after");
			}
			domClass.add(this.cover, "dijitSplitterCoverActive");

			// Safeguard in case the stop event was missed.  Shouldn't be necessary if we always get the mouse up.
			if(this.fake){
				domConstruct.destroy(this.fake);
			}
			if(!(this._resize = this.live)){ //TODO: disable live for IE6?
				// create fake splitter to display at old position while we drag
				(this.fake = this.domNode.cloneNode(true)).removeAttribute("id");
				domClass.add(this.domNode, "dijitSplitterShadow");
				domConstruct.place(this.fake, this.domNode, "after");
			}
			domClass.add(this.domNode, "dijitSplitterActive dijitSplitter" + (this.horizontal ? "H" : "V") + "Active");
			if(this.fake){
				domClass.remove(this.fake, "dijitSplitterHover dijitSplitter" + (this.horizontal ? "H" : "V") + "Hover");
			}

			//Performance: load data info local vars for onmousevent function closure
			var factor = this._factor,
				isHorizontal = this.horizontal,
				axis = isHorizontal ? "pageY" : "pageX",
				pageStart = e[axis],
				splitterStyle = this.domNode.style,
				dim = isHorizontal ? 'h' : 'w',
				childCS = domStyle.getComputedStyle(this.child.domNode),
				childStart = domGeometry.getMarginBox(this.child.domNode, childCS)[dim],
				max = this._computeMaxSize(),
				min = Math.max(this.child.minSize, domGeometry.getPadBorderExtents(this.child.domNode, childCS)[dim] + 10),
				region = this.region,
				splitterAttr = region == "top" || region == "bottom" ? "top" : "left", // style attribute of splitter to adjust
				splitterStart = parseInt(splitterStyle[splitterAttr], 10),
				resize = this._resize,
				layoutFunc = lang.hitch(this.container, "_layoutChildren", this.child.id),
				de = this.ownerDocument;

			var minDim = min;
 			this._handlers = this._handlers.concat([
 				on(de, touch.move, this._drag = function(e, forceResize){
				    // restore old size
				    if (this.child && this.child.domNode.style[this.horizontal ? "height" : "width"] === "0px" && this.container && this.container.persist) {
			            var persistSize = cookie(this._cookieName);
			            if (persistSize) {
		                min = persistSize.replace("px", "");
				        }
				    } else {
				        min = minDim;
				    }
					var delta = e[axis] - pageStart,
						childSize = factor * delta + childStart,
						boundChildSize = Math.max(Math.min(childSize, max), min);

					if(resize || forceResize){
						layoutFunc(boundChildSize);
					}
					// TODO: setting style directly (usually) sets content box size, need to set margin box size
					splitterStyle[splitterAttr] = delta + splitterStart + factor * (boundChildSize - childSize) + "px";
				}),
				on(de, "dragstart", function(e){
					e.stopPropagation();
					e.preventDefault();
				}),
				on(this.ownerDocumentBody, "selectstart", function(e){
					e.stopPropagation();
					e.preventDefault();
				}),
				on(de, touch.release, lang.hitch(this, "_stopDrag"))
			]);
			e.stopPropagation();
			e.preventDefault();
		},

		_onMouse: function(e){
			// summary:
			//		Handler for onmouseenter / onmouseleave events
			var o = (e.type == "mouseover" || e.type == "mouseenter");
			domClass.toggle(this.domNode, "dijitSplitterHover", o);
			domClass.toggle(this.domNode, "dijitSplitter" + (this.horizontal ? "H" : "V") + "Hover", o);
		},

		_stopDrag: function(e){
			try{
				if(this.cover){
					domClass.remove(this.cover, "dijitSplitterCoverActive");
				}
				if(this.fake){
					domConstruct.destroy(this.fake);
				}
				domClass.remove(this.domNode, "dijitSplitterActive dijitSplitter"
					+ (this.horizontal ? "H" : "V") + "Active dijitSplitterShadow");
				this._drag(e); //TODO: redundant with onmousemove?
				this._drag(e, true);
			}finally{
				this._cleanupHandlers();
				delete this._drag;
			}

			if(this.container.persist){
				cookie(this._cookieName, this.child.domNode.style[this.horizontal ? "height" : "width"], {expires: 365});
			}
		},

		_cleanupHandlers: function(){
			var h;
			while(h = this._handlers.pop()){
				h.remove();
			}
		},

		_onKeyDown: function(/*Event*/ e){
			// should we apply typematic to this?
			this._resize = true;
			var horizontal = this.horizontal;
			var tick = 1;
			switch(e.keyCode){
				case horizontal ? keys.UP_ARROW : keys.LEFT_ARROW:
					tick *= -1;
//				break;
				case horizontal ? keys.DOWN_ARROW : keys.RIGHT_ARROW:
					break;
				default:
//				this.inherited(arguments);
					return;
			}
			var childSize = domGeometry.getMarginSize(this.child.domNode)[ horizontal ? 'h' : 'w' ] + this._factor * tick;
			this.container._layoutChildren(this.child.id, Math.max(Math.min(childSize, this._computeMaxSize()), this.child.minSize));
			e.stopPropagation();
			e.preventDefault();
		},

		destroy: function(){
			this._cleanupHandlers();
			delete this.child;
			delete this.container;
			delete this.cover;
			delete this.fake;
			this.inherited(arguments);
		}
	});

	var _Gutter = declare("dijit.layout._Gutter", [_Widget, _TemplatedMixin], {
		// summary:
		//		Just a spacer div to separate side pane from center pane.
		//		Basically a trick to lookup the gutter/splitter width from the theme.
		// description:
		//		Instantiated by `dijit/layout/BorderContainer`.  Users should not
		//		create directly.
		// tags:
		//		private

		templateString: '<div class="dijitGutter" role="presentation"></div>',

		postMixInProperties: function(){
			this.inherited(arguments);
			this.horizontal = /top|bottom/.test(this.region);
		},

		buildRendering: function(){
			this.inherited(arguments);
			domClass.add(this.domNode, "dijitGutter" + (this.horizontal ? "H" : "V"));
		}
	});

	var BorderContainer = declare("dijit.layout.BorderContainer", LayoutContainer, {
		// summary:
		//		A BorderContainer is a `dijit/LayoutContainer` that can have draggable splitters between the children,
		//		in order to adjust their sizes.
		//
		//		In addition, it automatically adds some space between the children even
		//		if they don't have a draggable splitter between them, and space between the edge of the BorderContainer
		//		and the children that are adjacent to the edge.  Note that the intended style is that all the children
		//		have borders, but (despite the name) the BorderContainer itself does not.
		//
		//		See `BorderContainer.ChildWidgetProperties` for details on the properties that can be set on
		//		children of a `BorderContainer`.

		// gutters: [const] Boolean
		//		Give each pane a border and margin.
		//		Margin determined by domNode.paddingLeft.
		//		When false, only resizable panes have a gutter (i.e. draggable splitter) for resizing.
		gutters: true,

		// liveSplitters: [const] Boolean
		//		Specifies whether splitters resize as you drag (true) or only upon mouseup (false)
		liveSplitters: true,

		// persist: Boolean
		//		Save splitter positions in a cookie.
		persist: false,

		baseClass: "dijitBorderContainer",

		// _splitterClass: Function||String
		//		Optional hook to override the default Splitter widget used by BorderContainer
		_splitterClass: _Splitter,

		postMixInProperties: function(){
			// change class name to indicate that BorderContainer is being used purely for
			// layout (like LayoutContainer) rather than for pretty formatting.
			if(!this.gutters){
				this.baseClass += "NoGutter";
			}
			this.inherited(arguments);
		},

		_setupChild: function(/*dijit/_WidgetBase*/ child){
			// Override LayoutContainer._setupChild().

			this.inherited(arguments);

			var region = child.region, ltr = child.isLeftToRight();
			if(region == "leading"){
				region = ltr ? "left" : "right";
			}
			if(region == "trailing"){
				region = ltr ? "right" : "left";
			}

			if(region){
				// Create draggable splitter for resizing pane,
				// or alternately if splitter=false but BorderContainer.gutters=true then
				// insert dummy div just for spacing
				if(region != "center" && (child.splitter || this.gutters) && !child._splitterWidget){
					var _Splitter = child.splitter ? this._splitterClass : _Gutter;
					if(lang.isString(_Splitter)){
						_Splitter = lang.getObject(_Splitter);	// for back-compat, remove in 2.0
					}
					var splitter = new _Splitter({
						id: child.id + "_splitter",
						container: this,
						child: child,
						region: region,
						live: this.liveSplitters
					});
					splitter.isSplitter = true;
					child._splitterWidget = splitter;

					// Make the tab order match the visual layout by placing the splitter before or after the pane,
					// depending on where the splitter is visually compared to the pane.
					var before = region == "bottom" || region == (this.isLeftToRight() ? "right" : "left");
					domConstruct.place(splitter.domNode, child.domNode, before ? "before" : "after");

					// Splitters aren't added as Contained children, so we need to call startup explicitly
					splitter.startup();
				}
			}
		},

		layout: function(){
			// Implement _LayoutWidget.layout() virtual method.
			this._layoutChildren();
		},

		removeChild: function(/*dijit/_WidgetBase*/ child){
			// Override _LayoutWidget.removeChild().

			var splitter = child._splitterWidget;
			if(splitter){
				splitter.destroy();
				delete child._splitterWidget;
			}

			this.inherited(arguments);
		},

		getChildren: function(){
			// Override _LayoutWidget.getChildren() to only return real children, not the splitters.
			return array.filter(this.inherited(arguments), function(widget){
				return !widget.isSplitter;
			});
		},

		// TODO: remove in 2.0
		getSplitter: function(/*String*/region){
			// summary:
			//		Returns the widget responsible for rendering the splitter associated with region
			// tags:
			//		deprecated
			return array.filter(this.getChildren(), function(child){
				return child.region == region;
			})[0]._splitterWidget;
		},

		resize: function(newSize, currentSize){
			// Overrides _LayoutWidget.resize().

			// resetting potential padding to 0px to provide support for 100% width/height + padding
			// TODO: this hack doesn't respect the box model and is a temporary fix
			if(!this.cs || !this.pe){
				var node = this.domNode;
				this.cs = domStyle.getComputedStyle(node);
				this.pe = domGeometry.getPadExtents(node, this.cs);
				this.pe.r = domStyle.toPixelValue(node, this.cs.paddingRight);
				this.pe.b = domStyle.toPixelValue(node, this.cs.paddingBottom);

				domStyle.set(node, "padding", "0px");
			}

			this.inherited(arguments);
		},

		_layoutChildren: function(/*String?*/ changedChildId, /*Number?*/ changedChildSize){
			// summary:
			//		This is the main routine for setting size/position of each child.
			// description:
			//		With no arguments, measures the height of top/bottom panes, the width
			//		of left/right panes, and then sizes all panes accordingly.
			//
			//		With changedRegion specified (as "left", "top", "bottom", or "right"),
			//		it changes that region's width/height to changedRegionSize and
			//		then resizes other regions that were affected.
			// changedChildId:
			//		Id of the child which should be resized because splitter was dragged.
			// changedChildSize:
			//		The new width/height (in pixels) to make specified child

			if(!this._borderBox || !this._borderBox.h){
				// We are currently hidden, or we haven't been sized by our parent yet.
				// Abort.   Someone will resize us later.
				return;
			}

			// Combining the externally specified children with splitters and gutters
			var childrenAndSplitters = [];
			array.forEach(this._getOrderedChildren(), function(pane){
				childrenAndSplitters.push(pane);
				if(pane._splitterWidget){
					childrenAndSplitters.push(pane._splitterWidget);
				}
			});

			// Compute the box in which to lay out my children
			var dim = {
				l: this.pe.l,
				t: this.pe.t,
				w: this._borderBox.w - this.pe.w,
				h: this._borderBox.h - this.pe.h
			};

			// Layout the children, possibly changing size due to a splitter drag
			layoutUtils.layoutChildren(this.domNode, dim, childrenAndSplitters,
				changedChildId, changedChildSize);
		},

		destroyRecursive: function(){
			// Destroy splitters first, while getChildren() still works
			array.forEach(this.getChildren(), function(child){
				var splitter = child._splitterWidget;
				if(splitter){
					splitter.destroy();
				}
				delete child._splitterWidget;
			});

			// Then destroy the real children, and myself
			this.inherited(arguments);
		}
	});

	BorderContainer.ChildWidgetProperties = {
		// summary:
		//		These properties can be specified for the children of a BorderContainer.

		// splitter: [const] Boolean
		//		Parameter for children where region != "center".
		//		If true, enables user to resize the widget by putting a draggable splitter between
		//		this widget and the region=center widget.
		splitter: false,

		// minSize: [const] Number
		//		Specifies a minimum size (in pixels) for this widget when resized by a splitter.
		minSize: 0,

		// maxSize: [const] Number
		//		Specifies a maximum size (in pixels) for this widget when resized by a splitter.
		maxSize: Infinity
	};
	lang.mixin(BorderContainer.ChildWidgetProperties, LayoutContainer.ChildWidgetProperties);

	// Since any widget can be specified as a BorderContainer child, mix it
	// into the base widget class.  (This is a hack, but it's effective.)
	// This is for the benefit of the parser.   Remove for 2.0.  Also, hide from doc viewer.
	lang.extend(_WidgetBase, /*===== {} || =====*/ BorderContainer.ChildWidgetProperties);

	// For monkey patching
	BorderContainer._Splitter = _Splitter;
	BorderContainer._Gutter = _Gutter;

	return BorderContainer;
});

},
'dijit/layout/LayoutContainer':function(){
define([
	"dojo/_base/array",
	"dojo/_base/declare", // declare
	"dojo/dom-class",
	"dojo/dom-style",
	"dojo/_base/lang",
	"../_WidgetBase",
	"./_LayoutWidget",
	"./utils" // layoutUtils.layoutChildren
], function(array, declare, domClass, domStyle, lang, _WidgetBase, _LayoutWidget, layoutUtils){

	// module:
	//		dijit/layout/LayoutContainer

	var LayoutContainer = declare("dijit.layout.LayoutContainer", _LayoutWidget, {
		// summary:
		//		A LayoutContainer is a box with a specified size, such as style="width: 500px; height: 500px;",
		//		that contains a child widget marked region="center" and optionally children widgets marked
		//		region equal to "top", "bottom", "leading", "trailing", "left" or "right".
		//		Children along the edges will be laid out according to width or height dimensions. The remaining
		//		space is designated for the center region.
		//
		//		The outer size must be specified on the LayoutContainer node.  Width must be specified for the sides
		//		and height for the top and bottom, respectively.  No dimensions should be specified on the center;
		//		it will fill the remaining space.  Regions named "leading" and "trailing" may be used just like
		//		"left" and "right" except that they will be reversed in right-to-left environments.
		//
		//		For complex layouts, multiple children can be specified for a single region.   In this case, the
		//		layoutPriority flag on the children determines which child is closer to the edge (low layoutPriority)
		//		and which child is closer to the center (high layoutPriority).   layoutPriority can also be used
		//		instead of the design attribute to control layout precedence of horizontal vs. vertical panes.
		//
		//		See `LayoutContainer.ChildWidgetProperties` for details on the properties that can be set on
		//		children of a `LayoutContainer`.
		//
		//		If layoutPriority is not set, lays out each child in the natural order the children occur in.
		//		Basically each child is laid out into the "remaining space", where "remaining space" is initially
		//		the content area of this widget, but is reduced to a smaller rectangle each time a child is added.

		// design: String
		//		Which design is used for the layout:
		//
		//		- "headline" (default) where the top and bottom extend the full width of the container
		//		- "sidebar" where the left and right sides extend from top to bottom.
		//
		//		However, a `layoutPriority` setting on child panes overrides the `design` attribute on the parent.
		//		In other words, if the top and bottom sections have a lower `layoutPriority` than the left and right
		//		panes, the top and bottom panes will extend the entire width of the box.
		design: "headline",

		baseClass: "dijitLayoutContainer",

		startup: function(){
			if(this._started){
				return;
			}
			array.forEach(this.getChildren(), this._setupChild, this);
			this.inherited(arguments);
		},

		_setupChild: function(/*dijit/_WidgetBase*/ child){
			// Override _LayoutWidget._setupChild().

			this.inherited(arguments);

			var region = child.region;
			if(region){
				domClass.add(child.domNode, this.baseClass + "Pane");
			}
		},

		_getOrderedChildren: function(){
			// summary:
			//		Return list of my children in the order that I want layoutChildren()
			//		to process them (i.e. from the outside to the inside)

			var wrappers = array.map(this.getChildren(), function(child, idx){
				return {
					pane: child,
					weight: [
						child.region == "center" ? Infinity : 0,
						child.layoutPriority,
						(this.design == "sidebar" ? 1 : -1) * (/top|bottom/.test(child.region) ? 1 : -1),
						idx
					]
				};
			}, this);
			wrappers.sort(function(a, b){
				var aw = a.weight, bw = b.weight;
				for(var i = 0; i < aw.length; i++){
					if(aw[i] != bw[i]){
						return aw[i] - bw[i];
					}
				}
				return 0;
			});

			return array.map(wrappers, function(w){ return w.pane; });
		},

		layout: function(){
			layoutUtils.layoutChildren(this.domNode, this._contentBox, this._getOrderedChildren());
		},

		addChild: function(/*dijit/_WidgetBase*/ child, /*Integer?*/ insertIndex){
			this.inherited(arguments);
			if(this._started){
				this.layout();
			}
		},

		removeChild: function(/*dijit/_WidgetBase*/ child){
			this.inherited(arguments);
			if(this._started){
				this.layout();
			}

			// Clean up whatever style changes we made to the child pane.
			// Unclear how height and width should be handled.
			domClass.remove(child.domNode, this.baseClass + "Pane");
			domStyle.set(child.domNode, {
				top: "auto",
				bottom: "auto",
				left: "auto",
				right: "auto",
				position: "static"
			});
			domStyle.set(child.domNode, /top|bottom/.test(child.region) ? "width" : "height", "auto");
		}
	});

	LayoutContainer.ChildWidgetProperties = {
		// summary:
		//		These properties can be specified for the children of a LayoutContainer.

		// region: [const] String
		//		Values: "top", "bottom", "leading", "trailing", "left", "right", "center".
		//		See the `dijit/layout/LayoutContainer` description for details.
		region: '',

		// layoutAlign: [const deprecated] String
		//		Synonym for region, except using "client" instead of "center".  Deprecated; use region instead.
		layoutAlign: '',

		// layoutPriority: [const] Number
		//		Children with a higher layoutPriority will be placed closer to the LayoutContainer center,
		//		between children with a lower layoutPriority.
		layoutPriority: 0
	};

	// Since any widget can be specified as a LayoutContainer child, mix it
	// into the base widget class.  (This is a hack, but it's effective.)
	// This is for the benefit of the parser.   Remove for 2.0.  Also, hide from doc viewer.
	lang.extend(_WidgetBase, /*===== {} || =====*/ LayoutContainer.ChildWidgetProperties);

	return LayoutContainer;
});

},
'dijit/layout/_LayoutWidget':function(){
define([
	"dojo/_base/lang", // lang.mixin
	"../_Widget",
	"../_Container",
	"../_Contained",
	"../Viewport",
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.remove
	"dojo/dom-geometry", // domGeometry.marginBox
	"dojo/dom-style" // domStyle.getComputedStyle
], function(lang, _Widget, _Container, _Contained, Viewport,
	declare, domClass, domGeometry, domStyle){

	// module:
	//		dijit/layout/_LayoutWidget


	return declare("dijit.layout._LayoutWidget", [_Widget, _Container, _Contained], {
		// summary:
		//		Base class for a _Container widget which is responsible for laying out its children.
		//		Widgets which mixin this code must define layout() to manage placement and sizing of the children.

		// baseClass: [protected extension] String
		//		This class name is applied to the widget's domNode
		//		and also may be used to generate names for sub nodes,
		//		for example dijitTabContainer-content.
		baseClass: "dijitLayoutContainer",

		// isLayoutContainer: [protected] Boolean
		//		Indicates that this widget is going to call resize() on its
		//		children widgets, setting their size, when they become visible.
		isLayoutContainer: true,

		// Cancel _WidgetBase's _setTitleAttr because we don't want the title property (used to specify
		// tab labels) to be set as an attribute on this.domNode... otherwise a tooltip shows up over the
		// entire widget.
		_setTitleAttr: null,

		buildRendering: function(){
			this.inherited(arguments);
			domClass.add(this.domNode, "dijitContainer");
		},

		startup: function(){
			// summary:
			//		Called after all the widgets have been instantiated and their
			//		dom nodes have been inserted somewhere under <body>.
			//
			//		Widgets should override this method to do any initialization
			//		dependent on other widgets existing, and then call
			//		this superclass method to finish things off.
			//
			//		startup() in subclasses shouldn't do anything
			//		size related because the size of the widget hasn't been set yet.

			if(this._started){ return; }

			// Need to call inherited first - so that child widgets get started
			// up correctly
			this.inherited(arguments);

			// If I am a not being controlled by a parent layout widget...
			var parent = this.getParent && this.getParent();
			if(!(parent && parent.isLayoutContainer)){
				// Do recursive sizing and layout of all my descendants
				// (passing in no argument to resize means that it has to glean the size itself)
				this.resize();

				// Since my parent isn't a layout container, and my style *may be* width=height=100%
				// or something similar (either set directly or via a CSS class),
				// monitor when viewport size changes so that I can re-layout.
				this.own(Viewport.on("resize", lang.hitch(this, "resize")));
			}
		},

		resize: function(changeSize, resultSize){
			// summary:
			//		Call this to resize a widget, or after its size has changed.
			// description:
			//		####Change size mode:
			//
			//		When changeSize is specified, changes the marginBox of this widget
			//		and forces it to re-layout its contents accordingly.
			//		changeSize may specify height, width, or both.
			//
			//		If resultSize is specified it indicates the size the widget will
			//		become after changeSize has been applied.
			//
			//		####Notification mode:
			//
			//		When changeSize is null, indicates that the caller has already changed
			//		the size of the widget, or perhaps it changed because the browser
			//		window was resized.  Tells widget to re-layout its contents accordingly.
			//
			//		If resultSize is also specified it indicates the size the widget has
			//		become.
			//
			//		In either mode, this method also:
			//
			//		1. Sets this._borderBox and this._contentBox to the new size of
			//			the widget.  Queries the current domNode size if necessary.
			//		2. Calls layout() to resize contents (and maybe adjust child widgets).
			// changeSize: Object?
			//		Sets the widget to this margin-box size and position.
			//		May include any/all of the following properties:
			//	|	{w: int, h: int, l: int, t: int}
			// resultSize: Object?
			//		The margin-box size of this widget after applying changeSize (if
			//		changeSize is specified).  If caller knows this size and
			//		passes it in, we don't need to query the browser to get the size.
			//	|	{w: int, h: int}

			var node = this.domNode;

			// set margin box size, unless it wasn't specified, in which case use current size
			if(changeSize){
				domGeometry.setMarginBox(node, changeSize);
			}

			// If either height or width wasn't specified by the user, then query node for it.
			// But note that setting the margin box and then immediately querying dimensions may return
			// inaccurate results, so try not to depend on it.
			var mb = resultSize || {};
			lang.mixin(mb, changeSize || {});	// changeSize overrides resultSize
			if( !("h" in mb) || !("w" in mb) ){
				mb = lang.mixin(domGeometry.getMarginBox(node), mb);	// just use domGeometry.marginBox() to fill in missing values
			}

			// Compute and save the size of my border box and content box
			// (w/out calling domGeometry.getContentBox() since that may fail if size was recently set)
			var cs = domStyle.getComputedStyle(node);
			var me = domGeometry.getMarginExtents(node, cs);
			var be = domGeometry.getBorderExtents(node, cs);
			var bb = (this._borderBox = {
				w: mb.w - (me.w + be.w),
				h: mb.h - (me.h + be.h)
			});
			var pe = domGeometry.getPadExtents(node, cs);
			this._contentBox = {
				l: domStyle.toPixelValue(node, cs.paddingLeft),
				t: domStyle.toPixelValue(node, cs.paddingTop),
				w: bb.w - pe.w,
				h: bb.h - pe.h
			};

			// Callback for widget to adjust size of its children
			this.layout();
		},

		layout: function(){
			// summary:
			//		Widgets override this method to size and position their contents/children.
			//		When this is called this._contentBox is guaranteed to be set (see resize()).
			//
			//		This is called after startup(), and also when the widget's size has been
			//		changed.
			// tags:
			//		protected extension
		},

		_setupChild: function(/*dijit/_WidgetBase*/child){
			// summary:
			//		Common setup for initial children and children which are added after startup
			// tags:
			//		protected extension

			var cls = this.baseClass + "-child "
				+ (child.baseClass ? this.baseClass + "-" + child.baseClass : "");
			domClass.add(child.domNode, cls);
		},

		addChild: function(/*dijit/_WidgetBase*/ child, /*Integer?*/ insertIndex){
			// Overrides _Container.addChild() to call _setupChild()
			this.inherited(arguments);
			if(this._started){
				this._setupChild(child);
			}
		},

		removeChild: function(/*dijit/_WidgetBase*/ child){
			// Overrides _Container.removeChild() to remove class added by _setupChild()
			var cls = this.baseClass + "-child"
					+ (child.baseClass ?
						" " + this.baseClass + "-" + child.baseClass : "");
			domClass.remove(child.domNode, cls);

			this.inherited(arguments);
		}
	});
});

},
'dijit/layout/TabContainer':function(){
define([
	"dojo/_base/lang", // lang.getObject
	"dojo/_base/declare", // declare
	"./_TabContainerBase",
	"./TabController",
	"./ScrollingTabController"
], function(lang, declare, _TabContainerBase, TabController, ScrollingTabController){

	// module:
	//		dijit/layout/TabContainer


	return declare("dijit.layout.TabContainer", _TabContainerBase, {
		// summary:
		//		A Container with tabs to select each child (only one of which is displayed at a time).
		// description:
		//		A TabContainer is a container that has multiple panes, but shows only
		//		one pane at a time.  There are a set of tabs corresponding to each pane,
		//		where each tab has the name (aka title) of the pane, and optionally a close button.
		//
		//		See `StackContainer.ChildWidgetProperties` for details on the properties that can be set on
		//		children of a `TabContainer`.

		// useMenu: [const] Boolean
		//		True if a menu should be used to select tabs when they are too
		//		wide to fit the TabContainer, false otherwise.
		useMenu: true,

		// useSlider: [const] Boolean
		//		True if a slider should be used to select tabs when they are too
		//		wide to fit the TabContainer, false otherwise.
		useSlider: true,

		// controllerWidget: Class
		//		An optional parameter to override the widget used to display the tab labels
		controllerWidget: "",

		_makeController: function(/*DomNode*/ srcNode){
			// summary:
			//		Instantiate tablist controller widget and return reference to it.
			//		Callback from _TabContainerBase.postCreate().
			// tags:
			//		protected extension

			// "string" branch for back-compat, remove for 2.0
			var cls = this.baseClass + "-tabs" + (this.doLayout ? "" : " dijitTabNoLayout"),
				TabController = typeof this.controllerWidget == "string" ? lang.getObject(this.controllerWidget) :
						this.controllerWidget;

			return new TabController({
				id: this.id + "_tablist",
				ownerDocument: this.ownerDocument,
				dir: this.dir,
				lang: this.lang,
				textDir: this.textDir,
				tabPosition: this.tabPosition,
				doLayout: this.doLayout,
				containerId: this.id,
				"class": cls,
				nested: this.nested,
				useMenu: this.useMenu,
				useSlider: this.useSlider,
				tabStripClass: this.tabStrip ? this.baseClass + (this.tabStrip ? "":"No") + "Strip": null
			}, srcNode);
		},

		postMixInProperties: function(){
			this.inherited(arguments);

			// Scrolling controller only works for horizontal non-nested tabs
			if(!this.controllerWidget){
				this.controllerWidget = (this.tabPosition == "top" || this.tabPosition == "bottom") && !this.nested ?
							ScrollingTabController : TabController;
			}
		}
	});
});

},
'dijit/layout/_TabContainerBase':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add
	"dojo/dom-geometry", // domGeometry.contentBox
	"dojo/dom-style", // domStyle.style
	"./StackContainer",
	"./utils", // marginBox2contextBox, layoutChildren
	"../registry",
	"../_TemplatedMixin",
	"dojo/text!./templates/TabContainer.html"
], function(declare, domClass, domGeometry, domStyle, StackContainer, layoutUtils, registry, _TemplatedMixin, template){

	// module:
	//		dijit/layout/_TabContainerBase

	return declare("dijit.layout._TabContainerBase", [StackContainer, _TemplatedMixin], {
		// summary:
		//		Abstract base class for TabContainer.   Must define _makeController() to instantiate
		//		and return the widget that displays the tab labels
		// description:
		//		A TabContainer is a container that has multiple panes, but shows only
		//		one pane at a time.  There are a set of tabs corresponding to each pane,
		//		where each tab has the name (aka title) of the pane, and optionally a close button.

		// tabPosition: String
		//		Defines where tabs go relative to tab content.
		//		"top", "bottom", "left-h", "right-h"
		tabPosition: "top",

		baseClass: "dijitTabContainer",

		// tabStrip: [const] Boolean
		//		Defines whether the tablist gets an extra class for layouting, putting a border/shading
		//		around the set of tabs.   Not supported by claro theme.
		tabStrip: false,

		// nested: [const] Boolean
		//		If true, use styling for a TabContainer nested inside another TabContainer.
		//		For tundra etc., makes tabs look like links, and hides the outer
		//		border since the outer TabContainer already has a border.
		nested: false,

		templateString: template,

		postMixInProperties: function(){
			// set class name according to tab position, ex: dijitTabContainerTop
			this.baseClass += this.tabPosition.charAt(0).toUpperCase() + this.tabPosition.substr(1).replace(/-.*/, "");

			this.srcNodeRef && domStyle.set(this.srcNodeRef, "visibility", "hidden");

			this.inherited(arguments);
		},

		buildRendering: function(){
			this.inherited(arguments);

			// Create the tab list that will have a tab (a.k.a. tab button) for each tab panel
			this.tablist = this._makeController(this.tablistNode);

			if(!this.doLayout){
				domClass.add(this.domNode, "dijitTabContainerNoLayout");
			}

			if(this.nested){
				/* workaround IE's lack of support for "a > b" selectors by
				 * tagging each node in the template.
				 */
				domClass.add(this.domNode, "dijitTabContainerNested");
				domClass.add(this.tablist.containerNode, "dijitTabContainerTabListNested");
				domClass.add(this.tablistSpacer, "dijitTabContainerSpacerNested");
				domClass.add(this.containerNode, "dijitTabPaneWrapperNested");
			}else{
				domClass.add(this.domNode, "tabStrip-" + (this.tabStrip ? "enabled" : "disabled"));
			}
		},

		_setupChild: function(/*dijit/_WidgetBase*/ tab){
			// Overrides StackContainer._setupChild().
			domClass.add(tab.domNode, "dijitTabPane");
			this.inherited(arguments);
		},

		startup: function(){
			if(this._started){
				return;
			}

			// wire up the tablist and its tabs
			this.tablist.startup();

			this.inherited(arguments);
		},

		layout: function(){
			// Overrides StackContainer.layout().
			// Configure the content pane to take up all the space except for where the tabs are

			if(!this._contentBox || typeof(this._contentBox.l) == "undefined"){
				return;
			}

			var sc = this.selectedChildWidget;

			if(this.doLayout){
				// position and size the titles and the container node
				var titleAlign = this.tabPosition.replace(/-h/, "");
				this.tablist.region = titleAlign;
				var children = [this.tablist, {
					domNode: this.tablistSpacer,
					region: titleAlign
				}, {
					domNode: this.containerNode,
					region: "center"
				}];
				layoutUtils.layoutChildren(this.domNode, this._contentBox, children);

				// Compute size to make each of my children.
				// children[2] is the margin-box size of this.containerNode, set by layoutChildren() call above
				this._containerContentBox = layoutUtils.marginBox2contentBox(this.containerNode, children[2]);

				if(sc && sc.resize){
					sc.resize(this._containerContentBox);
				}
			}else{
				// just layout the tab controller, so it can position left/right buttons etc.
				if(this.tablist.resize){
					//make the tabs zero width so that they don't interfere with width calc, then reset
					var s = this.tablist.domNode.style;
					s.width = "0";
					var width = domGeometry.getContentBox(this.domNode).w;
					s.width = "";
					this.tablist.resize({w: width});
				}

				// and call resize() on the selected pane just to tell it that it's been made visible
				if(sc && sc.resize){
					sc.resize();
				}
			}
		},

		destroy: function(preserveDom){
			if(this.tablist){
				this.tablist.destroy(preserveDom);
			}
			this.inherited(arguments);
		},

		selectChild: function(/*dijit/_WidgetBase|String*/ page, /*Boolean*/ animate){
			// Override _StackContainer.selectChild() so the page's focus isn't left in a strange state.

			if(this._focused){
				// Focus must be inside the currently selected tab,
				// or on the currently selected tab label.
				page = registry.byId(page);
				this.tablist.pane2button(page.id).focus();
			}
			return this.inherited(arguments);
		}
	});
});

},
'dijit/layout/StackContainer':function(){
define([
	"dojo/_base/array", // array.forEach array.indexOf array.some
	"dojo/cookie", // cookie
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.replace
	"dojo/dom-construct",
	"dojo/has", // has("dijit-legacy-requires")
	"dojo/_base/lang", // lang.extend
	"dojo/on",
	"dojo/ready",
	"dojo/topic", // publish
	"dojo/when",
	"../registry", // registry.byId
	"../_WidgetBase",
	"./_LayoutWidget"
], function(array, cookie, declare, domClass, domConstruct, has, lang, on, ready, topic, when, registry, _WidgetBase, _LayoutWidget){

	// module:
	//		dijit/layout/StackContainer

	// Back compat w/1.6, remove for 2.0
	if(has("dijit-legacy-requires")){
		ready(0, function(){
			var requires = ["dijit/layout/StackController"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	var StackContainer = declare("dijit.layout.StackContainer", _LayoutWidget, {
		// summary:
		//		A container that has multiple children, but shows only
		//		one child at a time
		//
		// description:
		//		A container for widgets (ContentPanes, for example) That displays
		//		only one Widget at a time.
		//
		//		Publishes topics [widgetId]-addChild, [widgetId]-removeChild, and [widgetId]-selectChild
		//
		//		Can be base class for container, Wizard, Show, etc.
		//
		//		See `StackContainer.ChildWidgetProperties` for details on the properties that can be set on
		//		children of a `StackContainer`.

		// doLayout: Boolean
		//		If true, change the size of my currently displayed child to match my size
		doLayout: true,

		// persist: Boolean
		//		Remembers the selected child across sessions
		persist: false,

		baseClass: "dijitStackContainer",

		/*=====
		// selectedChildWidget: [readonly] dijit._Widget
		//		References the currently selected child widget, if any.
		//		Adjust selected child with selectChild() method.
		selectedChildWidget: null,
		=====*/

		buildRendering: function(){
			this.inherited(arguments);
			domClass.add(this.domNode, "dijitLayoutContainer");
		},

		postCreate: function(){
			this.inherited(arguments);
			this.own(
				on(this.domNode, "keydown", lang.hitch(this, "_onKeyDown"))
			);
		},

		startup: function(){
			if(this._started){
				return;
			}

			var children = this.getChildren();

			// Setup each page panel to be initially hidden
			array.forEach(children, this._setupChild, this);

			// Figure out which child to initially display, defaulting to first one
			if(this.persist){
				this.selectedChildWidget = registry.byId(cookie(this.id + "_selectedChild"));
			}else{
				array.some(children, function(child){
					if(child.selected){
						this.selectedChildWidget = child;
					}
					return child.selected;
				}, this);
			}
			var selected = this.selectedChildWidget;
			if(!selected && children[0]){
				selected = this.selectedChildWidget = children[0];
				selected.selected = true;
			}

			// Publish information about myself so any StackControllers can initialize.
			// This needs to happen before this.inherited(arguments) so that for
			// TabContainer, this._contentBox doesn't include the space for the tab labels.
			topic.publish(this.id + "-startup", {children: children, selected: selected, textDir: this.textDir});

			// Startup each child widget, and do initial layout like setting this._contentBox,
			// then calls this.resize() which does the initial sizing on the selected child.
			this.inherited(arguments);
		},

		resize: function(){
			// Overrides _LayoutWidget.resize()
			// Resize is called when we are first made visible (it's called from startup()
			// if we are initially visible). If this is the first time we've been made
			// visible then show our first child.
			if(!this._hasBeenShown){
				this._hasBeenShown = true;
				var selected = this.selectedChildWidget;
				if(selected){
					this._showChild(selected);
				}
			}
			this.inherited(arguments);
		},

		_setupChild: function(/*dijit/_WidgetBase*/ child){
			// Overrides _LayoutWidget._setupChild()

			// For aria support, wrap child widget in a <div role="tabpanel">
			var childNode = child.domNode,
				wrapper = domConstruct.place(
					"<div role='tabpanel' class='" + this.baseClass + "ChildWrapper dijitHidden'>",
					child.domNode,
					"replace"),
				label = child["aria-label"] || child.title || child.label;
			if(label){
				// setAttribute() escapes special chars, and if() statement avoids setting aria-label="undefined"
				wrapper.setAttribute("aria-label", label);
			}
			domConstruct.place(childNode, wrapper);
			child._wrapper = wrapper;	// to set the aria-labelledby in StackController

			this.inherited(arguments);

			// child may have style="display: none" (at least our test cases do), so remove that
			if(childNode.style.display == "none"){
				childNode.style.display = "block";
			}

			// remove the title attribute so it doesn't show up when i hover over a node
			child.domNode.removeAttribute("title");
		},

		addChild: function(/*dijit/_WidgetBase*/ child, /*Integer?*/ insertIndex){
			// Overrides _Container.addChild() to do layout and publish events

			this.inherited(arguments);

			if(this._started){
				topic.publish(this.id + "-addChild", child, insertIndex);	// publish

				// in case the tab titles have overflowed from one line to two lines
				// (or, if this if first child, from zero lines to one line)
				// TODO: w/ScrollingTabController this is no longer necessary, although
				// ScrollTabController.resize() does need to get called to show/hide
				// the navigation buttons as appropriate, but that's handled in ScrollingTabController.onAddChild().
				// If this is updated to not layout [except for initial child added / last child removed], update
				// "childless startup" test in StackContainer.html to check for no resize event after second addChild()
				this.layout();

				// if this is the first child, then select it
				if(!this.selectedChildWidget){
					this.selectChild(child);
				}
			}
		},

		removeChild: function(/*dijit/_WidgetBase*/ page){
			// Overrides _Container.removeChild() to do layout and publish events

			var idx = array.indexOf(this.getChildren(), page);

			this.inherited(arguments);

			// Remove the child widget wrapper we use to set aria roles.  This won't affect the page itself since it's
			// already been detached from page._wrapper via the this.inherited(arguments) call above.
			domConstruct.destroy(page._wrapper);
			delete page._wrapper;

			if(this._started){
				// This will notify any tablists to remove a button; do this first because it may affect sizing.
				topic.publish(this.id + "-removeChild", page);
			}

			// If all our children are being destroyed than don't run the code below (to select another page),
			// because we are deleting every page one by one
			if(this._descendantsBeingDestroyed){
				return;
			}

			// Select new page to display, also updating TabController to show the respective tab.
			// Do this before layout call because it can affect the height of the TabController.
			if(this.selectedChildWidget === page){
				this.selectedChildWidget = undefined;
				if(this._started){
					var children = this.getChildren();
					if(children.length){
						this.selectChild(children[Math.max(idx - 1, 0)]);
					}
				}
			}

			if(this._started){
				// In case the tab titles now take up one line instead of two lines
				// (note though that ScrollingTabController never overflows to multiple lines),
				// or the height has changed slightly because of addition/removal of tab which close icon
				this.layout();
			}
		},

		selectChild: function(/*dijit/_WidgetBase|String*/ page, /*Boolean*/ animate){
			// summary:
			//		Show the given widget (which must be one of my children)
			// page:
			//		Reference to child widget or id of child widget

			var d;

			page = registry.byId(page);

			if(this.selectedChildWidget != page){
				// Deselect old page and select new one
				d = this._transition(page, this.selectedChildWidget, animate);
				this._set("selectedChildWidget", page);
				topic.publish(this.id + "-selectChild", page);	// publish

				if(this.persist){
					cookie(this.id + "_selectedChild", this.selectedChildWidget.id);
				}
			}

			// d may be null, or a scalar like true.  Return a promise in all cases
			return when(d || true);		// Promise
		},

		_transition: function(newWidget, oldWidget /*===== ,  animate =====*/){
			// summary:
			//		Hide the old widget and display the new widget.
			//		Subclasses should override this.
			// newWidget: dijit/_WidgetBase
			//		The newly selected widget.
			// oldWidget: dijit/_WidgetBase
			//		The previously selected widget.
			// animate: Boolean
			//		Used by AccordionContainer to turn on/off slide effect.
			// tags:
			//		protected extension
			if(oldWidget){
				this._hideChild(oldWidget);
			}
			var d = this._showChild(newWidget);

			// Size the new widget, in case this is the first time it's being shown,
			// or I have been resized since the last time it was shown.
			// Note that page must be visible for resizing to work.
			if(newWidget.resize){
				if(this.doLayout){
					newWidget.resize(this._containerContentBox || this._contentBox);
				}else{
					// the child should pick it's own size but we still need to call resize()
					// (with no arguments) to let the widget lay itself out
					newWidget.resize();
				}
			}

			return d;	// If child has an href, promise that fires when the child's href finishes loading
		},

		_adjacent: function(/*Boolean*/ forward){
			// summary:
			//		Gets the next/previous child widget in this container from the current selection.

			// TODO: remove for 2.0 if this isn't being used.   Otherwise, fix to skip disabled tabs.

			var children = this.getChildren();
			var index = array.indexOf(children, this.selectedChildWidget);
			index += forward ? 1 : children.length - 1;
			return children[ index % children.length ]; // dijit/_WidgetBase
		},

		forward: function(){
			// summary:
			//		Advance to next page.
			return this.selectChild(this._adjacent(true), true);
		},

		back: function(){
			// summary:
			//		Go back to previous page.
			return this.selectChild(this._adjacent(false), true);
		},

		_onKeyDown: function(e){
			topic.publish(this.id + "-containerKeyDown", { e: e, page: this});	// publish
		},

		layout: function(){
			// Implement _LayoutWidget.layout() virtual method.
			var child = this.selectedChildWidget;
			if(child && child.resize){
				if(this.doLayout){
					child.resize(this._containerContentBox || this._contentBox);
				}else{
					child.resize();
				}
			}
		},

		_showChild: function(/*dijit/_WidgetBase*/ page){
			// summary:
			//		Show the specified child by changing it's CSS, and call _onShow()/onShow() so
			//		it can do any updates it needs regarding loading href's etc.
			// returns:
			//		Promise that fires when page has finished showing, or true if there's no href
			var children = this.getChildren();
			page.isFirstChild = (page == children[0]);
			page.isLastChild = (page == children[children.length - 1]);
			page._set("selected", true);

			if(page._wrapper){	// false if not started yet
				domClass.replace(page._wrapper, "dijitVisible", "dijitHidden");
			}

			return (page._onShow && page._onShow()) || true;
		},

		_hideChild: function(/*dijit/_WidgetBase*/ page){
			// summary:
			//		Hide the specified child by changing it's CSS, and call _onHide() so
			//		it's notified.
			page._set("selected", false);

			if(page._wrapper){	// false if not started yet
				domClass.replace(page._wrapper, "dijitHidden", "dijitVisible");
			}

			page.onHide && page.onHide();
		},

		closeChild: function(/*dijit/_WidgetBase*/ page){
			// summary:
			//		Callback when user clicks the [X] to remove a page.
			//		If onClose() returns true then remove and destroy the child.
			// tags:
			//		private
			var remove = page.onClose && page.onClose(this, page);
			if(remove){
				this.removeChild(page);
				// makes sure we can clean up executeScripts in ContentPane onUnLoad
				page.destroyRecursive();
			}
		},

		destroyDescendants: function(/*Boolean*/ preserveDom){
			this._descendantsBeingDestroyed = true;
			this.selectedChildWidget = undefined;
			array.forEach(this.getChildren(), function(child){
				if(!preserveDom){
					this.removeChild(child);
				}
				child.destroyRecursive(preserveDom);
			}, this);
			this._descendantsBeingDestroyed = false;
		}
	});

	StackContainer.ChildWidgetProperties = {
		// summary:
		//		These properties can be specified for the children of a StackContainer.

		// selected: Boolean
		//		Specifies that this widget should be the initially displayed pane.
		//		Note: to change the selected child use `dijit/layout/StackContainer.selectChild`
		selected: false,

		// disabled: Boolean
		//		Specifies that the button to select this pane should be disabled.
		//		Doesn't affect programmatic selection of the pane, nor does it deselect the pane if it is currently selected.
		disabled: false,

		// closable: Boolean
		//		True if user can close (destroy) this child, such as (for example) clicking the X on the tab.
		closable: false,

		// iconClass: String
		//		CSS Class specifying icon to use in label associated with this pane.
		iconClass: "dijitNoIcon",

		// showTitle: Boolean
		//		When true, display title of this widget as tab label etc., rather than just using
		//		icon specified in iconClass
		showTitle: true
	};

	// Since any widget can be specified as a StackContainer child, mix them
	// into the base widget class.  (This is a hack, but it's effective.)
	// This is for the benefit of the parser.   Remove for 2.0.  Also, hide from doc viewer.
	lang.extend(_WidgetBase, /*===== {} || =====*/ StackContainer.ChildWidgetProperties);

	return StackContainer;
});

},
'dijit/layout/TabController':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"dojo/dom-attr", // domAttr.attr
	"dojo/dom-class", // domClass.toggle
	"dojo/has",
	"dojo/i18n", // i18n.getLocalization
	"dojo/_base/lang", // lang.hitch lang.trim
	"./StackController",
	"../registry",
	"../Menu",
	"../MenuItem",
	"dojo/text!./templates/_TabButton.html",
	"dojo/i18n!../nls/common"
], function(declare, dom, domAttr, domClass, has, i18n, lang, StackController, registry, Menu, MenuItem, template){

	// module:
	//		dijit/layout/TabController

	var TabButton = declare("dijit.layout._TabButton" + (has("dojo-bidi") ? "_NoBidi" : ""), StackController.StackButton, {
		// summary:
		//		A tab (the thing you click to select a pane).
		// description:
		//		Contains the title of the pane, and optionally a close-button to destroy the pane.
		//		This is an internal widget and should not be instantiated directly.
		// tags:
		//		private

		// baseClass: String
		//		The CSS class applied to the domNode.
		baseClass: "dijitTab",

		// Apply dijitTabCloseButtonHover when close button is hovered
		cssStateNodes: {
			closeNode: "dijitTabCloseButton"
		},

		templateString: template,

		// Button superclass maps name to a this.valueNode, but we don't have a this.valueNode attach point
		_setNameAttr: "focusNode",

		// Override _FormWidget.scrollOnFocus.
		// Don't scroll the whole tab container into view when the button is focused.
		scrollOnFocus: false,

		buildRendering: function(){
			this.inherited(arguments);

			dom.setSelectable(this.containerNode, false);
		},

		startup: function(){
			this.inherited(arguments);
			var n = this.domNode;

			// Required to give IE6 a kick, as it initially hides the
			// tabs until they are focused on.
			this.defer(function(){
				n.className = n.className;
			}, 1);
		},

		_setCloseButtonAttr: function(/*Boolean*/ disp){
			// summary:
			//		Hide/show close button
			this._set("closeButton", disp);
			domClass.toggle(this.domNode, "dijitClosable", disp);
			this.closeNode.style.display = disp ? "" : "none";
			if(disp){
				var _nlsResources = i18n.getLocalization("dijit", "common");
				if(this.closeNode){
					domAttr.set(this.closeNode, "title", _nlsResources.itemClose);
				}
			}
		},

		_setDisabledAttr: function(/*Boolean*/ disabled){
			// summary:
			//		Make tab selected/unselectable

			this.inherited(arguments);

			// Don't show tooltip for close button when tab is disabled
			if(this.closeNode){
				if(disabled){
					domAttr.remove(this.closeNode, "title");
				}else{
					var _nlsResources = i18n.getLocalization("dijit", "common");
					domAttr.set(this.closeNode, "title", _nlsResources.itemClose);
				}
			}
		},

		_setLabelAttr: function(/*String*/ content){
			// summary:
			//		Hook for set('label', ...) to work.
			// description:
			//		takes an HTML string.
			//		Inherited ToggleButton implementation will Set the label (text) of the button;
			//		Need to set the alt attribute of icon on tab buttons if no label displayed
			this.inherited(arguments);
			if(!this.showLabel && !this.params.title){
				this.iconNode.alt = lang.trim(this.containerNode.innerText || this.containerNode.textContent || '');
			}
		}
	});

	if(has("dojo-bidi")){
		TabButton = declare("dijit.layout._TabButton", TabButton, {
			_setLabelAttr: function(/*String*/ content){
				this.inherited(arguments);
				this.applyTextDir(this.iconNode, this.iconNode.alt);
			}
		});
	}

	var TabController = declare("dijit.layout.TabController", StackController, {
		// summary:
		//		Set of tabs (the things with titles and a close button, that you click to show a tab panel).
		//		Used internally by `dijit/layout/TabContainer`.
		// description:
		//		Lets the user select the currently shown pane in a TabContainer or StackContainer.
		//		TabController also monitors the TabContainer, and whenever a pane is
		//		added or deleted updates itself accordingly.
		// tags:
		//		private

		baseClass: "dijitTabController",

		templateString: "<div role='tablist' data-dojo-attach-event='onkeydown:onkeydown'></div>",

		// tabPosition: String
		//		Defines where tabs go relative to the content.
		//		"top", "bottom", "left-h", "right-h"
		tabPosition: "top",

		// buttonWidget: Constructor
		//		The tab widget to create to correspond to each page
		buttonWidget: TabButton,

		// buttonWidgetCloseClass: String
		//		Class of [x] close icon, used by event delegation code to tell when close button was clicked
		buttonWidgetCloseClass: "dijitTabCloseButton",

		postCreate: function(){
			this.inherited(arguments);

			// Setup a close menu to be shared between all the closable tabs (excluding disabled tabs)
			var closeMenu = new Menu({
				id: this.id + "_Menu",
				ownerDocument: this.ownerDocument,
				dir: this.dir,
				lang: this.lang,
				textDir: this.textDir,
				targetNodeIds: [this.domNode],
				selector: function(node){
					return domClass.contains(node, "dijitClosable") && !domClass.contains(node, "dijitTabDisabled");
				}
			});
			this.own(closeMenu);

			var _nlsResources = i18n.getLocalization("dijit", "common"),
				controller = this;
			closeMenu.addChild(new MenuItem({
				label: _nlsResources.itemClose,
				ownerDocument: this.ownerDocument,
				dir: this.dir,
				lang: this.lang,
				textDir: this.textDir,
				onClick: function(evt){
					var button = registry.byNode(this.getParent().currentTarget);
					controller.onCloseButtonClick(button.page);
				}
			}));
		}
	});

	TabController.TabButton = TabButton;	// for monkey patching

	return TabController;
});

},
'dijit/layout/StackController':function(){
define([
	"dojo/_base/array", // array.forEach array.indexOf array.map
	"dojo/_base/declare", // declare
	"dojo/dom-class",
	"dojo/dom-construct",
	"dojo/keys", // keys
	"dojo/_base/lang", // lang.getObject
	"dojo/on",
	"dojo/topic",
	"../focus", // focus.focus()
	"../registry", // registry.byId
	"../_Widget",
	"../_TemplatedMixin",
	"../_Container",
	"../form/ToggleButton",
	"dojo/touch"	// for normalized click handling, see dojoClick property setting in postCreate()
], function(array, declare, domClass, domConstruct, keys, lang, on, topic,
			focus, registry, _Widget, _TemplatedMixin,_Container, ToggleButton){

	// module:
	//		dijit/layout/StackController

	var StackButton = declare("dijit.layout._StackButton", ToggleButton, {
		// summary:
		//		Internal widget used by StackContainer.
		// description:
		//		The button-like or tab-like object you click to select or delete a page
		// tags:
		//		private

		// Override _FormWidget.tabIndex.
		// StackContainer buttons are not in the tab order by default.
		// Probably we should be calling this.startupKeyNavChildren() instead.
		tabIndex: "-1",

		// closeButton: Boolean
		//		When true, display close button for this tab
		closeButton: false,

		_aria_attr: "aria-selected",

		buildRendering: function(/*Event*/ evt){
			this.inherited(arguments);
			(this.focusNode || this.domNode).setAttribute("role", "tab");
		}
	});


	var StackController = declare("dijit.layout.StackController", [_Widget, _TemplatedMixin, _Container], {
		// summary:
		//		Set of buttons to select a page in a `dijit/layout/StackContainer`
		// description:
		//		Monitors the specified StackContainer, and whenever a page is
		//		added, deleted, or selected, updates itself accordingly.

		baseClass: "dijitStackController",

		templateString: "<span role='tablist' data-dojo-attach-event='onkeydown'></span>",

		// containerId: [const] String
		//		The id of the page container that I point to
		containerId: "",

		// buttonWidget: [const] Constructor
		//		The button widget to create to correspond to each page
		buttonWidget: StackButton,

		// buttonWidgetCloseClass: String
		//		CSS class of [x] close icon, used by event delegation code to tell when close button was clicked
		buttonWidgetCloseClass: "dijitStackCloseButton",

		pane2button: function(/*String*/ id){
			// summary:
			//		Returns the button corresponding to the pane w/the given id.
			// tags:
			//		protected
			return registry.byId(this.id + "_" + id);
		},

		postCreate: function(){
			this.inherited(arguments);

			// Listen to notifications from StackContainer.  This is tricky because the StackContainer may not have
			// been created yet, so abstracting it through topics.
			// Note: for TabContainer we can do this through bubbled events instead of topics; maybe that's
			// all we support for 2.0?
			this.own(
				topic.subscribe(this.containerId + "-startup", lang.hitch(this, "onStartup")),
				topic.subscribe(this.containerId + "-addChild", lang.hitch(this, "onAddChild")),
				topic.subscribe(this.containerId + "-removeChild", lang.hitch(this, "onRemoveChild")),
				topic.subscribe(this.containerId + "-selectChild", lang.hitch(this, "onSelectChild")),
				topic.subscribe(this.containerId + "-containerKeyDown", lang.hitch(this, "onContainerKeyDown"))
			);

			// Listen for click events to select or close tabs.
			// No need to worry about ENTER/SPACE key handling: tabs are selected via left/right arrow keys,
			// and closed via shift-F10 (to show the close menu).
			// Also, add flag to use normalized click handling from dojo/touch
			this.containerNode.dojoClick = true;
			this.own(on(this.containerNode, 'click', lang.hitch(this, function(evt){
				var button = registry.getEnclosingWidget(evt.target);
				if(button != this.containerNode && !button.disabled && button.page){
					for(var target = evt.target; target !== this.containerNode; target = target.parentNode){
						if(domClass.contains(target, this.buttonWidgetCloseClass)){
							this.onCloseButtonClick(button.page);
							break;
						}else if(target == button.domNode){
							this.onButtonClick(button.page);
							break;
						}
					}
				}
			})));
		},

		onStartup: function(/*Object*/ info){
			// summary:
			//		Called after StackContainer has finished initializing
			// tags:
			//		private
			this.textDir = info.textDir;
			array.forEach(info.children, this.onAddChild, this);
			if(info.selected){
				// Show button corresponding to selected pane (unless selected
				// is null because there are no panes)
				this.onSelectChild(info.selected);
			}

			// Reflect events like page title changes to tab buttons
			var containerNode = registry.byId(this.containerId).containerNode,
				pane2button = lang.hitch(this, "pane2button"),
				paneToButtonAttr = {
					"title": "label",
					"showtitle": "showLabel",
					"iconclass": "iconClass",
					"closable": "closeButton",
					"tooltip": "title",
					"disabled": "disabled",
					"textdir": "textdir"
				},
				connectFunc = function(attr, buttonAttr){
					return on(containerNode, "attrmodified-" + attr, function(evt){
						var button = pane2button(evt.detail && evt.detail.widget && evt.detail.widget.id);
						if(button){
							button.set(buttonAttr, evt.detail.newValue);
						}
					});
				};
			for(var attr in paneToButtonAttr){
				this.own(connectFunc(attr, paneToButtonAttr[attr]));
			}
		},

		destroy: function(preserveDom){
			// Since the buttons are internal to the StackController widget, destroy() should remove them.
			// When #5796 is fixed for 2.0 can get rid of this function completely.
			this.destroyDescendants(preserveDom);
			this.inherited(arguments);
		},

		onAddChild: function(/*dijit/_WidgetBase*/ page, /*Integer?*/ insertIndex){
			// summary:
			//		Called whenever a page is added to the container.
			//		Create button corresponding to the page.
			// tags:
			//		private

			// create an instance of the button widget
			// (remove typeof buttonWidget == string support in 2.0)
			var Cls = lang.isString(this.buttonWidget) ? lang.getObject(this.buttonWidget) : this.buttonWidget;
			var button = new Cls({
				id: this.id + "_" + page.id,
				name: this.id + "_" + page.id, // note: must match id used in pane2button()
				label: page.title,
				disabled: page.disabled,
				ownerDocument: this.ownerDocument,
				dir: page.dir,
				lang: page.lang,
				textDir: page.textDir || this.textDir,
				showLabel: page.showTitle,
				iconClass: page.iconClass,
				closeButton: page.closable,
				title: page.tooltip,
				page: page
			});

			this.addChild(button, insertIndex);
			page.controlButton = button;	// this value might be overwritten if two tabs point to same container
			if(!this._currentChild){
				// If this is the first child then StackContainer will soon publish that it's selected,
				// but before that StackContainer calls layout(), and before layout() is called the
				// StackController needs to have the proper height... which means that the button needs
				// to be marked as selected now.   See test_TabContainer_CSS.html for test.
				this.onSelectChild(page);
			}

			// Add this StackController button to the list of things that labels that StackContainer pane.
			// Also, if there's an aria-labelledby parameter for the pane, then the aria-label parameter is unneeded.
			var labelledby = page._wrapper.getAttribute("aria-labelledby") ?
				page._wrapper.getAttribute("aria-labelledby") + " " + button.id : button.id;
			page._wrapper.removeAttribute("aria-label");
			page._wrapper.setAttribute("aria-labelledby", labelledby);
		},

		onRemoveChild: function(/*dijit/_WidgetBase*/ page){
			// summary:
			//		Called whenever a page is removed from the container.
			//		Remove the button corresponding to the page.
			// tags:
			//		private

			if(this._currentChild === page){
				this._currentChild = null;
			}

			var button = this.pane2button(page.id);
			if(button){
				this.removeChild(button);
				button.destroy();
			}
			delete page.controlButton;
		},

		onSelectChild: function(/*dijit/_WidgetBase*/ page){
			// summary:
			//		Called when a page has been selected in the StackContainer, either by me or by another StackController
			// tags:
			//		private

			if(!page){
				return;
			}

			if(this._currentChild){
				var oldButton = this.pane2button(this._currentChild.id);
				oldButton.set('checked', false);
				oldButton.focusNode.setAttribute("tabIndex", "-1");
			}

			var newButton = this.pane2button(page.id);
			newButton.set('checked', true);
			this._currentChild = page;
			newButton.focusNode.setAttribute("tabIndex", "0");
			var container = registry.byId(this.containerId);
		},

		onButtonClick: function(/*dijit/_WidgetBase*/ page){
			// summary:
			//		Called whenever one of my child buttons is pressed in an attempt to select a page
			// tags:
			//		private

			var button = this.pane2button(page.id);

			// For TabContainer where the tabs are <span>, need to set focus explicitly when left/right arrow
			focus.focus(button.focusNode);

			if(this._currentChild && this._currentChild.id === page.id){
				//In case the user clicked the checked button, keep it in the checked state because it remains to be the selected stack page.
				button.set('checked', true);
			}
			var container = registry.byId(this.containerId);
			container.selectChild(page);
		},

		onCloseButtonClick: function(/*dijit/_WidgetBase*/ page){
			// summary:
			//		Called whenever one of my child buttons [X] is pressed in an attempt to close a page
			// tags:
			//		private

			var container = registry.byId(this.containerId);
			container.closeChild(page);
			if(this._currentChild){
				var b = this.pane2button(this._currentChild.id);
				if(b){
					focus.focus(b.focusNode || b.domNode);
				}
			}
		},

		// TODO: this is a bit redundant with forward, back api in StackContainer
		adjacent: function(/*Boolean*/ forward){
			// summary:
			//		Helper for onkeydown to find next/previous button
			// tags:
			//		private

			if(!this.isLeftToRight() && (!this.tabPosition || /top|bottom/.test(this.tabPosition))){
				forward = !forward;
			}
			// find currently focused button in children array
			var children = this.getChildren();
			var idx = array.indexOf(children, this.pane2button(this._currentChild.id)),
				current = children[idx];

			// Pick next/previous non-disabled button to focus on.   If we get back to the original button it means
			// that all buttons must be disabled, so return current child to avoid an infinite loop.
			var child;
			do{
				idx = (idx + (forward ? 1 : children.length - 1)) % children.length;
				child = children[idx];
			}while(child.disabled && child != current);

			return child; // dijit/_WidgetBase
		},

		onkeydown: function(/*Event*/ e, /*Boolean?*/ fromContainer){
			// summary:
			//		Handle keystrokes on the page list, for advancing to next/previous button
			//		and closing the current page if the page is closable.
			// tags:
			//		private

			if(this.disabled || e.altKey){
				return;
			}
			var forward = null;
			if(e.ctrlKey || !e._djpage){
				switch(e.keyCode){
					case keys.LEFT_ARROW:
					case keys.UP_ARROW:
						if(!e._djpage){
							forward = false;
						}
						break;
					case keys.PAGE_UP:
						if(e.ctrlKey){
							forward = false;
						}
						break;
					case keys.RIGHT_ARROW:
					case keys.DOWN_ARROW:
						if(!e._djpage){
							forward = true;
						}
						break;
					case keys.PAGE_DOWN:
						if(e.ctrlKey){
							forward = true;
						}
						break;
					case keys.HOME:
						// Navigate to first non-disabled child
						var children = this.getChildren();
						for(var idx = 0; idx < children.length; idx++){
							var child = children[idx];
							if(!child.disabled){
								this.onButtonClick(child.page);
								break;
							}
						}
						e.stopPropagation();
						e.preventDefault();
						break;
					case keys.END:
						// Navigate to last non-disabled child
						var children = this.getChildren();
						for(var idx = children.length - 1; idx >= 0; idx--){
							var child = children[idx];
							if(!child.disabled){
								this.onButtonClick(child.page);
								break;
							}
						}
						e.stopPropagation();
						e.preventDefault();
						break;
					case keys.DELETE:
					case "W".charCodeAt(0):    // ctrl-W
						if(this._currentChild.closable &&
							(e.keyCode == keys.DELETE || e.ctrlKey)){
							this.onCloseButtonClick(this._currentChild);

							// avoid browser tab closing
							e.stopPropagation();
							e.preventDefault();
						}
						break;
					case keys.TAB:
						if(e.ctrlKey){
							this.onButtonClick(this.adjacent(!e.shiftKey).page);
							e.stopPropagation();
							e.preventDefault();
						}
						break;
				}
				// handle next/previous page navigation (left/right arrow, etc.)
				if(forward !== null){
					this.onButtonClick(this.adjacent(forward).page);
					e.stopPropagation();
					e.preventDefault();
				}
			}
		},

		onContainerKeyDown: function(/*Object*/ info){
			// summary:
			//		Called when there was a keydown on the container
			// tags:
			//		private
			info.e._djpage = info.page;
			this.onkeydown(info.e);
		}
	});

	StackController.StackButton = StackButton;	// for monkey patching

	return StackController;
});

},
'dijit/form/ToggleButton':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/_base/kernel", // kernel.deprecated
	"./Button",
	"./_ToggleButtonMixin"
], function(declare, kernel, Button, _ToggleButtonMixin){

	// module:
	//		dijit/form/ToggleButton


	return declare("dijit.form.ToggleButton", [Button, _ToggleButtonMixin], {
		// summary:
		//		A templated button widget that can be in two states (checked or not).
		//		Can be base class for things like tabs or checkbox or radio buttons.

		baseClass: "dijitToggleButton",

		setChecked: function(/*Boolean*/ checked){
			// summary:
			//		Deprecated.  Use set('checked', true/false) instead.
			kernel.deprecated("setChecked("+checked+") is deprecated. Use set('checked',"+checked+") instead.", "", "2.0");
			this.set('checked', checked);
		}
	});
});

},
'dijit/form/_ToggleButtonMixin':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-attr" // domAttr.set
], function(declare, domAttr){

	// module:
	//		dijit/form/_ToggleButtonMixin

	return declare("dijit.form._ToggleButtonMixin", null, {
		// summary:
		//		A mixin to provide functionality to allow a button that can be in two states (checked or not).

		// checked: Boolean
		//		Corresponds to the native HTML `<input>` element's attribute.
		//		In markup, specified as "checked='checked'" or just "checked".
		//		True if the button is depressed, or the checkbox is checked,
		//		or the radio button is selected, etc.
		checked: false,

		// aria-pressed for toggle buttons, and aria-checked for checkboxes
		_aria_attr: "aria-pressed",

		_onClick: function(/*Event*/ evt){
			var original = this.checked;
			this._set('checked', !original); // partially set the toggled value, assuming the toggle will work, so it can be overridden in the onclick handler
			var ret = this.inherited(arguments); // the user could reset the value here
			this.set('checked', ret ? this.checked : original); // officially set the toggled or user value, or reset it back
			return ret;
		},

		_setCheckedAttr: function(/*Boolean*/ value, /*Boolean?*/ priorityChange){
			this._set("checked", value);
			var node = this.focusNode || this.domNode;
			if(this._created){ // IE is not ready to handle checked attribute (affects tab order)
				// needlessly setting "checked" upsets IE's tab order
				if(domAttr.get(node, "checked") != !!value){
					domAttr.set(node, "checked", !!value); // "mixed" -> true
				}
			}
			node.setAttribute(this._aria_attr, String(value)); // aria values should be strings
			this._handleOnChange(value, priorityChange);
		},

		postCreate: function(){ // use postCreate instead of startup so users forgetting to call startup are OK
			this.inherited(arguments);
			var node = this.focusNode || this.domNode;
			if(this.checked){
				// need this here instead of on the template so IE8 tab order works
				node.setAttribute('checked', 'checked');
			}

			// Update our reset value if it hasn't yet been set (because this.set()
			// is only called when there *is* a value)
			if(this._resetValue === undefined){
				this._lastValueReported = this._resetValue = this.checked;
			}
		},

		reset: function(){
			// summary:
			//		Reset the widget's value to what it was at initialization time

			this._hasBeenBlurred = false;

			// set checked state to original setting
			this.set('checked', this.params.checked || false);
		}
	});
});

},
'dijit/Menu':function(){
define([
	"require",
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.byId dom.isDescendant
	"dojo/dom-attr", // domAttr.get domAttr.set domAttr.has domAttr.remove
	"dojo/dom-geometry", // domStyle.getComputedStyle domGeometry.position
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/keys", // keys.F10
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/sniff", // has("ie"), has("quirks")
	"dojo/_base/window", // win.body
	"dojo/window", // winUtils.get
	"./popup",
	"./DropDownMenu",
	"dojo/ready"
], function(require, array, declare, dom, domAttr, domGeometry, domStyle, keys, lang, on, has, win, winUtils, pm, DropDownMenu, ready){

	// module:
	//		dijit/Menu

	// Back compat w/1.6, remove for 2.0
	if(has("dijit-legacy-requires")){
		ready(0, function(){
			var requires = ["dijit/MenuItem", "dijit/PopupMenuItem", "dijit/CheckedMenuItem", "dijit/MenuSeparator"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	return declare("dijit.Menu", DropDownMenu, {
		// summary:
		//		A context menu you can assign to multiple elements

		constructor: function(/*===== params, srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified:
			//
			//		- use srcNodeRef.innerHTML as my contents
			//		- replace srcNodeRef with my generated DOM tree

			this._bindings = [];
		},

		// targetNodeIds: [const] String[]
		//		Array of dom node ids of nodes to attach to.
		//		Fill this with nodeIds upon widget creation and it becomes context menu for those nodes.
		targetNodeIds: [],

		// selector: String?
		//		CSS expression to apply this Menu to descendants of targetNodeIds, rather than to
		//		the nodes specified by targetNodeIds themselves.  Useful for applying a Menu to
		//		a range of rows in a table, tree, etc.
		//
		//		The application must require() an appropriate level of dojo/query to handle the selector.
		selector: "",

		// TODO: in 2.0 remove support for multiple targetNodeIds.   selector gives the same effect.
		// So, change targetNodeIds to a targetNodeId: "", remove bindDomNode()/unBindDomNode(), etc.

		/*=====
		// currentTarget: [readonly] DOMNode
		//		For context menus, set to the current node that the Menu is being displayed for.
		//		Useful so that the menu actions can be tailored according to the node
		currentTarget: null,
		=====*/

		// contextMenuForWindow: [const] Boolean
		//		If true, right clicking anywhere on the window will cause this context menu to open.
		//		If false, must specify targetNodeIds.
		contextMenuForWindow: false,

		// leftClickToOpen: [const] Boolean
		//		If true, menu will open on left click instead of right click, similar to a file menu.
		leftClickToOpen: false,
		// TODO: remove in 2.0, we have better ways of opening a menu with a left click, by extending _HasDropDown.

		// refocus: Boolean
		//		When this menu closes, re-focus the element which had focus before it was opened.
		refocus: true,

		postCreate: function(){
			if(this.contextMenuForWindow){
				this.bindDomNode(this.ownerDocumentBody);
			}else{
				array.forEach(this.targetNodeIds, this.bindDomNode, this);
			}
			this.inherited(arguments);
		},

		// thanks burstlib!
		_iframeContentWindow: function(/* HTMLIFrameElement */iframe_el){
			// summary:
			//		Returns the window reference of the passed iframe
			// tags:
			//		private
			return winUtils.get(this._iframeContentDocument(iframe_el)) ||
				// Moz. TODO: is this available when defaultView isn't?
				this._iframeContentDocument(iframe_el)['__parent__'] ||
				(iframe_el.name && document.frames[iframe_el.name]) || null;	//	Window
		},

		_iframeContentDocument: function(/* HTMLIFrameElement */iframe_el){
			// summary:
			//		Returns a reference to the document object inside iframe_el
			// tags:
			//		protected
			return iframe_el.contentDocument // W3
				|| (iframe_el.contentWindow && iframe_el.contentWindow.document) // IE
				|| (iframe_el.name && document.frames[iframe_el.name] && document.frames[iframe_el.name].document)
				|| null;	//	HTMLDocument
		},

		bindDomNode: function(/*String|DomNode*/ node){
			// summary:
			//		Attach menu to given node
			node = dom.byId(node, this.ownerDocument);

			var cn;	// Connect node

			// Support context menus on iframes.  Rather than binding to the iframe itself we need
			// to bind to the <body> node inside the iframe.
			if(node.tagName.toLowerCase() == "iframe"){
				var iframe = node,
					window = this._iframeContentWindow(iframe);
				cn = win.body(window.document);
			}else{
				// To capture these events at the top level, attach to <html>, not <body>.
				// Otherwise right-click context menu just doesn't work.
				cn = (node == win.body(this.ownerDocument) ? this.ownerDocument.documentElement : node);
			}


			// "binding" is the object to track our connection to the node (ie, the parameter to bindDomNode())
			var binding = {
				node: node,
				iframe: iframe
			};

			// Save info about binding in _bindings[], and make node itself record index(+1) into
			// _bindings[] array.  Prefix w/_dijitMenu to avoid setting an attribute that may
			// start with a number, which fails on FF/safari.
			domAttr.set(node, "_dijitMenu" + this.id, this._bindings.push(binding));

			// Setup the connections to monitor click etc., unless we are connecting to an iframe which hasn't finished
			// loading yet, in which case we need to wait for the onload event first, and then connect
			// On linux Shift-F10 produces the oncontextmenu event, but on Windows it doesn't, so
			// we need to monitor keyboard events in addition to the oncontextmenu event.
			var doConnects = lang.hitch(this, function(cn){
				var selector = this.selector,
					delegatedEvent = selector ?
						function(eventType){
							return on.selector(selector, eventType);
						} :
						function(eventType){
							return eventType;
						},
					self = this;
				return [
					on(cn, delegatedEvent(this.leftClickToOpen ? "click" : "contextmenu"), function(evt){
						evt.stopPropagation();
						evt.preventDefault();

						if((new Date()).getTime() < this._lastKeyDown + 500){
							// Ignore contextmenu/click events that were already processed in keydown handler below.
							// But still call preventDefault() (above) so system context menu doesn't appear.
							return;
						}

						// Schedule context menu to be opened.
						// Note that this won't work will if the click was generated by the keyboard, while
						// focused on a <button> etc.   In that case evt.pageX and evt.pageY are either (0,0) or
						// wherever the mouse cursor is.  See keydown handler below.
						self._scheduleOpen(this, iframe, {x: evt.pageX, y: evt.pageY}, evt.target);
					}),
					on(cn, delegatedEvent("keydown"), function(evt){
						if(evt.keyCode == 93 ||									// context menu key
							(evt.shiftKey && evt.keyCode == keys.F10) ||		// shift-F10
							(this.leftClickToOpen && evt.keyCode == keys.SPACE)	// space key
						){
							evt.stopPropagation();
							evt.preventDefault();

							// Open the menu around evt.target.  Note that "this" and evt.target
							// are likely different, especially for global context menu, where "this" is <body>.
							self._scheduleOpen(this, iframe, null, evt.target);	// no coords - open near evt.target

							this._lastKeyDown = (new Date()).getTime();
						}
					})
				];
			});
			binding.connects = cn ? doConnects(cn) : [];

			if(iframe){
				// Setup handler to [re]bind to the iframe when the contents are initially loaded,
				// and every time the contents change.
				// Need to do this b/c we are actually binding to the iframe's <body> node.
				// Note: can't use connect.connect(), see #9609.

				binding.onloadHandler = lang.hitch(this, function(){
					// want to remove old connections, but IE throws exceptions when trying to
					// access the <body> node because it's already gone, or at least in a state of limbo

					var window = this._iframeContentWindow(iframe),
						cn = win.body(window.document);
					binding.connects = doConnects(cn);
				});
				if(iframe.addEventListener){
					iframe.addEventListener("load", binding.onloadHandler, false);
				}else{
					iframe.attachEvent("onload", binding.onloadHandler);
				}
			}
		},

		unBindDomNode: function(/*String|DomNode*/ nodeName){
			// summary:
			//		Detach menu from given node

			var node;
			try{
				node = dom.byId(nodeName, this.ownerDocument);
			}catch(e){
				// On IE the dom.byId() call will get an exception if the attach point was
				// the <body> node of an <iframe> that has since been reloaded (and thus the
				// <body> node is in a limbo state of destruction.
				return;
			}

			// node["_dijitMenu" + this.id] contains index(+1) into my _bindings[] array
			var attrName = "_dijitMenu" + this.id;
			if(node && domAttr.has(node, attrName)){
				var bid = domAttr.get(node, attrName) - 1, b = this._bindings[bid], h;
				while((h = b.connects.pop())){
					h.remove();
				}

				// Remove listener for iframe onload events
				var iframe = b.iframe;
				if(iframe){
					if(iframe.removeEventListener){
						iframe.removeEventListener("load", b.onloadHandler, false);
					}else{
						iframe.detachEvent("onload", b.onloadHandler);
					}
				}

				domAttr.remove(node, attrName);
				delete this._bindings[bid];
			}
		},

		_scheduleOpen: function(delegatedTarget, iframe, coords, target){
			// summary:
			//		Set timer to display myself.  Using a timer rather than displaying immediately solves
			//		IE problem: without the delay, focus work in "open" causes the system
			//		context menu to appear in spite of evt.preventDefault().
			// delegatedTarget: Element
			//		The node specified in targetNodeIds or matching selector that the menu is being opened for.
			// iframe: HTMLIframeElement?
			//		Set if target is inside the specified iframe.
			// coords: Object
			//		x/y position to center the menu around.  Undefined if menu was opened via keyboard.
			// target: Element
			//		The actual clicked node, either delegatedTarget or a descendant.

			if(!this._openTimer){
				this._openTimer = this.defer(function(){
					delete this._openTimer;
					this._openMyself({
						target: target,
						delegatedTarget: delegatedTarget,
						iframe: iframe,
						coords: coords
					});
				}, 1);
			}
		},

		_openMyself: function(args){
			// summary:
			//		Internal function for opening myself when the user does a right-click or something similar.
			// args:
			//		This is an Object containing:
			//
			//		- target: The node that is being clicked.
			//		- delegatedTarget: The node from this.targetNodeIds or matching this.selector,
			//		  either the same as target or an ancestor of target.
			//		- iframe: If an `<iframe>` is being clicked, iframe points to that iframe
			//		- coords: Mouse cursor x/y coordinates.  Null when opened via keyboard.
			//		  Put menu at specified position in iframe (if iframe specified) or otherwise in viewport.
			//
			//		_openMyself() formerly took the event object, and since various code references
			//		evt.target (after connecting to _openMyself()), using an Object for parameters
			//		(so that old code still works).

			var target = args.target,
				iframe = args.iframe,
				coords = args.coords,
				byKeyboard = !coords;

			// To be used by MenuItem event handlers to tell which node the menu was opened on
			this.currentTarget = args.delegatedTarget;

			// Get coordinates to open menu, either at specified (mouse) position or (if triggered via keyboard)
			// then near the node the menu is assigned to.
			if(coords){
				if(iframe){
					// Specified coordinates are on <body> node of an <iframe>, convert to match main document
					var ifc = domGeometry.position(iframe, true),
						window = this._iframeContentWindow(iframe),
						scroll = domGeometry.docScroll(window.document);

					var cs = domStyle.getComputedStyle(iframe),
						tp = domStyle.toPixelValue,
						left = (has("ie") && has("quirks") ? 0 : tp(iframe, cs.paddingLeft)) + (has("ie") && has("quirks") ? tp(iframe, cs.borderLeftWidth) : 0),
						top = (has("ie") && has("quirks") ? 0 : tp(iframe, cs.paddingTop)) + (has("ie") && has("quirks") ? tp(iframe, cs.borderTopWidth) : 0);

					coords.x += ifc.x + left - scroll.x;
					coords.y += ifc.y + top - scroll.y;
				}
			}else{
				coords = domGeometry.position(target, true);
				coords.x += 10;
				coords.y += 10;
			}

			var self = this;
			var prevFocusNode = this._focusManager.get("prevNode");
			var curFocusNode = this._focusManager.get("curNode");
			var savedFocusNode = !curFocusNode || (dom.isDescendant(curFocusNode, this.domNode)) ? prevFocusNode : curFocusNode;

			function closeAndRestoreFocus(){
				// user has clicked on a menu or popup
				if(self.refocus && savedFocusNode){
					savedFocusNode.focus();
				}
				pm.close(self);
			}

			pm.open({
				popup: this,
				x: coords.x,
				y: coords.y,
				onExecute: closeAndRestoreFocus,
				onCancel: closeAndRestoreFocus,
				orient: this.isLeftToRight() ? 'L' : 'R'
			});

			// Focus the menu even when opened by mouse, so that a click on blank area of screen will close it
			this.focus();
			if(!byKeyboard){
				// But then (when opened by mouse), mark Menu as passive, so that the first item isn't highlighted.
				// On IE9+ this needs to be on a delay because the focus is asynchronous.
				this.defer(function(){
					this._cleanUp(true);
				});
			}

			this._onBlur = function(){
				this.inherited('_onBlur', arguments);
				// Usually the parent closes the child widget but if this is a context
				// menu then there is no parent
				pm.close(this);
				// don't try to restore focus; user has clicked another part of the screen
				// and set focus there
			};
		},

		destroy: function(){
			array.forEach(this._bindings, function(b){
				if(b){
					this.unBindDomNode(b.node);
				}
			}, this);
			this.inherited(arguments);
		}
	});
});

},
'dijit/DropDownMenu':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/keys", // keys
	"dojo/text!./templates/Menu.html",
	"./_MenuBase"
], function(declare, keys, template, _MenuBase){

	// module:
	//		dijit/DropDownMenu

	return declare("dijit.DropDownMenu", _MenuBase, {
		// summary:
		//		A menu, without features for context menu (Meaning, drop down menu)

		templateString: template,

		baseClass: "dijitMenu",

		// Arrow key navigation
		_onUpArrow: function(){
			this.focusPrev();
		},
		_onDownArrow: function(){
			this.focusNext();
		},
		_onRightArrow: function(/*Event*/ evt){
			this._moveToPopup(evt);
			evt.stopPropagation();
			evt.preventDefault();
		},
		_onLeftArrow: function(/*Event*/ evt){
			if(this.parentMenu){
				if(this.parentMenu._isMenuBar){
					this.parentMenu.focusPrev();
				}else{
					this.onCancel(false);
				}
			}else{
				evt.stopPropagation();
				evt.preventDefault();
			}
		}
	});
});

},
'dijit/_MenuBase':function(){
define([
	"dojo/_base/array", // array.indexOf
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.isDescendant domClass.replace
	"dojo/dom-attr",
	"dojo/dom-class", // domClass.replace
	"dojo/_base/lang", // lang.hitch
	"dojo/mouse", // mouse.enter, mouse.leave
	"dojo/on",
	"dojo/window",
	"./a11yclick",
	"./registry",
	"./_Widget",
	"./_CssStateMixin",
	"./_KeyNavContainer",
	"./_TemplatedMixin"
], function(array, declare, dom, domAttr, domClass, lang, mouse, on, winUtils, a11yclick,
			registry, _Widget, _CssStateMixin, _KeyNavContainer, _TemplatedMixin){

	// module:
	//		dijit/_MenuBase

	return declare("dijit._MenuBase", [_Widget, _TemplatedMixin, _KeyNavContainer, _CssStateMixin], {
		// summary:
		//		Abstract base class for Menu and MenuBar.
		//		Subclass should implement _onUpArrow(), _onDownArrow(), _onLeftArrow(), and _onRightArrow().

		// selected: dijit/MenuItem
		//		Currently selected (a.k.a. highlighted) MenuItem, or null if no MenuItem is selected.
		//		If a submenu is open, will be set to MenuItem that displayed the submenu.   OTOH, if
		//		this Menu is in passive mode (i.e. hasn't been clicked yet), will be null, because
		//		"selected" is not merely "hovered".
		selected: null,
		_setSelectedAttr: function(item){
			if(this.selected != item){
				if(this.selected){
					this.selected._setSelected(false);
					this._onChildDeselect(this.selected);
				}
				if(item){
					item._setSelected(true);
				}
				this._set("selected", item);
			}
		},

		// activated: [readonly] Boolean
		//		This Menu has been clicked (mouse or via space/arrow key) or opened as a submenu,
		//		so mere mouseover will open submenus.  Focusing a menu via TAB does NOT automatically make it active
		//		since TAB is a navigation operation and not a selection one.
		//		For Windows apps, pressing the ALT key focuses the menubar menus (similar to TAB navigation) but the
		//		menu is not active (ie no dropdown) until an item is clicked.
		activated: false,
		_setActivatedAttr: function(val){
			domClass.toggle(this.domNode, "dijitMenuActive", val);
			domClass.toggle(this.domNode, "dijitMenuPassive", !val);
			this._set("activated", val);
		},

		// parentMenu: [readonly] Widget
		//		pointer to menu that displayed me
		parentMenu: null,

		// popupDelay: Integer
		//		After a menu has been activated (by clicking on it etc.), number of milliseconds before hovering
		//		(without clicking) another MenuItem causes that MenuItem's popup to automatically open.
		popupDelay: 500,

		// passivePopupDelay: Integer
		//		For a passive (unclicked) Menu, number of milliseconds before hovering (without clicking) will cause
		//		the popup to open.  Default is Infinity, meaning you need to click the menu to open it.
		passivePopupDelay: Infinity,

		// autoFocus: Boolean
		//		A toggle to control whether or not a Menu gets focused when opened as a drop down from a MenuBar
		//		or DropDownButton/ComboButton.   Note though that it always get focused when opened via the keyboard.
		autoFocus: false,

		childSelector: function(/*DOMNode*/ node){
			// summary:
			//		Selector (passed to on.selector()) used to identify MenuItem child widgets, but exclude inert children
			//		like MenuSeparator.  If subclass overrides to a string (ex: "> *"), the subclass must require dojo/query.
			// tags:
			//		protected

			var widget = registry.byNode(node);
			return node.parentNode == this.containerNode && widget && widget.focus;
		},

		postCreate: function(){
			var self = this,
				matches = typeof this.childSelector == "string" ? this.childSelector : lang.hitch(this, "childSelector");
			this.own(
				on(this.containerNode, on.selector(matches, mouse.enter), function(){
					self.onItemHover(registry.byNode(this));
				}),
				on(this.containerNode, on.selector(matches, mouse.leave), function(){
					self.onItemUnhover(registry.byNode(this));
				}),
				on(this.containerNode, on.selector(matches, a11yclick), function(evt){
					self.onItemClick(registry.byNode(this), evt);
					evt.stopPropagation();
				}),
				on(this.containerNode, on.selector(matches, "focusin"), function(){
					self._onItemFocus(registry.byNode(this));
				})
			);
			this.inherited(arguments);
		},

		onKeyboardSearch: function(/*MenuItem*/ item, /*Event*/ evt, /*String*/ searchString, /*Number*/ numMatches){
			// summary:
			//		Attach point for notification about when a menu item has been searched for
			//		via the keyboard search mechanism.
			// tags:
			//		protected
			this.inherited(arguments);
			if(!!item && (numMatches == -1 || (!!item.popup && numMatches == 1))){
				this.onItemClick(item, evt);
			}
		},

		_keyboardSearchCompare: function(/*dijit/_WidgetBase*/ item, /*String*/ searchString){
			// summary:
			//		Compares the searchString to the widget's text label, returning:
			//		-1: a high priority match and stop searching
			//		 0: no match
			//		 1: a match but keep looking for a higher priority match
			// tags:
			//		private
			if(!!item.shortcutKey){
				// accessKey matches have priority
				return searchString == item.shortcutKey.toLowerCase() ? -1 : 0;
			}
			return this.inherited(arguments) ? 1 : 0; // change return value of -1 to 1 so that searching continues
		},

		onExecute: function(){
			// summary:
			//		Attach point for notification about when a menu item has been executed.
			//		This is an internal mechanism used for Menus to signal to their parent to
			//		close them, because they are about to execute the onClick handler.  In
			//		general developers should not attach to or override this method.
			// tags:
			//		protected
		},

		onCancel: function(/*Boolean*/ /*===== closeAll =====*/){
			// summary:
			//		Attach point for notification about when the user cancels the current menu
			//		This is an internal mechanism used for Menus to signal to their parent to
			//		close them.  In general developers should not attach to or override this method.
			// tags:
			//		protected
		},

		_moveToPopup: function(/*Event*/ evt){
			// summary:
			//		This handles the right arrow key (left arrow key on RTL systems),
			//		which will either open a submenu, or move to the next item in the
			//		ancestor MenuBar
			// tags:
			//		private

			if(this.focusedChild && this.focusedChild.popup && !this.focusedChild.disabled){
				this.onItemClick(this.focusedChild, evt);
			}else{
				var topMenu = this._getTopMenu();
				if(topMenu && topMenu._isMenuBar){
					topMenu.focusNext();
				}
			}
		},

		_onPopupHover: function(/*Event*/ /*===== evt =====*/){
			// summary:
			//		This handler is called when the mouse moves over the popup.
			// tags:
			//		private

			// if the mouse hovers over a menu popup that is in pending-close state,
			// then stop the close operation.
			// This can't be done in onItemHover since some popup targets don't have MenuItems (e.g. ColorPicker)

			// highlight the parent menu item pointing to this popup (in case user temporarily moused over another MenuItem)
			this.set("selected", this.currentPopupItem);

			// cancel the pending close (if there is one) (in case user temporarily moused over another MenuItem)
			this._stopPendingCloseTimer();
		},

		onItemHover: function(/*MenuItem*/ item){
			// summary:
			//		Called when cursor is over a MenuItem.
			// tags:
			//		protected

			// Don't do anything unless user has "activated" the menu by:
			//		1) clicking it
			//		2) opening it from a parent menu (which automatically activates it)

			if(this.activated){
				this.set("selected", item);
				if(item.popup && !item.disabled && !this.hover_timer){
					this.hover_timer = this.defer(function(){
						this._openItemPopup(item);
					}, this.popupDelay);
				}
			}else if(this.passivePopupDelay < Infinity){
				if(this.passive_hover_timer){
					this.passive_hover_timer.remove();
				}
				this.passive_hover_timer = this.defer(function(){
					this.onItemClick(item, {type: "click"});
				}, this.passivePopupDelay);
			}

			this._hoveredChild = item;

			item._set("hovering", true);
		},

		_onChildDeselect: function(item){
			// summary:
			//		Called when a child MenuItem becomes deselected.   Setup timer to close its popup.

			this._stopPopupTimer();

			// Setup timer to close all popups that are open and descendants of this menu.
			// Will be canceled if user quickly moves the mouse over the popup.
			if(this.currentPopupItem == item){
				this._stopPendingCloseTimer();
				this._pendingClose_timer = this.defer(function(){
					this._pendingClose_timer = null;
					this.currentPopupItem = null;
					item._closePopup(); // this calls onClose
				}, this.popupDelay);
			}
		},

		onItemUnhover: function(/*MenuItem*/ item){
			// summary:
			//		Callback fires when mouse exits a MenuItem
			// tags:
			//		protected

			if(this._hoveredChild == item){
				this._hoveredChild = null;
			}

			if(this.passive_hover_timer){
				this.passive_hover_timer.remove();
				this.passive_hover_timer = null;
			}

			item._set("hovering", false);
		},

		_stopPopupTimer: function(){
			// summary:
			//		Cancels the popup timer because the user has stop hovering
			//		on the MenuItem, etc.
			// tags:
			//		private

			if(this.hover_timer){
				this.hover_timer = this.hover_timer.remove();
			}
		},

		_stopPendingCloseTimer: function(){
			// summary:
			//		Cancels the pending-close timer because the close has been preempted
			// tags:
			//		private
			if(this._pendingClose_timer){
				this._pendingClose_timer = this._pendingClose_timer.remove();
			}
		},

		_getTopMenu: function(){
			// summary:
			//		Returns the top menu in this chain of Menus
			// tags:
			//		private
			for(var top = this; top.parentMenu; top = top.parentMenu){}
			return top;
		},

		onItemClick: function(/*dijit/_WidgetBase*/ item, /*Event*/ evt){
			// summary:
			//		Handle clicks on an item.
			// tags:
			//		private

			if(this.passive_hover_timer){
				this.passive_hover_timer.remove();
			}

			this.focusChild(item);

			if(item.disabled){
				return false;
			}

			if(item.popup){
				this.set("selected", item);
				this.set("activated", true);
				var byKeyboard = /^key/.test(evt._origType || evt.type) ||
					(evt.clientX == 0 && evt.clientY == 0);	// detects accessKey like ALT+SHIFT+F, where type is "click"
				this._openItemPopup(item, byKeyboard);
			}else{
				// before calling user defined handler, close hierarchy of menus
				// and restore focus to place it was when menu was opened
				this.onExecute();

				// user defined handler for click
				item._onClick ? item._onClick(evt) : item.onClick(evt);
			}
		},

		_openItemPopup: function(/*dijit/MenuItem*/ from_item, /*Boolean*/ focus){
			// summary:
			//		Open the popup to the side of/underneath the current menu item, and optionally focus first item
			// tags:
			//		protected

			if(from_item == this.currentPopupItem){
				// Specified popup is already being shown, so just return
				return;
			}
			if(this.currentPopupItem){
				// If another popup is currently shown, then close it
				this._stopPendingCloseTimer();
				this.currentPopupItem._closePopup();
			}
			this._stopPopupTimer();

			var popup = from_item.popup;
			popup.parentMenu = this;

			// detect mouseover of the popup to handle lazy mouse movements that temporarily focus other menu items\c
			this.own(this._mouseoverHandle = on.once(popup.domNode, "mouseover", lang.hitch(this, "_onPopupHover")));

			var self = this;
			from_item._openPopup({
				parent: this,
				orient: this._orient || ["after", "before"],
				onCancel: function(){ // called when the child menu is canceled
					if(focus){
						// put focus back on my node before focused node is hidden
						self.focusChild(from_item);
					}

					// close the submenu (be sure this is done _after_ focus is moved)
					self._cleanUp();
				},
				onExecute: lang.hitch(this, "_cleanUp", true),
				onClose: function(){
					// Remove handler created by onItemHover
					if(self._mouseoverHandle){
						self._mouseoverHandle.remove();
						delete self._mouseoverHandle;
					}
				}
			}, focus);

			this.currentPopupItem = from_item;

			// TODO: focusing a popup should clear tabIndex on Menu (and it's child MenuItems), so that neither
			// TAB nor SHIFT-TAB returns to the menu.  Only ESC or ENTER should return to the menu.
		},

		onOpen: function(/*Event*/ /*===== e =====*/){
			// summary:
			//		Callback when this menu is opened.
			//		This is called by the popup manager as notification that the menu
			//		was opened.
			// tags:
			//		private

			this.isShowingNow = true;
			this.set("activated", true);
		},

		onClose: function(){
			// summary:
			//		Callback when this menu is closed.
			//		This is called by the popup manager as notification that the menu
			//		was closed.
			// tags:
			//		private

			this.set("activated", false);
			this.set("selected", null);
			this.isShowingNow = false;
			this.parentMenu = null;
		},

		_closeChild: function(){
			// summary:
			//		Called when submenu is clicked or focus is lost.  Close hierarchy of menus.
			// tags:
			//		private
			this._stopPopupTimer();

			if(this.currentPopupItem){
				// If focus is on a descendant MenuItem then move focus to me,
				// because IE doesn't like it when you display:none a node with focus,
				// and also so keyboard users don't lose control.
				// Likely, immediately after a user defined onClick handler will move focus somewhere
				// else, like a Dialog.
				if(this.focused){
					domAttr.set(this.selected.focusNode, "tabIndex", this.tabIndex);
					this.selected.focusNode.focus();
				}

				// Close all popups that are open and descendants of this menu
				this.currentPopupItem._closePopup();
				this.currentPopupItem = null;
			}
		},

		_onItemFocus: function(/*MenuItem*/ item){
			// summary:
			//		Called when child of this Menu gets focus from:
			//
			//		1. clicking it
			//		2. tabbing into it
			//		3. being opened by a parent menu.
			//
			//		This is not called just from mouse hover.

			if(this._hoveredChild && this._hoveredChild != item){
				this.onItemUnhover(this._hoveredChild);	// any previous mouse movement is trumped by focus selection
			}
			this.set("selected", item);
		},

		_onBlur: function(){
			// summary:
			//		Called when focus is moved away from this Menu and it's submenus.
			// tags:
			//		protected

			this._cleanUp(true);
			this.inherited(arguments);
		},

		_cleanUp: function(/*Boolean*/ clearSelectedItem){
			// summary:
			//		Called when the user is done with this menu.  Closes hierarchy of menus.
			// tags:
			//		private

			this._closeChild(); // don't call this.onClose since that's incorrect for MenuBar's that never close
			if(typeof this.isShowingNow == 'undefined'){ // non-popup menu doesn't call onClose
				this.set("activated", false);
			}

			if(clearSelectedItem){
				this.set("selected", null);
			}
		}
	});
});

},
'dijit/_KeyNavContainer':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/keys", // keys.END keys.HOME
	"dojo/_base/lang", // lang.hitch
	"./registry",
	"./_Container",
	"./_FocusMixin",
	"./_KeyNavMixin"
], function(array, declare, domAttr, kernel, keys, lang, registry, _Container, _FocusMixin, _KeyNavMixin){


	// module:
	//		dijit/_KeyNavContainer

	return declare("dijit._KeyNavContainer", [_FocusMixin, _KeyNavMixin, _Container], {
		// summary:
		//		A _Container with keyboard navigation of its children.
		// description:
		//		Provides normalized keyboard and focusing code for Container widgets.
		//		To use this mixin, call connectKeyNavHandlers() in postCreate().
		//		Also, child widgets must implement a focus() method.

		connectKeyNavHandlers: function(/*keys[]*/ prevKeyCodes, /*keys[]*/ nextKeyCodes){
			// summary:
			//		Deprecated.  You can call this in postCreate() to attach the keyboard handlers to the container,
			//		but the preferred method is to override _onLeftArrow() and _onRightArrow(), or
			//		_onUpArrow() and _onDownArrow(), to call focusPrev() and focusNext().
			// prevKeyCodes: keys[]
			//		Key codes for navigating to the previous child.
			// nextKeyCodes: keys[]
			//		Key codes for navigating to the next child.
			// tags:
			//		protected

			// TODO: remove for 2.0, and make subclasses override _onLeftArrow, _onRightArrow etc. instead.

			var keyCodes = (this._keyNavCodes = {});
			var prev = lang.hitch(this, "focusPrev");
			var next = lang.hitch(this, "focusNext");
			array.forEach(prevKeyCodes, function(code){
				keyCodes[code] = prev;
			});
			array.forEach(nextKeyCodes, function(code){
				keyCodes[code] = next;
			});
			keyCodes[keys.HOME] = lang.hitch(this, "focusFirstChild");
			keyCodes[keys.END] = lang.hitch(this, "focusLastChild");
		},

		startupKeyNavChildren: function(){
			kernel.deprecated("startupKeyNavChildren() call no longer needed", "", "2.0");
		},

		startup: function(){
			this.inherited(arguments);
			array.forEach(this.getChildren(), lang.hitch(this, "_startupChild"));
		},

		addChild: function(/*dijit/_WidgetBase*/ widget, /*int?*/ insertIndex){
			this.inherited(arguments);
			this._startupChild(widget);
		},

		_startupChild: function(/*dijit/_WidgetBase*/ widget){
			// summary:
			//		Setup for each child widget.
			// description:
			//		Sets tabIndex=-1 on each child, so that the tab key will
			//		leave the container rather than visiting each child.
			//
			//		Note: if you add children by a different method than addChild(), then need to call this manually
			//		or at least make sure the child's tabIndex is -1.
			//
			//		Note: see also _LayoutWidget.setupChild(), which is also called for each child widget.
			// tags:
			//		private

			widget.set("tabIndex", "-1");
		},

		_getFirst: function(){
			// summary:
			//		Returns the first child.
			// tags:
			//		abstract extension
			var children = this.getChildren();
			return children.length ? children[0] : null;
		},

		_getLast: function(){
			// summary:
			//		Returns the last descendant.
			// tags:
			//		abstract extension
			var children = this.getChildren();
			return children.length ? children[children.length - 1] : null;
		},

		focusNext: function(){
			// summary:
			//		Focus the next widget
			// tags:
			//		protected
			this.focusChild(this._getNextFocusableChild(this.focusedChild, 1));
		},

		focusPrev: function(){
			// summary:
			//		Focus the last focusable node in the previous widget
			//		(ex: go to the ComboButton icon section rather than button section)
			// tags:
			//		protected
			this.focusChild(this._getNextFocusableChild(this.focusedChild, -1), true);
		},

		childSelector: function(/*DOMNode*/ node){
			// Implement _KeyNavMixin.childSelector, to identify focusable child nodes.
			// If we allowed a dojo/query dependency from this module this could more simply be a string "> *"
			// instead of this function.

			var node = registry.byNode(node);
			return node && node.getParent() == this;
		}
	});
});

},
'dijit/layout/ScrollingTabController':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.contains
	"dojo/dom-geometry", // domGeometry.contentBox
	"dojo/dom-style", // domStyle.style
	"dojo/_base/fx", // Animation
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/query", // query
	"dojo/sniff", // has("ie"), has("webkit"), has("quirks")
	"../registry", // registry.byId()
	"dojo/text!./templates/ScrollingTabController.html",
	"dojo/text!./templates/_ScrollingTabControllerButton.html",
	"./TabController",
	"./utils", // marginBox2contextBox, layoutChildren
	"../_WidgetsInTemplateMixin",
	"../Menu",
	"../MenuItem",
	"../form/Button",
	"../_HasDropDown",
	"dojo/NodeList-dom", // NodeList.style
	"../a11yclick"	// template uses ondijitclick (not for keyboard support, but for responsive touch support)
], function(array, declare, domClass, domGeometry, domStyle, fx, lang, on, query, has,
	registry, tabControllerTemplate, buttonTemplate, TabController, layoutUtils, _WidgetsInTemplateMixin,
	Menu, MenuItem, Button, _HasDropDown){

	// module:
	//		dijit/layout/ScrollingTabController

	var ScrollingTabController = declare("dijit.layout.ScrollingTabController", [TabController, _WidgetsInTemplateMixin], {
		// summary:
		//		Set of tabs with left/right arrow keys and a menu to switch between tabs not
		//		all fitting on a single row.
		//		Works only for horizontal tabs (either above or below the content, not to the left
		//		or right).
		// tags:
		//		private

		baseClass: "dijitTabController dijitScrollingTabController",

		templateString: tabControllerTemplate,

		// useMenu: [const] Boolean
		//		True if a menu should be used to select tabs when they are too
		//		wide to fit the TabContainer, false otherwise.
		useMenu: true,

		// useSlider: [const] Boolean
		//		True if a slider should be used to select tabs when they are too
		//		wide to fit the TabContainer, false otherwise.
		useSlider: true,

		// tabStripClass: [const] String
		//		The css class to apply to the tab strip, if it is visible.
		tabStripClass: "",

		// _minScroll: Number
		//		The distance in pixels from the edge of the tab strip which,
		//		if a scroll animation is less than, forces the scroll to
		//		go all the way to the left/right.
		_minScroll: 5,

		// Override default behavior mapping class to DOMNode
		_setClassAttr: { node: "containerNode", type: "class" },

		buildRendering: function(){
			this.inherited(arguments);
			var n = this.domNode;

			this.scrollNode = this.tablistWrapper;
			this._initButtons();

			if(!this.tabStripClass){
				this.tabStripClass = "dijitTabContainer" +
					this.tabPosition.charAt(0).toUpperCase() +
					this.tabPosition.substr(1).replace(/-.*/, "") +
					"None";
				domClass.add(n, "tabStrip-disabled")
			}

			domClass.add(this.tablistWrapper, this.tabStripClass);
		},

		onStartup: function(){
			this.inherited(arguments);

			// TabController is hidden until it finishes drawing, to give
			// a less visually jumpy instantiation.   When it's finished, set visibility to ""
			// to that the tabs are hidden/shown depending on the container's visibility setting.
			domStyle.set(this.domNode, "visibility", "");
			this._postStartup = true;

			// changes to the tab button label or iconClass will have changed the width of the
			// buttons, so do a resize
			this.own(on(this.containerNode, "attrmodified-label, attrmodified-iconclass", lang.hitch(this, function(evt){
				if(this._dim){
					this.resize(this._dim);
				}
			})));
		},

		onAddChild: function(page, insertIndex){
			this.inherited(arguments);

			// Increment the width of the wrapper when a tab is added
			// This makes sure that the buttons never wrap.
			// The value 200 is chosen as it should be bigger than most
			// Tab button widths.
			domStyle.set(this.containerNode, "width",
				(domStyle.get(this.containerNode, "width") + 200) + "px");
		},

		onRemoveChild: function(page, insertIndex){
			// null out _selectedTab because we are about to delete that dom node
			var button = this.pane2button(page.id);
			if(this._selectedTab === button.domNode){
				this._selectedTab = null;
			}

			this.inherited(arguments);
		},

		_initButtons: function(){
			// summary:
			//		Creates the buttons used to scroll to view tabs that
			//		may not be visible if the TabContainer is too narrow.

			// Make a list of the buttons to display when the tab labels become
			// wider than the TabContainer, and hide the other buttons.
			// Also gets the total width of the displayed buttons.
			this._btnWidth = 0;
			this._buttons = query("> .tabStripButton", this.domNode).filter(function(btn){
				if((this.useMenu && btn == this._menuBtn.domNode) ||
					(this.useSlider && (btn == this._rightBtn.domNode || btn == this._leftBtn.domNode))){
					this._btnWidth += domGeometry.getMarginSize(btn).w;
					return true;
				}else{
					domStyle.set(btn, "display", "none");
					return false;
				}
			}, this);
		},

		_getTabsWidth: function(){
			var children = this.getChildren();
			if(children.length){
				var leftTab = children[this.isLeftToRight() ? 0 : children.length - 1].domNode,
					rightTab = children[this.isLeftToRight() ? children.length - 1 : 0].domNode;
				return rightTab.offsetLeft + rightTab.offsetWidth - leftTab.offsetLeft;
			}else{
				return 0;
			}
		},

		_enableBtn: function(width){
			// summary:
			//		Determines if the tabs are wider than the width of the TabContainer, and
			//		thus that we need to display left/right/menu navigation buttons.
			var tabsWidth = this._getTabsWidth();
			width = width || domStyle.get(this.scrollNode, "width");
			return tabsWidth > 0 && width < tabsWidth;
		},

		resize: function(dim){
			// summary:
			//		Hides or displays the buttons used to scroll the tab list and launch the menu
			//		that selects tabs.

			// Save the dimensions to be used when a child is renamed.
			this._dim = dim;

			// Set my height to be my natural height (tall enough for one row of tab labels),
			// and my content-box width based on margin-box width specified in dim parameter.
			// But first reset scrollNode.height in case it was set by layoutChildren() call
			// in a previous run of this method.
			this.scrollNode.style.height = "auto";
			var cb = this._contentBox = layoutUtils.marginBox2contentBox(this.domNode, {h: 0, w: dim.w});
			cb.h = this.scrollNode.offsetHeight;
			domGeometry.setContentSize(this.domNode, cb);

			// Show/hide the left/right/menu navigation buttons depending on whether or not they
			// are needed.
			var enable = this._enableBtn(this._contentBox.w);
			this._buttons.style("display", enable ? "" : "none");

			// Position and size the navigation buttons and the tablist
			this._leftBtn.region = "left";
			this._rightBtn.region = "right";
			this._menuBtn.region = this.isLeftToRight() ? "right" : "left";
			layoutUtils.layoutChildren(this.domNode, this._contentBox,
				[this._menuBtn, this._leftBtn, this._rightBtn, {domNode: this.scrollNode, region: "center"}]);

			// set proper scroll so that selected tab is visible
			if(this._selectedTab){
				if(this._anim && this._anim.status() == "playing"){
					this._anim.stop();
				}
				this.scrollNode.scrollLeft = this._convertToScrollLeft(this._getScrollForSelectedTab());
			}

			// Enable/disabled left right buttons depending on whether or not user can scroll to left or right
			this._setButtonClass(this._getScroll());

			this._postResize = true;

			// Return my size so layoutChildren() can use it.
			// Also avoids IE9 layout glitch on browser resize when scroll buttons present
			return {h: this._contentBox.h, w: dim.w};
		},

		_getScroll: function(){
			// summary:
			//		Returns the current scroll of the tabs where 0 means
			//		"scrolled all the way to the left" and some positive number, based on #
			//		of pixels of possible scroll (ex: 1000) means "scrolled all the way to the right"
			return (this.isLeftToRight() || has("ie") < 8 || (has("ie") && has("quirks")) || has("webkit")) ? this.scrollNode.scrollLeft :
				domStyle.get(this.containerNode, "width") - domStyle.get(this.scrollNode, "width")
					+ (has("ie") >= 8 ? -1 : 1) * this.scrollNode.scrollLeft;
		},

		_convertToScrollLeft: function(val){
			// summary:
			//		Given a scroll value where 0 means "scrolled all the way to the left"
			//		and some positive number, based on # of pixels of possible scroll (ex: 1000)
			//		means "scrolled all the way to the right", return value to set this.scrollNode.scrollLeft
			//		to achieve that scroll.
			//
			//		This method is to adjust for RTL funniness in various browsers and versions.
			if(this.isLeftToRight() || has("ie") < 8 || (has("ie") && has("quirks")) || has("webkit")){
				return val;
			}else{
				var maxScroll = domStyle.get(this.containerNode, "width") - domStyle.get(this.scrollNode, "width");
				return (has("ie") >= 8 ? -1 : 1) * (val - maxScroll);
			}
		},

		onSelectChild: function(/*dijit/_WidgetBase*/ page){
			// summary:
			//		Smoothly scrolls to a tab when it is selected.

			var tab = this.pane2button(page.id);
			if(!tab){
				return;
			}

			var node = tab.domNode;

			// Save the selection
			if(node != this._selectedTab){
				this._selectedTab = node;

				// Scroll to the selected tab, except on startup, when scrolling is handled in resize()
				if(this._postResize){
					var sl = this._getScroll();

					if(sl > node.offsetLeft ||
						sl + domStyle.get(this.scrollNode, "width") <
							node.offsetLeft + domStyle.get(node, "width")){
						this.createSmoothScroll().play();
					}
				}
			}

			this.inherited(arguments);
		},

		_getScrollBounds: function(){
			// summary:
			//		Returns the minimum and maximum scroll setting to show the leftmost and rightmost
			//		tabs (respectively)
			var children = this.getChildren(),
				scrollNodeWidth = domStyle.get(this.scrollNode, "width"), // about 500px
				containerWidth = domStyle.get(this.containerNode, "width"), // 50,000px
				maxPossibleScroll = containerWidth - scrollNodeWidth, // scrolling until right edge of containerNode visible
				tabsWidth = this._getTabsWidth();

			if(children.length && tabsWidth > scrollNodeWidth){
				// Scrolling should happen
				return {
					min: this.isLeftToRight() ? 0 : children[children.length - 1].domNode.offsetLeft,
					max: this.isLeftToRight() ?
						(children[children.length - 1].domNode.offsetLeft + children[children.length - 1].domNode.offsetWidth) - scrollNodeWidth :
						maxPossibleScroll
				};
			}else{
				// No scrolling needed, all tabs visible, we stay either scrolled to far left or far right (depending on dir)
				var onlyScrollPosition = this.isLeftToRight() ? 0 : maxPossibleScroll;
				return {
					min: onlyScrollPosition,
					max: onlyScrollPosition
				};
			}
		},

		_getScrollForSelectedTab: function(){
			// summary:
			//		Returns the scroll value setting so that the selected tab
			//		will appear in the center
			var w = this.scrollNode,
				n = this._selectedTab,
				scrollNodeWidth = domStyle.get(this.scrollNode, "width"),
				scrollBounds = this._getScrollBounds();

			// TODO: scroll minimal amount (to either right or left) so that
			// selected tab is fully visible, and just return if it's already visible?
			var pos = (n.offsetLeft + domStyle.get(n, "width") / 2) - scrollNodeWidth / 2;
			pos = Math.min(Math.max(pos, scrollBounds.min), scrollBounds.max);

			// TODO:
			// If scrolling close to the left side or right side, scroll
			// all the way to the left or right.  See this._minScroll.
			// (But need to make sure that doesn't scroll the tab out of view...)
			return pos;
		},

		createSmoothScroll: function(x){
			// summary:
			//		Creates a dojo._Animation object that smoothly scrolls the tab list
			//		either to a fixed horizontal pixel value, or to the selected tab.
			// description:
			//		If an number argument is passed to the function, that horizontal
			//		pixel position is scrolled to.  Otherwise the currently selected
			//		tab is scrolled to.
			// x: Integer?
			//		An optional pixel value to scroll to, indicating distance from left.

			// Calculate position to scroll to
			if(arguments.length > 0){
				// position specified by caller, just make sure it's within bounds
				var scrollBounds = this._getScrollBounds();
				x = Math.min(Math.max(x, scrollBounds.min), scrollBounds.max);
			}else{
				// scroll to center the current tab
				x = this._getScrollForSelectedTab();
			}

			if(this._anim && this._anim.status() == "playing"){
				this._anim.stop();
			}

			var self = this,
				w = this.scrollNode,
				anim = new fx.Animation({
					beforeBegin: function(){
						if(this.curve){
							delete this.curve;
						}
						var oldS = w.scrollLeft,
							newS = self._convertToScrollLeft(x);
						anim.curve = new fx._Line(oldS, newS);
					},
					onAnimate: function(val){
						w.scrollLeft = val;
					}
				});
			this._anim = anim;

			// Disable/enable left/right buttons according to new scroll position
			this._setButtonClass(x);

			return anim; // dojo/_base/fx/Animation
		},

		_getBtnNode: function(/*Event*/ e){
			// summary:
			//		Gets a button DOM node from a mouse click event.
			// e:
			//		The mouse click event.
			var n = e.target;
			while(n && !domClass.contains(n, "tabStripButton")){
				n = n.parentNode;
			}
			return n;
		},

		doSlideRight: function(/*Event*/ e){
			// summary:
			//		Scrolls the menu to the right.
			// e:
			//		The mouse click event.
			this.doSlide(1, this._getBtnNode(e));
		},

		doSlideLeft: function(/*Event*/ e){
			// summary:
			//		Scrolls the menu to the left.
			// e:
			//		The mouse click event.
			this.doSlide(-1, this._getBtnNode(e));
		},

		doSlide: function(/*Number*/ direction, /*DomNode*/ node){
			// summary:
			//		Scrolls the tab list to the left or right by 75% of the widget width.
			// direction:
			//		If the direction is 1, the widget scrolls to the right, if it is -1,
			//		it scrolls to the left.

			if(node && domClass.contains(node, "dijitTabDisabled")){
				return;
			}

			var sWidth = domStyle.get(this.scrollNode, "width");
			var d = (sWidth * 0.75) * direction;

			var to = this._getScroll() + d;

			this._setButtonClass(to);

			this.createSmoothScroll(to).play();
		},

		_setButtonClass: function(/*Number*/ scroll){
			// summary:
			//		Disables the left scroll button if the tabs are scrolled all the way to the left,
			//		or the right scroll button in the opposite case.
			// scroll: Integer
			//		amount of horizontal scroll

			var scrollBounds = this._getScrollBounds();
			this._leftBtn.set("disabled", scroll <= scrollBounds.min);
			this._rightBtn.set("disabled", scroll >= scrollBounds.max);
		}
	});


	var ScrollingTabControllerButtonMixin = declare("dijit.layout._ScrollingTabControllerButtonMixin", null, {
		baseClass: "dijitTab tabStripButton",

		templateString: buttonTemplate,

		// Override inherited tabIndex: 0 from dijit/form/Button, because user shouldn't be
		// able to tab to the left/right/menu buttons
		tabIndex: "",

		// Similarly, override FormWidget.isFocusable() because clicking a button shouldn't focus it
		// either (this override avoids focus() call in FormWidget.js)
		isFocusable: function(){
			return false;
		}
	});

	// Class used in template
	declare("dijit.layout._ScrollingTabControllerButton", [Button, ScrollingTabControllerButtonMixin]);

	// Class used in template
	declare("dijit.layout._ScrollingTabControllerMenuButton", [Button, _HasDropDown, ScrollingTabControllerButtonMixin], {
		// id of the TabContainer itself
		containerId: "",

		// -1 so user can't tab into the button, but so that button can still be focused programatically.
		// Because need to move focus to the button (or somewhere) before the menu is hidden or IE6 will crash.
		tabIndex: "-1",

		isLoaded: function(){
			// recreate menu every time, in case the TabContainer's list of children (or their icons/labels) have changed
			return false;
		},

		loadDropDown: function(callback){
			this.dropDown = new Menu({
				id: this.containerId + "_menu",
				ownerDocument: this.ownerDocument,
				dir: this.dir,
				lang: this.lang,
				textDir: this.textDir
			});
			var container = registry.byId(this.containerId);
			array.forEach(container.getChildren(), function(page){
				var menuItem = new MenuItem({
					id: page.id + "_stcMi",
					label: page.title,
					iconClass: page.iconClass,
					disabled: page.disabled,
					ownerDocument: this.ownerDocument,
					dir: page.dir,
					lang: page.lang,
					textDir: page.textDir || container.textDir,
					onClick: function(){
						container.selectChild(page);
					}
				});
				this.dropDown.addChild(menuItem);
			}, this);
			callback();
		},

		closeDropDown: function(/*Boolean*/ focus){
			this.inherited(arguments);
			if(this.dropDown){
				this._popupStateNode.removeAttribute("aria-owns");	// remove ref to node that we are about to delete
				this.dropDown.destroyRecursive();
				delete this.dropDown;
			}
		}
	});

	return ScrollingTabController;
});

},
'dojox/data/QueryReadStore':function(){
define(["dojo", "dojox", "dojo/data/util/sorter", "dojo/string"], function(dojo, dojox) {

	return dojo.declare("dojox.data.QueryReadStore", null, {
		// summary:
		//		This class provides a store that is mainly intended to be used
		//		for loading data dynamically from the server, used i.e. for
		//		retrieving chunks of data from huge data stores on the server (by server-side filtering!).
		//		Upon calling the fetch() method of this store the data are requested from
		//		the server if they are not yet loaded for paging (or cached).
		//
		//		For example used for a combobox which works on lots of data. It
		//		can be used to retrieve the data partially upon entering the
		//		letters "ac" it returns only items like "action", "acting", etc.
		//
		//		note:
		//		The field name "id" in a query is reserved for looking up data
		//		by id. This is necessary as before the first fetch, the store
		//		has no way of knowing which field the server will declare as
		//		identifier.
		//
		// example:
		// |	// The parameter "query" contains the data that are sent to the server.
		// |	var store = new dojox.data.QueryReadStore({url:'/search.php'});
		// |	store.fetch({query:{name:'a'}, queryOptions:{ignoreCase:false}});
		//
		// |	// Since "serverQuery" is given, it overrules and those data are
		// |	// sent to the server.
		// |	var store = new dojox.data.QueryReadStore({url:'/search.php'});
		// |	store.fetch({serverQuery:{name:'a'}, queryOptions:{ignoreCase:false}});
		//
		// |	<div dojoType="dojox.data.QueryReadStore"
		// |		jsId="store2"
		// |		url="../tests/stores/QueryReadStore.php"
		// |		requestMethod="post"></div>
		// |	<div dojoType="dojox.grid.data.DojoData"
		// |		jsId="model2"
		// |		store="store2"
		// |		sortFields="[{attribute: 'name', descending: true}]"
		// |		rowsPerPage="30"></div>
		// |	<div dojoType="dojox.Grid" id="grid2"
		// |		model="model2"
		// |		structure="gridLayout"
		// |		style="height:300px; width:800px;"></div>

		// todo:
		//		- there is a bug in the paging, when i set start:2, count:5 after an initial fetch() and doClientPaging:true
		//		  it returns 6 elemetns, though count=5, try it in QueryReadStore.html
		//		- add optional caching
		//		- when the first query searched for "a" and the next for a subset of
		//		  the first, i.e. "ab" then we actually dont need a server request, if
		//		  we have client paging, we just need to filter the items we already have
		//		  that might also be tooo much logic
		
		url:"",
		requestMethod:"get",
		//useCache:false,
		
		// We use the name in the errors, once the name is fixed hardcode it, may be.
		_className:"dojox.data.QueryReadStore",
		
		// This will contain the items we have loaded from the server.
		// The contents of this array is optimized to satisfy all read-api requirements
		// and for using lesser storage, so the keys and their content need some explaination:
		//		this._items[0].i - the item itself
		//		this._items[0].r - a reference to the store, so we can identify the item
		//			securely. We set this reference right after receiving the item from the
		//			server.
		_items:[],
		
		// Store the last query that triggered xhr request to the server.
		// So we can compare if the request changed and if we shall reload
		// (this also depends on other factors, such as is caching used, etc).
		_lastServerQuery:null,
		
		// Store how many rows we have so that we can pass it to a clientPaging handler
		_numRows:-1,
		
		// Store a hash of the last server request. Actually I introduced this
		// for testing, so I can check if no unnecessary requests were issued for
		// client-side-paging.
		lastRequestHash:null,
		
		// doClientPaging: Boolean
		//		By default every request for paging is sent to the server.
		doClientPaging:false,
	
		// doClientSorting: Boolean
		//		By default all the sorting is done serverside before the data is returned
		//		which is the proper place to be doing it for really large datasets.
		doClientSorting:false,
	
		// Items by identify for Identify API
		_itemsByIdentity:null,
		
		// Identifier used
		_identifier:null,
	
		_features: {'dojo.data.api.Read':true, 'dojo.data.api.Identity':true},
	
		_labelAttr: "label",
		
		constructor: function(/* Object */ params){
			dojo.mixin(this,params);
		},
		
		getValue: function(/* item */ item, /* attribute-name-string */ attribute, /* value? */ defaultValue){
			//	According to the Read API comments in getValue() and exception is
			//	thrown when an item is not an item or the attribute not a string!
			this._assertIsItem(item);
			if(!dojo.isString(attribute)){
				throw new Error(this._className+".getValue(): Invalid attribute, string expected!");
			}
			if(!this.hasAttribute(item, attribute)){
				// read api says: return defaultValue "only if *item* does not have a value for *attribute*."
				// Is this the case here? The attribute doesn't exist, but a defaultValue, sounds reasonable.
				if(defaultValue){
					return defaultValue;
				}
			}
			return item.i[attribute];
		},
		
		getValues: function(/* item */ item, /* attribute-name-string */ attribute){
			this._assertIsItem(item);
			var ret = [];
			if(this.hasAttribute(item, attribute)){
				ret.push(item.i[attribute]);
			}
			return ret;
		},
		
		getAttributes: function(/* item */ item){
			this._assertIsItem(item);
			var ret = [];
			for(var i in item.i){
				ret.push(i);
			}
			return ret;
		},
	
		hasAttribute: function(/* item */ item,	/* attribute-name-string */ attribute){
			// summary:
			//		See dojo/data/api/Read.hasAttribute()
			return this.isItem(item) && typeof item.i[attribute]!="undefined";
		},
		
		containsValue: function(/* item */ item, /* attribute-name-string */ attribute, /* anything */ value){
			var values = this.getValues(item, attribute);
			var len = values.length;
			for(var i=0; i<len; i++){
				if(values[i] == value){
					return true;
				}
			}
			return false;
		},
		
		isItem: function(/* anything */ something){
			// Some basic tests, that are quick and easy to do here.
			// >>> var store = new dojox.data.QueryReadStore({});
			// >>> store.isItem("");
			// false
			//
			// >>> var store = new dojox.data.QueryReadStore({});
			// >>> store.isItem({});
			// false
			//
			// >>> var store = new dojox.data.QueryReadStore({});
			// >>> store.isItem(0);
			// false
			//
			// >>> var store = new dojox.data.QueryReadStore({});
			// >>> store.isItem({name:"me", label:"me too"});
			// false

			if(something){
				return typeof something.r != "undefined" && something.r == this;
			}
			return false;
		},
		
		isItemLoaded: function(/* anything */ something){
			// Currently we dont have any state that tells if an item is loaded or not
			// if the item exists its also loaded.
			// This might change when we start working with refs inside items ...
			return this.isItem(something);
		},
	
		loadItem: function(/* object */ args){
			if(this.isItemLoaded(args.item)){
				return;
			}
			// Actually we have nothing to do here, or at least I dont know what to do here ...
		},
	
		fetch:function(/* Object? */ request){
			// summary:
			//		See dojo.data.util.simpleFetch.fetch() this is just a copy and I adjusted
			//		only the paging, since it happens on the server if doClientPaging is
			//		false, thx to http://trac.dojotoolkit.org/ticket/4761 reporting this.
			//		Would be nice to be able to use simpleFetch() to reduce copied code,
			//		but i dont know how yet. Ideas please!
			request = request || {};
			if(!request.store){
				request.store = this;
			}
			var self = this;
		
			var _errorHandler = function(errorData, requestObject){
				if(requestObject.onError){
					var scope = requestObject.scope || dojo.global;
					requestObject.onError.call(scope, errorData, requestObject);
				}
			};
		
			var _fetchHandler = function(items, requestObject, numRows){
				var oldAbortFunction = requestObject.abort || null;
				var aborted = false;
				
				var startIndex = requestObject.start?requestObject.start:0;
				if(self.doClientPaging == false){
					// For client paging we dont need no slicing of the result.
					startIndex = 0;
				}
				var endIndex = requestObject.count?(startIndex + requestObject.count):items.length;
		
				requestObject.abort = function(){
					aborted = true;
					if(oldAbortFunction){
						oldAbortFunction.call(requestObject);
					}
				};
		
				var scope = requestObject.scope || dojo.global;
				if(!requestObject.store){
					requestObject.store = self;
				}
				if(requestObject.onBegin){
					requestObject.onBegin.call(scope, numRows, requestObject);
				}
				if(requestObject.sort && self.doClientSorting){
					items.sort(dojo.data.util.sorter.createSortFunction(requestObject.sort, self));
				}
				if(requestObject.onItem){
					for(var i = startIndex; (i < items.length) && (i < endIndex); ++i){
						var item = items[i];
						if(!aborted){
							requestObject.onItem.call(scope, item, requestObject);
						}
					}
				}
				if(requestObject.onComplete && !aborted){
					var subset = null;
					if(!requestObject.onItem){
						subset = items.slice(startIndex, endIndex);
					}
					requestObject.onComplete.call(scope, subset, requestObject);
				}
			};
			this._fetchItems(request, _fetchHandler, _errorHandler);
			return request;	// Object
		},
	
		getFeatures: function(){
			return this._features;
		},
	
		close: function(/*dojo/data/api/Request|Object?*/ request){
			// I have no idea if this is really needed ...
		},
	
		getLabel: function(/* item */ item){
			// summary:
			//		See dojo/data/api/Read.getLabel()
			if(this._labelAttr && this.isItem(item)){
				return this.getValue(item, this._labelAttr); //String
			}
			return undefined; //undefined
		},
	
		getLabelAttributes: function(/* item */ item){
			// summary:
			//		See dojo/data/api/Read.getLabelAttributes()
			if(this._labelAttr){
				return [this._labelAttr]; //array
			}
			return null; //null
		},
		
		_xhrFetchHandler: function(data, request, fetchHandler, errorHandler){
			data = this._filterResponse(data);
			if(data.label){
				this._labelAttr = data.label;
			}
			var numRows = data.numRows || -1;

			this._items = [];
			// Store a ref to "this" in each item, so we can simply check if an item
			// really origins form here (idea is from ItemFileReadStore, I just don't know
			// how efficient the real storage use, garbage collection effort, etc. is).
			dojo.forEach(data.items,function(e){
				this._items.push({i:e, r:this});
			},this);
			
			var identifier = data.identifier;
			this._itemsByIdentity = {};
			if(identifier){
				this._identifier = identifier;
				var i;
				for(i = 0; i < this._items.length; ++i){
					var item = this._items[i].i;
					var identity = item[identifier];
					if(!this._itemsByIdentity[identity]){
						this._itemsByIdentity[identity] = item;
					}else{
						throw new Error(this._className+":  The json data as specified by: [" + this.url + "] is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}
				}
			}else{
				this._identifier = Number;
				for(i = 0; i < this._items.length; ++i){
					this._items[i].n = i;
				}
			}
			
			// TODO actually we should do the same as dojo.data.ItemFileReadStore._getItemsFromLoadedData() to sanitize
			// (does it really sanititze them) and store the data optimal. should we? for security reasons???
			numRows = this._numRows = (numRows === -1) ? this._items.length : numRows;
			fetchHandler(this._items, request, numRows);
			this._numRows = numRows;
		},
		
		_fetchItems: function(request, fetchHandler, errorHandler){
			// summary:
			//		The request contains the data as defined in the Read-API.
			//		Additionally there is following keyword "serverQuery".
			//
			//		####The *serverQuery* parameter, optional.
			//
			//		This parameter contains the data that will be sent to the server.
			//		If this parameter is not given the parameter "query"'s
			//		data are sent to the server. This is done for some reasons:
			//
			//		- to specify explicitly which data are sent to the server, they
			//		  might also be a mix of what is contained in "query", "queryOptions"
			//		  and the paging parameters "start" and "count" or may be even
			//		  completely different things.
			//		- don't modify the request.query data, so the interface using this
			//		  store can rely on unmodified data, as the combobox dijit currently
			//		  does it, it compares if the query has changed
			//		- request.query is required by the Read-API
			//
			//		I.e. the following examples might be sent via GET:
			//	|	  fetch({query:{name:"abc"}, queryOptions:{ignoreCase:true}})
			//		  the URL will become:   /url.php?name=abc
			//
			//	|	  fetch({serverQuery:{q:"abc", c:true}, query:{name:"abc"}, queryOptions:{ignoreCase:true}})
			//		  the URL will become:   /url.php?q=abc&c=true
			//	|	  // The serverQuery-parameter has overruled the query-parameter
			//	|	  // but the query parameter stays untouched, but is not sent to the server!
			//	|	  // The serverQuery contains more data than the query, so they might differ!

			var serverQuery = request.serverQuery || request.query || {};
			//Need to add start and count
			if(!this.doClientPaging){
				serverQuery.start = request.start || 0;
				// Count might not be sent if not given.
				if(request.count){
					serverQuery.count = request.count;
				}
			}
			if(!this.doClientSorting && request.sort){
				var sortInfo = [];
				dojo.forEach(request.sort, function(sort){
					if(sort && sort.attribute){
						sortInfo.push((sort.descending ? "-" : "") + sort.attribute);
					}
				});
				serverQuery.sort = sortInfo.join(',');
			}
			// Compare the last query and the current query by simply json-encoding them,
			// so we dont have to do any deep object compare ... is there some dojo.areObjectsEqual()???
			if(this.doClientPaging && this._lastServerQuery !== null &&
				dojo.toJson(serverQuery) == dojo.toJson(this._lastServerQuery)
				){
				this._numRows = (this._numRows === -1) ? this._items.length : this._numRows;
				fetchHandler(this._items, request, this._numRows);
			}else{
				var xhrFunc = this.requestMethod.toLowerCase() == "post" ? dojo.xhrPost : dojo.xhrGet;
				var xhrHandler = xhrFunc({url:this.url, handleAs:"json-comment-optional", content:serverQuery, failOk: true});
				request.abort = function(){
					xhrHandler.cancel();
				};
				xhrHandler.addCallback(dojo.hitch(this, function(data){
					this._xhrFetchHandler(data, request, fetchHandler, errorHandler);
				}));
				xhrHandler.addErrback(function(error){
					errorHandler(error, request);
				});
				// Generate the hash using the time in milliseconds and a randon number.
				// Since Math.randon() returns something like: 0.23453463, we just remove the "0."
				// probably just for esthetic reasons :-).
				this.lastRequestHash = new Date().getTime()+"-"+String(Math.random()).substring(2);
				this._lastServerQuery = dojo.mixin({}, serverQuery);
			}
		},
		
		_filterResponse: function(data){
			// summary:
			//		If the data from servers needs to be processed before it can be processed by this
			//		store, then this function should be re-implemented in subclass. This default
			//		implementation just return the data unchanged.
			// data:
			//		The data received from server
			return data;
		},
	
		_assertIsItem: function(/* item */ item){
			// summary:
			//		It throws an error if item is not valid, so you can call it in every method that needs to
			//		throw an error when item is invalid.
			// item:
			//		The item to test for being contained by the store.
			if(!this.isItem(item)){
				throw new Error(this._className+": Invalid item argument.");
			}
		},
	
		_assertIsAttribute: function(/* attribute-name-string */ attribute){
			// summary:
			//		This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.
			// attribute:
			//		The attribute to test for being contained by the store.
			if(typeof attribute !== "string"){
				throw new Error(this._className+": Invalid attribute argument ('"+attribute+"').");
			}
		},
	
		fetchItemByIdentity: function(/* Object */ keywordArgs){
			// summary:
			//		See dojo/data/api/Identity.fetchItemByIdentity()
	
			// See if we have already loaded the item with that id
			// In case there hasn't been a fetch yet, _itemsByIdentity is null
			// and thus a fetch will be triggered below.
			if(this._itemsByIdentity){
				var item = this._itemsByIdentity[keywordArgs.identity];
				if(!(item === undefined)){
					if(keywordArgs.onItem){
						var scope = keywordArgs.scope ? keywordArgs.scope : dojo.global;
						keywordArgs.onItem.call(scope, {i:item, r:this});
					}
					return;
				}
			}
	
			// Otherwise we need to go remote
			// Set up error handler
			var _errorHandler = function(errorData, requestObject){
				var scope = keywordArgs.scope ? keywordArgs.scope : dojo.global;
				if(keywordArgs.onError){
					keywordArgs.onError.call(scope, errorData);
				}
			};
			
			// Set up fetch handler
			var _fetchHandler = function(items, requestObject){
				var scope = keywordArgs.scope ? keywordArgs.scope : dojo.global;
				try{
					// There is supposed to be only one result
					var item = null;
					if(items && items.length == 1){
						item = items[0];
					}
					
					// If no item was found, item is still null and we'll
					// fire the onItem event with the null here
					if(keywordArgs.onItem){
						keywordArgs.onItem.call(scope, item);
					}
				}catch(error){
					if(keywordArgs.onError){
						keywordArgs.onError.call(scope, error);
					}
				}
			};
			
			// Construct query
			var request = {serverQuery:{id:keywordArgs.identity}};
			
			// Dispatch query
			this._fetchItems(request, _fetchHandler, _errorHandler);
		},
		
		getIdentity: function(/* item */ item){
			// summary:
			//		See dojo/data/api/Identity.getIdentity()
			var identifier = null;
			if(this._identifier === Number){
				identifier = item.n; // Number
			}else{
				identifier = item.i[this._identifier];
			}
			return identifier;
		},
		
		getIdentityAttributes: function(/* item */ item){
			// summary:
			//		See dojo/data/api/Identity.getIdentityAttributes()
			return [this._identifier];
		}
	});

});

},
'dojox/grid/EnhancedGrid':function(){
define([
	"dojo/_base/kernel",
	"../main",
	"dojo/_base/declare",
	"dojo/_base/lang",
	"dojo/_base/array",
	"dojo/_base/sniff",
	"dojo/dom",
	"dojo/dom-geometry",
	"./DataGrid",
	"./DataSelection",
	"./enhanced/_PluginManager",
	"./enhanced/plugins/_SelectionPreserver",//default loaded plugin
	"dojo/i18n!./enhanced/nls/EnhancedGrid"
], function(dojo, dojox, declare, lang, array, has, dom, domGeometry,
	DataGrid, DataSelection, _PluginManager, _SelectionPreserver, nls){

dojo.experimental("dojox.grid.EnhancedGrid");

var EnhancedGrid = declare("dojox.grid.EnhancedGrid", DataGrid, {
	// summary:
	//		Provides enhanced features based on DataGrid
	//
	// description:
	//		EnhancedGrid features are implemented as plugins that could be loaded on demand.
	//		Explicit dojo.require() is needed to use these feature plugins.
	//
	// example:
	//		A quick sample to use EnhancedGrid features:
	//
	//	   Step 1. Load EnhancedGrid and required features
	// |   <script type="text/javascript">
	// |		dojo.require("dojox.grid.EnhancedGrid");
	// |		dojo.require("dojox.grid.enhanced.plugins.DnD");
	// |		dojo.require("dojox.grid.enhanced.plugins.Menu");
	// |		dojo.require("dojox.grid.enhanced.plugins.NestedSorting");
	// |		dojo.require("dojox.grid.enhanced.plugins.IndirectSelection");
	// |	</script>
	//
	//		Step 2. Use EnhancedGrid
	//
	//		- Via HTML markup
	//
	// |	<div dojoType="dojox.grid.EnhancedGrid" ...
	// |		plugins="{nestedSorting: true, dnd: true, indirectSelection: true,
	// |		menus:{headerMenu:"headerMenuId", rowMenu:"rowMenuId", cellMenu:"cellMenuId",
	// |		selectedRegionMenu:"selectedRegionMenuId"}}">
	// |			...
	// |	</div>
	//
	//		- Or via JavaScript
	//
	// |	<script type="text/javascript">
	// |		var grid = new dojox.grid.EnhancedGrid({plugins : {nestedSorting: true, dnd: true, indirectSelection: true,
	// |	               menus:{headerMenu:"headerMenuId", rowMenu:"rowMenuId", cellMenu:"cellMenuId",selectedRegionMenu:"selectedRegionMenuId"}},
	// |			       ... }, dojo.byId('gridDiv'));
	// |		grid.startup();
	// |	</script>
	//
	//
	//		Plugin Support
	//		[Note: Plugin support is still experimental]
	//
	//		You can either customize the default plugins or add new ones, more details please see
	//
	//		- dojox.grid.enhanced._PluginManager
	//		- dojox.grid.enhanced._Plugin
	//		- dojox.grid.enhanced.plugins.*

	// plugins: Object
	//		Plugin properties, e.g. {nestedSorting: true, dnd: true, ...}
	plugins: null,

	// pluginMgr: Object
	//		Singleton plugin manager
	pluginMgr: null,

	// _pluginMgrClass: Object
	//		Default plugin manager class
	_pluginMgrClass: _PluginManager,

	postMixInProperties: function(){
		this._nls = nls;
		this.inherited(arguments);
	},
	postCreate: function(){
		//create plugin manager
		this.pluginMgr = new this._pluginMgrClass(this);
		this.pluginMgr.preInit();
		this.inherited(arguments);
		this.pluginMgr.postInit();
	},
	plugin: function(/*String*/name){
		// summary:
		//		An easier way for getting a plugin, e.g. grid.plugin('dnd')
		return this.pluginMgr.getPlugin(name);
	},
	startup: function(){
		this.inherited(arguments);
		this.pluginMgr.startup();
	},
	createSelection: function(){
		this.selection = new dojox.grid.enhanced.DataSelection(this);
	},
	canSort: function(colIndex, field){
		// summary:
		//		Overwritten
		return true;
	},
	doKeyEvent: function(e){
		// summary:
		//		Overwritten, see _Grid.doKeyEvent()
		try{
			var view = this.focus.focusView;
			view.content.decorateEvent(e);
			if(!e.cell){ view.header.decorateEvent(e); }
		}catch(e){}
		this.inherited(arguments);
	},
	doApplyCellEdit: function(inValue, inRowIndex, inAttrName){
		// summary:
		//		Overwritten, see DataGrid.doApplyCellEdit()
		if(!inAttrName){
			this.invalidated[inRowIndex] = true;
			return;
		}
		this.inherited(arguments);
	},
	mixin: function(target, source){
		var props = {};
		for(var p in source){
			if(p == '_inherited' || p == 'declaredClass' || p == 'constructor' ||
				source['privates'] && source['privates'][p]){
				continue;
			}
			props[p] = source[p];
		}
		lang.mixin(target, props);
	},
	_copyAttr: function(idx, attr){
		// summary:
		//		Overwritten, see DataGrid._copyAttr()
		//		Fix cell TAB navigation for single click editing
		if(!attr){ return; }
		return this.inherited(arguments);
	},
	_getHeaderHeight: function(){
		// summary:
		//		Overwritten, see _Grid._getHeaderHeight()
		//		Should include borders/margins of this.viewsHeaderNode
		this.inherited(arguments);
		return domGeometry.getMarginBox(this.viewsHeaderNode).h;
	},
	_fetch: function(start, isRender){
		// summary:
		//		Overwritten, see DataGrid._fetch()
		if(this.items){
			return this.inherited(arguments);
		}
		start = start || 0;
		if(this.store && !this._pending_requests[start]){
			if(!this._isLoaded && !this._isLoading){
				this._isLoading = true;
				this.showMessage(this.loadingMessage);
			}
			this._pending_requests[start] = true;
			try{
				var req = {
					start: start,
					count: this.rowsPerPage,
					query: this.query,
					sort: this.getSortProps(),
					queryOptions: this.queryOptions,
					isRender: isRender,
					onBegin: lang.hitch(this, "_onFetchBegin"),
					onComplete: lang.hitch(this, "_onFetchComplete"),
					onError: lang.hitch(this, "_onFetchError")
				};
				this._storeLayerFetch(req);
			}catch(e){
				this._onFetchError(e, {start: start, count: this.rowsPerPage});
			}
		}
		return 0;
	},
	_storeLayerFetch: function(req){
		// summary:
		//		Extracted fetch specifically for store layer use
		this.store.fetch(req);
	},
	getCellByField: function(field){
		return array.filter(this.layout.cells, function(cell){
			return cell.field == field;
		})[0];
	},
	onMouseUp: function(e){	},
	createView: function(){
		// summary:
		//		Overwrite: rewrite getCellX of view.header
		var view = this.inherited(arguments);
		if(has('mozilla')){
			var ascendDom = function(inNode, inWhile){
				for(var n = inNode; n && inWhile(n); n = n.parentNode){}
				return n;
			};//copied from dojox.grid._Builder
			var makeNotTagName = function(inTagName){
				var name = inTagName.toUpperCase();
				return function(node){ return node.tagName != name; };
			};//copied from dojox.grid._Builder

			var func = view.header.getCellX;
			view.header.getCellX = function(e){
				var x = func.call(view.header, e);
				var n = ascendDom(e.target, makeNotTagName("th"));
				if(n && n !== e.target && dom.isDescendant(e.target, n)){ x += n.firstChild.offsetLeft; }
				return x;
			};
		}
		return view;
	},
	destroy: function(){
		// summary:
		//		Destroy all resources
		delete this._nls;
		this.pluginMgr.destroy();
		this.inherited(arguments);
	}
});

declare("dojox.grid.enhanced.DataSelection", DataSelection, {
	constructor: function(grid){
		if(grid.keepSelection){
			if(this.preserver){
				this.preserver.destroy();
			}
			this.preserver = new _SelectionPreserver(this);
		}
	},
	_range: function(inFrom, inTo){
		this.grid._selectingRange = true;
		this.inherited(arguments);
		this.grid._selectingRange = false;
		this.onChanged();
	},
	deselectAll: function(inItemOrIndex){
		this.grid._selectingRange = true;
		this.inherited(arguments);
		this.grid._selectingRange = false;
		this.onChanged();
	}
});

EnhancedGrid.markupFactory = function(props, node, ctor, cellFunc){
	return dojox.grid._Grid.markupFactory(props, node, ctor,
					lang.partial(DataGrid.cell_markupFactory, cellFunc));
};

EnhancedGrid.registerPlugin = function(clazz, props){
	_PluginManager.registerPlugin(clazz, props);
};

return EnhancedGrid;

});

},
'dojox/grid/DataGrid':function(){
define([
	"../main",
	"dojo/_base/array",
	"dojo/_base/lang",
	"dojo/_base/json",
	"dojo/_base/sniff",
	"dojo/_base/declare",
	"./_Grid",
	"./DataSelection",
	"dojo/_base/html",
	"dojo/has",
	"dojo/has!dojo-bidi?./bidi/_BidiMixin"
], function(dojox, array, lang, json, has, declare, _Grid, DataSelection, html){

/*=====
declare("dojox.grid.__DataCellDef", dojox.grid.__CellDef, {
	constructor: function(){
		// field: String?
		//		The attribute to read from the dojo.data item for the row.
		// fields: String[]?
		//		An array of fields to grab the values of and pass as an array to the grid
		// get: Function?
		//		function(rowIndex, item?){} rowIndex is of type Integer, item is of type
		//		Object.  This function will be called when a cell requests data.  Returns
		//		the unformatted data for the cell.
	}
});
=====*/

/*=====
declare("dojox.grid.__DataViewDef", dojox.grid.__ViewDef, {
	constructor: function(){
		// cells: dojox.grid.__DataCellDef[]|Array[dojox.grid.__DataCellDef[]]?
		//		The structure of the cells within this grid.
		// defaultCell: dojox.grid.__DataCellDef?
		//		A cell definition with default values for all cells in this view.  If
		//		a property is defined in a cell definition in the "cells" array and
		//		this property, the cell definition's property will override this
		//		property's property.
	}
});
=====*/

var DataGrid = declare("dojox.grid.DataGrid", _Grid, {
	store: null,
	query: null,
	queryOptions: null,
	fetchText: '...',
	sortFields: null,
	
	// updateDelay: int
	//		Time, in milliseconds, to delay updates automatically so that multiple
	//		calls to onSet/onNew/onDelete don't keep rerendering the grid.  Set
	//		to 0 to immediately cause updates.  A higher value will result in
	//		better performance at the expense of responsiveness of the grid.
	updateDelay: 1,

/*=====
	// structure: dojox.grid.__DataViewDef|dojox.grid.__DataViewDef[]|dojox.grid.__DataCellDef[]|Array[dojox.grid.__DataCellDef[]]
	//		View layout definition.
	structure: '',
=====*/

	// You can specify items instead of a query, if you like.  They do not need
	// to be loaded - but the must be items in the store
	items: null,
	
	_store_connects: null,
	_by_idty: null,
	_by_idx: null,
	_cache: null,
	_pages: null,
	_pending_requests: null,
	_bop: -1,
	_eop: -1,
	_requests: 0,
	rowCount: 0,

	_isLoaded: false,
	_isLoading: false,
	
	// keepSelection: Boolean
	//		Whether keep selection after sort, filter etc.
	keepSelection: false,	
	
	postCreate: function(){
		this._pages = [];
		this._store_connects = [];
		this._by_idty = {};
		this._by_idx = [];
		this._cache = [];
		this._pending_requests = {};

		this._setStore(this.store);
		this.inherited(arguments);
	},
	
	destroy: function(){
		this.selection.destroy();
		this.inherited(arguments);
	},

	createSelection: function(){
		this.selection = new DataSelection(this);
	},

	get: function(inRowIndex, inItem){
		// summary:
		//		Default data getter.
		// description:
		//		Provides data to display in a grid cell. Called in grid cell context.
		//		So this.cell.index is the column index.
		// inRowIndex: Integer
		//		Row for which to provide data
		// returns:
		//		Data to display for a given grid cell.
		
		if(inItem && this.field == "_item" && !this.fields){
			return inItem;
		}else if(inItem && this.fields){
			var ret = [];
			var s = this.grid.store;
			array.forEach(this.fields, function(f){
				ret = ret.concat(s.getValues(inItem, f));
			});
			return ret;
		}else if(!inItem && typeof inRowIndex === "string"){
			return this.inherited(arguments);
		}
		return (!inItem ? this.defaultValue : (!this.field ? this.value : (this.field == "_item" ? inItem : this.grid.store.getValue(inItem, this.field))));
	},

	_checkUpdateStatus: function(){
		if(this.updateDelay > 0){
			var iStarted = false;
			if(this._endUpdateDelay){
				clearTimeout(this._endUpdateDelay);
				delete this._endUpdateDelay;
				iStarted = true;
			}
			if(!this.updating){
				this.beginUpdate();
				iStarted = true;
			}
			if(iStarted){
				var _this = this;
				this._endUpdateDelay = setTimeout(function(){
					delete _this._endUpdateDelay;
					_this.endUpdate();
				}, this.updateDelay);
			}
		}
	},
	
	_onSet: function(item, attribute, oldValue, newValue){
		this._checkUpdateStatus();
		var idx = this.getItemIndex(item);
		if(idx>-1){
			this.updateRow(idx);
		}
	},
	
	_createItem: function(item, index){
		var idty = this._hasIdentity ? this.store.getIdentity(item) : json.toJson(this.query) + ":idx:" + index + ":sort:" + json.toJson(this.getSortProps());
		var o = this._by_idty[idty] = { idty: idty, item: item };
		return o;
	},

	_addItem: function(item, index, noUpdate){
		this._by_idx[index] = this._createItem(item, index);
		if(!noUpdate){
			this.updateRow(index);
		}
	},

	_onNew: function(item, parentInfo){
		this._checkUpdateStatus();
		var rowCount = this.get('rowCount');
		this._addingItem = true;
		this.updateRowCount(rowCount+1);
		this._addingItem = false;
		this._addItem(item, rowCount);
		this.showMessage();
	},

	_onDelete: function(item){
		this._checkUpdateStatus();
		var idx = this._getItemIndex(item, true);

		if(idx >= 0){
			// When a row is deleted, all rest rows are shifted down,
			// and migrate from page to page. If some page is not
			// loaded yet empty rows can migrate to initialized pages
			// without refreshing. It causes empty rows in some pages, see:
			// http://bugs.dojotoolkit.org/ticket/6818
			// this code fix this problem by reseting loaded page info
			this._pages = [];
			this._bop = -1;
			this._eop = -1;

			var o = this._by_idx[idx];
			this._by_idx.splice(idx, 1);
			delete this._by_idty[o.idty];
			this.updateRowCount(this.get('rowCount')-1);
			if(this.get('rowCount') === 0){
				this.showMessage(this.noDataMessage);
			}
		}
		if(this.selection.isSelected(idx)){
			this.selection.deselect(idx);
			this.selection.selected.splice(idx, 1);
		}
	},

	_onRevert: function(){
		this._refresh();
	},

	setStore: function(store, query, queryOptions){
		if(this._requestsPending(0)){
			return;
		}
		this._setQuery(query, queryOptions);
		this._setStore(store);
		this._refresh(true);
	},
	
	setQuery: function(query, queryOptions){
		if(this._requestsPending(0)){
			return;
		}
		this._setQuery(query, queryOptions);
		this._refresh(true);
	},
	
	setItems: function(items){
		this.items = items;
		this._setStore(this.store);
		this._refresh(true);
	},
	
	_setQuery: function(query, queryOptions){
		this.query = query;
		this.queryOptions = queryOptions || this.queryOptions;
	},

	_setStore: function(store){
		if(this.store && this._store_connects){
			array.forEach(this._store_connects, this.disconnect, this);
		}
		this.store = store;

		if(this.store){
			var f = this.store.getFeatures();
			var h = [];

			this._canEdit = !!f["dojo.data.api.Write"] && !!f["dojo.data.api.Identity"];
			this._hasIdentity = !!f["dojo.data.api.Identity"];

			if(!!f["dojo.data.api.Notification"] && !this.items){
				h.push(this.connect(this.store, "onSet", "_onSet"));
				h.push(this.connect(this.store, "onNew", "_onNew"));
				h.push(this.connect(this.store, "onDelete", "_onDelete"));
			}
			if(this._canEdit){
				h.push(this.connect(this.store, "revert", "_onRevert"));
			}

			this._store_connects = h;
		}
	},

	_onFetchBegin: function(size, req){
		if(!this.scroller){ return; }
		if(this.rowCount != size){
			if(req.isRender){
				this.scroller.init(size, this.keepRows, this.rowsPerPage);
				this.rowCount = size;
				this._setAutoHeightAttr(this.autoHeight, true);
				this._skipRowRenormalize = true;
				this.prerender();
				this._skipRowRenormalize = false;
			}else{
				this.updateRowCount(size);
			}
		}
		if(!size){
			this.views.render();
			this._resize();
			this.showMessage(this.noDataMessage);
			this.focus.initFocusView();
		}else{
			this.showMessage();
		}
	},

	_onFetchComplete: function(items, req){
		if(!this.scroller){ return; }
		if(items && items.length > 0){
			//console.log(items);
			array.forEach(items, function(item, idx){
				this._addItem(item, req.start+idx, true);
			}, this);
			this.updateRows(req.start, items.length);
			if(req.isRender){
				this.setScrollTop(0);
				this.postrender();
			}else if(this._lastScrollTop){
				this.setScrollTop(this._lastScrollTop);
			}
			if(has("ie")){
				html.setSelectable(this.domNode, this.selectable);
			}	
		}
		delete this._lastScrollTop;
		if(!this._isLoaded){
			this._isLoading = false;
			this._isLoaded = true;
		}
		this._pending_requests[req.start] = false;
	},

	_onFetchError: function(err, req){
		console.log(err);
		delete this._lastScrollTop;
		if(!this._isLoaded){
			this._isLoading = false;
			this._isLoaded = true;
			this.showMessage(this.errorMessage);
		}
		this._pending_requests[req.start] = false;
		this.onFetchError(err, req);
	},

	onFetchError: function(err, req){
	},

	_fetch: function(start, isRender){
		start = start || 0;
		if(this.store && !this._pending_requests[start]){
			if(!this._isLoaded && !this._isLoading){
				this._isLoading = true;
				this.showMessage(this.loadingMessage);
			}
			this._pending_requests[start] = true;
			//console.log("fetch: ", start);
			try{
				if(this.items){
					var items = this.items;
					var store = this.store;
					this.rowsPerPage = items.length;
					var req = {
						start: start,
						count: this.rowsPerPage,
						isRender: isRender
					};
					this._onFetchBegin(items.length, req);
					
					// Load them if we need to
					var waitCount = 0;
					array.forEach(items, function(i){
						if(!store.isItemLoaded(i)){ waitCount++; }
					});
					if(waitCount === 0){
						this._onFetchComplete(items, req);
					}else{
						var onItem = function(item){
							waitCount--;
							if(waitCount === 0){
								this._onFetchComplete(items, req);
							}
						};
						array.forEach(items, function(i){
							if(!store.isItemLoaded(i)){
								store.loadItem({item: i, onItem: onItem, scope: this});
							}
						}, this);
					}
				}else{
					this.store.fetch({
						start: start,
						count: this.rowsPerPage,
						query: this.query,
						sort: this.getSortProps(),
						queryOptions: this.queryOptions,
						isRender: isRender,
						onBegin: lang.hitch(this, "_onFetchBegin"),
						onComplete: lang.hitch(this, "_onFetchComplete"),
						onError: lang.hitch(this, "_onFetchError")
					});
				}
			}catch(e){
				this._onFetchError(e, {start: start, count: this.rowsPerPage});
			}
		}
	},

	_clearData: function(){
		this.updateRowCount(0);
		this._by_idty = {};
		this._by_idx = [];
		this._pages = [];
		this._bop = this._eop = -1;
		this._isLoaded = false;
		this._isLoading = false;
	},

	getItem: function(idx){
		var data = this._by_idx[idx];
		if(!data||(data&&!data.item)){
			this._preparePage(idx);
			return null;
		}
		return data.item;
	},

	getItemIndex: function(item){
		return this._getItemIndex(item, false);
	},
	
	_getItemIndex: function(item, isDeleted){
		if(!isDeleted && !this.store.isItem(item)){
			return -1;
		}

		var idty = this._hasIdentity ? this.store.getIdentity(item) : null;

		for(var i=0, l=this._by_idx.length; i<l; i++){
			var d = this._by_idx[i];
			if(d && ((idty && d.idty == idty) || (d.item === item))){
				return i;
			}
		}
		return -1;
	},

	filter: function(query, reRender){
		this.query = query;
		if(reRender){
			this._clearData();
		}
		this._fetch();
	},

	_getItemAttr: function(idx, attr){
		var item = this.getItem(idx);
		return (!item ? this.fetchText : this.store.getValue(item, attr));
	},

	// rendering
	_render: function(){
		if(this.domNode.parentNode){
			this.scroller.init(this.get('rowCount'), this.keepRows, this.rowsPerPage);
			this.prerender();
			this._fetch(0, true);
		}
	},

	// paging
	_requestsPending: function(inRowIndex){
		return this._pending_requests[inRowIndex];
	},

	_rowToPage: function(inRowIndex){
		return (this.rowsPerPage ? Math.floor(inRowIndex / this.rowsPerPage) : inRowIndex);
	},

	_pageToRow: function(inPageIndex){
		return (this.rowsPerPage ? this.rowsPerPage * inPageIndex : inPageIndex);
	},

	_preparePage: function(inRowIndex){
		if((inRowIndex < this._bop || inRowIndex >= this._eop) && !this._addingItem){
			var pageIndex = this._rowToPage(inRowIndex);
			this._needPage(pageIndex);
			this._bop = pageIndex * this.rowsPerPage;
			this._eop = this._bop + (this.rowsPerPage || this.get('rowCount'));
		}
	},

	_needPage: function(inPageIndex){
		if(!this._pages[inPageIndex]){
			this._pages[inPageIndex] = true;
			this._requestPage(inPageIndex);
		}
	},

	_requestPage: function(inPageIndex){
		var row = this._pageToRow(inPageIndex);
		var count = Math.min(this.rowsPerPage, this.get('rowCount') - row);
		if(count > 0){
			this._requests++;
			if(!this._requestsPending(row)){
				setTimeout(lang.hitch(this, "_fetch", row, false), 1);
				//this.requestRows(row, count);
			}
		}
	},

	getCellName: function(inCell){
		return inCell.field;
		//console.log(inCell);
	},

	_refresh: function(isRender){
		this._clearData();
		this._fetch(0, isRender);
	},

	sort: function(){
		this.edit.apply();
		this._lastScrollTop = this.scrollTop;
		this._refresh();
	},

	canSort: function(){
		return (!this._isLoading);
	},

	getSortProps: function(){
		var c = this.getCell(this.getSortIndex());
		if(!c){
			if(this.sortFields){
				return this.sortFields;
			}
			return null;
		}else{
			var desc = c["sortDesc"];
			var si = !(this.sortInfo>0);
			if(typeof desc == "undefined"){
				desc = si;
			}else{
				desc = si ? !desc : desc;
			}
			return [{ attribute: c.field, descending: desc }];
		}
	},

	styleRowState: function(inRow){
		// summary:
		//		Perform row styling
		if(this.store && this.store.getState){
			var states=this.store.getState(inRow.index), c='';
			for(var i=0, ss=["inflight", "error", "inserting"], s; s=ss[i]; i++){
				if(states[s]){
					c = ' dojoxGridRow-' + s;
					break;
				}
			}
			inRow.customClasses += c;
		}
	},

	onStyleRow: function(inRow){
		this.styleRowState(inRow);
		this.inherited(arguments);
	},

	// editing
	canEdit: function(inCell, inRowIndex){
		return this._canEdit;
	},

	_copyAttr: function(idx, attr){
		var row = {};
		var backstop = {};
		var src = this.getItem(idx);
		return this.store.getValue(src, attr);
	},

	doStartEdit: function(inCell, inRowIndex){
		if(!this._cache[inRowIndex]){
			this._cache[inRowIndex] = this._copyAttr(inRowIndex, inCell.field);
		}
		this.onStartEdit(inCell, inRowIndex);
	},

	doApplyCellEdit: function(inValue, inRowIndex, inAttrName){
		this.store.fetchItemByIdentity({
			identity: this._by_idx[inRowIndex].idty,
			onItem: lang.hitch(this, function(item){
				var oldValue = this.store.getValue(item, inAttrName);
				if(typeof oldValue == 'number'){
					inValue = isNaN(inValue) ? inValue : parseFloat(inValue);
				}else if(typeof oldValue == 'boolean'){
					inValue = inValue == 'true' ? true : inValue == 'false' ? false : inValue;
				}else if(oldValue instanceof Date){
					var asDate = new Date(inValue);
					inValue = isNaN(asDate.getTime()) ? inValue : asDate;
				}
				this.store.setValue(item, inAttrName, inValue);
				this.onApplyCellEdit(inValue, inRowIndex, inAttrName);
			})
		});
	},

	doCancelEdit: function(inRowIndex){
		var cache = this._cache[inRowIndex];
		if(cache){
			this.updateRow(inRowIndex);
			delete this._cache[inRowIndex];
		}
		this.onCancelEdit.apply(this, arguments);
	},

	doApplyEdit: function(inRowIndex, inDataAttr){
		var cache = this._cache[inRowIndex];
		/*if(cache){
			var data = this.getItem(inRowIndex);
			if(this.store.getValue(data, inDataAttr) != cache){
				this.update(cache, data, inRowIndex);
			}
			delete this._cache[inRowIndex];
		}*/
		this.onApplyEdit(inRowIndex);
	},

	removeSelectedRows: function(){
		// summary:
		//		Remove the selected rows from the grid.
		if(this._canEdit){
			this.edit.apply();
			var fx = lang.hitch(this, function(items){
				if(items.length){
					array.forEach(items, this.store.deleteItem, this.store);
					this.selection.clear();
				}
			});
			if(this.allItemsSelected){
				this.store.fetch({
							query: this.query,
							queryOptions: this.queryOptions,
							onComplete: fx});
			}else{
				fx(this.selection.getSelected());
			}
		}
	}
});

DataGrid.cell_markupFactory = function(cellFunc, node, cellDef){
	var field = lang.trim(html.attr(node, "field")||"");
	if(field){
		cellDef.field = field;
	}
	cellDef.field = cellDef.field||cellDef.name;
	var fields = lang.trim(html.attr(node, "fields")||"");
	if(fields){
		cellDef.fields = fields.split(",");
	}
	if(cellFunc){
		cellFunc(node, cellDef);
	}
};

DataGrid.markupFactory = function(props, node, ctor, cellFunc){
	return _Grid.markupFactory(props, node, ctor,
					lang.partial(DataGrid.cell_markupFactory, cellFunc));
};

return DataGrid;

});

},
'dojox/grid/_Grid':function(){
define([
	"dojo/_base/kernel",
	"../main",
	"dojo/_base/declare",
	"./_Events",
	"./_Scroller",
	"./_Layout",
	"./_View",
	"./_ViewManager",
	"./_RowManager",
	"./_FocusManager",
	"./_EditManager",
	"./Selection",
	"./_RowSelector",
	"./util",
	"dijit/_Widget",
	"dijit/_TemplatedMixin",
	"dijit/CheckedMenuItem",
	"dojo/text!./resources/_Grid.html",
	"dojo/string",
	"dojo/_base/array",
	"dojo/_base/lang",
	"dojo/_base/sniff",
	"dojox/html/metrics",
	"dojo/_base/html",
	"dojo/query",
	"dojo/dnd/common",
	"dojo/i18n!dijit/nls/loading"
], function(dojo, dojox, declare, _Events, _Scroller, _Layout, _View, _ViewManager,
	_RowManager, _FocusManager, _EditManager, Selection, _RowSelector, util, _Widget,
	 _TemplatedMixin, CheckedMenuItem, template, string, array, lang, has, metrics, html, query){

	// NOTE: this is for backwards compatibility with Dojo 1.3
	if(!dojo.isCopyKey){
		dojo.isCopyKey = dojo.dnd.getCopyKeyState;
	}
	/*=====
	dojox.grid.__CellDef = {
		// name: String?
		//		The text to use in the header of the grid for this cell.
		// get: Function?
		//		function(rowIndex){} rowIndex is of type Integer.  This
		//		function will be called when a cell	requests data.  Returns the
		//		unformatted data for the cell.
		// value: String?
		//		If "get" is not specified, this is used as the data for the cell.
		// defaultValue: String?
		//		If "get" and "value" aren't specified or if "get" returns an undefined
		//		value, this is used as the data for the cell.  "formatter" is not run
		//		on this if "get" returns an undefined value.
		// formatter: Function?
		//		function(data, rowIndex){} data is of type anything, rowIndex
		//		is of type Integer.  This function will be called after the cell
		//		has its data but before it passes it back to the grid to render.
		//		Returns the formatted version of the cell's data.
		// type: dojox.grid.cells._Base|Function?
		//		TODO
		// editable: Boolean?
		//		Whether this cell should be editable or not.
		// hidden: Boolean?
		//		If true, the cell will not be displayed.
		// noresize: Boolean?
		//		If true, the cell will not be able to be resized.
		// width: Integer|String?
		//		A CSS size.  If it's an Integer, the width will be in em's.
		// colSpan: Integer?
		//		How many columns to span this cell.  Will not work in the first
		//		sub-row of cells.
		// rowSpan: Integer?
		//		How many sub-rows to span this cell.
		// styles: String?
		//		A string of styles to apply to both the header cell and main
		//		grid cells.  Must end in a ';'.
		// headerStyles: String?
		//		A string of styles to apply to just the header cell.  Must end
		//		in a ';'
		// cellStyles: String?
		//		A string of styles to apply to just the main grid cells.  Must
		//		end in a ';'
		// classes: String?
		//		A space separated list of classes to apply to both the header
		//		cell and the main grid cells.
		// headerClasses: String?
		//		A space separated list of classes to apply to just the header
		//		cell.
		// cellClasses: String?
		//		A space separated list of classes to apply to just the main
		//		grid cells.
		// attrs: String?
		//		A space separated string of attribute='value' pairs to add to
		//		the header cell element and main grid cell elements.
	};
	=====*/

	/*=====
	dojox.grid.__ViewDef = {
		// noscroll: Boolean?
		//		If true, no scrollbars will be rendered without scrollbars.
		// width: Integer|String?
		//		A CSS size.  If it's an Integer, the width will be in em's. If
		//		"noscroll" is true, this value is ignored.
		// cells: dojox.grid.__CellDef[]|Array[dojox.grid.__CellDef[]]?
		//		The structure of the cells within this grid.
		// type: String?
		//		A string containing the constructor of a subclass of
		//		dojox.grid._View.  If this is not specified, dojox.grid._View
		//		is used.
		// defaultCell: dojox.grid.__CellDef?
		//		A cell definition with default values for all cells in this view.  If
		//		a property is defined in a cell definition in the "cells" array and
		//		this property, the cell definition's property will override this
		//		property's property.
		// onBeforeRow: Function?
		//		function(rowIndex, cells){} rowIndex is of type Integer, cells
		//		is of type Array[dojox.grid.__CellDef[]].  This function is called
		//		before each row of data is rendered.  Before the header is
		//		rendered, rowIndex will be -1.  "cells" is a reference to the
		//		internal structure of this view's cells so any changes you make to
		//		it will persist between calls.
		// onAfterRow: Function?
		//		function(rowIndex, cells, rowNode){} rowIndex is of type Integer, cells
		//		is of type Array[dojox.grid.__CellDef[]], rowNode is of type DOMNode.
		//		This function is called	after each row of data is rendered.  After the
		//		header is rendered, rowIndex will be -1.  "cells" is a reference to the
		//		internal structure of this view's cells so any changes you make to
		//		it will persist between calls.
	};
	=====*/

	var _Grid = declare('dojox.grid._Grid',
		[ _Widget, _TemplatedMixin, _Events ],
		{
		// summary:
		//		A grid widget with virtual scrolling, cell editing, complex rows,
		//		sorting, fixed columns, sizeable columns, etc.
		//
		// description:
		//		_Grid provides the full set of grid features without any
		//		direct connection to a data store.
		//
		//		The grid exposes a get function for the grid, or optionally
		//		individual columns, to populate cell contents.
		//
		//		The grid is rendered based on its structure, an object describing
		//		column and cell layout.
		//
		// example:
		//		A quick sample:
		//
		//		define a get function
		//	|	function get(inRowIndex){ // called in cell context
		//	|		return [this.index, inRowIndex].join(', ');
		//	|	}
		//
		//		define the grid structure:
		//	|	var structure = [ // array of view objects
		//	|		{ cells: [// array of rows, a row is an array of cells
		//	|			[
		//	|				{ name: "Alpha", width: 6 },
		//	|				{ name: "Beta" },
		//	|				{ name: "Gamma", get: get }]
		//	|		]}
		//	|	];
		//
		//	|	<div id="grid"
		//	|		rowCount="100" get="get"
		//	|		structure="structure"
		//	|		dojoType="dojox.grid._Grid"></div>

		templateString: template,

		// classTag: String
		//		CSS class applied to the grid's domNode
		classTag: 'dojoxGrid',

		// settings
		// rowCount: Integer
		//		Number of rows to display.
		rowCount: 5,

		// keepRows: Integer
		//		Number of rows to keep in the rendering cache.
		keepRows: 75,

		// rowsPerPage: Integer
		//		Number of rows to render at a time.
		rowsPerPage: 25,

		// autoWidth: Boolean
		//		If autoWidth is true, grid width is automatically set to fit the data.
		autoWidth: false,
		
		// initialWidth: String
		//		A css string to use to set our initial width (only used if autoWidth
		//		is true).  The first rendering of the grid will be this width, any
		//		resizing of columns, etc will result in the grid switching to
		//		autoWidth mode.  Note, this width will override any styling in a
		//		stylesheet or directly on the node.
		initialWidth: "",

		// autoHeight: Boolean|Integer
		//		If autoHeight is true, grid height is automatically set to fit the data.
		//		If it is an integer, the height will be automatically set to fit the data
		//		if there are fewer than that many rows - and the height will be set to show
		//		that many rows if there are more
		autoHeight: '',

		// rowHeight: Integer
		//		If rowHeight is set to a positive number, it will define the height of the rows
		//		in pixels. This can provide a significant performance advantage, since it
		//		eliminates the need to measure row sizes during rendering, which is one
		//		the primary bottlenecks in the DataGrid's performance.
		rowHeight: 0,
		
		// autoRender: Boolean
		//		If autoRender is true, grid will render itself after initialization.
		autoRender: true,

		// defaultHeight: String
		//		default height of the grid, measured in any valid css unit.
		defaultHeight: '15em',
		
		// height: String
		//		explicit height of the grid, measured in any valid css unit.  This will be populated (and overridden)
		//		if the height: css attribute exists on the source node.
		height: '',

		// structure: dojox.grid.__ViewDef|dojox.grid.__ViewDef[]|dojox.grid.__CellDef[]|Array[dojox.grid.__CellDef[]]
		//		View layout definition.
		structure: null,

		// elasticView: Integer
		//	Override defaults and make the indexed grid view elastic, thus filling available horizontal space.
		elasticView: -1,

		// singleClickEdit: boolean
		//		Single-click starts editing. Default is double-click
		singleClickEdit: false,

		// selectionMode: String
		//		Set the selection mode of grid's Selection.  Value must be 'single', 'multiple',
		//		or 'extended'.  Default is 'extended'.
		selectionMode: 'extended',

		// rowSelector: Boolean|String
		//		If set to true, will add a row selector view to this grid.  If set to a CSS width, will add
		//		a row selector of that width to this grid.
		rowSelector: '',

		// columnReordering: Boolean
		//		If set to true, will add drag and drop reordering to views with one row of columns.
		columnReordering: false,

		// headerMenu: dijit.Menu
		//		If set to a dijit.Menu, will use this as a context menu for the grid headers.
		headerMenu: null,

		// placeholderLabel: String
		//		Label of placeholders to search for in the header menu to replace with column toggling
		//		menu items.
		placeholderLabel: "GridColumns",
		
		// selectable: Boolean
		//		Set to true if you want to be able to select the text within the grid.
		selectable: false,
		
		// Used to store the last two clicks, to ensure double-clicking occurs based on the intended row
		_click: null,
		
		// loadingMessage: String
		//		Message that shows while the grid is loading
		loadingMessage: "<span class='dojoxGridLoading'>${loadingState}</span>",

		// errorMessage: String
		//		Message that shows when the grid encounters an error loading
		errorMessage: "<span class='dojoxGridError'>${errorState}</span>",

		// noDataMessage: String
		//		Message that shows if the grid has no data - wrap it in a
		//		span with class 'dojoxGridNoData' if you want it to be
		//		styled similar to the loading and error messages
		noDataMessage: "",
		
		// escapeHTMLInData: Boolean
		//		This will escape HTML brackets from the data to prevent HTML from
		//		user-inputted data being rendered with may contain JavaScript and result in
		//		XSS attacks. This is true by default, and it is recommended that it remain
		//		true. Setting this to false will allow data to be displayed in the grid without
		//		filtering, and should be only used if it is known that the data won't contain
		//		malicious scripts. If HTML is needed in grid cells, it is recommended that
		//		you use the formatter function to generate the HTML (the output of
		//		formatter functions is not filtered, even with escapeHTMLInData set to true).
		escapeHTMLInData: true,
		
		// formatterScope: Object
		//		An object to execute format functions within.  If not set, the
		//		format functions will execute within the scope of the cell that
		//		has a format function.
		formatterScope: null,
		
		// editable: boolean
		//		indicates if the grid contains editable cells, default is false
		//		set to true if editable cell encountered during rendering
		editable: false,

		// summary: String
		//		Customizable summary descriptions which will be added to grid.domNode
		summary: '',
		_setSummaryAttr: 'domNode',
		
		// sortInfo: [private] Number
		sortInfo: 0,

		// _placeholders: [private] Array
		_placeholders: null,

		// _layoutClass: Object
		//	The class to use for our layout - can be overridden by grid subclasses
		_layoutClass: _Layout,

		// initialization
		buildRendering: function(){
			this.inherited(arguments);
			if(!this.domNode.getAttribute('tabIndex')){
				this.domNode.tabIndex = "0";
			}
			this.createScroller();
			this.createLayout();
			this.createViews();
			this.createManagers();

			this.createSelection();

			this.connect(this.selection, "onSelected", "onSelected");
			this.connect(this.selection, "onDeselected", "onDeselected");
			this.connect(this.selection, "onChanged", "onSelectionChanged");

			metrics.initOnFontResize();
			this.connect(metrics, "onFontResize", "textSizeChanged");
			util.funnelEvents(this.domNode, this, 'doKeyEvent', util.keyEvents);
			if (this.selectionMode != "none") {
				this.domNode.setAttribute("aria-multiselectable", this.selectionMode == "single" ? "false" : "true");
			}

			html.addClass(this.domNode, this.classTag);
			if(!this.isLeftToRight()){
				html.addClass(this.domNode, this.classTag+"Rtl");
			}
			if(this.rowHeight > 0){
				html.addClass(this.viewsNode, this.classTag + "FixedRowHeight");
			}
		},
		
		postMixInProperties: function(){
			this.inherited(arguments);
			var messages = dojo.i18n.getLocalization("dijit", "loading", this.lang);
			this.loadingMessage = string.substitute(this.loadingMessage, messages);
			this.errorMessage = string.substitute(this.errorMessage, messages);
			if(this.srcNodeRef && this.srcNodeRef.style.height){
				this.height = this.srcNodeRef.style.height;
			}
			// Call this to update our autoheight to start out
			this._setAutoHeightAttr(this.autoHeight, true);
			this.lastScrollTop = this.scrollTop = 0;
		},
		
		postCreate: function(){
			this._placeholders = [];
			this._setHeaderMenuAttr(this.headerMenu);
			this._setStructureAttr(this.structure);
			this._click = [];
			this.inherited(arguments);
			if(this.domNode && this.autoWidth && this.initialWidth){
				this.domNode.style.width = this.initialWidth;
			}
			if (this.domNode && !this.editable){
				// default value for aria-readonly is false, set to true if grid is not editable
				html.attr(this.domNode,"aria-readonly", "true");
			}
		},

		destroy: function(){
			this.domNode.onReveal = null;
			this.domNode.onSizeChange = null;

			// Fixes IE domNode leak
			delete this._click;

			if(this.scroller){
				this.scroller.destroy();
				delete this.scroller;
			}
			this.edit.destroy();
			delete this.edit;
			this.views.destroyViews();
			if(this.focus){
				this.focus.destroy();
				delete this.focus;
			}
			if(this.headerMenu&&this._placeholders.length){
				array.forEach(this._placeholders, function(p){ p.unReplace(true); });
				this.headerMenu.unBindDomNode(this.viewsHeaderNode);
			}
			this.inherited(arguments);
		},

		_setAutoHeightAttr: function(ah, skipRender){
			// Calculate our autoheight - turn it into a boolean or an integer
			if(typeof ah == "string"){
				if(!ah || ah == "false"){
					ah = false;
				}else if (ah == "true"){
					ah = true;
				}else{
					ah = window.parseInt(ah, 10);
				}
			}
			if(typeof ah == "number"){
				if(isNaN(ah)){
					ah = false;
				}
				// Autoheight must be at least 1, if it's a number.  If it's
				// less than 0, we'll take that to mean "all" rows (same as
				// autoHeight=true - if it is equal to zero, we'll take that
				// to mean autoHeight=false
				if(ah < 0){
					ah = true;
				}else if (ah === 0){
					ah = false;
				}
			}
			this.autoHeight = ah;
			if(typeof ah == "boolean"){
				this._autoHeight = ah;
			}else if(typeof ah == "number"){
				this._autoHeight = (ah >= this.get('rowCount'));
			}else{
				this._autoHeight = false;
			}
			if(this._started && !skipRender){
				this.render();
			}
		},

		_getRowCountAttr: function(){
			return this.updating && this.invalidated && this.invalidated.rowCount != undefined ?
				this.invalidated.rowCount : this.rowCount;
		},
		
		textSizeChanged: function(){
			this.render();
		},

		sizeChange: function(){
			this.update();
		},

		createManagers: function(){
			// summary:
			//		create grid managers for various tasks including rows, focus, selection, editing

			// row manager
			this.rows = new _RowManager(this);
			// focus manager
			this.focus = new _FocusManager(this);
			// edit manager
			this.edit = new _EditManager(this);
		},

		createSelection: function(){
			// summary:	Creates a new Grid selection manager.

			// selection manager
			this.selection = new Selection(this);
		},

		createScroller: function(){
			// summary:
			//		Creates a new virtual scroller
			this.scroller = new _Scroller();
			this.scroller.grid = this;
			this.scroller.renderRow = lang.hitch(this, "renderRow");
			this.scroller.removeRow = lang.hitch(this, "rowRemoved");
		},

		createLayout: function(){
			// summary:
			//		Creates a new Grid layout
			this.layout = new this._layoutClass(this);
			this.connect(this.layout, "moveColumn", "onMoveColumn");
		},

		onMoveColumn: function(){
			this.update();
		},
		
		onResizeColumn: function(/*int*/ cellIdx){
			// Called when a column is resized.
		},

		// views
		createViews: function(){
			this.views = new _ViewManager(this);
			this.views.createView = lang.hitch(this, "createView");
		},

		createView: function(inClass, idx){
			var c = lang.getObject(inClass);
			var view = new c({ grid: this, index: idx });
			this.viewsNode.appendChild(view.domNode);
			this.viewsHeaderNode.appendChild(view.headerNode);
			this.views.addView(view);
			html.attr(this.domNode, "align", this.isLeftToRight() ? 'left' : 'right');
			return view;
		},

		buildViews: function(){
			for(var i=0, vs; (vs=this.layout.structure[i]); i++){
				this.createView(vs.type || dojox._scopeName + ".grid._View", i).setStructure(vs);
			}
			this.scroller.setContentNodes(this.views.getContentNodes());
		},

		_setStructureAttr: function(structure){
			var s = structure;
			if(s && lang.isString(s)){
				dojo.deprecated("dojox.grid._Grid.set('structure', 'objVar')", "use dojox.grid._Grid.set('structure', objVar) instead", "2.0");
				s=lang.getObject(s);
			}
			this.structure = s;
			if(!s){
				if(this.layout.structure){
					s = this.layout.structure;
				}else{
					return;
				}
			}
			this.views.destroyViews();
			this.focus.focusView = null;
			if(s !== this.layout.structure){
				this.layout.setStructure(s);
			}
			this._structureChanged();
		},

		setStructure: function(/* dojox.grid.__ViewDef|dojox.grid.__ViewDef[]|dojox.grid.__CellDef[]|Array[dojox.grid.__CellDef[]] */ inStructure){
			// summary:
			//		Install a new structure and rebuild the grid.
			dojo.deprecated("dojox.grid._Grid.setStructure(obj)", "use dojox.grid._Grid.set('structure', obj) instead.", "2.0");
			this._setStructureAttr(inStructure);
		},
		
		getColumnTogglingItems: function(){
			// summary:
			//		returns an array of dijit.CheckedMenuItem widgets that can be
			//		added to a menu for toggling columns on and off.
			var items, checkedItems = [];
			items = array.map(this.layout.cells, function(cell){
				if(!cell.menuItems){ cell.menuItems = []; }

				var self = this;
				var item = new CheckedMenuItem({
					label: cell.name,
					checked: !cell.hidden,
					_gridCell: cell,
					onChange: function(checked){
						if(self.layout.setColumnVisibility(this._gridCell.index, checked)){
							var items = this._gridCell.menuItems;
							if(items.length > 1){
								array.forEach(items, function(item){
									if(item !== this){
										item.setAttribute("checked", checked);
									}
								}, this);
							}
							checked = array.filter(self.layout.cells, function(c){
								if(c.menuItems.length > 1){
									array.forEach(c.menuItems, "item.set('disabled', false);");
								}else{
									c.menuItems[0].set('disabled', false);
								}
								return !c.hidden;
							});
							if(checked.length == 1){
								array.forEach(checked[0].menuItems, "item.set('disabled', true);");
							}
						}
					},
					destroy: function(){
						var index = array.indexOf(this._gridCell.menuItems, this);
						this._gridCell.menuItems.splice(index, 1);
						delete this._gridCell;
						CheckedMenuItem.prototype.destroy.apply(this, arguments);
					}
				});
				cell.menuItems.push(item);
				if(!cell.hidden) {
					checkedItems.push(item);
				}
				return item;
			}, this); // dijit.CheckedMenuItem[]
			if(checkedItems.length == 1) {
				checkedItems[0].set('disabled', true);
			}
			return items;
		},

		_setHeaderMenuAttr: function(menu){
			if(this._placeholders && this._placeholders.length){
				array.forEach(this._placeholders, function(p){
					p.unReplace(true);
				});
				this._placeholders = [];
			}
			if(this.headerMenu){
				this.headerMenu.unBindDomNode(this.viewsHeaderNode);
			}
			this.headerMenu = menu;
			if(!menu){ return; }

			this.headerMenu.bindDomNode(this.viewsHeaderNode);
			if(this.headerMenu.getPlaceholders){
				this._placeholders = this.headerMenu.getPlaceholders(this.placeholderLabel);
			}
		},

		setHeaderMenu: function(/* dijit.Menu */ menu){
			dojo.deprecated("dojox.grid._Grid.setHeaderMenu(obj)", "use dojox.grid._Grid.set('headerMenu', obj) instead.", "2.0");
			this._setHeaderMenuAttr(menu);
		},
		
		setupHeaderMenu: function(){
			if(this._placeholders && this._placeholders.length){
				array.forEach(this._placeholders, function(p){
					if(p._replaced){
						p.unReplace(true);
					}
					p.replace(this.getColumnTogglingItems());
				}, this);
			}
		},

		_fetch: function(start){
			this.setScrollTop(0);
		},

		getItem: function(inRowIndex){
			return null;
		},
		
		showMessage: function(message){
			if(message){
				this.messagesNode.innerHTML = message;
				this.messagesNode.style.display = "";
			}else{
				this.messagesNode.innerHTML = "";
				this.messagesNode.style.display = "none";
			}
		},

		_structureChanged: function() {
			this.buildViews();
			if(this.autoRender && this._started){
				this.render();
			}
		},

		hasLayout: function() {
			return this.layout.cells.length;
		},

		// sizing
		resize: function(changeSize, resultSize){
			// summary:
			//		Update the grid's rendering dimensions and resize it
			
			// Calling sizeChange calls update() which calls _resize...so let's
			// save our input values, if any, and use them there when it gets
			// called.  This saves us an extra call to _resize(), which can
			// get kind of heavy.
			
			this._pendingChangeSize = changeSize;
			this._pendingResultSize = resultSize;
			this.sizeChange();
		},

		_getPadBorder: function() {
			this._padBorder = this._padBorder || html._getPadBorderExtents(this.domNode);
			return this._padBorder;
		},

		_getHeaderHeight: function(){
			var vns = this.viewsHeaderNode.style, t = vns.display == "none" ? 0 : this.views.measureHeader();
			vns.height = t + 'px';
			// header heights are reset during measuring so must be normalized after measuring.
			this.views.normalizeHeaderNodeHeight();
			return t;
		},
		
		_resize: function(changeSize, resultSize){
			// Restore our pending values, if any
			changeSize = changeSize || this._pendingChangeSize;
			resultSize = resultSize || this._pendingResultSize;
			delete this._pendingChangeSize;
			delete this._pendingResultSize;
			// if we have set up everything except the DOM, we cannot resize
			if(!this.domNode){ return; }
			var pn = this.domNode.parentNode;
			if(!pn || pn.nodeType != 1 || !this.hasLayout() || pn.style.visibility == "hidden" || pn.style.display == "none"){
				return;
			}
			// useful measurement
			var padBorder = this._getPadBorder();
			var hh = undefined;
			var h;
			// grid height
			if(this._autoHeight){
				this.domNode.style.height = 'auto';
			}else if(typeof this.autoHeight == "number"){
				h = hh = this._getHeaderHeight();
				h += (this.scroller.averageRowHeight * this.autoHeight);
				this.domNode.style.height = h + "px";
			}else if(this.domNode.clientHeight <= padBorder.h){
				if(pn == document.body){
					this.domNode.style.height = this.defaultHeight;
				}else if(this.height){
					this.domNode.style.height = this.height;
				}else{
					this.fitTo = "parent";
				}
			}
			// if we are given dimensions, size the grid's domNode to those dimensions
			if(resultSize){
				changeSize = resultSize;
			}
			if(!this._autoHeight && changeSize){
				html.marginBox(this.domNode, changeSize);
				this.height = this.domNode.style.height;
				delete this.fitTo;
			}else if(this.fitTo == "parent"){
				h = this._parentContentBoxHeight = (this._parentContentBoxHeight > 0 ? this._parentContentBoxHeight : html._getContentBox(pn).h);
				this.domNode.style.height = Math.max(0, h) + "px";
			}
			
			var hasFlex = array.some(this.views.views, function(v){ return v.flexCells; });

			if(!this._autoHeight && (h || html._getContentBox(this.domNode).h) === 0){
				// We need to hide the header, since the Grid is essentially hidden.
				this.viewsHeaderNode.style.display = "none";
			}else{
				// Otherwise, show the header and give it an appropriate height.
				this.viewsHeaderNode.style.display = "block";
				if(!hasFlex && hh === undefined){
					hh = this._getHeaderHeight();
				}
			}
			if(hasFlex){
				hh = undefined;
			}

			// NOTE: it is essential that width be applied before height
			// Header height can only be calculated properly after view widths have been set.
			// This is because flex column width is naturally 0 in Firefox.
			// Therefore prior to width sizing flex columns with spaces are maximally wrapped
			// and calculated to be too tall.
			this.adaptWidth();
			this.adaptHeight(hh);

			this.postresize();
		},

		adaptWidth: function() {
			// summary:
			//		sets width and position for views and update grid width if necessary
			// tags:
			//		private
			var doAutoWidth = (!this.initialWidth && this.autoWidth);
			var w = doAutoWidth ? 0 : this.domNode.clientWidth || (this.domNode.offsetWidth - this._getPadBorder().w),
				vw = this.views.arrange(1, w);
			this.views.onEach("adaptWidth");
			if(doAutoWidth){
				this.domNode.style.width = vw + "px";
			}
		},

		adaptHeight: function(inHeaderHeight){
			// summary:
			//		measures and normalizes header height, then sets view heights, and then updates scroller
			//		content extent
			// tags:
			//		private
			var t = inHeaderHeight === undefined ? this._getHeaderHeight() : inHeaderHeight;
			var h = (this._autoHeight ? -1 : Math.max(this.domNode.clientHeight - t, 0) || 0);
			this.views.onEach('setSize', [0, h]);
			this.views.onEach('adaptHeight');
			if(!this._autoHeight){
				var numScroll = 0, numNoScroll = 0;
				var noScrolls = array.filter(this.views.views, function(v){
					var has = v.hasHScrollbar();
					if(has){ numScroll++; }else{ numNoScroll++; }
					return (!has);
				});
				if(numScroll > 0 && numNoScroll > 0){
					array.forEach(noScrolls, function(v){
						v.adaptHeight(true);
					});
				}
			}
			if(this.autoHeight === true || h != -1 || (typeof this.autoHeight == "number" && this.autoHeight >= this.get('rowCount'))){
				this.scroller.windowHeight = h;
			}else{
				this.scroller.windowHeight = Math.max(this.domNode.clientHeight - t, 0);
			}
		},

		// startup
		startup: function(){
			if(this._started){return;}
			this.inherited(arguments);
			if(this.autoRender){
				this.render();
			}
		},

		// render
		render: function(){
			// summary:
			//	Render the grid, headers, and views. Edit and scrolling states are reset. To retain edit and
			//	scrolling states, see Update.

			if(!this.domNode){return;}
			if(!this._started){return;}

			if(!this.hasLayout()) {
				this.scroller.init(0, this.keepRows, this.rowsPerPage);
				return;
			}
			//
			this.update = this.defaultUpdate;
			this._render();
		},

		_render: function(){
			this.scroller.init(this.get('rowCount'), this.keepRows, this.rowsPerPage);
			this.prerender();
			this.setScrollTop(0);
			this.postrender();
		},

		prerender: function(){
			// if autoHeight, make sure scroller knows not to virtualize; everything must be rendered.
			this.keepRows = this._autoHeight ? 0 : this.keepRows;
			this.scroller.setKeepInfo(this.keepRows);
			this.views.render();
			this._resize();
		},

		postrender: function(){
			this.postresize();
			this.focus.initFocusView();
			// make rows unselectable
			html.setSelectable(this.domNode, this.selectable);
		},

		postresize: function(){
			// views are position absolute, so they do not inflate the parent
			if(this._autoHeight){
				var size = Math.max(this.views.measureContent()) + 'px';
				
				this.viewsNode.style.height = size;
			}
		},

		renderRow: function(inRowIndex, inNodes){
			// summary:
			//		used internally to render rows
			// tags:
			//		private
			this.views.renderRow(inRowIndex, inNodes, this._skipRowRenormalize);
		},

		rowRemoved: function(inRowIndex){
			// summary:
			//		used internally to remove rows
			// tags:
			//		private
			this.views.rowRemoved(inRowIndex);
		},

		invalidated: null,

		updating: false,

		beginUpdate: function(){
			// summary:
			//		Use to make multiple changes to rows while queueing row updating.
			// NOTE: not currently supporting nested begin/endUpdate calls
			this.invalidated = [];
			this.updating = true;
		},

		endUpdate: function(){
			// summary:
			//		Use after calling beginUpdate to render any changes made to rows.
			this.updating = false;
			var i = this.invalidated, r;
			if(i.all){
				this.update();
			}else if(i.rowCount != undefined){
				this.updateRowCount(i.rowCount);
			}else{
				for(r in i){
					this.updateRow(Number(r));
				}
			}
			this.invalidated = [];
		},

		// update
		defaultUpdate: function(){
			// note: initial update calls render and subsequently this function.
			if(!this.domNode){return;}
			if(this.updating){
				this.invalidated.all = true;
				return;
			}
			//this.edit.saveState(inRowIndex);
			this.lastScrollTop = this.scrollTop;
			this.prerender();
			this.scroller.invalidateNodes();
			this.setScrollTop(this.lastScrollTop);
			this.postrender();
			//this.edit.restoreState(inRowIndex);
		},

		update: function(){
			// summary:
			//		Update the grid, retaining edit and scrolling states.
			this.render();
		},

		updateRow: function(inRowIndex){
			// summary:
			//		Render a single row.
			// inRowIndex: Integer
			//		Index of the row to render
			inRowIndex = Number(inRowIndex);
			if(this.updating){
				this.invalidated[inRowIndex]=true;
			}else{
				this.views.updateRow(inRowIndex);
				this.scroller.rowHeightChanged(inRowIndex);
			}
		},

		updateRows: function(startIndex, howMany){
			// summary:
			//		Render consecutive rows at once.
			// startIndex: Integer
			//		Index of the starting row to render
			// howMany: Integer
			//		How many rows to update.
			startIndex = Number(startIndex);
			howMany = Number(howMany);
			var i;
			if(this.updating){
				for(i=0; i<howMany; i++){
					this.invalidated[i+startIndex]=true;
				}
			}else{
				for(i=0; i<howMany; i++){
					this.views.updateRow(i+startIndex, this._skipRowRenormalize);
				}
				this.scroller.rowHeightChanged(startIndex);
			}
		},

		updateRowCount: function(inRowCount){
			// summary:
			//		Change the number of rows.
			// inRowCount: int
			//		Number of rows in the grid.
			if(this.updating){
				this.invalidated.rowCount = inRowCount;
			}else{
				this.rowCount = inRowCount;
				this._setAutoHeightAttr(this.autoHeight, true);
				if(this.layout.cells.length){
					this.scroller.updateRowCount(inRowCount);
				}
				this._resize();
				if(this.layout.cells.length){
					this.setScrollTop(this.scrollTop);
				}
			}
		},

		updateRowStyles: function(inRowIndex){
			// summary:
			//		Update the styles for a row after it's state has changed.
			this.views.updateRowStyles(inRowIndex);
		},
		getRowNode: function(inRowIndex){
			// summary:
			//		find the rowNode that is not a rowSelector
			if (this.focus.focusView && !(this.focus.focusView instanceof _RowSelector)){
					return this.focus.focusView.rowNodes[inRowIndex];
			}else{ // search through views
				for (var i = 0, cView; (cView = this.views.views[i]); i++) {
					if (!(cView instanceof _RowSelector)) {
						return cView.rowNodes[inRowIndex];
					}
				}
			}
			return null;
		},
		rowHeightChanged: function(inRowIndex){
			// summary:
			//		Update grid when the height of a row has changed. Row height is handled automatically as rows
			//		are rendered. Use this function only to update a row's height outside the normal rendering process.
			// inRowIndex: Integer
			//		index of the row that has changed height

			this.views.renormalizeRow(inRowIndex);
			this.scroller.rowHeightChanged(inRowIndex);
		},

		// fastScroll: Boolean
		//		flag modifies vertical scrolling behavior. Defaults to true but set to false for slower
		//		scroll performance but more immediate scrolling feedback
		fastScroll: true,

		delayScroll: false,

		// scrollRedrawThreshold: int
		//	pixel distance a user must scroll vertically to trigger grid scrolling.
		scrollRedrawThreshold: (has('ie') ? 100 : 50),

		// scroll methods
		scrollTo: function(inTop){
			// summary:
			//		Vertically scroll the grid to a given pixel position
			// inTop: Integer
			//		vertical position of the grid in pixels
			if(!this.fastScroll){
				this.setScrollTop(inTop);
				return;
			}
			var delta = Math.abs(this.lastScrollTop - inTop);
			this.lastScrollTop = inTop;
			if(delta > this.scrollRedrawThreshold || this.delayScroll){
				this.delayScroll = true;
				this.scrollTop = inTop;
				this.views.setScrollTop(inTop);
				if(this._pendingScroll){
					window.clearTimeout(this._pendingScroll);
				}
				var _this = this;
				this._pendingScroll = window.setTimeout(function(){
					delete _this._pendingScroll;
					_this.finishScrollJob();
				}, 200);
			}else{
				this.setScrollTop(inTop);
			}
		},

		finishScrollJob: function(){
			this.delayScroll = false;
			this.setScrollTop(this.scrollTop);
		},

		setScrollTop: function(inTop){
			this.scroller.scroll(this.views.setScrollTop(inTop));
		},

		scrollToRow: function(inRowIndex){
			// summary:
			//		Scroll the grid to a specific row.
			// inRowIndex: Integer
			//		grid row index
			this.setScrollTop(this.scroller.findScrollTop(inRowIndex) + 1);
		},

		styleRowNode: function(inRowIndex, inRowNode){
			// summary:
			//		styling (used internally to style individual parts of a row)
			// tags:
			//		private
			if(inRowNode){
				this.rows.styleRowNode(inRowIndex, inRowNode);
			}
		},
		
		// called when the mouse leaves the grid so we can deselect all hover rows
		_mouseOut: function(e){
			this.rows.setOverRow(-2);
		},
	
		// cells
		getCell: function(inIndex){
			// summary:
			//		Retrieves the cell object for a given grid column.
			// inIndex: Integer
			//		Grid column index of cell to retrieve
			// returns:
			//		a grid cell
			return this.layout.cells[inIndex];
		},

		setCellWidth: function(inIndex, inUnitWidth){
			this.getCell(inIndex).unitWidth = inUnitWidth;
		},

		getCellName: function(inCell){
			// summary:
			//		Returns the cell name of a passed cell
			return "Cell " + inCell.index; // String
		},

		// sorting
		canSort: function(inSortInfo){
			// summary:
			//		Determines if the grid can be sorted
			// inSortInfo: Integer
			//		Sort information, 1-based index of column on which to sort, positive for an ascending sort
			//		and negative for a descending sort
			// returns: Boolean
			//		True if grid can be sorted on the given column in the given direction
		},

		sort: function(){
		},

		getSortAsc: function(inSortInfo){
			// summary:
			//		Returns true if grid is sorted in an ascending direction.
			inSortInfo = inSortInfo == undefined ? this.sortInfo : inSortInfo;
			return Boolean(inSortInfo > 0); // Boolean
		},

		getSortIndex: function(inSortInfo){
			// summary:
			//		Returns the index of the column on which the grid is sorted
			inSortInfo = inSortInfo == undefined ? this.sortInfo : inSortInfo;
			return Math.abs(inSortInfo) - 1; // Integer
		},

		setSortIndex: function(inIndex, inAsc){
			// summary:
			//		Sort the grid on a column in a specified direction
			// inIndex: Integer
			//		Column index on which to sort.
			// inAsc: Boolean
			//		If true, sort the grid in ascending order, otherwise in descending order
			var si = inIndex +1;
			if(inAsc != undefined){
				si *= (inAsc ? 1 : -1);
			} else if(this.getSortIndex() == inIndex){
				si = -this.sortInfo;
			}
			this.setSortInfo(si);
		},

		setSortInfo: function(inSortInfo){
			if(this.canSort(inSortInfo)){
				this.sortInfo = inSortInfo;
				this.sort();
				this.update();
			}
		},

		// DOM event handler
		doKeyEvent: function(e){
			e.dispatch = 'do' + e.type;
			this.onKeyEvent(e);
		},

		// event dispatch
		//: protected
		_dispatch: function(m, e){
			if(m in this){
				return this[m](e);
			}
			return false;
		},

		dispatchKeyEvent: function(e){
			this._dispatch(e.dispatch, e);
		},

		dispatchContentEvent: function(e){
			this.edit.dispatchEvent(e) || e.sourceView.dispatchContentEvent(e) || this._dispatch(e.dispatch, e);
		},

		dispatchHeaderEvent: function(e){
			e.sourceView.dispatchHeaderEvent(e) || this._dispatch('doheader' + e.type, e);
		},

		dokeydown: function(e){
			this.onKeyDown(e);
		},

		doclick: function(e){
			if(e.cellNode){
				this.onCellClick(e);
			}else{
				this.onRowClick(e);
			}
		},

		dodblclick: function(e){
			if(e.cellNode){
				this.onCellDblClick(e);
			}else{
				this.onRowDblClick(e);
			}
		},

		docontextmenu: function(e){
			if(e.cellNode){
				this.onCellContextMenu(e);
			}else{
				this.onRowContextMenu(e);
			}
		},

		doheaderclick: function(e){
			if(e.cellNode){
				this.onHeaderCellClick(e);
			}else{
				this.onHeaderClick(e);
			}
		},

		doheaderdblclick: function(e){
			if(e.cellNode){
				this.onHeaderCellDblClick(e);
			}else{
				this.onHeaderDblClick(e);
			}
		},

		doheadercontextmenu: function(e){
			if(e.cellNode){
				this.onHeaderCellContextMenu(e);
			}else{
				this.onHeaderContextMenu(e);
			}
		},

		// override to modify editing process
		doStartEdit: function(inCell, inRowIndex){
			this.onStartEdit(inCell, inRowIndex);
		},

		doApplyCellEdit: function(inValue, inRowIndex, inFieldIndex){
			this.onApplyCellEdit(inValue, inRowIndex, inFieldIndex);
		},

		doCancelEdit: function(inRowIndex){
			this.onCancelEdit(inRowIndex);
		},

		doApplyEdit: function(inRowIndex){
			this.onApplyEdit(inRowIndex);
		},

		// row editing
		addRow: function(){
			// summary:
			//		Add a row to the grid.
			this.updateRowCount(this.get('rowCount')+1);
		},

		removeSelectedRows: function(){
			// summary:
			//		Remove the selected rows from the grid.
			if(this.allItemsSelected){
				this.updateRowCount(0);
			}else{
				this.updateRowCount(Math.max(0, this.get('rowCount') - this.selection.getSelected().length));
			}
			this.selection.clear();
		}

	});

	_Grid.markupFactory = function(props, node, ctor, cellFunc){
		var widthFromAttr = function(n){
			var w = html.attr(n, "width")||"auto";
			if((w != "auto")&&(w.slice(-2) != "em")&&(w.slice(-1) != "%")){
				w = parseInt(w, 10)+"px";
			}
			return w;
		};
		// if(!props.store){ console.debug("no store!"); }
		// if a structure isn't referenced, do we have enough
		// data to try to build one automatically?
		if(	!props.structure &&
			node.nodeName.toLowerCase() == "table"){

			// try to discover a structure
			props.structure = query("> colgroup", node).map(function(cg){
				var sv = html.attr(cg, "span");
				var v = {
					noscroll: (html.attr(cg, "noscroll") == "true") ? true : false,
					__span: (!!sv ? parseInt(sv, 10) : 1),
					cells: []
				};
				if(html.hasAttr(cg, "width")){
					v.width = widthFromAttr(cg);
				}
				return v; // for vendetta
			});
			if(!props.structure.length){
				props.structure.push({
					__span: Infinity,
					cells: [] // catch-all view
				});
			}
			// check to see if we're gonna have more than one view

			// for each tr in our th, create a row of cells
			query("thead > tr", node).forEach(function(tr, tr_idx){
				var cellCount = 0;
				var viewIdx = 0;
				var lastViewIdx;
				var cView = null;
				query("> th", tr).map(function(th){
					// what view will this cell go into?

					// NOTE:
					//		to prevent extraneous iteration, we start counters over
					//		for each row, incrementing over the surface area of the
					//		structure that colgroup processing generates and
					//		creating cell objects for each <th> to place into those
					//		cell groups.  There's a lot of state-keepking logic
					//		here, but it is what it has to be.
					if(!cView){ // current view book keeping
						lastViewIdx = 0;
						cView = props.structure[0];
					}else if(cellCount >= (lastViewIdx+cView.__span)){
						viewIdx++;
						// move to allocating things into the next view
						lastViewIdx += cView.__span;
						var lastView = cView;
						cView = props.structure[viewIdx];
					}

					// actually define the cell from what markup hands us
					var cell = {
						name: lang.trim(html.attr(th, "name")||th.innerHTML),
						colSpan: parseInt(html.attr(th, "colspan")||1, 10),
						type: lang.trim(html.attr(th, "cellType")||""),
						id: lang.trim(html.attr(th,"id")||"")
					};
					cellCount += cell.colSpan;
					var rowSpan = html.attr(th, "rowspan");
					if(rowSpan){
						cell.rowSpan = rowSpan;
					}
					if(html.hasAttr(th, "width")){
						cell.width = widthFromAttr(th);
					}
					if(html.hasAttr(th, "relWidth")){
						cell.relWidth = window.parseInt(html.attr(th, "relWidth"), 10);
					}
					if(html.hasAttr(th, "hidden")){
						cell.hidden = (html.attr(th, "hidden") == "true" || html.attr(th, "hidden") === true/*always boolean true in Chrome*/);
					}

					if(cellFunc){
						cellFunc(th, cell);
					}

					cell.type = cell.type ? lang.getObject(cell.type) : dojox.grid.cells.Cell;

					if(cell.type && cell.type.markupFactory){
						cell.type.markupFactory(th, cell);
					}

					if(!cView.cells[tr_idx]){
						cView.cells[tr_idx] = [];
					}
					cView.cells[tr_idx].push(cell);
				});
			});
		}

		return new ctor(props, node);
	};

	return _Grid;

});

},
'dojox/grid/_Events':function(){
define([
	"dojo/keys",
	"dojo/dom-class",
	"dojo/_base/declare",
	"dojo/_base/event",
	"dojo/_base/sniff"
], function(keys, domClass, declare, event, has){

return declare("dojox.grid._Events", null, {
	// summary:
	//		_Grid mixin that provides default implementations for grid events.
	// description:
	//		Default synthetic events dispatched for _Grid. dojo.connect to events to
	//		retain default implementation or override them for custom handling.
	
	// cellOverClass: String
	//		css class to apply to grid cells over which the cursor is placed.
	cellOverClass: "dojoxGridCellOver",
	
	onKeyEvent: function(e){
		// summary:
		//		top level handler for Key Events
		this.dispatchKeyEvent(e);
	},

	onContentEvent: function(e){
		// summary:
		//		Top level handler for Content events
		this.dispatchContentEvent(e);
	},

	onHeaderEvent: function(e){
		// summary:
		//		Top level handler for header events
		this.dispatchHeaderEvent(e);
	},

	onStyleRow: function(inRow){
		// summary:
		//		Perform row styling on a given row. Called whenever row styling is updated.
		// inRow: Object
		//		Object containing row state information: selected, true if the row is selcted; over:
		//		true of the mouse is over the row; odd: true if the row is odd. Use customClasses and
		//		customStyles to control row css classes and styles; both properties are strings.
		// example:
		// |	onStyleRow({ selected: true, over:true, odd:false })
		var i = inRow;
		i.customClasses += (i.odd?" dojoxGridRowOdd":"") + (i.selected?" dojoxGridRowSelected":"") + (i.over?" dojoxGridRowOver":"");
		this.focus.styleRow(inRow);
		this.edit.styleRow(inRow);
	},
	
	onKeyDown: function(e){
		// summary:
		//		Grid key event handler. By default enter begins editing and applies edits, escape cancels an edit,
		//		tab, shift-tab, and arrow keys move grid cell focus.
		if(e.altKey || e.metaKey){
			return;
		}
		var colIdx;
		switch(e.keyCode){
			case keys.ESCAPE:
				this.edit.cancel();
				break;
			case keys.ENTER:
				if(!this.edit.isEditing()){
					colIdx = this.focus.getHeaderIndex();
					if(colIdx >= 0) {
						this.setSortIndex(colIdx);
						break;
					}else {
						this.selection.clickSelect(this.focus.rowIndex, dojo.isCopyKey(e), e.shiftKey);
					}
					event.stop(e);
				}
				if(!e.shiftKey){
					var isEditing = this.edit.isEditing();
					this.edit.apply();
					if(!isEditing){
						this.edit.setEditCell(this.focus.cell, this.focus.rowIndex);
					}
				}
				if (!this.edit.isEditing()){
					var curView = this.focus.focusView || this.views.views[0];  //if no focusView than only one view
					curView.content.decorateEvent(e);
					this.onRowClick(e);
					event.stop(e);
				}
				break;
			case keys.SPACE:
				if(!this.edit.isEditing()){
					colIdx = this.focus.getHeaderIndex();
					if(colIdx >= 0) {
						this.setSortIndex(colIdx);
						break;
					}else {
						this.selection.clickSelect(this.focus.rowIndex, dojo.isCopyKey(e), e.shiftKey);
					}
					event.stop(e);
				}
				break;
			case keys.TAB:
				this.focus[e.shiftKey ? 'previousKey' : 'nextKey'](e);
				break;
			case keys.LEFT_ARROW:
			case keys.RIGHT_ARROW:
				if(!this.edit.isEditing()){
					var keyCode = e.keyCode;  // IE seems to lose after stopEvent when modifier keys
					event.stop(e);
					colIdx = this.focus.getHeaderIndex();
					if (colIdx >= 0 && (e.shiftKey && e.ctrlKey)){
						this.focus.colSizeAdjust(e, colIdx, (keyCode == keys.LEFT_ARROW ? -1 : 1)*5);
					}
					else{
						var offset = (keyCode == keys.LEFT_ARROW) ? 1 : -1;
						if(this.isLeftToRight()){ offset *= -1; }
						this.focus.move(0, offset);
					}
				}
				break;
			case keys.UP_ARROW:
				if(!this.edit.isEditing() && this.focus.rowIndex !== 0){
					event.stop(e);
					this.focus.move(-1, 0);
				}
				break;
			case keys.DOWN_ARROW:
				if(!this.edit.isEditing() && this.focus.rowIndex+1 != this.rowCount){
					event.stop(e);
					this.focus.move(1, 0);
				}
				break;
			case keys.PAGE_UP:
				if(!this.edit.isEditing() && this.focus.rowIndex !== 0){
					event.stop(e);
					if(this.focus.rowIndex != this.scroller.firstVisibleRow+1){
						this.focus.move(this.scroller.firstVisibleRow-this.focus.rowIndex, 0);
					}else{
						this.setScrollTop(this.scroller.findScrollTop(this.focus.rowIndex-1));
						this.focus.move(this.scroller.firstVisibleRow-this.scroller.lastVisibleRow+1, 0);
					}
				}
				break;
			case keys.PAGE_DOWN:
				if(!this.edit.isEditing() && this.focus.rowIndex+1 != this.rowCount){
					event.stop(e);
					if(this.focus.rowIndex != this.scroller.lastVisibleRow-1){
						this.focus.move(this.scroller.lastVisibleRow-this.focus.rowIndex-1, 0);
					}else{
						this.setScrollTop(this.scroller.findScrollTop(this.focus.rowIndex+1));
						this.focus.move(this.scroller.lastVisibleRow-this.scroller.firstVisibleRow-1, 0);
					}
				}
				break;
			default:
				break;
		}
	},
	
	onMouseOver: function(e){
		// summary:
		//		Event fired when mouse is over the grid.
		// e: Event
		//		Decorated event object contains reference to grid, cell, and rowIndex
		e.rowIndex == -1 ? this.onHeaderCellMouseOver(e) : this.onCellMouseOver(e);
	},
	
	onMouseOut: function(e){
		// summary:
		//		Event fired when mouse moves out of the grid.
		// e: Event
		//		Decorated event object that contains reference to grid, cell, and rowIndex
		e.rowIndex == -1 ? this.onHeaderCellMouseOut(e) : this.onCellMouseOut(e);
	},
	
	onMouseDown: function(e){
		// summary:
		//		Event fired when mouse is down inside grid.
		// e: Event
		//		Decorated event object that contains reference to grid, cell, and rowIndex
		e.rowIndex == -1 ? this.onHeaderCellMouseDown(e) : this.onCellMouseDown(e);
	},
	
	onMouseOverRow: function(e){
		// summary:
		//		Event fired when mouse is over any row (data or header).
		// e: Event
		//		Decorated event object contains reference to grid, cell, and rowIndex
		if(!this.rows.isOver(e.rowIndex)){
			this.rows.setOverRow(e.rowIndex);
			e.rowIndex == -1 ? this.onHeaderMouseOver(e) : this.onRowMouseOver(e);
		}
	},
	onMouseOutRow: function(e){
		// summary:
		//		Event fired when mouse moves out of any row (data or header).
		// e: Event
		//		Decorated event object contains reference to grid, cell, and rowIndex
		if(this.rows.isOver(-1)){
			this.onHeaderMouseOut(e);
		}else if(!this.rows.isOver(-2)){
			this.rows.setOverRow(-2);
			this.onRowMouseOut(e);
		}
	},
	
	onMouseDownRow: function(e){
		// summary:
		//		Event fired when mouse is down inside grid row
		// e: Event
		//		Decorated event object that contains reference to grid, cell, and rowIndex
		if(e.rowIndex != -1)
			this.onRowMouseDown(e);
	},

	// cell events
	onCellMouseOver: function(e){
		// summary:
		//		Event fired when mouse is over a cell.
		// e: Event
		//		Decorated event object contains reference to grid, cell, and rowIndex
		if(e.cellNode){
			domClass.add(e.cellNode, this.cellOverClass);
		}
	},
	
	onCellMouseOut: function(e){
		// summary:
		//		Event fired when mouse moves out of a cell.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		if(e.cellNode){
			domClass.remove(e.cellNode, this.cellOverClass);
		}
	},
	
	onCellMouseDown: function(e){
		// summary:
		//		Event fired when mouse is down in a header cell.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onCellClick: function(e){
		// summary:
		//		Event fired when a cell is clicked.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this._click[0] = this._click[1];
		this._click[1] = e;
		if(!this.edit.isEditCell(e.rowIndex, e.cellIndex)){
			this.focus.setFocusCell(e.cell, e.rowIndex);
		}
		// in some cases click[0] is null which causes false doubeClicks. Fixes #100703
		if(this._click.length > 1 && this._click[0] == null){
			this._click.shift();
		}
		this.onRowClick(e);
	},

	onCellDblClick: function(e){
		// summary:
		//		Event fired when a cell is double-clicked.
		// e: Event
		//		Decorated event object contains reference to grid, cell, and rowIndex
		var event;
		if(this._click.length > 1 && has('ie')){
			event = this._click[1];
		}else if(this._click.length > 1 && this._click[0].rowIndex != this._click[1].rowIndex){
			event = this._click[0];
		}else{
			event = e;
		}
		this.focus.setFocusCell(event.cell, event.rowIndex);
		this.edit.setEditCell(event.cell, event.rowIndex);
		this.onRowDblClick(e);
	},

	onCellContextMenu: function(e){
		// summary:
		//		Event fired when a cell context menu is accessed via mouse right click.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this.onRowContextMenu(e);
	},

	onCellFocus: function(inCell, inRowIndex){
		// summary:
		//		Event fired when a cell receives focus.
		// inCell: Object
		//		Cell object containing properties of the grid column.
		// inRowIndex: Integer
		//		Index of the grid row
		this.edit.cellFocus(inCell, inRowIndex);
	},

	// row events
	onRowClick: function(e){
		// summary:
		//		Event fired when a row is clicked.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this.edit.rowClick(e);
		this.selection.clickSelectEvent(e);
	},

	onRowDblClick: function(e){
		// summary:
		//		Event fired when a row is double clicked.
		// e: Event
		//		decorated event object which contains reference to grid, cell, and rowIndex
	},

	onRowMouseOver: function(e){
		// summary:
		//		Event fired when mouse moves over a data row.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onRowMouseOut: function(e){
		// summary:
		//		Event fired when mouse moves out of a data row.
		// e: Event
		//		Decorated event object contains reference to grid, cell, and rowIndex
	},
	
	onRowMouseDown: function(e){
		// summary:
		//		Event fired when mouse is down in a row.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onRowContextMenu: function(e){
		// summary:
		//		Event fired when a row context menu is accessed via mouse right click.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		event.stop(e);
	},

	// header events
	onHeaderMouseOver: function(e){
		// summary:
		//		Event fired when mouse moves over the grid header.
		// e: Event
		//		Decorated event object contains reference to grid, cell, and rowIndex
	},

	onHeaderMouseOut: function(e){
		// summary:
		//		Event fired when mouse moves out of the grid header.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onHeaderCellMouseOver: function(e){
		// summary:
		//		Event fired when mouse moves over a header cell.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		if(e.cellNode){
			domClass.add(e.cellNode, this.cellOverClass);
		}
	},

	onHeaderCellMouseOut: function(e){
		// summary:
		//		Event fired when mouse moves out of a header cell.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		if(e.cellNode){
			domClass.remove(e.cellNode, this.cellOverClass);
		}
	},
	
	onHeaderCellMouseDown: function(e) {
		// summary:
		//		Event fired when mouse is down in a header cell.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onHeaderClick: function(e){
		// summary:
		//		Event fired when the grid header is clicked.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onHeaderCellClick: function(e){
		// summary:
		//		Event fired when a header cell is clicked.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this.setSortIndex(e.cell.index);
		this.onHeaderClick(e);
	},

	onHeaderDblClick: function(e){
		// summary:
		//		Event fired when the grid header is double clicked.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onHeaderCellDblClick: function(e){
		// summary:
		//		Event fired when a header cell is double clicked.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this.onHeaderDblClick(e);
	},

	onHeaderCellContextMenu: function(e){
		// summary:
		//		Event fired when a header cell context menu is accessed via mouse right click.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this.onHeaderContextMenu(e);
	},

	onHeaderContextMenu: function(e){
		// summary:
		//		Event fired when the grid header context menu is accessed via mouse right click.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		if(!this.headerMenu){
			event.stop(e);
		}
	},

	// editing
	onStartEdit: function(inCell, inRowIndex){
		// summary:
		//		Event fired when editing is started for a given grid cell
		// inCell: Object
		//		Cell object containing properties of the grid column.
		// inRowIndex: Integer
		//		Index of the grid row
	},

	onApplyCellEdit: function(inValue, inRowIndex, inFieldIndex){
		// summary:
		//		Event fired when editing is applied for a given grid cell
		// inValue: String
		//		Value from cell editor
		// inRowIndex: Integer
		//		Index of the grid row
		// inFieldIndex: Integer
		//		Index in the grid's data store
	},

	onCancelEdit: function(inRowIndex){
		// summary:
		//		Event fired when editing is cancelled for a given grid cell
		// inRowIndex: Integer
		//		Index of the grid row
	},

	onApplyEdit: function(inRowIndex){
		// summary:
		//		Event fired when editing is applied for a given grid row
		// inRowIndex: Integer
		//		Index of the grid row
	},

	onCanSelect: function(inRowIndex){
		// summary:
		//		Event to determine if a grid row may be selected
		// inRowIndex: Integer
		//		Index of the grid row
		// returns: Boolean
		//		true if the row can be selected
		return true;
	},

	onCanDeselect: function(inRowIndex){
		// summary:
		//		Event to determine if a grid row may be deselected
		// inRowIndex: Integer
		//		Index of the grid row
		// returns: Boolean
		//		true if the row can be deselected
		return true;
	},

	onSelected: function(inRowIndex){
		// summary:
		//		Event fired when a grid row is selected
		// inRowIndex: Integer
		//		Index of the grid row
		this.updateRowStyles(inRowIndex);
	},

	onDeselected: function(inRowIndex){
		// summary:
		//		Event fired when a grid row is deselected
		// inRowIndex: Integer
		//		Index of the grid row
		this.updateRowStyles(inRowIndex);
	},

	onSelectionChanged: function(){
	}
});
});
},
'dojox/grid/_Scroller':function(){
define([
	"dijit/registry",
	"dojo/_base/declare",
	"dojo/_base/lang",
	"./util",
	"dojo/_base/html"
], function(dijitRegistry, declare, lang, util, html){

	var indexInParent = function(inNode){
		var i=0, n, p=inNode.parentNode;
		while((n = p.childNodes[i++])){
			if(n == inNode){
				return i - 1;
			}
		}
		return -1;
	};
	
	var cleanNode = function(inNode){
		if(!inNode){
			return;
		}
		dojo.forEach(dijitRegistry.toArray(), function(w){
			if(w.domNode && html.isDescendant(w.domNode, inNode, true)){
				w.destroy();
			}
		});
	};

	var getTagName = function(inNodeOrId){
		var node = html.byId(inNodeOrId);
		return (node && node.tagName ? node.tagName.toLowerCase() : '');
	};
	
	var nodeKids = function(inNode, inTag){
		var result = [];
		var i=0, n;
		while((n = inNode.childNodes[i])){
			i++;
			if(getTagName(n) == inTag){
				result.push(n);
			}
		}
		return result;
	};
	
	var divkids = function(inNode){
		return nodeKids(inNode, 'div');
	};

	return declare("dojox.grid._Scroller", null, {
		constructor: function(inContentNodes){
			this.setContentNodes(inContentNodes);
			this.pageHeights = [];
			this.pageNodes = [];
			this.stack = [];
		},
		// specified
		rowCount: 0, // total number of rows to manage
		defaultRowHeight: 32, // default height of a row
		keepRows: 100, // maximum number of rows that should exist at one time
		contentNode: null, // node to contain pages
		scrollboxNode: null, // node that controls scrolling
		// calculated
		defaultPageHeight: 0, // default height of a page
		keepPages: 10, // maximum number of pages that should exists at one time
		pageCount: 0,
		windowHeight: 0,
		firstVisibleRow: 0,
		lastVisibleRow: 0,
		averageRowHeight: 0, // the average height of a row
		// private
		page: 0,
		pageTop: 0,
		// init
		init: function(inRowCount, inKeepRows, inRowsPerPage){
			switch(arguments.length){
				case 3: this.rowsPerPage = inRowsPerPage;
				case 2: this.keepRows = inKeepRows;
				case 1: this.rowCount = inRowCount;
				default: break;
			}
			this.defaultPageHeight = (this.grid.rowHeight > 0 ? this.grid.rowHeight : this.defaultRowHeight) * this.rowsPerPage;
			this.pageCount = this._getPageCount(this.rowCount, this.rowsPerPage);
			this.setKeepInfo(this.keepRows);
			this.invalidate();
			if(this.scrollboxNode){
				this.scrollboxNode.scrollTop = 0;
				this.scroll(0);
				this.scrollboxNode.onscroll = lang.hitch(this, 'onscroll');
			}
		},
		_getPageCount: function(rowCount, rowsPerPage){
			return rowCount ? (Math.ceil(rowCount / rowsPerPage) || 1) : 0;
		},
		destroy: function(){
			this.invalidateNodes();
			delete this.contentNodes;
			delete this.contentNode;
			delete this.scrollboxNode;
		},
		setKeepInfo: function(inKeepRows){
			this.keepRows = inKeepRows;
			this.keepPages = !this.keepRows ? this.keepPages : Math.max(Math.ceil(this.keepRows / this.rowsPerPage), 2);
		},
		// nodes
		setContentNodes: function(inNodes){
			this.contentNodes = inNodes;
			this.colCount = (this.contentNodes ? this.contentNodes.length : 0);
			this.pageNodes = [];
			for(var i=0; i<this.colCount; i++){
				this.pageNodes[i] = [];
			}
		},
		getDefaultNodes: function(){
			return this.pageNodes[0] || [];
		},
		// updating
		invalidate: function(){
			this._invalidating = true;
			this.invalidateNodes();
			this.pageHeights = [];
			this.height = (this.pageCount ? (this.pageCount - 1)* this.defaultPageHeight + this.calcLastPageHeight() : 0);
			this.resize();
			this._invalidating = false;
		},
		updateRowCount: function(inRowCount){
			this.invalidateNodes();
			this.rowCount = inRowCount;
			// update page count, adjust document height
			var oldPageCount = this.pageCount;
			if(oldPageCount === 0){
				//We want to have at least 1px in height to keep scroller.  Otherwise with an
				//empty grid you can't scroll to see the header.
				this.height = 1;
			}
			this.pageCount = this._getPageCount(this.rowCount, this.rowsPerPage);
			if(this.pageCount < oldPageCount){
				for(var i=oldPageCount-1; i>=this.pageCount; i--){
					this.height -= this.getPageHeight(i);
					delete this.pageHeights[i];
				}
			}else if(this.pageCount > oldPageCount){
				this.height += this.defaultPageHeight * (this.pageCount - oldPageCount - 1) + this.calcLastPageHeight();
			}
			this.resize();
		},
		// implementation for page manager
		pageExists: function(inPageIndex){
			return Boolean(this.getDefaultPageNode(inPageIndex));
		},
		measurePage: function(inPageIndex){
			if(this.grid.rowHeight){
				return ((inPageIndex + 1) * this.rowsPerPage > this.rowCount ?
					this.rowCount - inPageIndex * this.rowsPerPage :
					this.rowsPerPage) * this.grid.rowHeight;
					 
			}
			var n = this.getDefaultPageNode(inPageIndex);
			return (n && n.innerHTML) ? n.offsetHeight : undefined;
		},
		positionPage: function(inPageIndex, inPos){
			for(var i=0; i<this.colCount; i++){
				this.pageNodes[i][inPageIndex].style.top = inPos + 'px';
			}
		},
		repositionPages: function(inPageIndex){
			var nodes = this.getDefaultNodes();
			var last = 0;

			for(var i=0; i<this.stack.length; i++){
				last = Math.max(this.stack[i], last);
			}
			//
			var n = nodes[inPageIndex];
			var y = (n ? this.getPageNodePosition(n) + this.getPageHeight(inPageIndex) : 0);
			for(var p=inPageIndex+1; p<=last; p++){
				n = nodes[p];
				if(n){
					if(this.getPageNodePosition(n) == y){
						return;
					}
					this.positionPage(p, y);
				}
				y += this.getPageHeight(p);
			}
		},
		installPage: function(inPageIndex){
			for(var i=0; i<this.colCount; i++){
				this.contentNodes[i].appendChild(this.pageNodes[i][inPageIndex]);
			}
		},
		preparePage: function(inPageIndex, inReuseNode){
			var p = (inReuseNode ? this.popPage() : null);
			for(var i=0; i<this.colCount; i++){
				var nodes = this.pageNodes[i];
				var new_p = (p === null ? this.createPageNode() : this.invalidatePageNode(p, nodes));
				new_p.pageIndex = inPageIndex;
				nodes[inPageIndex] = new_p;
			}
		},
		// rendering implementation
		renderPage: function(inPageIndex){
			var nodes = [];
			var i, j;
			for(i=0; i<this.colCount; i++){
				nodes[i] = this.pageNodes[i][inPageIndex];
			}
			for(i=0, j=inPageIndex*this.rowsPerPage; (i<this.rowsPerPage)&&(j<this.rowCount); i++, j++){
				this.renderRow(j, nodes);
			}
		},
		removePage: function(inPageIndex){
			for(var i=0, j=inPageIndex*this.rowsPerPage; i<this.rowsPerPage; i++, j++){
				this.removeRow(j);
			}
		},
		destroyPage: function(inPageIndex){
			for(var i=0; i<this.colCount; i++){
				var n = this.invalidatePageNode(inPageIndex, this.pageNodes[i]);
				if(n){
					html.destroy(n);
				}
			}
		},
		pacify: function(inShouldPacify){
		},
		// pacification
		pacifying: false,
		pacifyTicks: 200,
		setPacifying: function(inPacifying){
			if(this.pacifying != inPacifying){
				this.pacifying = inPacifying;
				this.pacify(this.pacifying);
			}
		},
		startPacify: function(){
			this.startPacifyTicks = new Date().getTime();
		},
		doPacify: function(){
			var result = (new Date().getTime() - this.startPacifyTicks) > this.pacifyTicks;
			this.setPacifying(true);
			this.startPacify();
			return result;
		},
		endPacify: function(){
			this.setPacifying(false);
		},
		// default sizing implementation
		resize: function(){
			if(this.scrollboxNode){
				this.windowHeight = this.scrollboxNode.clientHeight;
			}
			for(var i=0; i<this.colCount; i++){
				//We want to have 1px in height min to keep scroller.  Otherwise can't scroll
				//and see header in empty grid.
				util.setStyleHeightPx(this.contentNodes[i], Math.max(1,this.height));
			}
			
			// Calculate the average row height and update the defaults (row and page).
			var needPage = (!this._invalidating);
			if(!needPage){
				var ah = this.grid.get("autoHeight");
				if(typeof ah == "number" && ah <= Math.min(this.rowsPerPage, this.rowCount)){
					needPage = true;
				}
			}
			if(needPage){
				this.needPage(this.page, this.pageTop);
			}
			var rowsOnPage = (this.page < this.pageCount - 1) ? this.rowsPerPage : ((this.rowCount % this.rowsPerPage) || this.rowsPerPage);
			var pageHeight = this.getPageHeight(this.page);
			this.averageRowHeight = (pageHeight > 0 && rowsOnPage > 0) ? (pageHeight / rowsOnPage) : 0;
		},
		calcLastPageHeight: function(){
			if(!this.pageCount){
				return 0;
			}
			var lastPage = this.pageCount - 1;
			var lastPageHeight = ((this.rowCount % this.rowsPerPage)||(this.rowsPerPage)) * this.defaultRowHeight;
			this.pageHeights[lastPage] = lastPageHeight;
			return lastPageHeight;
		},
		updateContentHeight: function(inDh){
			this.height += inDh;
			this.resize();
		},
		updatePageHeight: function(inPageIndex, fromBuild, fromAsynRendering){
			if(this.pageExists(inPageIndex)){
				var oh = this.getPageHeight(inPageIndex);
				var h = (this.measurePage(inPageIndex));
				if(h === undefined){
					h = oh;
				}
				this.pageHeights[inPageIndex] = h;
				if(oh != h){
					this.updateContentHeight(h - oh);
					var ah = this.grid.get("autoHeight");
					if((typeof ah == "number" && ah > this.rowCount)||(ah === true && !fromBuild)){
						if(!fromAsynRendering){
							this.grid.sizeChange();
						}else{//fix #11101 by using fromAsynRendering to avoid deadlock
							var ns = this.grid.viewsNode.style;
							ns.height = parseInt(ns.height) + h - oh + 'px';
							this.repositionPages(inPageIndex);
						}
					}else{
						this.repositionPages(inPageIndex);
					}
				}
				return h;
			}
			return 0;
		},
		rowHeightChanged: function(inRowIndex, fromAsynRendering){
			this.updatePageHeight(Math.floor(inRowIndex / this.rowsPerPage), false, fromAsynRendering);
		},
		// scroller core
		invalidateNodes: function(){
			while(this.stack.length){
				this.destroyPage(this.popPage());
			}
		},
		createPageNode: function(){
			var p = document.createElement('div');
			html.attr(p,"role","presentation");
			p.style.position = 'absolute';
			//p.style.width = '100%';
			p.style[this.grid.isLeftToRight() ? "left" : "right"] = '0';
			return p;
		},
		getPageHeight: function(inPageIndex){
			var ph = this.pageHeights[inPageIndex];
			return (ph !== undefined ? ph : this.defaultPageHeight);
		},
		// FIXME: this is not a stack, it's a FIFO list
		pushPage: function(inPageIndex){
			return this.stack.push(inPageIndex);
		},
		popPage: function(){
			return this.stack.shift();
		},
		findPage: function(inTop){
			var i = 0, h = 0;
			for(var ph = 0; i<this.pageCount; i++, h += ph){
				ph = this.getPageHeight(i);
				if(h + ph >= inTop){
					break;
				}
			}
			this.page = i;
			this.pageTop = h;
		},
		buildPage: function(inPageIndex, inReuseNode, inPos){
			this.preparePage(inPageIndex, inReuseNode);
			this.positionPage(inPageIndex, inPos);
			// order of operations is key below
			this.installPage(inPageIndex);
			this.renderPage(inPageIndex);
			// order of operations is key above
			this.pushPage(inPageIndex);
		},
		needPage: function(inPageIndex, inPos){
			var h = this.getPageHeight(inPageIndex), oh = h;
			if(!this.pageExists(inPageIndex)){
				this.buildPage(inPageIndex, (!this.grid._autoHeight/*fix #10543*/ && this.keepPages&&(this.stack.length >= this.keepPages)), inPos);
				h = this.updatePageHeight(inPageIndex, true);
			}else{
				this.positionPage(inPageIndex, inPos);
			}
			return h;
		},
		onscroll: function(){
			this.scroll(this.scrollboxNode.scrollTop);
		},
		scroll: function(inTop){
			this.grid.scrollTop = inTop;
			if(this.colCount){
				this.startPacify();
				this.findPage(inTop);
				var h = this.height;
				var b = this.getScrollBottom(inTop);
				for(var p=this.page, y=this.pageTop; (p<this.pageCount)&&((b<0)||(y<b)); p++){
					y += this.needPage(p, y);
				}
				this.firstVisibleRow = this.getFirstVisibleRow(this.page, this.pageTop, inTop);
				this.lastVisibleRow = this.getLastVisibleRow(p - 1, y, b);
				// indicates some page size has been updated
				if(h != this.height){
					this.repositionPages(p-1);
				}
				this.endPacify();
			}
		},
		getScrollBottom: function(inTop){
			return (this.windowHeight >= 0 ? inTop + this.windowHeight : -1);
		},
		// events
		processNodeEvent: function(e, inNode){
			var t = e.target;
			while(t && (t != inNode) && t.parentNode && (t.parentNode.parentNode != inNode)){
				t = t.parentNode;
			}
			if(!t || !t.parentNode || (t.parentNode.parentNode != inNode)){
				return false;
			}
			var page = t.parentNode;
			e.topRowIndex = page.pageIndex * this.rowsPerPage;
			e.rowIndex = e.topRowIndex + indexInParent(t);
			e.rowTarget = t;
			return true;
		},
		processEvent: function(e){
			return this.processNodeEvent(e, this.contentNode);
		},
		// virtual rendering interface
		renderRow: function(inRowIndex, inPageNode){
		},
		removeRow: function(inRowIndex){
		},
		// page node operations
		getDefaultPageNode: function(inPageIndex){
			return this.getDefaultNodes()[inPageIndex];
		},
		positionPageNode: function(inNode, inPos){
		},
		getPageNodePosition: function(inNode){
			return inNode.offsetTop;
		},
		invalidatePageNode: function(inPageIndex, inNodes){
			var p = inNodes[inPageIndex];
			if(p){
				delete inNodes[inPageIndex];
				this.removePage(inPageIndex, p);
				cleanNode(p);
				p.innerHTML = '';
			}
			return p;
		},
		// scroll control
		getPageRow: function(inPage){
			return inPage * this.rowsPerPage;
		},
		getLastPageRow: function(inPage){
			return Math.min(this.rowCount, this.getPageRow(inPage + 1)) - 1;
		},
		getFirstVisibleRow: function(inPage, inPageTop, inScrollTop){
			if(!this.pageExists(inPage)){
				return 0;
			}
			var row = this.getPageRow(inPage);
			var nodes = this.getDefaultNodes();
			var rows = divkids(nodes[inPage]);
			for(var i=0,l=rows.length; i<l && inPageTop<inScrollTop; i++, row++){
				inPageTop += rows[i].offsetHeight;
			}
			return (row ? row - 1 : row);
		},
		getLastVisibleRow: function(inPage, inBottom, inScrollBottom){
			if(!this.pageExists(inPage)){
				return 0;
			}
			var nodes = this.getDefaultNodes();
			var row = this.getLastPageRow(inPage);
			var rows = divkids(nodes[inPage]);
			for(var i=rows.length-1; i>=0 && inBottom>inScrollBottom; i--, row--){
				inBottom -= rows[i].offsetHeight;
			}
			return row + 1;
		},
		findTopRow: function(inScrollTop){
			var nodes = this.getDefaultNodes();
			var rows = divkids(nodes[this.page]);
			for(var i=0,l=rows.length,t=this.pageTop,h; i<l; i++){
				h = rows[i].offsetHeight;
				t += h;
				if(t >= inScrollTop){
					this.offset = h - (t - inScrollTop);
					return i + this.page * this.rowsPerPage;
				}
			}
			return -1;
		},
		findScrollTop: function(inRow){
			var rowPage = Math.floor(inRow / this.rowsPerPage);
			var t = 0;
			var i, l;
			for(i=0; i<rowPage; i++){
				t += this.getPageHeight(i);
			}
			this.pageTop = t;
			this.page = rowPage;//fix #10543
			this.needPage(rowPage, this.pageTop);

			var nodes = this.getDefaultNodes();
			var rows = divkids(nodes[rowPage]);
			var r = inRow - this.rowsPerPage * rowPage;
			for(i=0,l=rows.length; i<l && i<r; i++){
				t += rows[i].offsetHeight;
			}
			return t;
		},
		dummy: 0
	});
});

},
'dojox/grid/util':function(){
define([
	"../main",
	"dojo/_base/lang",
	"dojo/dom"
], function(dojox, lang, dom){

	var dgu = lang.getObject("grid.util", true, dojox);

/*=====
dgu = {
	// summary:
	//		grid utility library
};
=====*/

	dgu.na = '...';
	dgu.rowIndexTag = "gridRowIndex";
	dgu.gridViewTag = "gridView";


	dgu.fire = function(ob, ev, args){
		var fn = ob && ev && ob[ev];
		return fn && (args ? fn.apply(ob, args) : ob[ev]());
	};
	
	dgu.setStyleHeightPx = function(inElement, inHeight){
		if(inHeight >= 0){
			var s = inElement.style;
			var v = inHeight + 'px';
			if(inElement && s['height'] != v){
				s['height'] = v;
			}
		}
	};
	
	dgu.mouseEvents = [ 'mouseover', 'mouseout', /*'mousemove',*/ 'mousedown', 'mouseup', 'click', 'dblclick', 'contextmenu' ];

	dgu.keyEvents = [ 'keyup', 'keydown', 'keypress' ];

	dgu.funnelEvents = function(inNode, inObject, inMethod, inEvents){
		var evts = (inEvents ? inEvents : dgu.mouseEvents.concat(dgu.keyEvents));
		for (var i=0, l=evts.length; i<l; i++){
			inObject.connect(inNode, 'on' + evts[i], inMethod);
		}
	};

	dgu.removeNode = function(inNode){
		inNode = dom.byId(inNode);
		inNode && inNode.parentNode && inNode.parentNode.removeChild(inNode);
		return inNode;
	};
	
	dgu.arrayCompare = function(inA, inB){
		for(var i=0,l=inA.length; i<l; i++){
			if(inA[i] != inB[i]){return false;}
		}
		return (inA.length == inB.length);
	};
	
	dgu.arrayInsert = function(inArray, inIndex, inValue){
		if(inArray.length <= inIndex){
			inArray[inIndex] = inValue;
		}else{
			inArray.splice(inIndex, 0, inValue);
		}
	};
	
	dgu.arrayRemove = function(inArray, inIndex){
		inArray.splice(inIndex, 1);
	};
	
	dgu.arraySwap = function(inArray, inI, inJ){
		var cache = inArray[inI];
		inArray[inI] = inArray[inJ];
		inArray[inJ] = cache;
	};

	return dgu;

});
},
'dojox/grid/_Layout':function(){
define([
	"dojo/_base/kernel",
	"../main",
	"dojo/_base/declare",
	"dojo/_base/array",
	"dojo/_base/lang",
	"dojo/dom-geometry",
	"./cells",
	"./_RowSelector"
], function(dojo, dojox, declare, array, lang, domGeometry){

return declare("dojox.grid._Layout", null, {
	// summary:
	//	Controls grid cell layout. Owned by grid and used internally.
	constructor: function(inGrid){
		this.grid = inGrid;
	},
	// flat array of grid cells
	cells: [],
	// structured array of grid cells
	structure: null,
	// default cell width
	defaultWidth: '6em',

	// methods
	moveColumn: function(sourceViewIndex, destViewIndex, cellIndex, targetIndex, before){
		var source_cells = this.structure[sourceViewIndex].cells[0];
		var dest_cells = this.structure[destViewIndex].cells[0];

		var cell = null;
		var cell_ri = 0;
		var target_ri = 0;

		for(var i=0, c; c=source_cells[i]; i++){
			if(c.index == cellIndex){
				cell_ri = i;
				break;
			}
		}
		cell = source_cells.splice(cell_ri, 1)[0];
		cell.view = this.grid.views.views[destViewIndex];

		for(i=0, c=null; c=dest_cells[i]; i++){
			if(c.index == targetIndex){
				target_ri = i;
				break;
			}
		}
		if(!before){
			target_ri += 1;
		}
		dest_cells.splice(target_ri, 0, cell);

		var sortedCell = this.grid.getCell(this.grid.getSortIndex());
		if(sortedCell){
			sortedCell._currentlySorted = this.grid.getSortAsc();
		}

		this.cells = [];
		cellIndex = 0;
		var v;
		for(i=0; v=this.structure[i]; i++){
			for(var j=0, cs; cs=v.cells[j]; j++){
				for(var k=0; c=cs[k]; k++){
					c.index = cellIndex;
					this.cells.push(c);
					if("_currentlySorted" in c){
						var si = cellIndex + 1;
						si *= c._currentlySorted ? 1 : -1;
						this.grid.sortInfo = si;
						delete c._currentlySorted;
					}
					cellIndex++;
				}
			}
		}
		
		//Fix #9481 - reset idx in cell markup
		array.forEach(this.cells, function(c){
			var marks = c.markup[2].split(" ");
			var oldIdx = parseInt(marks[1].substring(5));//get old "idx"
			if(oldIdx != c.index){
				marks[1] = "idx=\"" + c.index + "\"";
				c.markup[2] = marks.join(" ");
			}
		});
		
		this.grid.setupHeaderMenu();
		//this.grid.renderOnIdle();
	},

	setColumnVisibility: function(columnIndex, visible){
		var cell = this.cells[columnIndex];
		if(cell.hidden == visible){
			cell.hidden = !visible;
			var v = cell.view, w = v.viewWidth;
			if(w && w != "auto"){
				v._togglingColumn = domGeometry.getMarginBox(cell.getHeaderNode()).w || 0;
			}
			v.update();
			return true;
		}else{
			return false;
		}
	},
	
	addCellDef: function(inRowIndex, inCellIndex, inDef){
		var self = this;
		var getCellWidth = function(inDef){
			var w = 0;
			if(inDef.colSpan > 1){
				w = 0;
			}else{
				w = inDef.width || self._defaultCellProps.width || self.defaultWidth;

				if(!isNaN(w)){
					w = w + "em";
				}
			}
			return w;
		};

		var props = {
			grid: this.grid,
			subrow: inRowIndex,
			layoutIndex: inCellIndex,
			index: this.cells.length
		};

		if(inDef && inDef instanceof dojox.grid.cells._Base){
			var new_cell = lang.clone(inDef);
			props.unitWidth = getCellWidth(new_cell._props);
			new_cell = lang.mixin(new_cell, this._defaultCellProps, inDef._props, props);
			return new_cell;
		}

		var cell_type = inDef.type || inDef.cellType || this._defaultCellProps.type || this._defaultCellProps.cellType || dojox.grid.cells.Cell;
		if(lang.isString(cell_type)){
			cell_type = lang.getObject(cell_type);
		}

		props.unitWidth = getCellWidth(inDef);
		return new cell_type(lang.mixin({}, this._defaultCellProps, inDef, props));
	},
	
	addRowDef: function(inRowIndex, inDef){
		var result = [];
		var relSum = 0, pctSum = 0, doRel = true;
		for(var i=0, def, cell; (def=inDef[i]); i++){
			cell = this.addCellDef(inRowIndex, i, def);
			result.push(cell);
			this.cells.push(cell);
			// Check and calculate the sum of all relative widths
			if(doRel && cell.relWidth){
				relSum += cell.relWidth;
			}else if(cell.width){
				var w = cell.width;
				if(typeof w == "string" && w.slice(-1) == "%"){
					pctSum += window.parseInt(w, 10);
				}else if(w == "auto"){
					// relative widths doesn't play nice with auto - since we
					// don't have a way of knowing how much space the auto is
					// supposed to take up.
					doRel = false;
				}
			}
		}
		if(relSum && doRel){
			// We have some kind of relWidths specified - so change them to %
			array.forEach(result, function(cell){
				if(cell.relWidth){
					cell.width = cell.unitWidth = ((cell.relWidth / relSum) * (100 - pctSum)) + "%";
				}
			});
		}
		return result;
	
	},

	addRowsDef: function(inDef){
		var result = [];
		if(lang.isArray(inDef)){
			if(lang.isArray(inDef[0])){
				for(var i=0, row; inDef && (row=inDef[i]); i++){
					result.push(this.addRowDef(i, row));
				}
			}else{
				result.push(this.addRowDef(0, inDef));
			}
		}
		return result;
	},
	
	addViewDef: function(inDef){
		this._defaultCellProps = inDef.defaultCell || {};
		if(inDef.width && inDef.width == "auto"){
			delete inDef.width;
		}
		return lang.mixin({}, inDef, {cells: this.addRowsDef(inDef.rows || inDef.cells)});
	},
	
	setStructure: function(inStructure){
		this.fieldIndex = 0;
		this.cells = [];
		var s = this.structure = [];

		if(this.grid.rowSelector){
			var sel = { type: dojox._scopeName + ".grid._RowSelector" };

			if(lang.isString(this.grid.rowSelector)){
				var width = this.grid.rowSelector;

				if(width == "false"){
					sel = null;
				}else if(width != "true"){
					sel['width'] = width;
				}
			}else{
				if(!this.grid.rowSelector){
					sel = null;
				}
			}

			if(sel){
				s.push(this.addViewDef(sel));
			}
		}

		var isCell = function(def){
			return ("name" in def || "field" in def || "get" in def);
		};

		var isRowDef = function(def){
			if(lang.isArray(def)){
				if(lang.isArray(def[0]) || isCell(def[0])){
					return true;
				}
			}
			return false;
		};

		var isView = function(def){
			return (def !== null && lang.isObject(def) &&
					("cells" in def || "rows" in def || ("type" in def && !isCell(def))));
		};

		if(lang.isArray(inStructure)){
			var hasViews = false;
			for(var i=0, st; (st=inStructure[i]); i++){
				if(isView(st)){
					hasViews = true;
					break;
				}
			}
			if(!hasViews){
				s.push(this.addViewDef({ cells: inStructure }));
			}else{
				for(i=0; (st=inStructure[i]); i++){
					if(isRowDef(st)){
						s.push(this.addViewDef({ cells: st }));
					}else if(isView(st)){
						s.push(this.addViewDef(st));
					}
				}
			}
		}else if(isView(inStructure)){
			// it's a view object
			s.push(this.addViewDef(inStructure));
		}

		this.cellCount = this.cells.length;
		this.grid.setupHeaderMenu();
	}
});
});
},
'dojox/grid/cells':function(){
define(["../main", "./cells/_base"], function(dojox){
	return dojox.grid.cells;
});
},
'dojox/grid/cells/_base':function(){
define([
	"dojo/_base/kernel",
	"dojo/_base/declare",
	"dojo/_base/lang",
	"dojo/_base/event",
	"dojo/_base/connect",
	"dojo/_base/array",
	"dojo/_base/sniff",
	"dojo/dom",
	"dojo/dom-attr",
	"dojo/dom-construct",
	"dijit/_Widget",
	"../util"
], function(dojo, declare, lang, event, connect, array, has, dom, domAttr, domConstruct, _Widget, util){

	var _DeferredTextWidget = declare("dojox.grid._DeferredTextWidget", _Widget, {
		deferred: null,
		_destroyOnRemove: true,
		postCreate: function(){
			if(this.deferred){
				this.deferred.addBoth(lang.hitch(this, function(text){
					if(this.domNode){
						this.domNode.innerHTML = text;
					}
				}));
			}
		}
	});

	var focusSelectNode = function(inNode){
		try{
			util.fire(inNode, "focus");
			util.fire(inNode, "select");
		}catch(e){// IE sux bad
		}
	};
	
	var whenIdle = function(/*inContext, inMethod, args ...*/){
		setTimeout(lang.hitch.apply(dojo, arguments), 0);
	};

	var BaseCell = declare("dojox.grid.cells._Base", null, {
		// summary:
		//		Represents a grid cell and contains information about column options and methods
		//		for retrieving cell related information.
		//		Each column in a grid layout has a cell object and most events and many methods
		//		provide access to these objects.
		styles: '',
		classes: '',
		editable: false,
		alwaysEditing: false,
		formatter: null,
		defaultValue: '...',
		value: null,
		hidden: false,
		noresize: false,
		draggable: true,
		//private
		_valueProp: "value",
		_formatPending: false,

		constructor: function(inProps){
			this._props = inProps || {};
			lang.mixin(this, inProps);
			if(this.draggable === undefined){
				this.draggable = true;
			}
		},

		_defaultFormat: function(inValue, callArgs){
			var s = this.grid.formatterScope || this;
			var f = this.formatter;
			if(f && s && typeof f == "string"){
				f = this.formatter = s[f];
			}
			var v = (inValue != this.defaultValue && f) ? f.apply(s, callArgs) : inValue;
			if(typeof v == "undefined"){
				return this.defaultValue;
			}
			if(v && v.addBoth){
				// Check if it's a deferred
				v = new _DeferredTextWidget({deferred: v},
									domConstruct.create("span", {innerHTML: this.defaultValue}));
			}
			if(v && v.declaredClass && v.startup){
				return "<div class='dojoxGridStubNode' linkWidget='" +
						v.id +
						"' cellIdx='" +
						this.index +
						"'>" +
						this.defaultValue +
						"</div>";
			}
			return v;
		},
		
		// data source
		format: function(inRowIndex, inItem){
			// summary:
			//		provides the html for a given grid cell.
			// inRowIndex: int
			//		grid row index
			// returns:
			//		html for a given grid cell
			var f, i=this.grid.edit.info, d=this.get ? this.get(inRowIndex, inItem) : (this.value || this.defaultValue);
			d = (d && d.replace && this.grid.escapeHTMLInData) ? d.replace(/&/g, '&amp;').replace(/</g, '&lt;') : d;
			if(this.editable && (this.alwaysEditing || (i.rowIndex==inRowIndex && i.cell==this))){
				return this.formatEditing(i.value ? i.value : d, inRowIndex);
			}else{
				return this._defaultFormat(d, [d, inRowIndex, this]);
			}
		},
		formatEditing: function(inDatum, inRowIndex){
			// summary:
			//		formats the cell for editing
			// inDatum: anything
			//		cell data to edit
			// inRowIndex: int
			//		grid row index
			// returns:
			//		string of html to place in grid cell
		},
		// utility
		getNode: function(inRowIndex){
			// summary:
			//		gets the dom node for a given grid cell.
			// inRowIndex: int
			//		grid row index
			// returns:
			//		dom node for a given grid cell
			return this.view.getCellNode(inRowIndex, this.index);
		},
		getHeaderNode: function(){
			return this.view.getHeaderCellNode(this.index);
		},
		getEditNode: function(inRowIndex){
			return (this.getNode(inRowIndex) || 0).firstChild || 0;
		},
		canResize: function(){
			var uw = this.unitWidth;
			return uw && (uw!=='auto');
		},
		isFlex: function(){
			var uw = this.unitWidth;
			return uw && lang.isString(uw) && (uw=='auto' || uw.slice(-1)=='%');
		},
		// edit support
		applyEdit: function(inValue, inRowIndex){
			if(this.getNode(inRowIndex)){
				this.grid.edit.applyCellEdit(inValue, this, inRowIndex);
			}
		},
		cancelEdit: function(inRowIndex){
			this.grid.doCancelEdit(inRowIndex);
		},
		_onEditBlur: function(inRowIndex){
			if(this.grid.edit.isEditCell(inRowIndex, this.index)){
				//console.log('editor onblur', e);
				this.grid.edit.apply();
			}
		},
		registerOnBlur: function(inNode, inRowIndex){
			if(this.commitOnBlur){
				connect.connect(inNode, "onblur", function(e){
					// hack: if editor still thinks this editor is current some ms after it blurs, assume we've focused away from grid
					setTimeout(lang.hitch(this, "_onEditBlur", inRowIndex), 250);
				});
			}
		},
		//protected
		needFormatNode: function(inDatum, inRowIndex){
			this._formatPending = true;
			whenIdle(this, "_formatNode", inDatum, inRowIndex);
		},
		cancelFormatNode: function(){
			this._formatPending = false;
		},
		//private
		_formatNode: function(inDatum, inRowIndex){
			if(this._formatPending){
				this._formatPending = false;
				// make cell selectable
				if(!has('ie')){
					dom.setSelectable(this.grid.domNode, true);
				}
				this.formatNode(this.getEditNode(inRowIndex), inDatum, inRowIndex);
			}
		},
		//protected
		formatNode: function(inNode, inDatum, inRowIndex){
			// summary:
			//		format the editing dom node. Use when editor is a widget.
			// inNode: dom node
			//		dom node for the editor
			// inDatum: anything
			//		cell data to edit
			// inRowIndex: int
			//		grid row index
			if(has('ie')){
				// IE sux bad
				whenIdle(this, "focus", inRowIndex, inNode);
			}else{
				this.focus(inRowIndex, inNode);
			}
		},
		dispatchEvent: function(m, e){
			if(m in this){
				return this[m](e);
			}
		},
		//public
		getValue: function(inRowIndex){
			// summary:
			//		returns value entered into editor
			// inRowIndex: int
			//		grid row index
			// returns:
			//		value of editor
			return this.getEditNode(inRowIndex)[this._valueProp];
		},
		setValue: function(inRowIndex, inValue){
			// summary:
			//		set the value of the grid editor
			// inRowIndex: int
			//		grid row index
			// inValue: anything
			//		value of editor
			var n = this.getEditNode(inRowIndex);
			if(n){
				n[this._valueProp] = inValue;
			}
		},
		focus: function(inRowIndex, inNode){
			// summary:
			//		focus the grid editor
			// inRowIndex: int
			//		grid row index
			// inNode: dom node
			//		editor node
			focusSelectNode(inNode || this.getEditNode(inRowIndex));
		},
		save: function(inRowIndex){
			// summary:
			//		save editor state
			// inRowIndex: int
			//		grid row index
			this.value = this.value || this.getValue(inRowIndex);
			//console.log("save", this.value, inCell.index, inRowIndex);
		},
		restore: function(inRowIndex){
			// summary:
			//		restore editor state
			// inRowIndex: int
			//		grid row index
			this.setValue(inRowIndex, this.value);
			//console.log("restore", this.value, inCell.index, inRowIndex);
		},
		//protected
		_finish: function(inRowIndex){
			// summary:
			//		called when editing is completed to clean up editor
			// inRowIndex: int
			//		grid row index
			dom.setSelectable(this.grid.domNode, false);
			this.cancelFormatNode();
		},
		//public
		apply: function(inRowIndex){
			// summary:
			//		apply edit from cell editor
			// inRowIndex: int
			//		grid row index
			this.applyEdit(this.getValue(inRowIndex), inRowIndex);
			this._finish(inRowIndex);
		},
		cancel: function(inRowIndex){
			// summary:
			//		cancel cell edit
			// inRowIndex: int
			//		grid row index
			this.cancelEdit(inRowIndex);
			this._finish(inRowIndex);
		}
	});
	BaseCell.markupFactory = function(node, cellDef){
		var formatter = lang.trim(domAttr.get(node, "formatter")||"");
		if(formatter){
			cellDef.formatter = lang.getObject(formatter)||formatter;
		}
		var get = lang.trim(domAttr.get(node, "get")||"");
		if(get){
			cellDef.get = lang.getObject(get);
		}
		var getBoolAttr = function(attr, cell, cellAttr){
			var value = lang.trim(domAttr.get(node, attr)||"");
			if(value){ cell[cellAttr||attr] = !(value.toLowerCase()=="false"); }
		};
		getBoolAttr("sortDesc", cellDef);
		getBoolAttr("editable", cellDef);
		getBoolAttr("alwaysEditing", cellDef);
		getBoolAttr("noresize", cellDef);
		getBoolAttr("draggable", cellDef);

		var value = lang.trim(domAttr.get(node, "loadingText")||domAttr.get(node, "defaultValue")||"");
		if(value){
			cellDef.defaultValue = value;
		}

		var getStrAttr = function(attr, cell, cellAttr){
			var value = lang.trim(domAttr.get(node, attr)||"")||undefined;
			if(value){ cell[cellAttr||attr] = value; }
		};
		getStrAttr("styles", cellDef);
		getStrAttr("headerStyles", cellDef);
		getStrAttr("cellStyles", cellDef);
		getStrAttr("classes", cellDef);
		getStrAttr("headerClasses", cellDef);
		getStrAttr("cellClasses", cellDef);
	};

	var Cell = BaseCell.Cell = declare("dojox.grid.cells.Cell", BaseCell, {
		// summary:
		//		grid cell that provides a standard text input box upon editing
		constructor: function(){
			this.keyFilter = this.keyFilter;
		},
		// keyFilter: RegExp
		//		optional regex for disallowing keypresses
		keyFilter: null,
		formatEditing: function(inDatum, inRowIndex){
			this.needFormatNode(inDatum, inRowIndex);
			return '<input class="dojoxGridInput" type="text" value="' + inDatum + '">';
		},
		formatNode: function(inNode, inDatum, inRowIndex){
			this.inherited(arguments);
			// FIXME: feels too specific for this interface
			this.registerOnBlur(inNode, inRowIndex);
		},
		doKey: function(e){
			if(this.keyFilter){
				var key = String.fromCharCode(e.charCode);
				if(key.search(this.keyFilter) == -1){
					event.stop(e);
				}
			}
		},
		_finish: function(inRowIndex){
			this.inherited(arguments);
			var n = this.getEditNode(inRowIndex);
			try{
				util.fire(n, "blur");
			}catch(e){}
		}
	});
	Cell.markupFactory = function(node, cellDef){
		BaseCell.markupFactory(node, cellDef);
		var keyFilter = lang.trim(domAttr.get(node, "keyFilter")||"");
		if(keyFilter){
			cellDef.keyFilter = new RegExp(keyFilter);
		}
	};

	var RowIndex = BaseCell.RowIndex = declare("dojox.grid.cells.RowIndex", Cell, {
		name: 'Row',

		postscript: function(){
			this.editable = false;
		},
		get: function(inRowIndex){
			return inRowIndex + 1;
		}
	});
	RowIndex.markupFactory = function(node, cellDef){
		Cell.markupFactory(node, cellDef);
	};

	var Select = BaseCell.Select = declare("dojox.grid.cells.Select", Cell, {
		// summary:
		//		grid cell that provides a standard select for editing

		// options: Array
		//		text of each item
		options: null,

		// values: Array
		//		value for each item
		values: null,

		// returnIndex: Integer
		//		editor returns only the index of the selected option and not the value
		returnIndex: -1,

		constructor: function(inCell){
			this.values = this.values || this.options;
		},
		formatEditing: function(inDatum, inRowIndex){
			this.needFormatNode(inDatum, inRowIndex);
			var h = [ '<select class="dojoxGridSelect">' ];
			for (var i=0, o, v; ((o=this.options[i]) !== undefined)&&((v=this.values[i]) !== undefined); i++){
				v = v.replace ? v.replace(/&/g, '&amp;').replace(/</g, '&lt;') : v;
				o = o.replace ? o.replace(/&/g, '&amp;').replace(/</g, '&lt;') : o;
				h.push("<option", (inDatum==v ? ' selected' : ''), ' value="' + v + '"', ">", o, "</option>");
			}
			h.push('</select>');
			return h.join('');
		},
		_defaultFormat: function(inValue, callArgs){
			var v = this.inherited(arguments);
			// when 'values' and 'options' both provided and there is no cutomized formatter,
			// then we use 'options' as label in order to be consistent
			if(!this.formatter && this.values && this.options){
				var i = array.indexOf(this.values, v);
				if(i >= 0){
					v = this.options[i];
				}
			}
			return v;
		},
		getValue: function(inRowIndex){
			var n = this.getEditNode(inRowIndex);
			if(n){
				var i = n.selectedIndex, o = n.options[i];
				return this.returnIndex > -1 ? i : o.value || o.innerHTML;
			}
		}
	});
	Select.markupFactory = function(node, cell){
		Cell.markupFactory(node, cell);
		var options = lang.trim(domAttr.get(node, "options")||"");
		if(options){
			var o = options.split(',');
			if(o[0] != options){
				cell.options = o;
			}
		}
		var values = lang.trim(domAttr.get(node, "values")||"");
		if(values){
			var v = values.split(',');
			if(v[0] != values){
				cell.values = v;
			}
		}
	};

	var AlwaysEdit = BaseCell.AlwaysEdit = declare("dojox.grid.cells.AlwaysEdit", Cell, {
		// summary:
		//		grid cell that is always in an editable state, regardless of grid editing state
		alwaysEditing: true,
		_formatNode: function(inDatum, inRowIndex){
			this.formatNode(this.getEditNode(inRowIndex), inDatum, inRowIndex);
		},
		applyStaticValue: function(inRowIndex){
			var e = this.grid.edit;
			e.applyCellEdit(this.getValue(inRowIndex), this, inRowIndex);
			e.start(this, inRowIndex, true);
		}
	});
	AlwaysEdit.markupFactory = function(node, cell){
		Cell.markupFactory(node, cell);
	};

	var Bool = BaseCell.Bool = declare("dojox.grid.cells.Bool", AlwaysEdit, {
		// summary:
		//		grid cell that provides a standard checkbox that is always on for editing
		_valueProp: "checked",
		formatEditing: function(inDatum, inRowIndex){
			return '<input class="dojoxGridInput" type="checkbox"' + (inDatum ? ' checked="checked"' : '') + ' style="width: auto" />';
		},
		doclick: function(e){
			if(e.target.tagName == 'INPUT'){
				this.applyStaticValue(e.rowIndex);
			}
		}
	});
	Bool.markupFactory = function(node, cell){
		AlwaysEdit.markupFactory(node, cell);
	};

	return BaseCell;

});
},
'dojox/grid/_RowSelector':function(){
define([
	"dojo/_base/declare",
	"./_View"
], function(declare, _View){

return declare('dojox.grid._RowSelector', _View, {
	// summary:
	//	Custom grid view. If used in a grid structure, provides a small selectable region for grid rows.
	defaultWidth: "2em",
	noscroll: true,
	padBorderWidth: 2,
	buildRendering: function(){
		this.inherited('buildRendering', arguments);
		this.scrollboxNode.style.overflow = "hidden";
		this.headerNode.style.visibility = "hidden";
	},
	getWidth: function(){
		return this.viewWidth || this.defaultWidth;
	},
	buildRowContent: function(inRowIndex, inRowNode){
		var w = this.contentWidth || 0;
		inRowNode.innerHTML = '<table class="dojoxGridRowbarTable" style="width:' + w + 'px;height:1px;" border="0" cellspacing="0" cellpadding="0" role="presentation"><tr><td class="dojoxGridRowbarInner">&nbsp;</td></tr></table>';
	},
	renderHeader: function(){
	},
	updateRow: function(){
	},
	resize: function(){
		this.adaptHeight();
	},
	adaptWidth: function(){
		// Only calculate this here - rather than every call to buildRowContent
		if(!("contentWidth" in this) && this.contentNode && this.contentNode.offsetWidth > 0){
			this.contentWidth = this.contentNode.offsetWidth - this.padBorderWidth;
		}
	},
	// styling
	doStyleRowNode: function(inRowIndex, inRowNode){
		var n = [ "dojoxGridRowbar dojoxGridNonNormalizedCell" ];
		if(this.grid.rows.isOver(inRowIndex)){
			n.push("dojoxGridRowbarOver");
		}
		if(this.grid.selection.isSelected(inRowIndex)){
			n.push("dojoxGridRowbarSelected");
		}
		inRowNode.className = n.join(" ");
	},
	// event handlers
	domouseover: function(e){
		this.grid.onMouseOverRow(e);
	},
	domouseout: function(e){
		if(!this.isIntraRowEvent(e)){
			this.grid.onMouseOutRow(e);
		}
	}
});
});
},
'dojox/grid/_View':function(){
define([
	"dojo",
	"dijit/registry",
	"../main",
	"dojo/_base/declare",
	"dojo/_base/array",
	"dojo/_base/lang",
	"dojo/_base/connect",
	"dojo/_base/sniff",
	"dojo/query",
	"dojo/_base/window",
	"dojo/text!./resources/View.html",
	"dojo/dnd/Source",
	"dijit/_Widget",
	"dijit/_TemplatedMixin",
	"dojox/html/metrics",
	"./util",
	"dojo/_base/html",
	"./_Builder",
	"dojo/dnd/Avatar",
	"dojo/dnd/Manager"
], function(dojo, dijit, dojox, declare, array, lang, connect, has, query,
	win, template, Source, _Widget, _TemplatedMixin, metrics, util, html, _Builder, Avatar, Manager){

	// a private function
	var getStyleText = function(inNode, inStyleText){
		return inNode.style.cssText == undefined ? inNode.getAttribute("style") : inNode.style.cssText;
	};

	// some public functions
	var _View = declare('dojox.grid._View', [_Widget, _TemplatedMixin], {
		// summary:
		//		A collection of grid columns. A grid is comprised of a set of views that stack horizontally.
		//		Grid creates views automatically based on grid's layout structure.
		//		Users should typically not need to access individual views directly.
		//
		// defaultWidth: String
		//		Default width of the view
		defaultWidth: "18em",

		// viewWidth: String
		//		Width for the view, in valid css unit
		viewWidth: "",

		templateString: template,

		classTag: 'dojoxGrid',
		marginBottom: 0,
		rowPad: 2,

		// _togglingColumn: int
		//		Width of the column being toggled (-1 for none)
		_togglingColumn: -1,
		
		// _headerBuilderClass: Object
		//		The class to use for our header builder
		_headerBuilderClass: _Builder._HeaderBuilder,
		
		// _contentBuilderClass: Object
		//		The class to use for our content builder
		_contentBuilderClass: _Builder._ContentBuilder,
		
		postMixInProperties: function(){
			this.rowNodes = {};
		},

		postCreate: function(){
			this.connect(this.scrollboxNode,"onscroll","doscroll");
			util.funnelEvents(this.contentNode, this, "doContentEvent", [ 'mouseover', 'mouseout', 'click', 'dblclick', 'contextmenu', 'mousedown' ]);
			util.funnelEvents(this.headerNode, this, "doHeaderEvent", [ 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'click', 'contextmenu' ]);
			this.content = new this._contentBuilderClass(this);
			this.header = new this._headerBuilderClass(this);
			//BiDi: in RTL case, style width='9000em' causes scrolling problem in head node
			if(!this.grid.isLeftToRight()){
				this.headerNodeContainer.style.width = "";
			}
		},

		destroy: function(){
			html.destroy(this.headerNode);
			delete this.headerNode;
			for(var i in this.rowNodes){
				this._cleanupRowWidgets(this.rowNodes[i]);
				html.destroy(this.rowNodes[i]);
			}
			this.rowNodes = {};
			if(this.source){
				this.source.destroy();
			}
			this.inherited(arguments);
		},

		// focus
		focus: function(){
			if(has('ie') || has('webkit') || has('opera')){
				this.hiddenFocusNode.focus();
			}else{
				this.scrollboxNode.focus();
			}
		},

		setStructure: function(inStructure){
			var vs = (this.structure = inStructure);
			// FIXME: similar logic is duplicated in layout
			if(vs.width && !isNaN(vs.width)){
				this.viewWidth = vs.width + 'em';
			}else{
				this.viewWidth = vs.width || (vs.noscroll ? 'auto' : this.viewWidth); //|| this.defaultWidth;
			}
			this._onBeforeRow = vs.onBeforeRow||function(){};
			this._onAfterRow = vs.onAfterRow||function(){};
			this.noscroll = vs.noscroll;
			if(this.noscroll){
				this.scrollboxNode.style.overflow = "hidden";
			}
			this.simpleStructure = Boolean(vs.cells.length == 1);
			// bookkeeping
			this.testFlexCells();
			// accommodate new structure
			this.updateStructure();
		},
		
		_cleanupRowWidgets: function(inRowNode){
			// Summary:
			//		Cleans up the widgets for the given row node so that
			//		we can reattach them if needed
			if(inRowNode){
				array.forEach(query("[widgetId]", inRowNode).map(dijit.byNode), function(w){
					if(w._destroyOnRemove){
						w.destroy();
						delete w;
					}else if(w.domNode && w.domNode.parentNode){
						w.domNode.parentNode.removeChild(w.domNode);
					}
				});
			}
		},
		
		onBeforeRow: function(inRowIndex, cells){
			this._onBeforeRow(inRowIndex, cells);
			if(inRowIndex >= 0){
				this._cleanupRowWidgets(this.getRowNode(inRowIndex));
			}
		},
		
		onAfterRow: function(inRowIndex, cells, inRowNode){
			this._onAfterRow(inRowIndex, cells, inRowNode);
			var g = this.grid;
			array.forEach(query(".dojoxGridStubNode", inRowNode), function(n){
				if(n && n.parentNode){
					var lw = n.getAttribute("linkWidget");
					var cellIdx = window.parseInt(html.attr(n, "cellIdx"), 10);
					var cellDef = g.getCell(cellIdx);
					var w = dijit.byId(lw);
					if(w){
						n.parentNode.replaceChild(w.domNode, n);
						if(!w._started){
							w.startup();
						}
						dojo.destroy(n);
					}else{
						n.innerHTML = "";
					}
				}
			}, this);
		},

		testFlexCells: function(){
			// FIXME: cheater, this function does double duty as initializer and tester
			this.flexCells = false;
			for(var j=0, row; (row=this.structure.cells[j]); j++){
				for(var i=0, cell; (cell=row[i]); i++){
					cell.view = this;
					this.flexCells = this.flexCells || cell.isFlex();
				}
			}
			return this.flexCells;
		},

		updateStructure: function(){
			// header builder needs to update table map
			this.header.update();
			// content builder needs to update markup cache
			this.content.update();
		},

		getScrollbarWidth: function(){
			var hasScrollSpace = this.hasVScrollbar();
			var overflow = html.style(this.scrollboxNode, "overflow");
			if(this.noscroll || !overflow || overflow == "hidden"){
				hasScrollSpace = false;
			}else if(overflow == "scroll"){
				hasScrollSpace = true;
			}
			return (hasScrollSpace ? metrics.getScrollbar().w : 0); // Integer
		},

		getColumnsWidth: function(){
			var h = this.headerContentNode;
			return h && h.firstChild ? (h.firstChild.offsetWidth || html.style(h.firstChild, 'width')) : 0; // Integer
		},

		setColumnsWidth: function(width){
			this.headerContentNode.firstChild.style.width = width + 'px';
			if(this.viewWidth){
				this.viewWidth = width + 'px';
			}
		},

		getWidth: function(){
			return this.viewWidth || (this.getColumnsWidth()+this.getScrollbarWidth()) +'px'; // String
		},

		getContentWidth: function(){
			return Math.max(0, html._getContentBox(this.domNode).w - this.getScrollbarWidth()) + 'px'; // String
		},

		render: function(){
			this.scrollboxNode.style.height = '';
			this.renderHeader();
			if(this._togglingColumn >= 0){
				this.setColumnsWidth(this.getColumnsWidth() - this._togglingColumn);
				this._togglingColumn = -1;
			}
			var cells = this.grid.layout.cells;
			var getSibling = lang.hitch(this, function(node, before){
				!this.grid.isLeftToRight() && (before = !before);
				var inc = before?-1:1;
				var idx = this.header.getCellNodeIndex(node) + inc;
				var cell = cells[idx];
				while(cell && cell.getHeaderNode() && cell.getHeaderNode().style.display == "none"){
					idx += inc;
					cell = cells[idx];
				}
				if(cell){
					return cell.getHeaderNode();
				}
				return null;
			});
			if(this.grid.columnReordering && this.simpleStructure){
				if(this.source){
					this.source.destroy();
				}
				
				// Create the top and bottom markers
				var bottomMarkerId = "dojoxGrid_bottomMarker";
				var topMarkerId = "dojoxGrid_topMarker";
				if(this.bottomMarker){
					html.destroy(this.bottomMarker);
				}
				this.bottomMarker = html.byId(bottomMarkerId);
				if(this.topMarker){
					html.destroy(this.topMarker);
				}
				this.topMarker = html.byId(topMarkerId);
				if (!this.bottomMarker) {
					this.bottomMarker = html.create("div", {
						"id": bottomMarkerId,
						"class": "dojoxGridColPlaceBottom"
					}, win.body());
					this._hide(this.bottomMarker);

					
					this.topMarker = html.create("div", {
						"id": topMarkerId,
						"class": "dojoxGridColPlaceTop"
					}, win.body());
					this._hide(this.topMarker);
				}
				this.arrowDim = html.contentBox(this.bottomMarker);

				var headerHeight = html.contentBox(this.headerContentNode.firstChild.rows[0]).h;
				
				this.source = new Source(this.headerContentNode.firstChild.rows[0], {
					horizontal: true,
					accept: [ "gridColumn_" + this.grid.id ],
					viewIndex: this.index,
					generateText: false,
					onMouseDown: lang.hitch(this, function(e){
						this.header.decorateEvent(e);
						if((this.header.overRightResizeArea(e) || this.header.overLeftResizeArea(e)) &&
							this.header.canResize(e) && !this.header.moveable){
							this.header.beginColumnResize(e);
						}else{
							if(this.grid.headerMenu){
								this.grid.headerMenu.onCancel(true);
							}
							// IE reports a left click as 1, where everything else reports 0
							if(e.button === (has('ie') < 9 ? 1 : 0)){
								Source.prototype.onMouseDown.call(this.source, e);
							}
						}
					}),
					onMouseOver: lang.hitch(this, function(e){
						var src = this.source;
						if(src._getChildByEvent(e)){
							Source.prototype.onMouseOver.apply(src, arguments);
						}
					}),
					_markTargetAnchor: lang.hitch(this, function(before){
						var src = this.source;
						if(src.current == src.targetAnchor && src.before == before){ return; }
						if(src.targetAnchor && getSibling(src.targetAnchor, src.before)){
							src._removeItemClass(getSibling(src.targetAnchor, src.before), src.before ? "After" : "Before");
						}
						Source.prototype._markTargetAnchor.call(src, before);
						
						var target = before ? src.targetAnchor : getSibling(src.targetAnchor, src.before);
						var endAdd = 0;

						if (!target) {
							target = src.targetAnchor;
							endAdd = html.contentBox(target).w + this.arrowDim.w/2 + 2;
						}

						var pos = html.position(target, true);
						var left = Math.floor(pos.x - this.arrowDim.w/2 + endAdd);

						html.style(this.bottomMarker, "visibility", "visible");
						html.style(this.topMarker, "visibility", "visible");
						html.style(this.bottomMarker, {
							"left": left + "px",
							"top" : (headerHeight + pos.y) + "px"
						});

						html.style(this.topMarker, {
							"left": left + "px",
							"top" : (pos.y - this.arrowDim.h) + "px"
						});

						if(src.targetAnchor && getSibling(src.targetAnchor, src.before)){
							src._addItemClass(getSibling(src.targetAnchor, src.before), src.before ? "After" : "Before");
						}
					}),
					_unmarkTargetAnchor: lang.hitch(this, function(){
						var src = this.source;
						if(!src.targetAnchor){ return; }
						if(src.targetAnchor && getSibling(src.targetAnchor, src.before)){
							src._removeItemClass(getSibling(src.targetAnchor, src.before), src.before ? "After" : "Before");
						}
						this._hide(this.bottomMarker);
						this._hide(this.topMarker);
						Source.prototype._unmarkTargetAnchor.call(src);
					}),
					destroy: lang.hitch(this, function(){
						connect.disconnect(this._source_conn);
						connect.unsubscribe(this._source_sub);
						Source.prototype.destroy.call(this.source);
						if(this.bottomMarker){
							html.destroy(this.bottomMarker);
							delete this.bottomMarker;
						}
						if(this.topMarker){
							html.destroy(this.topMarker);
							delete this.topMarker;
						}
					}),
					onDndCancel: lang.hitch(this, function(){
						Source.prototype.onDndCancel.call(this.source);
						this._hide(this.bottomMarker);
						this._hide(this.topMarker);
					})
				});

				this._source_conn = connect.connect(this.source, "onDndDrop", this, "_onDndDrop");
				this._source_sub = connect.subscribe("/dnd/drop/before", this, "_onDndDropBefore");
				this.source.startup();
			}
		},
		
		_hide: function(node){
			html.style(node, {
				top: "-10000px",
				"visibility": "hidden"
			});
		},

		_onDndDropBefore: function(source, nodes, copy){
			if(Manager.manager().target !== this.source){
				return;
			}
			this.source._targetNode = this.source.targetAnchor;
			this.source._beforeTarget = this.source.before;
			var views = this.grid.views.views;
			var srcView = views[source.viewIndex];
			var tgtView = views[this.index];
			if(tgtView != srcView){
				srcView.convertColPctToFixed();
				tgtView.convertColPctToFixed();
			}
		},

		_onDndDrop: function(source, nodes, copy){
			if(Manager.manager().target !== this.source){
				if(Manager.manager().source === this.source){
					this._removingColumn = true;
				}
				return;
			}
			this._hide(this.bottomMarker);
			this._hide(this.topMarker);

			var getIdx = function(n){
				return n ? html.attr(n, "idx") : null;
			};
			var w = html.marginBox(nodes[0]).w;
			if(source.viewIndex !== this.index){
				var views = this.grid.views.views;
				var srcView = views[source.viewIndex];
				var tgtView = views[this.index];
				if(srcView.viewWidth && srcView.viewWidth != "auto"){
					srcView.setColumnsWidth(srcView.getColumnsWidth() - w);
				}
				if(tgtView.viewWidth && tgtView.viewWidth != "auto"){
					tgtView.setColumnsWidth(tgtView.getColumnsWidth());
				}
			}
			var stn = this.source._targetNode;
			var stb = this.source._beforeTarget;
			!this.grid.isLeftToRight() && (stb = !stb);
			var layout = this.grid.layout;
			var idx = this.index;
			delete this.source._targetNode;
			delete this.source._beforeTarget;
			
			layout.moveColumn(
				source.viewIndex,
				idx,
				getIdx(nodes[0]),
				getIdx(stn),
				stb);
		},

		renderHeader: function(){
			this.headerContentNode.innerHTML = this.header.generateHtml(this._getHeaderContent);
			if(this.flexCells){
				this.contentWidth = this.getContentWidth();
				this.headerContentNode.firstChild.style.width = this.contentWidth;
			}
			util.fire(this, "onAfterRow", [-1, this.structure.cells, this.headerContentNode]);
		},

		// note: not called in 'view' context
		_getHeaderContent: function(inCell){
			var n = inCell.name || inCell.grid.getCellName(inCell);
			if(/^\s+$/.test(n)){
				n = '&nbsp;'//otherwise arrow styles will be messed up
			}
			var ret = [ '<div class="dojoxGridSortNode' ];
			
			if(inCell.index != inCell.grid.getSortIndex()){
				ret.push('">');
			}else{
				ret = ret.concat([ ' ',
							inCell.grid.sortInfo > 0 ? 'dojoxGridSortUp' : 'dojoxGridSortDown',
							'"><div class="dojoxGridArrowButtonChar">',
							inCell.grid.sortInfo > 0 ? '&#9650;' : '&#9660;',
							'</div><div class="dojoxGridArrowButtonNode" role="presentation"></div>',
							'<div class="dojoxGridColCaption">']);
			}
			ret = ret.concat([n, '</div></div>']);
			return ret.join('');
		},

		resize: function(){
			this.adaptHeight();
			this.adaptWidth();
		},

		hasHScrollbar: function(reset){
			var hadScroll = this._hasHScroll||false;
			if(this._hasHScroll == undefined || reset){
				if(this.noscroll){
					this._hasHScroll = false;
				}else{
					var style = html.style(this.scrollboxNode, "overflow");
					if(style == "hidden"){
						this._hasHScroll = false;
					}else if(style == "scroll"){
						this._hasHScroll = true;
					}else{
						this._hasHScroll = (this.scrollboxNode.offsetWidth - this.getScrollbarWidth() < this.contentNode.offsetWidth );
					}
				}
			}
			if(hadScroll !== this._hasHScroll){
				this.grid.update();
			}
			return this._hasHScroll; // Boolean
		},

		hasVScrollbar: function(reset){
			var hadScroll = this._hasVScroll||false;
			if(this._hasVScroll == undefined || reset){
				if(this.noscroll){
					this._hasVScroll = false;
				}else{
					var style = html.style(this.scrollboxNode, "overflow");
					if(style == "hidden"){
						this._hasVScroll = false;
					}else if(style == "scroll"){
						this._hasVScroll = true;
					}else{
						this._hasVScroll = (this.scrollboxNode.scrollHeight > this.scrollboxNode.clientHeight);
					}
				}
			}
			if(hadScroll !== this._hasVScroll){
				this.grid.update();
			}
			return this._hasVScroll; // Boolean
		},
		
		convertColPctToFixed: function(){
			// Fix any percentage widths to be pixel values
			var hasPct = false;
			this.grid.initialWidth = "";
			var cellNodes = query("th", this.headerContentNode);
			var fixedWidths = array.map(cellNodes, function(c, vIdx){
				var w = c.style.width;
				html.attr(c, "vIdx", vIdx);
				if(w && w.slice(-1) == "%"){
					hasPct = true;
				}else if(w && w.slice(-2) == "px"){
					return window.parseInt(w, 10);
				}
				return html.contentBox(c).w;
			});
			if(hasPct){
				array.forEach(this.grid.layout.cells, function(cell, idx){
					if(cell.view == this){
						var cellNode = cell.view.getHeaderCellNode(cell.index);
						if(cellNode && html.hasAttr(cellNode, "vIdx")){
							var vIdx = window.parseInt(html.attr(cellNode, "vIdx"));
							this.setColWidth(idx, fixedWidths[vIdx]);
							html.removeAttr(cellNode, "vIdx");
						}
					}
				}, this);
				return true;
			}
			return false;
		},

		adaptHeight: function(minusScroll){
			if(!this.grid._autoHeight){
				var h = (this.domNode.style.height && parseInt(this.domNode.style.height.replace(/px/,''), 10)) || this.domNode.clientHeight;
				var self = this;
				var checkOtherViewScrollers = function(){
					var v;
					for(var i = 0; i < self.grid.views.views.length; ++i){
						v = self.grid.views.views[i];
						if(v !== self && v.hasHScrollbar()){
							return true;
						}
					}
					return false;
				};
				if(minusScroll || (this.noscroll && checkOtherViewScrollers())){
					h -= metrics.getScrollbar().h;
				}
				util.setStyleHeightPx(this.scrollboxNode, h);
			}
			this.hasVScrollbar(true);
		},

		adaptWidth: function(){
			if(this.flexCells){
				// the view content width
				this.contentWidth = this.getContentWidth();
				this.headerContentNode.firstChild.style.width = this.contentWidth;
			}
			// FIXME: it should be easier to get w from this.scrollboxNode.clientWidth,
			// but clientWidth seemingly does not include scrollbar width in some cases
			var w = this.scrollboxNode.offsetWidth - this.getScrollbarWidth();
			if(!this._removingColumn){
				w = Math.max(w, this.getColumnsWidth()) + 'px';
			}else{
				w = Math.min(w, this.getColumnsWidth()) + 'px';
				this._removingColumn = false;
			}
			var cn = this.contentNode;
			cn.style.width = w;
			this.hasHScrollbar(true);
		},

		setSize: function(w, h){
			var ds = this.domNode.style;
			var hs = this.headerNode.style;

			if(w){
				ds.width = w;
				hs.width = w;
			}
			ds.height = (h >= 0 ? h + 'px' : '');
		},

		renderRow: function(inRowIndex){
			var rowNode = this.createRowNode(inRowIndex);
			this.buildRow(inRowIndex, rowNode);
			//this.grid.edit.restore(this, inRowIndex);
			return rowNode;
		},

		createRowNode: function(inRowIndex){
			var node = document.createElement("div");
			node.className = this.classTag + 'Row';
			if (this instanceof dojox.grid._RowSelector){
				html.attr(node,"role","presentation");
			}else{
				html.attr(node,"role","row");
				if (this.grid.selectionMode != "none") {
					node.setAttribute("aria-selected", "false"); //rows can be selected so add aria-selected prop
				}
			}
			node[util.gridViewTag] = this.id;
			node[util.rowIndexTag] = inRowIndex;
			this.rowNodes[inRowIndex] = node;
			return node;
		},

		buildRow: function(inRowIndex, inRowNode){
			
			this.buildRowContent(inRowIndex, inRowNode);
		  	
			this.styleRow(inRowIndex, inRowNode);
		  
		 
		},

		buildRowContent: function(inRowIndex, inRowNode){
			inRowNode.innerHTML = this.content.generateHtml(inRowIndex, inRowIndex);
			if(this.flexCells && this.contentWidth){
				// FIXME: accessing firstChild here breaks encapsulation
				inRowNode.firstChild.style.width = this.contentWidth;
			}
			util.fire(this, "onAfterRow", [inRowIndex, this.structure.cells, inRowNode]);
		},

		rowRemoved:function(inRowIndex){
			if(inRowIndex >= 0){
				this._cleanupRowWidgets(this.getRowNode(inRowIndex));
			}
			this.grid.edit.save(this, inRowIndex);
			delete this.rowNodes[inRowIndex];
		},

		getRowNode: function(inRowIndex){
			return this.rowNodes[inRowIndex];
		},

		getCellNode: function(inRowIndex, inCellIndex){
			var row = this.getRowNode(inRowIndex);
			if(row){
				return this.content.getCellNode(row, inCellIndex);
			}
		},

		getHeaderCellNode: function(inCellIndex){
			if(this.headerContentNode){
				return this.header.getCellNode(this.headerContentNode, inCellIndex);
			}
		},

		// styling
		styleRow: function(inRowIndex, inRowNode){
			inRowNode._style = getStyleText(inRowNode);
			this.styleRowNode(inRowIndex, inRowNode);
		},

		styleRowNode: function(inRowIndex, inRowNode){
			if(inRowNode){
				this.doStyleRowNode(inRowIndex, inRowNode);
			}
		},

		doStyleRowNode: function(inRowIndex, inRowNode){
			this.grid.styleRowNode(inRowIndex, inRowNode);
		},

		// updating
		updateRow: function(inRowIndex){
			var rowNode = this.getRowNode(inRowIndex);
			if(rowNode){
				rowNode.style.height = '';
				this.buildRow(inRowIndex, rowNode);
			}
			return rowNode;
		},

		updateRowStyles: function(inRowIndex){
			this.styleRowNode(inRowIndex, this.getRowNode(inRowIndex));
		},

		// scrolling
		lastTop: 0,
		firstScroll:0,
		_nativeScroll: false,

		doscroll: function(inEvent){
			if(has('ff') >= 13 || has('chrome')){
				this._nativeScroll = true;
			}
			//var s = dojo.marginBox(this.headerContentNode.firstChild);
			var isLtr = this.grid.isLeftToRight();
			if(this.firstScroll < 2){
				if((!isLtr && this.firstScroll == 1) || (isLtr && this.firstScroll === 0)){
					var s = html.marginBox(this.headerNodeContainer);
					if(has('ie')){
						this.headerNodeContainer.style.width = s.w + this.getScrollbarWidth() + 'px';
					}else if(has('mozilla')){
						//TODO currently only for FF, not sure for safari and opera
						this.headerNodeContainer.style.width = s.w - this.getScrollbarWidth() + 'px';
						//this.headerNodeContainer.style.width = s.w + 'px';
						//set scroll to right in FF
						this.scrollboxNode.scrollLeft = isLtr ?
							this.scrollboxNode.clientWidth - this.scrollboxNode.scrollWidth :
							this.scrollboxNode.scrollWidth - this.scrollboxNode.clientWidth;
					}
				}
				this.firstScroll++;
			}
			this.headerNode.scrollLeft = this.scrollboxNode.scrollLeft;
			// 'lastTop' is a semaphore to prevent feedback-loop with setScrollTop below
			var top = this.scrollboxNode.scrollTop;
			if(top !== this.lastTop){
				this.grid.scrollTo(top);
			}
			this._nativeScroll = false;
		},

		setScrollTop: function(inTop){
			// 'lastTop' is a semaphore to prevent feedback-loop with doScroll above
			this.lastTop = inTop;
			if(!this._nativeScroll){
				//fix #15487
				this.scrollboxNode.scrollTop = inTop;
			}
			return this.scrollboxNode.scrollTop;
		},

		// event handlers (direct from DOM)
		doContentEvent: function(e){
			if(this.content.decorateEvent(e)){
				this.grid.onContentEvent(e);
			}
		},

		doHeaderEvent: function(e){
			if(this.header.decorateEvent(e)){
				this.grid.onHeaderEvent(e);
			}
		},

		// event dispatch(from Grid)
		dispatchContentEvent: function(e){
			return this.content.dispatchEvent(e);
		},

		dispatchHeaderEvent: function(e){
			return this.header.dispatchEvent(e);
		},

		// column resizing
		setColWidth: function(inIndex, inWidth){
			this.grid.setCellWidth(inIndex, inWidth + 'px');
		},

		update: function(){
			if(!this.domNode){
				return;
			}
			this.content.update();
			this.grid.update();
			//get scroll after update or scroll left setting goes wrong on IE.
			//See trac: #8040
			var left = this.scrollboxNode.scrollLeft;
			this.scrollboxNode.scrollLeft = left;
			this.headerNode.scrollLeft = left;
		}
	});

	var _GridAvatar = declare("dojox.grid._GridAvatar", Avatar, {
		construct: function(){
			var dd = win.doc;

			var a = dd.createElement("table");
			a.cellPadding = a.cellSpacing = "0";
			a.className = "dojoxGridDndAvatar";
			a.style.position = "absolute";
			a.style.zIndex = 1999;
			a.style.margin = "0px"; // to avoid dojo.marginBox() problems with table's margins
			var b = dd.createElement("tbody");
			var tr = dd.createElement("tr");
			var td = dd.createElement("td");
			var img = dd.createElement("td");
			tr.className = "dojoxGridDndAvatarItem";
			img.className = "dojoxGridDndAvatarItemImage";
			img.style.width = "16px";
			var source = this.manager.source, node;
			if(source.creator){
				// create an avatar representation of the node
				node = source._normalizedCreator(source.getItem(this.manager.nodes[0].id).data, "avatar").node;
			}else{
				// or just clone the node and hope it works
				node = this.manager.nodes[0].cloneNode(true);
				var table, tbody;
				if(node.tagName.toLowerCase() == "tr"){
					// insert extra table nodes
					table = dd.createElement("table");
					tbody = dd.createElement("tbody");
					tbody.appendChild(node);
					table.appendChild(tbody);
					node = table;
				}else if(node.tagName.toLowerCase() == "th"){
					// insert extra table nodes
					table = dd.createElement("table");
					tbody = dd.createElement("tbody");
					var r = dd.createElement("tr");
					table.cellPadding = table.cellSpacing = "0";
					r.appendChild(node);
					tbody.appendChild(r);
					table.appendChild(tbody);
					node = table;
				}
			}
			node.id = "";
			td.appendChild(node);
			tr.appendChild(img);
			tr.appendChild(td);
			html.style(tr, "opacity", 0.9);
			b.appendChild(tr);

			a.appendChild(b);
			this.node = a;

			var m = Manager.manager();
			this.oldOffsetY = m.OFFSET_Y;
			m.OFFSET_Y = 1;
		},
		destroy: function(){
			Manager.manager().OFFSET_Y = this.oldOffsetY;
			this.inherited(arguments);
		}
	});

	var oldMakeAvatar = Manager.manager().makeAvatar;
	Manager.manager().makeAvatar = function(){
		var src = this.source;
		if(src.viewIndex !== undefined && !html.hasClass(win.body(),"dijit_a11y")){
			return new _GridAvatar(this);
		}
		return oldMakeAvatar.call(Manager.manager());
	};

	return _View;

});
},
'dojox/html/metrics':function(){
define(["dojo/_base/kernel","dojo/_base/lang", "dojo/_base/sniff", "dojo/ready", "dojo/_base/unload",
		"dojo/_base/window", "dojo/dom-geometry"],
  function(kernel,lang,has,ready,UnloadUtil,Window,DOMGeom){
	var dhm = lang.getObject("dojox.html.metrics",true);
	var dojox = lang.getObject("dojox");

	//	derived from Morris John's emResized measurer
	dhm.getFontMeasurements = function(){
		// summary:
		//		Returns an object that has pixel equivilents of standard font size values.
		var heights = {
			'1em':0, '1ex':0, '100%':0, '12pt':0, '16px':0, 'xx-small':0, 'x-small':0,
			'small':0, 'medium':0, 'large':0, 'x-large':0, 'xx-large':0
		};
	
		var oldStyle;	
		if(has("ie")){
			//	We do a font-size fix if and only if one isn't applied already.
			// NOTE: If someone set the fontSize on the HTML Element, this will kill it.
			oldStyle = Window.doc.documentElement.style.fontSize || "";
			if(!oldStyle){
				Window.doc.documentElement.style.fontSize="100%";
			}
		}		
	
		//	set up the measuring node.
		var div=Window.doc.createElement("div");
		var ds = div.style;
		ds.position="absolute";
		ds.left="-100px";
		ds.top="0";
		ds.width="30px";
		ds.height="1000em";
		ds.borderWidth="0";
		ds.margin="0";
		ds.padding="0";
		ds.outline="0";
		ds.lineHeight="1";
		ds.overflow="hidden";
		Window.body().appendChild(div);
	
		//	do the measurements.
		for(var p in heights){
			ds.fontSize = p;
			heights[p] = Math.round(div.offsetHeight * 12/16) * 16/12 / 1000;
		}

		if(has("ie")){
			// Restore the font to its old style.
			Window.doc.documentElement.style.fontSize = oldStyle;
		}
		
		Window.body().removeChild(div);
		div = null;
		return heights; 	//	object
	};

	var fontMeasurements = null;
	
	dhm.getCachedFontMeasurements = function(recalculate){
		if(recalculate || !fontMeasurements){
			fontMeasurements = dhm.getFontMeasurements();
		}
		return fontMeasurements;
	};

	var measuringNode = null, empty = {};
	dhm.getTextBox = function(/* String */ text, /* Object */ style, /* String? */ className){
		var m, s;
		if(!measuringNode){
			m = measuringNode = Window.doc.createElement("div");
			// Container that we can set constraints on so that it doesn't
			// trigger a scrollbar.
			var c = Window.doc.createElement("div");
			c.appendChild(m);
			s = c.style;
			s.overflow='scroll';
			s.position = "absolute";
			s.left = "0px";
			s.top = "-10000px";
			s.width = "1px";
			s.height = "1px";
			s.visibility = "hidden";
			s.borderWidth = "0";
			s.margin = "0";
			s.padding = "0";
			s.outline = "0";
			Window.body().appendChild(c);
		}else{
			m = measuringNode;
		}
		// reset styles
		m.className = "";
		s = m.style;
		s.borderWidth = "0";
		s.margin = "0";
		s.padding = "0";
		s.outline = "0";
		// set new style
		if(arguments.length > 1 && style){
			for(var i in style){
				if(i in empty){ continue; }
				s[i] = style[i];
			}
		}
		// set classes
		if(arguments.length > 2 && className){
			m.className = className;
		}
		// take a measure
		m.innerHTML = text;
		var box = DOMGeom.position(m);
		// position doesn't report right (reports 1, since parent is 1)
		// So we have to look at the scrollWidth to get the real width
		// Height is right.
		box.w = m.parentNode.scrollWidth;
		return box;
	};

	//	determine the scrollbar sizes on load.
	var scroll={ w:16, h:16 };
	dhm.getScrollbar=function(){ return { w:scroll.w, h:scroll.h }; };

	dhm._fontResizeNode = null;

	dhm.initOnFontResize = function(interval){
		var f = dhm._fontResizeNode = Window.doc.createElement("iframe");
		var fs = f.style;
		fs.position = "absolute";
		fs.width = "5em";
		fs.height = "10em";
		fs.top = "-10000px";
		fs.display = "none";
		if(has("ie")){
			f.onreadystatechange = function(){
				if(f.contentWindow.document.readyState == "complete"){
					f.onresize = f.contentWindow.parent[dojox._scopeName].html.metrics._fontresize;
				}
			};
		}else{
			f.onload = function(){
				f.contentWindow.onresize = f.contentWindow.parent[dojox._scopeName].html.metrics._fontresize;
			};
		}
		//The script tag is to work around a known firebug race condition.  See comments in bug #9046
		f.setAttribute("src", "javascript:'<html><head><script>if(\"loadFirebugConsole\" in window){window.loadFirebugConsole();}</script></head><body></body></html>'");
		Window.body().appendChild(f);
		dhm.initOnFontResize = function(){};
	};

	dhm.onFontResize = function(){};
	dhm._fontresize = function(){
		dhm.onFontResize();
	};

	UnloadUtil.addOnUnload(function(){
		// destroy our font resize iframe if we have one
		var f = dhm._fontResizeNode;
		if(f){
			if(has("ie") && f.onresize){
				f.onresize = null;
			}else if(f.contentWindow && f.contentWindow.onresize){
				f.contentWindow.onresize = null;
			}
			dhm._fontResizeNode = null;
		}
	});

	ready(function(){
		// getScrollbar metrics node
		try{
			var n=Window.doc.createElement("div");
			n.style.cssText = "top:0;left:0;width:100px;height:100px;overflow:scroll;position:absolute;visibility:hidden;";
			Window.body().appendChild(n);
			scroll.w = n.offsetWidth - n.clientWidth;
			scroll.h = n.offsetHeight - n.clientHeight;
			Window.body().removeChild(n);
			//console.log("Scroll bar dimensions: ", scroll);
			delete n;
		}catch(e){}

		// text size poll setup
		if("fontSizeWatch" in kernel.config && !!kernel.config.fontSizeWatch){
			dhm.initOnFontResize();
		}
	});
	return dhm;
});
},
'dojox/grid/_Builder':function(){
define([
	"../main",
	"dojo/_base/array",
	"dojo/_base/lang",
	"dojo/_base/window",
	"dojo/_base/event",
	"dojo/_base/sniff",
	"dojo/_base/connect",
	"dojo/dnd/Moveable",
	"dojox/html/metrics",
	"./util",
	"dojo/_base/html",
	"dojo/dom-geometry"
], function(dojox, array, lang, win, event, has, connect, Moveable, metrics, util, html, domGeometry){

	var dg = dojox.grid;

	var getTdIndex = function(td){
		return td.cellIndex >=0 ? td.cellIndex : array.indexOf(td.parentNode.cells, td);
	};
	
	var getTrIndex = function(tr){
		return tr.rowIndex >=0 ? tr.rowIndex : array.indexOf(tr.parentNode.childNodes, tr);
	};
	
	var getTr = function(rowOwner, index){
		return rowOwner && ((rowOwner.rows||0)[index] || rowOwner.childNodes[index]);
	};

	var findTable = function(node){
		for(var n=node; n && n.tagName!='TABLE'; n=n.parentNode){}
		return n;
	};
	
	var ascendDom = function(inNode, inWhile){
		for(var n=inNode; n && inWhile(n); n=n.parentNode){}
		return n;
	};
	
	var makeNotTagName = function(inTagName){
		var name = inTagName.toUpperCase();
		return function(node){ return node.tagName != name; };
	};

	var rowIndexTag = util.rowIndexTag;
	var gridViewTag = util.gridViewTag;

	// base class for generating markup for the views
	var _Builder = dg._Builder = lang.extend(function(view){
		if(view){
			this.view = view;
			this.grid = view.grid;
		}
	},{
		view: null,
		// boilerplate HTML
		_table: '<table class="dojoxGridRowTable" border="0" cellspacing="0" cellpadding="0" role="presentation"',

		// Returns the table variable as an array - and with the view width, if specified
		getTableArray: function(){
			var html = [this._table];
			if(this.view.viewWidth){
				html.push([' style="width:', this.view.viewWidth, ';"'].join(''));
			}
			html.push('>');
			return html;
		},
		
		// generate starting tags for a cell
		generateCellMarkup: function(inCell, inMoreStyles, inMoreClasses, isHeader){
			var result = [], html;
			if(isHeader){
				var sortInfo = inCell.index != inCell.grid.getSortIndex() ? "" : inCell.grid.sortInfo > 0 ? 'aria-sort="ascending"' : 'aria-sort="descending"';
				if (!inCell.id){
					inCell.id = this.grid.id + "Hdr" + inCell.index;
				}
				// column headers are not editable, mark as aria-readonly=true
				html = ['<th tabIndex="-1" aria-readonly="true" role="columnheader"', sortInfo, ' id="', inCell.id, '"'];
			}else{
				// cells inherit grid aria-readonly property; default value for aria-readonly is false(grid is editable)
				// if grid is editable (had any editable cells), mark non editable cells as aria-readonly=true
				// if no editable cells, grid's aria-readonly value will have been set to true and cells will inherit
				var editInfo = this.grid.editable && !inCell.editable ? 'aria-readonly="true"' : "";
				html = ['<td tabIndex="-1" role="gridcell"', editInfo];
			}
			if(inCell.colSpan){
				html.push(' colspan="', inCell.colSpan, '"');
			}
			if(inCell.rowSpan){
				html.push(' rowspan="', inCell.rowSpan, '"');
			}
			html.push(' class="dojoxGridCell ');
			if(inCell.classes){
				html.push(inCell.classes, ' ');
			}
			if(inMoreClasses){
				html.push(inMoreClasses, ' ');
			}
			// result[0] => td opener, style
			result.push(html.join(''));
			// SLOT: result[1] => td classes
			result.push('');
			html = ['" idx="', inCell.index, '" style="'];
			if(inMoreStyles && inMoreStyles[inMoreStyles.length-1] != ';'){
				inMoreStyles += ';';
			}
			html.push(inCell.styles, inMoreStyles||'', inCell.hidden?'display:none;':'');
			if(inCell.unitWidth){
				html.push('width:', inCell.unitWidth, ';');
			}
			// result[2] => markup
			result.push(html.join(''));
			// SLOT: result[3] => td style
			result.push('');
			html = [ '"' ];
			if(inCell.attrs){
				html.push(" ", inCell.attrs);
			}
			html.push('>');
			// result[4] => td postfix
			result.push(html.join(''));
			// SLOT: result[5] => content
			result.push('');
			// result[6] => td closes
			result.push(isHeader?'</th>':'</td>');
			return result; // Array
		},

		// cell finding
		isCellNode: function(inNode){
			return Boolean(inNode && inNode!=win.doc && html.attr(inNode, "idx"));
		},
		
		getCellNodeIndex: function(inCellNode){
			return inCellNode ? Number(html.attr(inCellNode, "idx")) : -1;
		},
		
		getCellNode: function(inRowNode, inCellIndex){
			for(var i=0, row; ((row = getTr(inRowNode.firstChild, i)) && row.cells); i++){
				for(var j=0, cell; (cell = row.cells[j]); j++){
					if(this.getCellNodeIndex(cell) == inCellIndex){
						return cell;
					}
				}
			}
			return null;
		},
		
		findCellTarget: function(inSourceNode, inTopNode){
			var n = inSourceNode;
			while(n && (!this.isCellNode(n) || (n.offsetParent && gridViewTag in n.offsetParent.parentNode && n.offsetParent.parentNode[gridViewTag] != this.view.id)) && (n!=inTopNode)){
				n = n.parentNode;
			}
			return n!=inTopNode ? n : null;
		},
		
		// event decoration
		baseDecorateEvent: function(e){
			e.dispatch = 'do' + e.type;
			e.grid = this.grid;
			e.sourceView = this.view;
			e.cellNode = this.findCellTarget(e.target, e.rowNode);
			e.cellIndex = this.getCellNodeIndex(e.cellNode);
			e.cell = (e.cellIndex >= 0 ? this.grid.getCell(e.cellIndex) : null);
		},
		
		// event dispatch
		findTarget: function(inSource, inTag){
			var n = inSource;
			while(n && (n!=this.domNode) && (!(inTag in n) || (gridViewTag in n && n[gridViewTag] != this.view.id))){
				n = n.parentNode;
			}
			return (n != this.domNode) ? n : null;
		},

		findRowTarget: function(inSource){
			return this.findTarget(inSource, rowIndexTag);
		},

		isIntraNodeEvent: function(e){
			try{
				return (e.cellNode && e.relatedTarget && html.isDescendant(e.relatedTarget, e.cellNode));
			}catch(x){
				// e.relatedTarget has permission problem in FF if it's an input: https://bugzilla.mozilla.org/show_bug.cgi?id=208427
				return false;
			}
		},

		isIntraRowEvent: function(e){
			try{
				var row = e.relatedTarget && this.findRowTarget(e.relatedTarget);
				return !row && (e.rowIndex==-1) || row && (e.rowIndex==row.gridRowIndex);
			}catch(x){
				// e.relatedTarget on INPUT has permission problem in FF: https://bugzilla.mozilla.org/show_bug.cgi?id=208427
				return false;
			}
		},

		dispatchEvent: function(e){
			if(e.dispatch in this){
				return this[e.dispatch](e);
			}
			return false;
		},

		// dispatched event handlers
		domouseover: function(e){
			if(e.cellNode && (e.cellNode!=this.lastOverCellNode)){
				this.lastOverCellNode = e.cellNode;
				this.grid.onMouseOver(e);
			}
			this.grid.onMouseOverRow(e);
		},

		domouseout: function(e){
			if(e.cellNode && (e.cellNode==this.lastOverCellNode) && !this.isIntraNodeEvent(e, this.lastOverCellNode)){
				this.lastOverCellNode = null;
				this.grid.onMouseOut(e);
				if(!this.isIntraRowEvent(e)){
					this.grid.onMouseOutRow(e);
				}
			}
		},
		
		domousedown: function(e){
			if (e.cellNode)
				this.grid.onMouseDown(e);
			this.grid.onMouseDownRow(e);
		},

		_getTextDirStyle: function(textDir, inCell, inRowIndex){
			// summary:
			//		 Get BiDi text dir, just a placeholder, defined in dojox/grid/bidi/_BidiMixin
			return "";
		}
	});

	// Produces html for grid data content. Owned by grid and used internally
	// for rendering data. Override to implement custom rendering.
	var _ContentBuilder = dg._ContentBuilder = lang.extend(function(view){
		_Builder.call(this, view);
	},_Builder.prototype,{
		update: function(){
			this.prepareHtml();
		},

		// cache html for rendering data rows
		prepareHtml: function(){
			var defaultGet=this.grid.get, cells=this.view.structure.cells;
			for(var j=0, row; (row=cells[j]); j++){
				for(var i=0, cell; (cell=row[i]); i++){
					cell.get = cell.get || (cell.value == undefined) && defaultGet;
					cell.markup = this.generateCellMarkup(cell, cell.cellStyles, cell.cellClasses, false);
					if (!this.grid.editable && cell.editable){
						this.grid.editable = true;
					}
				}
			}
		},

		// time critical: generate html using cache and data source
		generateHtml: function(inDataIndex, inRowIndex){
			var
				html = this.getTableArray(),
				v = this.view, dir,
				cells = v.structure.cells,
				item = this.grid.getItem(inRowIndex);

			util.fire(this.view, "onBeforeRow", [inRowIndex, cells]);
			for(var j=0, row; (row=cells[j]); j++){
				if(row.hidden || row.header){
					continue;
				}
				html.push(!row.invisible ? '<tr>' : '<tr class="dojoxGridInvisible">');
				for(var i=0, cell, m, cc, cs; (cell=row[i]); i++){
					m = cell.markup; cc = cell.customClasses = []; cs = cell.customStyles = [];
					// content (format can fill in cc and cs as side-effects)
					m[5] = cell.format(inRowIndex, item);
					// classes
					m[1] = cc.join(' ');
					// styles
					m[3] = cs.join(';');
					dir = cell.textDir || this.grid.textDir;
					if(dir){
					    m[3] += this._getTextDirStyle(dir, cell, inRowIndex);
					}
					// in-place concat
					html.push.apply(html, m);
				}
				html.push('</tr>');
			}
			html.push('</table>');
			return html.join(''); // String
		},

		decorateEvent: function(e){
			e.rowNode = this.findRowTarget(e.target);
			if(!e.rowNode){return false;}
			e.rowIndex = e.rowNode[rowIndexTag];
			this.baseDecorateEvent(e);
			e.cell = this.grid.getCell(e.cellIndex);
			return true; // Boolean
		}
	});

	// Produces html for grid header content. Owned by grid and used internally
	// for rendering data. Override to implement custom rendering.
	var _HeaderBuilder = dg._HeaderBuilder = lang.extend(function(view){
		this.moveable = null;
		_Builder.call(this, view);
	},_Builder.prototype,{
		_skipBogusClicks: false,
		overResizeWidth: 4,
		minColWidth: 1,
		
		update: function(){
			if(this.tableMap){
				this.tableMap.mapRows(this.view.structure.cells);
			}else{
				this.tableMap = new dg._TableMap(this.view.structure.cells);
			}
		},

		generateHtml: function(inGetValue, inValue){
			var dir, html = this.getTableArray(), cells = this.view.structure.cells;
			
			util.fire(this.view, "onBeforeRow", [-1, cells]);
			for(var j=0, row; (row=cells[j]); j++){
				if(row.hidden){
					continue;
				}
				html.push(!row.invisible ? '<tr>' : '<tr class="dojoxGridInvisible">');
				for(var i=0, cell, markup; (cell=row[i]); i++){
					cell.customClasses = [];
					cell.customStyles = [];
					if(this.view.simpleStructure){
						if(cell.draggable){
							if(cell.headerClasses){
								if(cell.headerClasses.indexOf('dojoDndItem') == -1){
									cell.headerClasses += ' dojoDndItem';
								}
							}else{
								cell.headerClasses = 'dojoDndItem';
							}
						}
						if(cell.attrs){
							if(cell.attrs.indexOf("dndType='gridColumn_") == -1){
								cell.attrs += " dndType='gridColumn_" + this.grid.id + "'";
							}
						}else{
							cell.attrs = "dndType='gridColumn_" + this.grid.id + "'";
						}
					}
					markup = this.generateCellMarkup(cell, cell.headerStyles, cell.headerClasses, true);
					// content
					markup[5] = (inValue != undefined ? inValue : inGetValue(cell));
					// styles
					markup[3] = cell.customStyles.join(';');
					dir = cell.textDir || this.grid.textDir;
					if(dir){
					    markup[3] += this._getTextDirStyle(dir, cell, inValue);
					}
					// classes
					markup[1] = cell.customClasses.join(' '); //(cell.customClasses ? ' ' + cell.customClasses : '');
					html.push(markup.join(''));
				}
				html.push('</tr>');
			}
			html.push('</table>');
			return html.join('');
		},

		// event helpers
		getCellX: function(e){
		    var n, x = e.layerX;
		    if (has('mozilla') || has('ie') >= 9) {
		        n = ascendDom(e.target, makeNotTagName("th"));
		        x -= (n && n.offsetLeft) || 0;
		        var t = e.sourceView.getScrollbarWidth();
		        if (!this.grid.isLeftToRight()/*&& e.sourceView.headerNode.scrollLeft < t*/) {
		            //fix #11253
		            table = ascendDom(n, makeNotTagName("table"));
		            x -= (table && table.offsetLeft) || 0;
		        }
		        //x -= getProp(ascendDom(e.target, mkNotTagName("td")), "offsetLeft") || 0;
		    }
		    n = ascendDom(e.target, function () {
		        if (!n || n == e.cellNode) {
		            return false;
		        }
		        // Mozilla 1.8 (FF 1.5) has a bug that makes offsetLeft = -parent border width
		        // when parent has border, overflow: hidden, and is positioned
		        // handle this problem here ... not a general solution!
		        x += (n.offsetLeft < 0 ? 0 : n.offsetLeft);
		        return true;
		    });
		    return x;
		},

		// event decoration
		decorateEvent: function(e){
			this.baseDecorateEvent(e);
			e.rowIndex = -1;
			e.cellX = this.getCellX(e);
			return true;
		},

		// event handlers
		// resizing
		prepareResize: function(e, mod){
			do{
				var i = e.cellIndex;
				e.cellNode = (i ? e.cellNode.parentNode.cells[i+mod] : null);
				e.cellIndex = (e.cellNode ? this.getCellNodeIndex(e.cellNode) : -1);
			}while(e.cellNode && e.cellNode.style.display == "none");
			return Boolean(e.cellNode);
		},

		canResize: function(e){
			if(!e.cellNode || e.cellNode.colSpan > 1){
				return false;
			}
			var cell = this.grid.getCell(e.cellIndex);
			return !cell.noresize && cell.canResize();
		},

		overLeftResizeArea: function(e){
			// We are never over a resize area if we are in the process of moving
			if(html.hasClass(win.body(), "dojoDndMove")){
				return false;
			}
			//Bugfix for crazy IE problem (#8807).  IE returns position information for the icon and text arrow divs
			//as if they were still on the left instead of returning the position they were 'float: right' to.
			//So, the resize check ends up checking the wrong adjacent cell.  This checks to see if the hover was over
			//the image or text nodes, then just ignored them/treat them not in scale range.
			if(has('ie')){
				var tN = e.target;
				if(html.hasClass(tN, "dojoxGridArrowButtonNode") ||
					html.hasClass(tN, "dojoxGridArrowButtonChar") ||
					html.hasClass(tN, "dojoxGridColCaption")){
					return false;
				}
			}

			if(this.grid.isLeftToRight()){
				return (e.cellIndex>0) && (e.cellX > 0 && e.cellX < this.overResizeWidth) && this.prepareResize(e, -1);
			}
			var t = e.cellNode && (e.cellX > 0 && e.cellX < this.overResizeWidth);
			return t;
		},

		overRightResizeArea: function(e){
			// We are never over a resize area if we are in the process of moving
			if(html.hasClass(win.body(), "dojoDndMove")){
				return false;
			}
			//Bugfix for crazy IE problem (#8807).  IE returns position information for the icon and text arrow divs
			//as if they were still on the left instead of returning the position they were 'float: right' to.
			//So, the resize check ends up checking the wrong adjacent cell.  This checks to see if the hover was over
			//the image or text nodes, then just ignored them/treat them not in scale range.
			if(has('ie')){
				var tN = e.target;
				if(html.hasClass(tN, "dojoxGridArrowButtonNode") ||
					html.hasClass(tN, "dojoxGridArrowButtonChar") ||
					html.hasClass(tN, "dojoxGridColCaption")){
					return false;
				}
			}

			if(this.grid.isLeftToRight()){
				return e.cellNode && (e.cellX >= e.cellNode.offsetWidth - this.overResizeWidth);
			}
			return (e.cellIndex>0) && (e.cellX >= e.cellNode.offsetWidth - this.overResizeWidth) && this.prepareResize(e, -1);
		},

		domousemove: function(e){
			//console.log(e.cellIndex, e.cellX, e.cellNode.offsetWidth);
			if(!this.moveable){
				var c = (this.overRightResizeArea(e) ? 'dojoxGridColResize' : (this.overLeftResizeArea(e) ? 'dojoxGridColResize' : ''));
				if(c && !this.canResize(e)){
					c = 'dojoxGridColNoResize';
				}
				html.toggleClass(e.sourceView.headerNode, "dojoxGridColNoResize", (c == "dojoxGridColNoResize"));
				html.toggleClass(e.sourceView.headerNode, "dojoxGridColResize", (c == "dojoxGridColResize"));
				if(c){
					event.stop(e);
				}
			}
		},

		domousedown: function(e){
			if(!this.moveable){
				if((this.overRightResizeArea(e) || this.overLeftResizeArea(e)) && this.canResize(e)){
					this.beginColumnResize(e);
				}else{
					this.grid.onMouseDown(e);
					this.grid.onMouseOverRow(e);
				}
				//else{
				//	this.beginMoveColumn(e);
				//}
			}
		},

		doclick: function(e) {
			if(this._skipBogusClicks){
				event.stop(e);
				return true;
			}
			return false;
		},

		// column resizing
		colResizeSetup: function(/*Event Object*/e, /*boolean*/ isMouse ){
			//Set up the drag object for column resizing
			// Called with mouse event in case of drag and drop,
			// Also called from keyboard shift-arrow event when focus is on a header
			var headContentBox = html.contentBox(e.sourceView.headerNode);
			
			if(isMouse){  //IE draws line even with no mouse down so separate from keyboard
				this.lineDiv = document.createElement('div');

				var vw = html.position(e.sourceView.headerNode, true);
				var bodyContentBox = html.contentBox(e.sourceView.domNode);
				//fix #11340
				var l = e.pageX;
				if(!this.grid.isLeftToRight() && has('ie') < 8){
					l -= metrics.getScrollbar().w;
				}
				html.style(this.lineDiv, {
					top: vw.y + "px",
					left: l + "px",
					height: (bodyContentBox.h + headContentBox.h) + "px"
				});
				html.addClass(this.lineDiv, "dojoxGridResizeColLine");
				this.lineDiv._origLeft = l;
				win.body().appendChild(this.lineDiv);
			}
			var spanners = [], nodes = this.tableMap.findOverlappingNodes(e.cellNode);
			for(var i=0, cell; (cell=nodes[i]); i++){
				spanners.push({ node: cell, index: this.getCellNodeIndex(cell), width: cell.offsetWidth });
				//console.log("spanner: " + this.getCellNodeIndex(cell));
			}

			var view = e.sourceView;
			var adj = this.grid.isLeftToRight() ? 1 : -1;
			var views = e.grid.views.views;
			var followers = [];
			for(var j=view.idx+adj, cView; (cView=views[j]); j=j+adj){
				followers.push({ node: cView.headerNode, left: window.parseInt(cView.headerNode.style.left) });
			}
			var table = view.headerContentNode.firstChild;
			var drag = {
				scrollLeft: e.sourceView.headerNode.scrollLeft,
				view: view,
				node: e.cellNode,
				index: e.cellIndex,
				w: html.contentBox(e.cellNode).w,
				vw: headContentBox.w,
				table: table,
				tw: html.contentBox(table).w,
				spanners: spanners,
				followers: followers
			};
			return drag;
		},
		beginColumnResize: function(e){
			this.moverDiv = document.createElement("div");
			html.style(this.moverDiv,{position: "absolute", left:0}); // to make DnD work with dir=rtl
			win.body().appendChild(this.moverDiv);
			html.addClass(this.grid.domNode, "dojoxGridColumnResizing");
			var m = (this.moveable = new Moveable(this.moverDiv));

			var drag = this.colResizeSetup(e,true);

			m.onMove = lang.hitch(this, "doResizeColumn", drag);

			connect.connect(m, "onMoveStop", lang.hitch(this, function(){
				this.endResizeColumn(drag);
				if(drag.node.releaseCapture){
					drag.node.releaseCapture();
				}
				this.moveable.destroy();
				delete this.moveable;
				this.moveable = null;
				html.removeClass(this.grid.domNode, "dojoxGridColumnResizing");
			}));

			if(e.cellNode.setCapture){
				e.cellNode.setCapture();
			}
			m.onMouseDown(e);
		},

		doResizeColumn: function(inDrag, mover, leftTop){
			var changeX = leftTop.l;
			var data = {
				deltaX: changeX,
				w: inDrag.w + (this.grid.isLeftToRight() ? changeX : -changeX),//fix #11341
				vw: inDrag.vw + changeX,
				tw: inDrag.tw + changeX
			};
			
			this.dragRecord = {inDrag: inDrag, mover: mover, leftTop:leftTop};
			
			if(data.w >= this.minColWidth){
				if (!mover) { // we are using keyboard do immediate resize
					this.doResizeNow(inDrag, data);
				}
				else{
					html.style(this.lineDiv, "left", (this.lineDiv._origLeft + data.deltaX) + "px");
				}
			}
		},

		endResizeColumn: function(inDrag){
			if(this.dragRecord){
				var leftTop = this.dragRecord.leftTop;
				var changeX = this.grid.isLeftToRight() ? leftTop.l : -leftTop.l;
				// Make sure we are not under our minimum
				// http://bugs.dojotoolkit.org/ticket/9390
				changeX += Math.max(inDrag.w + changeX, this.minColWidth) - (inDrag.w + changeX);
				if(has('webkit') && inDrag.spanners.length){
					// Webkit needs the pad border extents back in
					changeX += html._getPadBorderExtents(inDrag.spanners[0].node).w;
				}
				var data = {
					deltaX: changeX,
					w: inDrag.w + changeX,
					vw: inDrag.vw + changeX,
					tw: inDrag.tw + changeX
				};
				// Only resize the columns when the drag has finished
				this.doResizeNow(inDrag, data);
				delete this.dragRecord;
			}
			
			html.destroy(this.lineDiv);
 			html.destroy(this.moverDiv);
			html.destroy(this.moverDiv);
			delete this.moverDiv;
			this._skipBogusClicks = true;
			inDrag.view.update();
			this._skipBogusClicks = false;
			this.grid.onResizeColumn(inDrag.index);
		},
		doResizeNow: function(inDrag, data){
			inDrag.view.convertColPctToFixed();
			if(inDrag.view.flexCells && !inDrag.view.testFlexCells()){
				var t = findTable(inDrag.node);
				if(t){
					(t.style.width = '');
				}
			}
			var i, s, sw, f, fl;
			for(i=0; (s=inDrag.spanners[i]); i++){
				sw = s.width + data.deltaX;
				if(sw > 0){
					s.node.style.width = sw + 'px';
					inDrag.view.setColWidth(s.index, sw);
				}
			}
			if(this.grid.isLeftToRight() || !has('ie')){//fix #11339
				for(i=0; (f=inDrag.followers[i]); i++){
					fl = f.left + data.deltaX;
					f.node.style.left = fl + 'px';
				}
			}
			inDrag.node.style.width = data.w + 'px';
			inDrag.view.setColWidth(inDrag.index, data.w);
			inDrag.view.headerNode.style.width = data.vw + 'px';
			inDrag.view.setColumnsWidth(data.tw);
			if(!this.grid.isLeftToRight()){
				inDrag.view.headerNode.scrollLeft = inDrag.scrollLeft + data.deltaX;
			}
		}
	});

	// Maps an html table into a structure parsable for information about cell row and col spanning.
	// Used by HeaderBuilder.
	dg._TableMap = lang.extend(function(rows){
		this.mapRows(rows);
	},{
		map: null,

		mapRows: function(inRows){
			// summary:
			//		Map table topography

			//console.log('mapRows');
			// # of rows
			var rowCount = inRows.length;
			if(!rowCount){
				return;
			}
			// map which columns and rows fill which cells
			this.map = [];
			var row;
			for(var k=0; (row=inRows[k]); k++){
				this.map[k] = [];
			}
			for(var j=0; (row=inRows[j]); j++){
				for(var i=0, x=0, cell, colSpan, rowSpan; (cell=row[i]); i++){
					while(this.map[j][x]){x++;}
					this.map[j][x] = { c: i, r: j };
					rowSpan = cell.rowSpan || 1;
					colSpan = cell.colSpan || 1;
					for(var y=0; y<rowSpan; y++){
						for(var s=0; s<colSpan; s++){
							this.map[j+y][x+s] = this.map[j][x];
						}
					}
					x += colSpan;
				}
			}
			//this.dumMap();
		},

		dumpMap: function(){
			for(var j=0, row, h=''; (row=this.map[j]); j++,h=''){
				for(var i=0, cell; (cell=row[i]); i++){
					h += cell.r + ',' + cell.c + '   ';
				}
			}
		},

		getMapCoords: function(inRow, inCol){
			// summary:
			//		Find node's map coords by it's structure coords
			for(var j=0, row; (row=this.map[j]); j++){
				for(var i=0, cell; (cell=row[i]); i++){
					if(cell.c==inCol && cell.r == inRow){
						return { j: j, i: i };
					}
					//else{console.log(inRow, inCol, ' : ', i, j, " : ", cell.r, cell.c); };
				}
			}
			return { j: -1, i: -1 };
		},
		
		getNode: function(inTable, inRow, inCol){
			// summary:
			//		Find a node in inNode's table with the given structure coords
			var row = inTable && inTable.rows[inRow];
			return row && row.cells[inCol];
		},
		
		_findOverlappingNodes: function(inTable, inRow, inCol){
			var nodes = [];
			var m = this.getMapCoords(inRow, inCol);
			//console.log("node j: %d, i: %d", m.j, m.i);
			for(var j=0, row; (row=this.map[j]); j++){
				if(j == m.j){ continue; }
				var rw = row[m.i];
				//console.log("overlaps: r: %d, c: %d", rw.r, rw.c);
				var n = (rw?this.getNode(inTable, rw.r, rw.c):null);
				if(n){ nodes.push(n); }
			}
			//console.log(nodes);
			return nodes;
		},
		
		findOverlappingNodes: function(inNode){
			return this._findOverlappingNodes(findTable(inNode), getTrIndex(inNode.parentNode), getTdIndex(inNode));
		}
	});

	return {
		_Builder: _Builder,
		_HeaderBuilder: _HeaderBuilder,
		_ContentBuilder: _ContentBuilder
	};
});

},
'dojox/grid/_ViewManager':function(){
define([
	"dojo/_base/declare",
	"dojo/_base/sniff",
	"dojo/dom-class"
], function(declare, has, domClass){

return declare('dojox.grid._ViewManager', null, {
	// summary:
	//		A collection of grid views. Owned by grid and used internally for managing grid views.
	// description:
	//		Grid creates views automatically based on grid's layout structure.
	//		Users should typically not need to access individual views or the views collection directly.
	constructor: function(inGrid){
		this.grid = inGrid;
	},

	defaultWidth: 200,

	views: [],

	// operations
	resize: function(){
		this.onEach("resize");
	},

	render: function(){
		this.onEach("render");
	},

	// views
	addView: function(inView){
		inView.idx = this.views.length;
		this.views.push(inView);
	},

	destroyViews: function(){
		for(var i=0, v; v=this.views[i]; i++){
			v.destroy();
		}
		this.views = [];
	},

	getContentNodes: function(){
		var nodes = [];
		for(var i=0, v; v=this.views[i]; i++){
			nodes.push(v.contentNode);
		}
		return nodes;
	},

	forEach: function(inCallback){
		for(var i=0, v; v=this.views[i]; i++){
			inCallback(v, i);
		}
	},

	onEach: function(inMethod, inArgs){
		inArgs = inArgs || [];
		for(var i=0, v; v=this.views[i]; i++){
			if(inMethod in v){
				v[inMethod].apply(v, inArgs);
			}
		}
	},

	// layout
	normalizeHeaderNodeHeight: function(){
		var rowNodes = [];
		for(var i=0, v; (v=this.views[i]); i++){
			if(v.headerContentNode.firstChild){
				rowNodes.push(v.headerContentNode);
			}
		}
		this.normalizeRowNodeHeights(rowNodes);
	},

	normalizeRowNodeHeights: function(inRowNodes){
		var h = 0;
		var currHeights = [];
		if(this.grid.rowHeight){
			h = this.grid.rowHeight;
		}else{
			if(inRowNodes.length <= 1){
				// no need to normalize if we are the only one...
				return;
			}
			for(var i=0, n; (n=inRowNodes[i]); i++){
				// We only care about the height - so don't use marginBox.  This
				// depends on the container not having any margin (which it shouldn't)
				// Also - we only look up the height if the cell doesn't have the
				// dojoxGridNonNormalizedCell class (like for row selectors)
				if(!domClass.contains(n, "dojoxGridNonNormalizedCell")){
					currHeights[i] = n.firstChild.offsetHeight;
					h =  Math.max(h, currHeights[i]);
				}
			}
			h = (h >= 0 ? h : 0);
	
			//Work around odd FF3 rendering bug: #8864.
			//A one px increase fixes FireFox 3's rounding bug for fractional font sizes.
			if((has('mozilla') || has('ie') > 8 ) && h){h++;}
		}
		for(i=0; (n=inRowNodes[i]); i++){
			if(currHeights[i] != h){
				n.firstChild.style.height = h + "px";
			}
		}
	},
	
	resetHeaderNodeHeight: function(){
		for(var i=0, v, n; (v=this.views[i]); i++){
			n = v.headerContentNode.firstChild;
			if(n){
				n.style.height = "";
			}
		}
	},

	renormalizeRow: function(inRowIndex){
		var rowNodes = [];
		for(var i=0, v, n; (v=this.views[i])&&(n=v.getRowNode(inRowIndex)); i++){
			n.firstChild.style.height = '';
			rowNodes.push(n);
		}
		this.normalizeRowNodeHeights(rowNodes);
	},

	getViewWidth: function(inIndex){
		return this.views[inIndex].getWidth() || this.defaultWidth;
	},

	// must be called after view widths are properly set or height can be miscalculated
	// if there are flex columns
	measureHeader: function(){
		// need to reset view header heights so they are properly measured.
		this.resetHeaderNodeHeight();
		this.forEach(function(inView){
			inView.headerContentNode.style.height = '';
		});
		var h = 0;
		// calculate maximum view header height
		this.forEach(function(inView){
			h = Math.max(inView.headerNode.offsetHeight, h);
		});
		return h;
	},

	measureContent: function(){
		var h = 0;
		this.forEach(function(inView){
			h = Math.max(inView.domNode.offsetHeight, h);
		});
		return h;
	},

	findClient: function(inAutoWidth){
		// try to use user defined client
		var c = this.grid.elasticView || -1;
		// attempt to find implicit client
		if(c < 0){
			for(var i=1, v; (v=this.views[i]); i++){
				if(v.viewWidth){
					for(i=1; (v=this.views[i]); i++){
						if(!v.viewWidth){
							c = i;
							break;
						}
					}
					break;
				}
			}
		}
		// client is in the middle by default
		if(c < 0){
			c = Math.floor(this.views.length / 2);
		}
		return c;
	},

	arrange: function(l, w){
		var i, v, vw, len = this.views.length, self = this;
		// find the client
		var c = (w <= 0 ? len : this.findClient());
		// layout views
		var setPosition = function(v, l){
			var ds = v.domNode.style;
			var hs = v.headerNode.style;

			if(!self.grid.isLeftToRight()){
				ds.right = l + 'px';
				// fixed rtl, the scrollbar is on the right side in FF < 4
				if(has('ff') < 4){
					hs.right = l + v.getScrollbarWidth() + 'px';
				}else{
					hs.right = l + 'px';
				}
				if(!has('webkit') && hs.width != 'auto'){
					hs.width = parseInt(hs.width, 10) - v.getScrollbarWidth() + 'px';					
				}
			}else{
				ds.left = l + 'px';
				hs.left = l + 'px';
			}
			ds.top = 0 + 'px';
			hs.top = 0;
		};
		// for views left of the client
		//BiDi TODO: The left and right should not appear in BIDI environment. Should be replaced with
		//leading and tailing concept.
		for(i=0; (v=this.views[i])&&(i<c); i++){
			// get width
			vw = this.getViewWidth(i);
			// process boxes
			v.setSize(vw, 0);
			setPosition(v, l);
			if(v.headerContentNode && v.headerContentNode.firstChild){
				vw = v.getColumnsWidth()+v.getScrollbarWidth();
			}else{
				vw = v.domNode.offsetWidth;
			}
			// update position
			l += vw;
		}
		// next view (is the client, i++ == c)
		i++;
		// start from the right edge
		var r = w;
		// for views right of the client (iterated from the right)
		for(var j=len-1; (v=this.views[j])&&(i<=j); j--){
			// get width
			vw = this.getViewWidth(j);
			// set size
			v.setSize(vw, 0);
			// measure in pixels
			vw = v.domNode.offsetWidth;
			// update position
			r -= vw;
			// set position
			setPosition(v, r);
		}
		if(c<len){
			v = this.views[c];
			// position the client box between left and right boxes
			vw = Math.max(1, r-l);
			// set size
			v.setSize(vw + 'px', 0);
			setPosition(v, l);
		}
		return l;
	},

	// rendering
	renderRow: function(inRowIndex, inNodes, skipRenorm){
		var rowNodes = [];
		for(var i=0, v, n, rowNode; (v=this.views[i])&&(n=inNodes[i]); i++){
			rowNode = v.renderRow(inRowIndex);
			n.appendChild(rowNode);
			rowNodes.push(rowNode);
		}
		if(!skipRenorm){
			this.normalizeRowNodeHeights(rowNodes);
		}
	},
	
	rowRemoved: function(inRowIndex){
		this.onEach("rowRemoved", [ inRowIndex ]);
	},
	
	// updating
	updateRow: function(inRowIndex, skipRenorm){
		for(var i=0, v; v=this.views[i]; i++){
			v.updateRow(inRowIndex);
		}
		if(!skipRenorm){
			this.renormalizeRow(inRowIndex);
		}
	},
	
	updateRowStyles: function(inRowIndex){
		this.onEach("updateRowStyles", [ inRowIndex ]);
	},
	
	// scrolling
	setScrollTop: function(inTop){
		var top = inTop;
		for(var i=0, v; v=this.views[i]; i++){
			top = v.setScrollTop(inTop);
			// Work around IE not firing scroll events that cause header offset
			// issues to occur.
			if(has('ie') && v.headerNode && v.scrollboxNode){
				v.headerNode.scrollLeft = v.scrollboxNode.scrollLeft;
			}
		}
		return top;
		//this.onEach("setScrollTop", [ inTop ]);
	},
	
	getFirstScrollingView: function(){
		// summary:
		//		Returns the first grid view with a scroll bar
		for(var i=0, v; (v=this.views[i]); i++){
			if(v.hasHScrollbar() || v.hasVScrollbar()){
				return v;
			}
		}
		return null;
	}
});
});
},
'dojox/grid/_RowManager':function(){
define([
	"dojo/_base/declare",
	"dojo/_base/lang",
	"dojo/dom-class"
], function(declare, lang, domClass){

	var setStyleText = function(inNode, inStyleText){
		if(inNode.style.cssText == undefined){
			inNode.setAttribute("style", inStyleText);
		}else{
			inNode.style.cssText = inStyleText;
		}
	};

	return declare("dojox.grid._RowManager", null, {
		//	Stores information about grid rows. Owned by grid and used internally.
		constructor: function(inGrid){
			this.grid = inGrid;
		},
		linesToEms: 2,
		overRow: -2,
		// styles
		prepareStylingRow: function(inRowIndex, inRowNode){
			return {
				index: inRowIndex,
				node: inRowNode,
				odd: Boolean(inRowIndex&1),
				selected: !!this.grid.selection.isSelected(inRowIndex),
				over: this.isOver(inRowIndex),
				customStyles: "",
				customClasses: "dojoxGridRow"
			};
		},
		styleRowNode: function(inRowIndex, inRowNode){
			var row = this.prepareStylingRow(inRowIndex, inRowNode);
			this.grid.onStyleRow(row);
			this.applyStyles(row);
		},
		applyStyles: function(inRow){
			var i = inRow;

			i.node.className = i.customClasses;
			var h = i.node.style.height;
			setStyleText(i.node, i.customStyles + ';' + (i.node._style||''));
			i.node.style.height = h;
		},
		updateStyles: function(inRowIndex){
			this.grid.updateRowStyles(inRowIndex);
		},
		// states and events
		setOverRow: function(inRowIndex){
			var last = this.overRow;
			this.overRow = inRowIndex;
			if((last!=this.overRow)&&(lang.isString(last) || last >= 0)){
				this.updateStyles(last);
			}
			this.updateStyles(this.overRow);
		},
		isOver: function(inRowIndex){
			return (this.overRow == inRowIndex && !domClass.contains(this.grid.domNode, "dojoxGridColumnResizing"));
		}
	});
});
},
'dojox/grid/_FocusManager':function(){
define([
	"dojo/_base/array",
	"dojo/_base/lang",
	"dojo/_base/declare",
	"dojo/_base/connect",
	"dojo/_base/event",
	"dojo/_base/sniff",
	"dojo/query",
	"./util",
	"dojo/_base/html"
], function(array, lang, declare, connect, event, has, query, util, html){

// focus management
return declare("dojox.grid._FocusManager", null, {
	// summary:
	//		Controls grid cell focus. Owned by grid and used internally for focusing.
	//		Note: grid cell actually receives keyboard input only when cell is being edited.
	constructor: function(inGrid){
		this.grid = inGrid;
		this.cell = null;
		this.rowIndex = -1;
		this._connects = [];
		this._headerConnects = [];
		this.headerMenu = this.grid.headerMenu;
		this._connects.push(connect.connect(this.grid.domNode, "onfocus", this, "doFocus"));
		this._connects.push(connect.connect(this.grid.domNode, "onblur", this, "doBlur"));
		this._connects.push(connect.connect(this.grid.domNode, "mousedown", this, "_mouseDown"));
		this._connects.push(connect.connect(this.grid.domNode, "mouseup", this, "_mouseUp"));
		this._connects.push(connect.connect(this.grid.domNode, "oncontextmenu", this, "doContextMenu"));
		this._connects.push(connect.connect(this.grid.lastFocusNode, "onfocus", this, "doLastNodeFocus"));
		this._connects.push(connect.connect(this.grid.lastFocusNode, "onblur", this, "doLastNodeBlur"));
		this._connects.push(connect.connect(this.grid,"_onFetchComplete", this, "_delayedCellFocus"));
		this._connects.push(connect.connect(this.grid,"postrender", this, "_delayedHeaderFocus"));
	},
	destroy: function(){
		array.forEach(this._connects, connect.disconnect);
		array.forEach(this._headerConnects, connect.disconnect);
		delete this.grid;
		delete this.cell;
	},
	_colHeadNode: null,
	_colHeadFocusIdx: null,
	_contextMenuBindNode: null,
	tabbingOut: false,
	focusClass: "dojoxGridCellFocus",
	focusView: null,
	initFocusView: function(){
		this.focusView = this.grid.views.getFirstScrollingView() || this.focusView || this.grid.views.views[0];
		this._initColumnHeaders();
	},
	isFocusCell: function(inCell, inRowIndex){
		// summary:
		//		states if the given cell is focused
		// inCell: object
		//		grid cell object
		// inRowIndex: int
		//		grid row index
		// returns:
		//		true of the given grid cell is focused
		return (this.cell == inCell) && (this.rowIndex == inRowIndex);
	},
	isLastFocusCell: function(){
		if(this.cell){
			return (this.rowIndex == this.grid.rowCount-1) && (this.cell.index == this.grid.layout.cellCount-1);
		}
		return false;
	},
	isFirstFocusCell: function(){
		if(this.cell){
			return (this.rowIndex === 0) && (this.cell.index === 0);
		}
		return false;
	},
	isNoFocusCell: function(){
		return (this.rowIndex < 0) || !this.cell;
	},
	isNavHeader: function(){
		// summary:
		//		states whether currently navigating among column headers.
		// returns:
		//		true if focus is on a column header; false otherwise.
		return (!!this._colHeadNode);
	},
	getHeaderIndex: function(){
		// summary:
		//		if one of the column headers currently has focus, return its index.
		// returns:
		//		index of the focused column header, or -1 if none have focus.
		if(this._colHeadNode){
			return array.indexOf(this._findHeaderCells(), this._colHeadNode);
		}else{
			return -1;
		}
	},
	_focusifyCellNode: function(inBork){
		var n = this.cell && this.cell.getNode(this.rowIndex);
		if(n){
			html.toggleClass(n, this.focusClass, inBork);
			if(inBork){
				var sl = this.scrollIntoView();
				try{
					if(has("webkit") || !this.grid.edit.isEditing()){
						util.fire(n, "focus");
						if(sl){ this.cell.view.scrollboxNode.scrollLeft = sl; }
					}
				}catch(e){}
			}
		}
	},
	_delayedCellFocus: function(){
		if(this.isNavHeader()||!this.grid.focused){
				return;
		}
		var n = this.cell && this.cell.getNode(this.rowIndex);
		if(n){
			try{
				if(!this.grid.edit.isEditing()){
					html.toggleClass(n, this.focusClass, true);
					if(this._colHeadNode){
						this.blurHeader();
					}
					util.fire(n, "focus");
				}
			}
			catch(e){}
		}
	},
	_delayedHeaderFocus: function(){
		if(this.isNavHeader()){
			this.focusHeader();
			//this.grid.domNode.focus();
		}
	},
	_initColumnHeaders: function(){
		array.forEach(this._headerConnects, connect.disconnect);
		this._headerConnects = [];
		var headers = this._findHeaderCells();
		for(var i = 0; i < headers.length; i++){
			this._headerConnects.push(connect.connect(headers[i], "onfocus", this, "doColHeaderFocus"));
			this._headerConnects.push(connect.connect(headers[i], "onblur", this, "doColHeaderBlur"));
		}
	},
	_findHeaderCells: function(){
		// This should be a one liner:
		//	query("th[tabindex=-1]", this.grid.viewsHeaderNode);
		// But there is a bug in query() for IE -- see trac #7037.
		var allHeads = query("th", this.grid.viewsHeaderNode);
		var headers = [];
		for (var i = 0; i < allHeads.length; i++){
			var aHead = allHeads[i];
			var hasTabIdx = html.hasAttr(aHead, "tabIndex");
			var tabindex = html.attr(aHead, "tabIndex");
			if (hasTabIdx && tabindex < 0) {
				headers.push(aHead);
			}
		}
		return headers;
	},
	_setActiveColHeader: function(/*Node*/colHeaderNode, /*Integer*/colFocusIdx, /*Integer*/ prevColFocusIdx){
		//console.log("setActiveColHeader() - colHeaderNode:colFocusIdx:prevColFocusIdx = " + colHeaderNode + ":" + colFocusIdx + ":" + prevColFocusIdx);
		this.grid.domNode.setAttribute("aria-activedescendant",colHeaderNode.id);
		if (prevColFocusIdx != null && prevColFocusIdx >= 0 && prevColFocusIdx != colFocusIdx){
			html.toggleClass(this._findHeaderCells()[prevColFocusIdx],this.focusClass,false);
		}
		html.toggleClass(colHeaderNode,this.focusClass, true);
		this._colHeadNode = colHeaderNode;
		this._colHeadFocusIdx = colFocusIdx;
		this._scrollHeader(this._colHeadFocusIdx);
	},
	scrollIntoView: function(){
		var info = (this.cell ? this._scrollInfo(this.cell) : null);
		if(!info || !info.s){
			return null;
		}
		var rt = this.grid.scroller.findScrollTop(this.rowIndex);
		// place cell within horizontal view
		if(info.n && info.sr){
			if(info.n.offsetLeft + info.n.offsetWidth > info.sr.l + info.sr.w){
				info.s.scrollLeft = info.n.offsetLeft + info.n.offsetWidth - info.sr.w;
			}else if(info.n.offsetLeft < info.sr.l){
				info.s.scrollLeft = info.n.offsetLeft;
			}
		}
		// place cell within vertical view
		if(info.r && info.sr){
			if(rt + info.r.offsetHeight > info.sr.t + info.sr.h){
				this.grid.setScrollTop(rt + info.r.offsetHeight - info.sr.h);
			}else if(rt < info.sr.t){
				this.grid.setScrollTop(rt);
			}
		}

		return info.s.scrollLeft;
	},
	_scrollInfo: function(cell, domNode){
		if(cell){
			var cl = cell,
				sbn = cl.view.scrollboxNode,
				sbnr = {
					w: sbn.clientWidth,
					l: sbn.scrollLeft,
					t: sbn.scrollTop,
					h: sbn.clientHeight
				},
				rn = cl.view.getRowNode(this.rowIndex);
			return {
				c: cl,
				s: sbn,
				sr: sbnr,
				n: (domNode ? domNode : cell.getNode(this.rowIndex)),
				r: rn
			};
		}
		return null;
	},
	_scrollHeader: function(currentIdx){
		var info = null;
		if(this._colHeadNode){
			var cell = this.grid.getCell(currentIdx);
			if(!cell){ return; }
			info = this._scrollInfo(cell, cell.getNode(0));
		}
		if(info && info.s && info.sr && info.n){
			// scroll horizontally as needed.
			var scroll = info.sr.l + info.sr.w;
			if(info.n.offsetLeft + info.n.offsetWidth > scroll){
				info.s.scrollLeft = info.n.offsetLeft + info.n.offsetWidth - info.sr.w;
			}else if(info.n.offsetLeft < info.sr.l){
				info.s.scrollLeft = info.n.offsetLeft;
			}else if(has('ie') <= 7 && cell && cell.view.headerNode){
				// Trac 7158: scroll dojoxGridHeader for IE7 and lower
				cell.view.headerNode.scrollLeft = info.s.scrollLeft;
			}
		}
	},
	_isHeaderHidden: function(){
		// summary:
		//		determine if the grid headers are hidden
		//		relies on documented technique of setting .dojoxGridHeader { display:none; }
		// returns: Boolean
		//		true if headers are hidden
		//		false if headers are not hidden
		
		var curView = this.focusView;
		if (!curView){
			// find one so we can determine if headers are hidden
			// there is no focusView after adding items to empty grid (test_data_grid_empty.html)
			for (var i = 0, cView; (cView = this.grid.views.views[i]); i++) {
				if(cView.headerNode ){
					curView=cView;
					break;
				}
			}
		}
		return (curView && html.getComputedStyle(curView.headerNode).display == "none");
	},
	colSizeAdjust: function (e, colIdx, delta){ // adjust the column specified by colIdx by the specified delta px
		var headers = this._findHeaderCells();
		var view = this.focusView;
		if(!view || !view.header.tableMap.map){
			for(var i = 0, cView; (cView = this.grid.views.views[i]); i++){
				// find first view with a tableMap in order to work with empty grid
				if(cView.header.tableMap.map){
					view=cView;
					break;
				}
			}
		}
		var curHeader = headers[colIdx];
		if (!view || (colIdx == headers.length-1 && colIdx === 0)){
			return; // can't adjust single col. grid
		}
		view.content.baseDecorateEvent(e);
		// need to adjust event with header cell info since focus is no longer on header cell
		e.cellNode = curHeader; //this.findCellTarget(e.target, e.rowNode);
		e.cellIndex = view.content.getCellNodeIndex(e.cellNode);
		e.cell = (e.cellIndex >= 0 ? this.grid.getCell(e.cellIndex) : null);
		if (view.header.canResize(e)){
			var deltaObj = {
				l: delta
			};
			var drag = view.header.colResizeSetup(e,false);
			view.header.doResizeColumn(drag, null, deltaObj);
			view.update();
		}
	},
	styleRow: function(inRow){
		return;
	},
	setFocusIndex: function(inRowIndex, inCellIndex){
		// summary:
		//		focuses the given grid cell
		// inRowIndex: int
		//		grid row index
		// inCellIndex: int
		//		grid cell index
		this.setFocusCell(this.grid.getCell(inCellIndex), inRowIndex);
	},
	setFocusCell: function(inCell, inRowIndex){
		// summary:
		//		focuses the given grid cell
		// inCell: object
		//		grid cell object
		// inRowIndex: int
		//		grid row index
		if(inCell && !this.isFocusCell(inCell, inRowIndex)){
			this.tabbingOut = false;
			if (this._colHeadNode){
				this.blurHeader();
			}
			this._colHeadNode = this._colHeadFocusIdx = null;
			this.focusGridView();
			this._focusifyCellNode(false);
			this.cell = inCell;
			this.rowIndex = inRowIndex;
			this._focusifyCellNode(true);
		}
		// even if this cell isFocusCell, the document focus may need to be rejiggered
		// call opera on delay to prevent keypress from altering focus
		if(has('opera')){
			setTimeout(lang.hitch(this.grid, 'onCellFocus', this.cell, this.rowIndex), 1);
		}else{
			this.grid.onCellFocus(this.cell, this.rowIndex);
		}
	},
	next: function(){
		// summary:
		//	focus next grid cell
		if(this.cell){
			var row=this.rowIndex, col=this.cell.index+1, cc=this.grid.layout.cellCount-1, rc=this.grid.rowCount-1;
			if(col > cc){
				col = 0;
				row++;
			}
			if(row > rc){
				col = cc;
				row = rc;
			}
			if(this.grid.edit.isEditing()){ //when editing, only navigate to editable cells
				var nextCell = this.grid.getCell(col);
				if (!this.isLastFocusCell() && (!nextCell.editable ||
					this.grid.canEdit && !this.grid.canEdit(nextCell, row))){
					this.cell=nextCell;
					this.rowIndex=row;
					this.next();
					return;
				}
			}
			this.setFocusIndex(row, col);
		}
	},
	previous: function(){
		// summary:
		//	focus previous grid cell
		if(this.cell){
			var row=(this.rowIndex || 0), col=(this.cell.index || 0) - 1;
			if(col < 0){
				col = this.grid.layout.cellCount-1;
				row--;
			}
			if(row < 0){
				row = 0;
				col = 0;
			}
			if(this.grid.edit.isEditing()){ //when editing, only navigate to editable cells
				var prevCell = this.grid.getCell(col);
				if (!this.isFirstFocusCell() && !prevCell.editable){
					this.cell=prevCell;
					this.rowIndex=row;
					this.previous();
					return;
				}
			}
			this.setFocusIndex(row, col);
		}
	},
	move: function(inRowDelta, inColDelta) {
		// summary:
		//		focus grid cell or  simulate focus to column header based on position relative to current focus
		// inRowDelta: int
		//		vertical distance from current focus
		// inColDelta: int
		//		horizontal distance from current focus

		var colDir = inColDelta < 0 ? -1 : 1;
		// Handle column headers.
		if(this.isNavHeader()){
			var headers = this._findHeaderCells();
			var savedIdx = currentIdx = array.indexOf(headers, this._colHeadNode);
			currentIdx += inColDelta;
			while(currentIdx >=0 && currentIdx < headers.length && headers[currentIdx].style.display == "none"){
				// skip over hidden column headers
				currentIdx += colDir;
			}
			if((currentIdx >= 0) && (currentIdx < headers.length)){
				this._setActiveColHeader(headers[currentIdx],currentIdx, savedIdx);
			}
		}else{
			if(this.cell){
				// Handle grid proper.
				var sc = this.grid.scroller,
					r = this.rowIndex,
					rc = this.grid.rowCount-1,
					row = Math.min(rc, Math.max(0, r+inRowDelta));
				if(inRowDelta){
					if(inRowDelta>0){
						if(row > sc.getLastPageRow(sc.page)){
							//need to load additional data, let scroller do that
							this.grid.setScrollTop(this.grid.scrollTop+sc.findScrollTop(row)-sc.findScrollTop(r));
						}
					}else if(inRowDelta<0){
						if(row <= sc.getPageRow(sc.page)){
							//need to load additional data, let scroller do that
							this.grid.setScrollTop(this.grid.scrollTop-sc.findScrollTop(r)-sc.findScrollTop(row));
						}
					}
				}
				var cc = this.grid.layout.cellCount-1,
				i = this.cell.index,
				col = Math.min(cc, Math.max(0, i+inColDelta));
				var cell = this.grid.getCell(col);
				while(col>=0 && col < cc && cell && cell.hidden === true){
					// skip hidden cells
					col += colDir;
					cell = this.grid.getCell(col);
				}
				if (!cell || cell.hidden === true){
					// don't change col if would move to hidden
					col = i;
				}
				//skip hidden row|cell
				var n = cell.getNode(row);
				if(!n && inRowDelta){
					if((row + inRowDelta) >= 0 && (row + inRowDelta) <= rc){
						this.move(inRowDelta > 0 ? ++inRowDelta : --inRowDelta, inColDelta);
					}
					return;
				}else if((!n || html.style(n, "display") === "none") && inColDelta){
					if((col + inColDelta) >= 0 && (col + inColDelta) <= cc){
						this.move(inRowDelta, inColDelta > 0 ? ++inColDelta : --inColDelta);
					}
					return;
				}
				this.setFocusIndex(row, col);
				if(inRowDelta){
					this.grid.updateRow(r);
				}
			}
		}
	},
	previousKey: function(e){
		if(this.grid.edit.isEditing()){
			event.stop(e);
			this.previous();
		}else if(!this.isNavHeader() && !this._isHeaderHidden()) {
			this.grid.domNode.focus(); // will call doFocus and set focus into header.
			event.stop(e);
		}else{
			this.tabOut(this.grid.domNode);
			if (this._colHeadFocusIdx != null) { // clear grid header focus
				html.toggleClass(this._findHeaderCells()[this._colHeadFocusIdx], this.focusClass, false);
				this._colHeadFocusIdx = null;
			}
			this._focusifyCellNode(false);
		}
	},
	nextKey: function(e) {
		var isEmpty = (this.grid.rowCount === 0);
		if(e.target === this.grid.domNode && this._colHeadFocusIdx == null){
			this.focusHeader();
			event.stop(e);
		}else if(this.isNavHeader()){
			// if tabbing from col header, then go to grid proper.
			this.blurHeader();
			if(!this.findAndFocusGridCell()){
				this.tabOut(this.grid.lastFocusNode);
			}
			this._colHeadNode = this._colHeadFocusIdx= null;
		}else if(this.grid.edit.isEditing()){
			event.stop(e);
			this.next();
		}else{
			this.tabOut(this.grid.lastFocusNode);
		}
	},
	tabOut: function(inFocusNode){
		this.tabbingOut = true;
		inFocusNode.focus();
	},
	focusGridView: function(){
		util.fire(this.focusView, "focus");
	},
	focusGrid: function(inSkipFocusCell){
		this.focusGridView();
		this._focusifyCellNode(true);
	},
	findAndFocusGridCell: function(){
		// summary:
		//		find the first focusable grid cell
		// returns: Boolean
		//		true if focus was set to a cell
		//		false if no cell found to set focus onto
		
		var didFocus = true;
		var isEmpty = (this.grid.rowCount === 0); // If grid is empty this.grid.rowCount == 0
		if (this.isNoFocusCell() && !isEmpty){
			var cellIdx = 0;
			var cell = this.grid.getCell(cellIdx);
			if (cell.hidden) {
				// if first cell isn't visible, use _colHeadFocusIdx
				// could also use a while loop to find first visible cell - not sure that is worth it
				cellIdx = this.isNavHeader() ? this._colHeadFocusIdx : 0;
			}
			this.setFocusIndex(0, cellIdx);
		}
		else if (this.cell && !isEmpty){
			if (this.focusView && !this.focusView.rowNodes[this.rowIndex]){
				// if rowNode for current index is undefined (likely as a result of a sort and because of #7304)
				// scroll to that row
				this.grid.scrollToRow(this.rowIndex);
			}
			this.focusGrid();
		}else {
			didFocus = false;
		}
		this._colHeadNode = this._colHeadFocusIdx= null;
		return didFocus;
	},
	focusHeader: function(){
		var headerNodes = this._findHeaderCells();
		var saveColHeadFocusIdx = this._colHeadFocusIdx;
		if (this._isHeaderHidden()){
			// grid header is hidden, focus a cell
			this.findAndFocusGridCell();
		}
		else if (!this._colHeadFocusIdx) {
			if (this.isNoFocusCell()) {
				this._colHeadFocusIdx = 0;
			}
			else {
				this._colHeadFocusIdx = this.cell.index;
			}
		}
		this._colHeadNode = headerNodes[this._colHeadFocusIdx];
		while(this._colHeadNode && this._colHeadFocusIdx >=0 && this._colHeadFocusIdx < headerNodes.length &&
				this._colHeadNode.style.display == "none"){
			// skip over hidden column headers
			this._colHeadFocusIdx++;
			this._colHeadNode = headerNodes[this._colHeadFocusIdx];
		}
		if(this._colHeadNode && this._colHeadNode.style.display != "none"){
			// Column header cells know longer receive actual focus.  So, for keyboard invocation of
			// contextMenu to work, the contextMenu must be bound to the grid.domNode rather than the viewsHeaderNode.
			// unbind the contextmenu from the viewsHeaderNode and to the grid when header cells are active.  Reset
			// the binding back to the viewsHeaderNode when header cells are no longer acive (in blurHeader) #10483
			if (this.headerMenu && this._contextMenuBindNode != this.grid.domNode){
				this.headerMenu.unBindDomNode(this.grid.viewsHeaderNode);
				this.headerMenu.bindDomNode(this.grid.domNode);
				this._contextMenuBindNode = this.grid.domNode;
			}
			this._setActiveColHeader(this._colHeadNode, this._colHeadFocusIdx, saveColHeadFocusIdx);
			this._scrollHeader(this._colHeadFocusIdx);
			this._focusifyCellNode(false);
		}else {
			// all col head nodes are hidden - focus the grid
			this.findAndFocusGridCell();
		}
	},
	blurHeader: function(){
		html.removeClass(this._colHeadNode, this.focusClass);
		html.removeAttr(this.grid.domNode,"aria-activedescendant");
		// reset contextMenu onto viewsHeaderNode so right mouse on header will invoke (see focusHeader)
		if (this.headerMenu && this._contextMenuBindNode == this.grid.domNode) {
			var viewsHeader = this.grid.viewsHeaderNode;
			this.headerMenu.unBindDomNode(this.grid.domNode);
			this.headerMenu.bindDomNode(viewsHeader);
			this._contextMenuBindNode = viewsHeader;
		}
	},
	doFocus: function(e){
		// trap focus only for grid dom node
		if(e && e.target != e.currentTarget){
			event.stop(e);
			return;
		}
		// don't change focus if clicking on scroller bar
		if(this._clickFocus){
			return;
		}
		// do not focus for scrolling if grid is about to blur
		if(!this.tabbingOut){
			this.focusHeader();
		}
		this.tabbingOut = false;
		event.stop(e);
	},
	doBlur: function(e){
		event.stop(e);	// FF2
	},
	doContextMenu: function(e){
	//stop contextMenu event if no header Menu to prevent default/browser contextMenu
		if (!this.headerMenu){
			event.stop(e);
		}
	},
	doLastNodeFocus: function(e){
		if (this.tabbingOut){
			this._focusifyCellNode(false);
		}else if(this.grid.rowCount >0){
			if (this.isNoFocusCell()){
				this.setFocusIndex(0,0);
			}
			this._focusifyCellNode(true);
		}else {
			this.focusHeader();
		}
		this.tabbingOut = false;
		event.stop(e);	 // FF2
	},
	doLastNodeBlur: function(e){
		event.stop(e);	 // FF2
	},
	doColHeaderFocus: function(e){
		this._setActiveColHeader(e.target,html.attr(e.target, "idx"),this._colHeadFocusIdx);
		this._scrollHeader(this.getHeaderIndex());
		event.stop(e);
	},
	doColHeaderBlur: function(e){
		html.toggleClass(e.target, this.focusClass, false);
	},
	_mouseDown: function(e){
		// a flag indicating grid is being focused by clicking
		this._clickFocus = dojo.some(this.grid.views.views, function(v){
			return v.scrollboxNode === e.target;
		});
	},
	_mouseUp: function(e){
		this._clickFocus = false;
	}
});
});
},
'dojox/grid/_EditManager':function(){
define([
	"dojo/_base/lang",
	"dojo/_base/array",
	"dojo/_base/declare",
	"dojo/_base/connect",
	"dojo/_base/sniff",
	"./util"
], function(lang, array, declare, connect, has, util){

return declare("dojox.grid._EditManager", null, {
	// summary:
	//		Controls grid cell editing process. Owned by grid and used internally for editing.
	constructor: function(inGrid){
		// inGrid: dojox.Grid
		//		The dojox.Grid this editor should be attached to
		this.grid = inGrid;
		this.connections = !has('ie') ? [] : [connect.connect(document.body, "onfocus", lang.hitch(this, "_boomerangFocus"))];
		this.connections.push(connect.connect(this.grid, 'onBlur', this, 'apply'));
		this.connections.push(connect.connect(this.grid, 'prerender', this, '_onPreRender'));
	},
	
	info: {},

	destroy: function(){
		array.forEach(this.connections, connect.disconnect);
	},

	cellFocus: function(inCell, inRowIndex){
		// summary:
		//		Invoke editing when cell is focused
		// inCell: cell object
		//		Grid cell object
		// inRowIndex: Integer
		//		Grid row index
		if(this.grid.singleClickEdit || this.isEditRow(inRowIndex)){
			// if same row or quick editing, edit
			this.setEditCell(inCell, inRowIndex);
		}else{
			// otherwise, apply any pending row edits
			this.apply();
		}
		// if dynamic or static editing...
		if(this.isEditing() || (inCell && inCell.editable && inCell.alwaysEditing)){
			// let the editor focus itself as needed
			this._focusEditor(inCell, inRowIndex);
		}
	},

	rowClick: function(e){
		if(this.isEditing() && !this.isEditRow(e.rowIndex)){
			this.apply();
		}
	},

	styleRow: function(inRow){
		if(inRow.index == this.info.rowIndex){
			inRow.customClasses += ' dojoxGridRowEditing';
		}
	},

	dispatchEvent: function(e){
		var c = e.cell, ed = (c && c["editable"]) ? c : 0;
		return ed && ed.dispatchEvent(e.dispatch, e);
	},

	// Editing
	isEditing: function(){
		// summary:
		//		Indicates editing state of the grid.
		// returns: Boolean
		//	 	True if grid is actively editing
		return this.info.rowIndex !== undefined;
	},

	isEditCell: function(inRowIndex, inCellIndex){
		// summary:
		//		Indicates if the given cell is being edited.
		// inRowIndex: Integer
		//		Grid row index
		// inCellIndex: Integer
		//		Grid cell index
		// returns: Boolean
		//	 	True if given cell is being edited
		return (this.info.rowIndex === inRowIndex) && (this.info.cell.index == inCellIndex);
	},

	isEditRow: function(inRowIndex){
		// summary:
		//		Indicates if the given row is being edited.
		// inRowIndex: Integer
		//		Grid row index
		// returns: Boolean
		//	 	True if given row is being edited
		return this.info.rowIndex === inRowIndex;
	},

	setEditCell: function(inCell, inRowIndex){
		// summary:
		//		Set the given cell to be edited
		// inRowIndex: Integer
		//		Grid row index
		// inCell: Object
		//		Grid cell object
		if(!this.isEditCell(inRowIndex, inCell.index) && this.grid.canEdit && this.grid.canEdit(inCell, inRowIndex)){
			this.start(inCell, inRowIndex, this.isEditRow(inRowIndex) || inCell.editable);
		}
	},

	_focusEditor: function(inCell, inRowIndex){
		util.fire(inCell, "focus", [inRowIndex]);
	},

	focusEditor: function(){
		if(this.isEditing()){
			this._focusEditor(this.info.cell, this.info.rowIndex);
		}
	},

	// implement fix for focus boomerang effect on IE
	_boomerangWindow: 500,
	_shouldCatchBoomerang: function(){
		return this._catchBoomerang > new Date().getTime();
	},
	_boomerangFocus: function(){
		//console.log("_boomerangFocus");
		if(this._shouldCatchBoomerang()){
			// make sure we don't utterly lose focus
			this.grid.focus.focusGrid();
			// let the editor focus itself as needed
			this.focusEditor();
			// only catch once
			this._catchBoomerang = 0;
		}
	},
	_doCatchBoomerang: function(){
		// give ourselves a few ms to boomerang IE focus effects
		if(has('ie')){this._catchBoomerang = new Date().getTime() + this._boomerangWindow;}
	},
	// end boomerang fix API

	start: function(inCell, inRowIndex, inEditing){
		if(!this._isValidInput()){
			return;
		}
		this.grid.beginUpdate();
		this.editorApply();
		if(this.isEditing() && !this.isEditRow(inRowIndex)){
			this.applyRowEdit();
			this.grid.updateRow(inRowIndex);
		}
		if(inEditing){
			this.info = { cell: inCell, rowIndex: inRowIndex };
			this.grid.doStartEdit(inCell, inRowIndex);
			this.grid.updateRow(inRowIndex);
		}else{
			this.info = {};
		}
		this.grid.endUpdate();
		// make sure we don't utterly lose focus
		this.grid.focus.focusGrid();
		// let the editor focus itself as needed
		this._focusEditor(inCell, inRowIndex);
		// give ourselves a few ms to boomerang IE focus effects
		this._doCatchBoomerang();
	},

	_editorDo: function(inMethod){
		var c = this.info.cell;
		//c && c.editor && c.editor[inMethod](c, this.info.rowIndex);
		if(c && c.editable){
			c[inMethod](this.info.rowIndex);
		}
	},

	editorApply: function(){
		this._editorDo("apply");
	},

	editorCancel: function(){
		this._editorDo("cancel");
	},

	applyCellEdit: function(inValue, inCell, inRowIndex){
		if(this.grid.canEdit(inCell, inRowIndex)){
			this.grid.doApplyCellEdit(inValue, inRowIndex, inCell.field);
		}
	},

	applyRowEdit: function(){
		this.grid.doApplyEdit(this.info.rowIndex, this.info.cell.field);
	},

	apply: function(){
		// summary:
		//		Apply a grid edit
		if(this.isEditing() && this._isValidInput()){
			this.grid.beginUpdate();
			this.editorApply();
			this.applyRowEdit();
			this.info = {};
			this.grid.endUpdate();
			this.grid.focus.focusGrid();
			this._doCatchBoomerang();
		}
	},

	cancel: function(){
		// summary:
		//		Cancel a grid edit
		if(this.isEditing()){
			this.grid.beginUpdate();
			this.editorCancel();
			this.info = {};
			this.grid.endUpdate();
			this.grid.focus.focusGrid();
			this._doCatchBoomerang();
		}
	},

	save: function(inRowIndex, inView){
		// summary:
		//		Save the grid editing state
		// inRowIndex: Integer
		//		Grid row index
		// inView: Object
		//		Grid view
		var c = this.info.cell;
		if(this.isEditRow(inRowIndex) && (!inView || c.view==inView) && c.editable){
			c.save(c, this.info.rowIndex);
		}
	},

	restore: function(inView, inRowIndex){
		// summary:
		//		Restores the grid editing state
		// inRowIndex: Integer
		//		Grid row index
		// inView: Object
		//		Grid view
		var c = this.info.cell;
		if(this.isEditRow(inRowIndex) && c.view == inView && c.editable){
			c.restore(this.info.rowIndex);
		}
	},
	
	_isValidInput: function(){
		var w = (this.info.cell || {}).widget;		
		if(!w || !w.isValid){
			//no validation needed
			return true;
		}		
		w.focused = true;
		return w.isValid(true);
	},
	
	_onPreRender: function(){
		if(this.isEditing()){
			//cache the current editing value before render
			this.info.value = this.info.cell.getValue();
		}
	}
});
});
},
'dojox/grid/Selection':function(){
define([
	"dojo/_base/declare",
	"dojo/_base/array",
	"dojo/_base/lang",
	"dojo/dom-attr"
], function(declare, array, lang, domAttr){

return declare("dojox.grid.Selection", null, {
	// summary:
	//		Manages row selection for grid. Owned by grid and used internally
	//		for selection. Override to implement custom selection.

	constructor: function(inGrid){
		this.grid = inGrid;
		this.selected = [];

		this.setMode(inGrid.selectionMode);
	},

	mode: 'extended',

	selected: null,
	updating: 0,
	selectedIndex: -1,
	rangeStartIndex: -1,

	setMode: function(mode){
		if(this.selected.length){
			this.deselectAll();
		}
		if(mode != 'extended' && mode != 'multiple' && mode != 'single' && mode != 'none'){
			this.mode = 'extended';
		}else{
			this.mode = mode;
		}
	},

	onCanSelect: function(inIndex){
		return this.grid.onCanSelect(inIndex);
	},

	onCanDeselect: function(inIndex){
		return this.grid.onCanDeselect(inIndex);
	},

	onSelected: function(inIndex){
	},

	onDeselected: function(inIndex){
	},

	//onSetSelected: function(inIndex, inSelect) { };
	onChanging: function(){
	},

	onChanged: function(){
	},

	isSelected: function(inIndex){
		if(this.mode == 'none'){
			return false;
		}
		return this.selected[inIndex];
	},

	getFirstSelected: function(){
		if(!this.selected.length||this.mode == 'none'){ return -1; }
		for(var i=0, l=this.selected.length; i<l; i++){
			if(this.selected[i]){
				return i;
			}
		}
		return -1;
	},

	getNextSelected: function(inPrev){
		if(this.mode == 'none'){ return -1; }
		for(var i=inPrev+1, l=this.selected.length; i<l; i++){
			if(this.selected[i]){
				return i;
			}
		}
		return -1;
	},

	getSelected: function(){
		var result = [];
		for(var i=0, l=this.selected.length; i<l; i++){
			if(this.selected[i]){
				result.push(i);
			}
		}
		return result;
	},

	getSelectedCount: function(){
		var c = 0;
		for(var i=0; i<this.selected.length; i++){
			if(this.selected[i]){
				c++;
			}
		}
		return c;
	},

	_beginUpdate: function(){
		if(this.updating === 0){
			this.onChanging();
		}
		this.updating++;
	},

	_endUpdate: function(){
		this.updating--;
		if(this.updating === 0){
			this.onChanged();
		}
	},

	select: function(inIndex){
		if(this.mode == 'none'){ return; }
		if(this.mode != 'multiple'){
			this.deselectAll(inIndex);
			this.addToSelection(inIndex);
		}else{
			this.toggleSelect(inIndex);
		}
	},

	addToSelection: function(inIndex){
		if(this.mode == 'none'){ return; }
		if(lang.isArray(inIndex)){
			array.forEach(inIndex, this.addToSelection, this);
			return;
		}
		inIndex = Number(inIndex);
		if(this.selected[inIndex]){
			this.selectedIndex = inIndex;
		}else{
			if(this.onCanSelect(inIndex) !== false){
				this.selectedIndex = inIndex;
				var rowNode = this.grid.getRowNode(inIndex);
				if(rowNode){
					domAttr.set(rowNode, "aria-selected", "true");
				}
				this._beginUpdate();
				this.selected[inIndex] = true;
				//this.grid.onSelected(inIndex);
				this.onSelected(inIndex);
				//this.onSetSelected(inIndex, true);
				this._endUpdate();
			}
		}
	},

	deselect: function(inIndex){
		if(this.mode == 'none'){ return; }
		if(lang.isArray(inIndex)){
			array.forEach(inIndex, this.deselect, this);
			return;
		}
		inIndex = Number(inIndex);
		if(this.selectedIndex == inIndex){
			this.selectedIndex = -1;
		}
		if(this.selected[inIndex]){
			if(this.onCanDeselect(inIndex) === false){
				return;
			}
			var rowNode = this.grid.getRowNode(inIndex);
			if(rowNode){
				domAttr.set(rowNode, "aria-selected", "false");
			}
			this._beginUpdate();
			delete this.selected[inIndex];
			//this.grid.onDeselected(inIndex);
			this.onDeselected(inIndex);
			//this.onSetSelected(inIndex, false);
			this._endUpdate();
		}
	},

	setSelected: function(inIndex, inSelect){
		this[(inSelect ? 'addToSelection' : 'deselect')](inIndex);
	},

	toggleSelect: function(inIndex){
		if(lang.isArray(inIndex)){
			array.forEach(inIndex, this.toggleSelect, this);
			return;
		}
		this.setSelected(inIndex, !this.selected[inIndex]);
	},

	_range: function(inFrom, inTo, func){
		var s = (inFrom >= 0 ? inFrom : inTo), e = inTo;
		if(s > e){
			e = s;
			s = inTo;
		}
		for(var i=s; i<=e; i++){
			func(i);
		}
	},

	selectRange: function(inFrom, inTo){
		this._range(inFrom, inTo, lang.hitch(this, "addToSelection"));
	},

	deselectRange: function(inFrom, inTo){
		this._range(inFrom, inTo, lang.hitch(this, "deselect"));
	},

	insert: function(inIndex){
		this.selected.splice(inIndex, 0, false);
		if(this.selectedIndex >= inIndex){
			this.selectedIndex++;
		}
	},

	remove: function(inIndex){
		this.selected.splice(inIndex, 1);
		if(this.selectedIndex >= inIndex){
			this.selectedIndex--;
		}
	},

	deselectAll: function(inExcept){
		for(var i in this.selected){
			if((i!=inExcept)&&(this.selected[i]===true)){
				this.deselect(i);
			}
		}
	},

	clickSelect: function(inIndex, inCtrlKey, inShiftKey){
		if(this.mode == 'none'){ return; }
		this._beginUpdate();
		if(this.mode != 'extended'){
			this.select(inIndex);
		}else{
			if(!inShiftKey || this.rangeStartIndex < 0){
				this.rangeStartIndex = inIndex;
			}
			if(!inCtrlKey){
				this.deselectAll(inIndex);
			}
			if(inShiftKey){
				this.selectRange(this.rangeStartIndex, inIndex);
			}else if(inCtrlKey){
				this.toggleSelect(inIndex);
			}else{
				this.addToSelection(inIndex);
			}
		}
		this._endUpdate();
	},

	clickSelectEvent: function(e){
		this.clickSelect(e.rowIndex, dojo.isCopyKey(e), e.shiftKey);
	},

	clear: function(){
		this._beginUpdate();
		this.deselectAll();
		this._endUpdate();
	}
});
});
},
'dojox/grid/DataSelection':function(){
define([
	"dojo/_base/declare",
	"./_SelectionPreserver",
	"./Selection"
], function(declare, _SelectionPreserver, Selection){
	
return declare("dojox.grid.DataSelection", Selection, {
	constructor: function(grid){
		if(grid.keepSelection){
			this.preserver = new _SelectionPreserver(this);
		}
	},
	
	destroy: function(){
		if(this.preserver){
			this.preserver.destroy();
		}
	},
	
	getFirstSelected: function(){
		var idx = Selection.prototype.getFirstSelected.call(this);

		if(idx == -1){ return null; }
		return this.grid.getItem(idx);
	},

	getNextSelected: function(inPrev){
		var old_idx = this.grid.getItemIndex(inPrev);
		var idx = Selection.prototype.getNextSelected.call(this, old_idx);

		if(idx == -1){ return null; }
		return this.grid.getItem(idx);
	},

	getSelected: function(){
		var result = [];
		for(var i=0, l=this.selected.length; i<l; i++){
			if(this.selected[i]){
				result.push(this.grid.getItem(i));
			}
		}
		return result;
	},

	addToSelection: function(inItemOrIndex){
		if(this.mode == 'none'){ return; }
		var idx = null;
		if(typeof inItemOrIndex == "number" || typeof inItemOrIndex == "string"){
			idx = inItemOrIndex;
		}else{
			idx = this.grid.getItemIndex(inItemOrIndex);
		}
		Selection.prototype.addToSelection.call(this, idx);
	},

	deselect: function(inItemOrIndex){
		if(this.mode == 'none'){ return; }
		var idx = null;
		if(typeof inItemOrIndex == "number" || typeof inItemOrIndex == "string"){
			idx = inItemOrIndex;
		}else{
			idx = this.grid.getItemIndex(inItemOrIndex);
		}
		Selection.prototype.deselect.call(this, idx);
	},

	deselectAll: function(inItemOrIndex){
		var idx = null;
		if(inItemOrIndex || typeof inItemOrIndex == "number"){
			if(typeof inItemOrIndex == "number" || typeof inItemOrIndex == "string"){
				idx = inItemOrIndex;
			}else{
				idx = this.grid.getItemIndex(inItemOrIndex);
			}
			Selection.prototype.deselectAll.call(this, idx);
		}else{
			this.inherited(arguments);
		}
	}
});
});
},
'dojox/grid/_SelectionPreserver':function(){
define([
	"dojo/_base/declare",
	"dojo/_base/connect",
	"dojo/_base/lang",
	"dojo/_base/array"
], function(declare, connect, lang, array){

return declare("dojox.grid._SelectionPreserver", null, {
	// summary:
	//		Preserve selections across various user actions.
	//
	// description:
	//		When this feature is turned on, Grid will try to preserve selections across actions, e.g. sorting, filtering etc.
	//
	//		Precondition - Identifier(id) is required for store since id is the only way for differentiating row items.
	//		Known issue - The preserved selections might be inaccurate if some unloaded rows are previously selected by range(e.g.SHIFT + click)
	//
	// example:
	// |	//To turn on this - please set 'keepSelection' attribute to true
	// |	<div dojoType="dojox.grid.DataGrid" keepSelection = true .../>
	// |	<div dojoType="dojox.grid.TreeGrid" keepSelection = true .../>
	// |	<div dojoType="dojox.grid.LazyTreeGrid" keepSelection = true .../>
	
	constructor: function(selection){
		this.selection = selection;
		var grid = this.grid = selection.grid;
		this.reset();
		this._connects = [
			connect.connect(grid, '_setStore', this, 'reset'),
			connect.connect(grid, '_addItem', this, '_reSelectById'),
			connect.connect(selection, 'onSelected', lang.hitch(this, '_selectById', true)),
			connect.connect(selection, 'onDeselected', lang.hitch(this, '_selectById', false)),
			connect.connect(selection, 'deselectAll', this, 'reset')
		];
	},
	destroy: function(){
		this.reset();
		array.forEach(this._connects, connect.disconnect);
		delete this._connects;
	},
	reset: function(){
		this._selectedById = {};
	},
	_reSelectById: function(item, index){
		// summary:
		//		When some rows is fetched, determine whether it should be selected.
		if(item && this.grid._hasIdentity){
			this.selection.selected[index] = this._selectedById[this.grid.store.getIdentity(item)];
		}
	},
	_selectById: function(toSelect, inItemOrIndex){
		// summary:
		//		Record selected rows by ID.
		if(this.selection.mode == 'none' || !this.grid._hasIdentity){ return; }
		var item = inItemOrIndex, g = this.grid;
		if(typeof inItemOrIndex == "number" || typeof inItemOrIndex == "string"){
			var entry = g._by_idx[inItemOrIndex];
			item = entry && entry.item;
		}
		if(item){
			this._selectedById[g.store.getIdentity(item)] = !!toSelect;
		}
		return item;
	}
});
});
},
'dojox/grid/enhanced/_PluginManager':function(){
define([
	"dojo/_base/kernel",
	"dojo/_base/lang",
	"dojo/_base/declare",
	"dojo/_base/array",
	"dojo/_base/connect",
	"./_Events",
	"./_FocusManager",
	"../util"
], function(dojo, lang, declare, array, connect, _Events, _FocusManager, util){

var _PluginManager = declare("dojox.grid.enhanced._PluginManager", null, {
	// summary:
	//		Singleton plugin manager
	// description:
	//		Plugin manager is responsible for:
	//
	//		1. Loading required plugins
	//		2. Handling collaboration and dependencies among plugins
	//
	//		Some plugin dependencies:
	//
	//		- "columnReordering" attribute won't work when either DnD or Indirect Selections plugin is on.
		
	// _options: Object
	//		Normalized plugin options
	_options: null,

	// _plugins: Array
	//		Plugin list
	_plugins: null,

	// _connects: Array
	//		Connection list
	_connects: null,

	constructor: function(inGrid){
		this.grid = inGrid;
		this._store = inGrid.store;
		this._options = {};
		this._plugins = [];
		this._connects = [];
		this._parseProps(this.grid.plugins);
		
		inGrid.connect(inGrid, "_setStore", lang.hitch(this, function(store){
			if(this._store !== store){
				this.forEach('onSetStore', [store, this._store]);
				this._store = store;
			}
		}));
	},
	startup: function(){
		this.forEach('onStartUp');
	},
	preInit: function(){
		// summary:
		//		Load appropriate plugins before DataGrid.postCreate().
		//		See EnhancedGrid.postCreate()
		this.grid.focus.destroy();
		this.grid.focus = new _FocusManager(this.grid);
		new _Events(this.grid);//overwrite some default events of DataGrid
		this._init(true);
		this.forEach('onPreInit');
	},
	postInit: function(){
		// summary:
		//		Load plugins after DataGrid.postCreate() - the default phase when plugins are created
		//		See EnhancedGrid.postCreate()
		this._init(false);
		
		array.forEach(this.grid.views.views, this._initView, this);
		this._connects.push(connect.connect(this.grid.views, 'addView', lang.hitch(this, this._initView)));
			
		if(this._plugins.length > 0){
			var edit = this.grid.edit;
			if(edit){ edit.styleRow = function(inRow){}; }
		}
		this.forEach('onPostInit');
	},
	forEach: function(func, args){
		array.forEach(this._plugins, function(p){
			if(!p || !p[func]){ return; }
			p[func].apply(p, args ? args : []);
		});
	},
	_parseProps: function(plugins){
		// summary:
		//		Parse plugins properties
		// plugins: Object
		//		Plugin properties defined by user
		if(!plugins){ return; }
		
		var p, loading = {}, options = this._options, grid = this.grid;
		var registry = _PluginManager.registry;//global plugin registry
		for(p in plugins){
			if(plugins[p]){//filter out boolean false e.g. {p:false}
				this._normalize(p, plugins, registry, loading);
			}
		}
		//"columnReordering" attribute won't work when DnD plugin is turned on.
		if(options.dnd){
			options.columnReordering = false;
		}
		
		//mixin all plugin properties into Grid
		lang.mixin(grid, options);
	},
	_normalize: function(p, plugins, registry, loading){
		// summary:
		//		Normalize plugin properties especially the dependency chain
		// p: String
		//		Plugin name
		// plugins: Object
		//		Plugin properties set by user
		// registry: Object
		//		The global plugin registry
		// loading: Object
		//		Map for checking process state
		if(!registry[p]){ throw new Error('Plugin ' + p + ' is required.');}
		
		if(loading[p]){ throw new Error('Recursive cycle dependency is not supported.'); }
		
		var options = this._options;
		if(options[p]){ return options[p]; }
		
		loading[p] = true;
		//TBD - more strict conditions?
		options[p] = lang.mixin({}, registry[p], lang.isObject(plugins[p]) ? plugins[p] : {});
		
		var dependencies = options[p]['dependency'];
		if(dependencies){
			if(!lang.isArray(dependencies)){
				dependencies = options[p]['dependency'] = [dependencies];
			}
			array.forEach(dependencies, function(dependency){
				if(!this._normalize(dependency, plugins, registry, loading)){
					throw new Error('Plugin ' + dependency + ' is required.');
				}
			}, this);
		}
		delete loading[p];
		return options[p];
	},
	_init: function(pre){
		// summary:
		//		Find appropriate plugins and load them
		// pre: Boolean
		//		True - preInit | False - postInit(by default)
		var p, preInit, options = this._options;
		for(p in options){
			preInit = options[p]['preInit'];
			if((pre ? preInit : !preInit) && options[p]['class'] && !this.pluginExisted(p)){
				this.loadPlugin(p);
			}
		}
	},
	loadPlugin: function(name){
		// summary:
		//		Load required plugin("name")
		// name: String
		//		Plugin name
		// returns: Object
		//		The newly loaded plugin
		var option = this._options[name];
		if(!option){ return null; } //return if no plugin option
		
		var plugin = this.getPlugin(name);
		if(plugin){ return plugin; } //return if plugin("name") already existed
		
		var dependencies = option['dependency'];
		array.forEach(dependencies, function(dependency){
			if(!this.loadPlugin(dependency)){
				throw new Error('Plugin ' + dependency + ' is required.');
			}
		}, this);
		var cls = option['class'];
		delete option['class'];//remove it for safety
		plugin = new this.getPluginClazz(cls)(this.grid, option);
		this._plugins.push(plugin);
		return plugin;
	},
	_initView: function(view){
		// summary:
		//		Overwrite several default behavior for each views(including _RowSelector view)
		if(!view){ return; }
		//add more events handler - _View
		util.funnelEvents(view.contentNode, view, "doContentEvent", ['mouseup', 'mousemove']);
		util.funnelEvents(view.headerNode, view, "doHeaderEvent", ['mouseup']);
	},
	pluginExisted: function(name){
		// summary:
		//		Check if plugin("name") existed
		// name: String
		//		Plugin name
		// returns: Boolean
		//		True - existed | False - not existed
		return !!this.getPlugin(name);
	},
	getPlugin: function(name){
		// summary:
		//		Get plugin("name")
		// name: String
		//		Plugin name
		// returns: Object
		//		Plugin instance
		var plugins = this._plugins;
		name = name.toLowerCase();
		for(var i = 0, len = plugins.length; i < len; i++){
			if(name == plugins[i]['name'].toLowerCase()){
				return plugins[i];
			}
		}
		return null;
	},
	getPluginClazz: function(clazz){
		// summary:
		//		Load target plugin which must be already required (require(..))
		// clazz: Class|String
		//		Plugin class
		if(lang.isFunction(clazz)){
			return clazz;//return if it's already a clazz
		}
		var errorMsg = 'Please make sure Plugin "' + clazz + '" is existed.';
		try{
			var cls = lang.getObject(clazz);
			if(!cls){ throw new Error(errorMsg); }
			return cls;
		}catch(e){
			throw new Error(errorMsg);
		}
	},
	isFixedCell: function(cell){
		// summary:
		//		See if target cell(column) is fixed or not.
		// cell: Object
		//		Target cell(column)
		// returns: Boolean
		//		True - fixed| False - not fixed

		//target cell can use Boolean attributes named "isRowSelector" or "fixedPos" to mark it's a fixed cell(column)
		return cell && (cell.isRowSelector || cell.fixedPos);
	},
	destroy: function(){
		// summary:
		//		Destroy all resources
		array.forEach(this._connects, connect.disconnect);
		this.forEach('destroy');
		if(this.grid.unwrap){
			this.grid.unwrap();
		}
		delete this._connects;
		delete this._plugins;
		delete this._options;
	}
});

_PluginManager.registerPlugin = function(clazz, props){
		// summary:
		//		Register plugins - TODO, a better way rather than global registry?
		// clazz: String
		//		Full class name, e.g. "dojox.grid.enhanced.plugins.DnD"
		// props: Object?
		//		Plugin properties e.g. {"dependency": ["nestedSorting"], ...}
	if(!clazz){
		console.warn("Failed to register plugin, class missed!");
		return;
	}
	var cls = _PluginManager;
	cls.registry = cls.registry || {};
	cls.registry[clazz.prototype.name]/*plugin name*/ = lang.mixin({"class": clazz}, (props ? props : {}));
};

return _PluginManager;

});

},
'dojox/grid/enhanced/_Events':function(){
define([
	"dojo/_base/kernel",
	"dojo/_base/declare",
	"dojo/keys",
	"dojo/_base/html",
	"dojo/_base/event",
	"dojox/grid/_Events"
], function(dojo, declare, keys, html, event, _Events){

return declare("dojox.grid.enhanced._Events", null, {
	// summary:
	//		Overwrite some default events of DataGrid
	//
	// description:
	//		Methods are copied or replaced for overwriting, this might be refined once
	//		an overall plugin architecture is set up for DataGrid.

	// _events: Object
	//		Method map cached from dojox.grid._Events().
	_events: null,

	// headerCellActiveClass: String
	//		css class to apply to grid header cells when activated(mouse down)
	headerCellActiveClass: 'dojoxGridHeaderActive',
	
	// cellActiveClass: String
	//		css class to apply to grid content cells when activated(mouse down)
	cellActiveClass: 'dojoxGridCellActive',
	
	// rowActiveClass: String
	//		css class to apply to grid rows when activated(mouse down)
	rowActiveClass: 'dojoxGridRowActive',

	constructor: function(inGrid){
		//TODO - extend dojox.grid._Events rather than mixin for 1.8
		this._events = new _Events();
		//mixin "this" to Grid
		inGrid.mixin(inGrid, this);
	},
	dokeyup: function(e){
		// summary:
		//		Grid key up event handler.
		// e: Event
		//		Un-decorated event object
		this.focus.currentArea().keyup(e);
	},
	onKeyDown: function(e){
		// summary:
		//		Overwritten, see dojox.grid._Events.onKeyDown();
		if(e.altKey || e.metaKey){ return; }
		var focus = this.focus;
		var editing = this.edit.isEditing();
		switch(e.keyCode){
			case keys.TAB:
				if(e.ctrlKey){ return; }
				focus.tab(e.shiftKey ? -1:1,e);
				break;
			case keys.UP_ARROW:
			case keys.DOWN_ARROW:
				if(editing){ return; }
				focus.currentArea().move(e.keyCode == keys.UP_ARROW ? -1 : 1, 0, e);
				break;
			case keys.LEFT_ARROW:
			case keys.RIGHT_ARROW:
				if(editing){ return; }
				var offset = (e.keyCode == keys.LEFT_ARROW) ? 1 : -1;
				if(html._isBodyLtr()){ offset *= -1; }
				focus.currentArea().move(0, offset, e);
				break;
			case keys.F10:
				if(this.menus && e.shiftKey){
					this.onRowContextMenu(e);
				}
				break;
			default:
				focus.currentArea().keydown(e);
				break;
		}
	},
	//TODO - make the following events more reasonalble - e.g. more accurate conditions
	//events for row selectors
	domouseup: function(e){
		if(e.cellNode){
			this.onMouseUp(e);
		}else{
			this.onRowSelectorMouseUp(e);
		}
	},
	domousedown: function(e){
		if(!e.cellNode){
			this.onRowSelectorMouseDown(e);
		}
	},
	onMouseUp: function(e){
		// summary:
		//		New - Event fired when mouse is up inside grid.
		// e: Event
		//		Decorated event object that contains reference to grid, cell, and rowIndex
		this[e.rowIndex == -1 ? "onHeaderCellMouseUp" : "onCellMouseUp"](e);
	},
	onCellMouseDown: function(e){
		// summary:
		//		Overwritten, see dojox.grid._Events.onCellMouseDown()
		html.addClass(e.cellNode, this.cellActiveClass);
		html.addClass(e.rowNode, this.rowActiveClass);
	},
	onCellMouseUp: function(e){
		// summary:
		//		New - Event fired when mouse is up inside content cell.
		// e: Event
		//		Decorated event object that contains reference to grid, cell, and rowIndex
		html.removeClass(e.cellNode, this.cellActiveClass);
		html.removeClass(e.rowNode, this.rowActiveClass);
	},
	onCellClick: function(e){
		// summary:
		//		Overwritten, see dojox.grid._Events.onCellClick()

		//invoke dojox.grid._Events.onCellClick()
		this._events.onCellClick.call(this, e);
		//move mouse events to the focus manager.
		this.focus.contentMouseEvent(e);//TODO
	},
	onCellDblClick: function(e){
		// summary:
		//		Overwritten, see dojox.grid._Events.onCellDblClick()
		if(this.pluginMgr.isFixedCell(e.cell)){ return; }
		if(this._click.length > 1 && (!this._click[0] || !this._click[1])){
			this._click[0] = this._click[1] = e;
		}
		//invoke dojox.grid._Events.onCellDblClick()
		this._events.onCellDblClick.call(this, e);
	},
	onRowClick: function(e){
		// summary:
		//		Overwritten, see dojox.grid._Events.onRowClick()
		this.edit.rowClick(e);
		if(!e.cell || !this.plugin('indirectSelection')){
			this.selection.clickSelectEvent(e);
		}
	},
	onRowContextMenu: function(e){
		// summary:
		//		Overwritten, see dojox.grid._Events.onRowContextMenu()
		if(!this.edit.isEditing() && this.menus){
			this.showMenu(e);
		}
	},
	onSelectedRegionContextMenu: function(e){
		// summary:
		//		New - Event fired when a selected region context menu is accessed via mouse right click.
		// e: Event
		//		Decorated event object which contains reference to grid and info of selected
		//		regions(selection type - row|column, selected index - [...])
		if(this.selectedRegionMenu){
			this.selectedRegionMenu._openMyself({
				target: e.target,
				coords: e.keyCode !== keys.F10 && "pageX" in e ? {
					x: e.pageX,
					y: e.pageY
				} : null
			});
			event.stop(e);
		}
	},
	onHeaderCellMouseOut: function(e){
		// summary:
		//		Overwritten, see dojox.grid._Events.onHeaderCellMouseOut()
		if(e.cellNode){
			html.removeClass(e.cellNode, this.cellOverClass);
			html.removeClass(e.cellNode, this.headerCellActiveClass);
		}
	},
	onHeaderCellMouseDown: function(e){
		// summary:
		//		Overwritten, see dojox.grid._Events.onHeaderCellMouseDown()
		if(e.cellNode){//TBD - apply to selection region for nested sorting?
			html.addClass(e.cellNode, this.headerCellActiveClass);
		}
	},
	onHeaderCellMouseUp: function(e){
		// summary:
		//		New event
		if(e.cellNode){
			html.removeClass(e.cellNode, this.headerCellActiveClass);
		}
	},
	onHeaderCellClick: function(e){
		// summary:
		//		Overwritten, see dojox.grid._Events.onHeaderCellClick()
		
		//move focus to header.
		this.focus.currentArea("header");
		//invoke dojox.grid._Events.onHeaderCellClick()
		if(!e.cell.isRowSelector){
			this._events.onHeaderCellClick.call(this, e);
		}
		//move mouse events to the focus manager.
		this.focus.headerMouseEvent(e);
	},
	onRowSelectorMouseDown: function(e){
		this.focus.focusArea("rowHeader", e);
	},
	
	onRowSelectorMouseUp: function(e){},
	
	//triggered in _View, see Selector plugin
	onMouseUpRow: function(e){
		if(e.rowIndex != -1){
			this.onRowMouseUp(e);
		}
	},
	onRowMouseUp: function(e){}
});
});
},
'dojox/grid/enhanced/_FocusManager':function(){
define([
	"dojo/_base/kernel",
	"dojo/_base/lang",
	"dojo/_base/declare",
	"dojo/_base/array",
	"dojo/_base/connect",
	"dojo/_base/event",
	"dojo/_base/sniff",
	"dojo/_base/html",
	"dojo/keys",
	"dijit/a11y",
	"dijit/focus",
	"../_FocusManager"
], function(dojo, lang, declare, array, connect, event, has, html, keys, dijitA11y, dijitFocus, _FocusManager){

var _FocusArea = declare("dojox.grid.enhanced._FocusArea", null, {
	// summary:
	//		This is a friend class of _FocusManager
/*=====
		// name: string
		//		Name of this area.
		name: "",

		onFocus: function(event, step){
			// summary:
			//		Called when this area logically gets focus.
			// event: Event object
			//		May be unavailable, should check before use.
			// step: Integer
			//		The distance in the tab sequence from last focused area to this area.
			// returns:
			//		whether this area is successfully focused. If not, the next area will get focus.

 			return true;
		},
		
		onBlur: function(event, step){
			// summary:
			//		Called when this area logically loses focus.
			// event: Event object
			//		May be unavailable, should check before use.
			// step: Integer
			//		The distance in the tab sequence from this area to the area to focus.
			// returns:
			//		If Boolean, means whether this area has successfully blurred. If not, the next area to focus is still this one.
			//		If String, means the next area to focus is given by this returned name.

			return true;
		},
		
		onMove: function(rowStep, colStep, event){
			// summary:
			//		Called when focus is moving around within this area.
			// rowStep: Integer
			// colStep: Integer
			// event: Event object
			//		May be unavailable, should check before use.
		},
		
		onKey: function(event, isBubble){
			// summary:
			//		Called when some key is pressed when focus is logically in this area.
			// event: Event object
			// isBubble: Boolean
			//		Whether is in bubble stage (true) or catch stage (false).
			// returns:
			//		If you do NOT want the event to propagate any further along the area stack, return exactly false.
			//		So if you return nothing (undefined), this event is still propagating.
			return true;
		},
		
		getRegions: function(){
			// summary:
			//		Define the small regions (dom nodes) in this area.
			// returns:
			//		Array of dom nodes.
		},
		
		onRegionFocus: function(event){
			// summary:
			//		Connected to the onfocus event of the defined regions (if any)
		},
		
		onRegionBlur: function(event){
			// summary:
			//		Connected to the onblur event of the defined regions (if any)
		},
=====*/
	constructor: function(area, focusManager){
		this._fm = focusManager;
		this._evtStack = [area.name];
		var dummy = function(){return true;};
		area.onFocus = area.onFocus || dummy;
		area.onBlur = area.onBlur || dummy;
		area.onMove = area.onMove || dummy;
		area.onKeyUp = area.onKeyUp || dummy;
		area.onKeyDown = area.onKeyDown || dummy;
		lang.mixin(this, area);
	},
	move: function(rowStep, colStep, evt){
		if(this.name){
			var i, len = this._evtStack.length;
			for(i = len - 1; i >= 0; --i){
				if(this._fm._areas[this._evtStack[i]].onMove(rowStep, colStep, evt) === false){
					return false;
				}
			}
		}
		return true;
	},
	_onKeyEvent: function(evt, funcName){
		if(this.name){
			var i, len = this._evtStack.length;
			for(i = len - 1; i >= 0; --i){
				if(this._fm._areas[this._evtStack[i]][funcName](evt, false) === false){
					return false;
				}
			}
			for(i = 0; i < len; ++i){
				if(this._fm._areas[this._evtStack[i]][funcName](evt, true) === false){
					return false;
				}
			}
		}
		return true;
	},
	keydown: function(evt){
		return this._onKeyEvent(evt, "onKeyDown");
	},
	keyup: function(evt){
		return this._onKeyEvent(evt, "onKeyUp");
	},
	contentMouseEventPlanner: function(){
		return 0;
	},
	headerMouseEventPlanner: function(){
		return 0;
	}
});

return declare("dojox.grid.enhanced._FocusManager", _FocusManager, {
	_stopEvent: function(evt){
		try{
			if(evt && evt.preventDefault){
				event.stop(evt);
			}
		}catch(e){}
	},
	
	constructor: function(grid){
		this.grid = grid;
		this._areas = {};
		this._areaQueue = [];
		this._contentMouseEventHandlers = [];
		this._headerMouseEventHandlers = [];
		this._currentAreaIdx = -1;
		this._gridBlured = true;
		this._connects.push(connect.connect(grid, "onBlur", this, "_doBlur"));
		this._connects.push(connect.connect(grid.scroller, "renderPage", this, "_delayedCellFocus"));
		
		this.addArea({
			name: "header",
			onFocus: lang.hitch(this, this.focusHeader),
			onBlur: lang.hitch(this, this._blurHeader),
			onMove: lang.hitch(this, this._navHeader),
			getRegions: lang.hitch(this, this._findHeaderCells),
			onRegionFocus: lang.hitch(this, this.doColHeaderFocus),
			onRegionBlur: lang.hitch(this, this.doColHeaderBlur),
			onKeyDown: lang.hitch(this, this._onHeaderKeyDown)
		});
		this.addArea({
			name: "content",
			onFocus: lang.hitch(this, this._focusContent),
			onBlur: lang.hitch(this, this._blurContent),
			onMove: lang.hitch(this, this._navContent),
			onKeyDown: lang.hitch(this, this._onContentKeyDown)
		});
		this.addArea({
			name: "editableCell",
			onFocus: lang.hitch(this, this._focusEditableCell),
			onBlur: lang.hitch(this, this._blurEditableCell),
			onKeyDown: lang.hitch(this, this._onEditableCellKeyDown),
			onContentMouseEvent: lang.hitch(this, this._onEditableCellMouseEvent),
			contentMouseEventPlanner: function(evt, areas){ return -1; }
		});
		this.placeArea("header");
		this.placeArea("content");
		this.placeArea("editableCell");
		this.placeArea("editableCell","above","content");
	},
	destroy: function(){
		for(var name in this._areas){
			var area = this._areas[name];
			array.forEach(area._connects, connect.disconnect);
			area._connects = null;
			if(area.uninitialize){
				area.uninitialize();
			}
		}
		this.inherited(arguments);
	},
	addArea: function(area){
		if(area.name && lang.isString(area.name)){
			if(this._areas[area.name]){
				//Just replace the original area, instead of remove it, so the position does not change.
				array.forEach(area._connects, connect.disconnect);
			}
			this._areas[area.name] = new _FocusArea(area, this);
			if(area.onHeaderMouseEvent){
				this._headerMouseEventHandlers.push(area.name);
			}
			if(area.onContentMouseEvent){
				this._contentMouseEventHandlers.push(area.name);
			}
		}
	},
	getArea: function(areaName){
		return this._areas[areaName];
	},
	_bindAreaEvents: function(){
		var area, hdl, areas = this._areas;
		array.forEach(this._areaQueue, function(name){
			area = areas[name];
			if(!area._initialized && lang.isFunction(area.initialize)){
				area.initialize();
				area._initialized = true;
			}
			if(area.getRegions){
				area._regions = area.getRegions() || [];
				array.forEach(area._connects || [], connect.disconnect);
				area._connects = [];
				array.forEach(area._regions, function(r){
					if(area.onRegionFocus){
						hdl = connect.connect(r, "onfocus", area.onRegionFocus);
						area._connects.push(hdl);
					}
					if(area.onRegionBlur){
						hdl = connect.connect(r, "onblur", area.onRegionBlur);
						area._connects.push(hdl);
					}
				});
			}
		});
	},
	removeArea: function(areaName){
		var area = this._areas[areaName];
		if(area){
			this.ignoreArea(areaName);
			var i = array.indexOf(this._contentMouseEventHandlers, areaName);
			if(i >= 0){
				this._contentMouseEventHandlers.splice(i, 1);
			}
			i = array.indexOf(this._headerMouseEventHandlers, areaName);
			if(i >= 0){
				this._headerMouseEventHandlers.splice(i, 1);
			}
			array.forEach(area._connects, connect.disconnect);
			if(area.uninitialize){
				area.uninitialize();
			}
			delete this._areas[areaName];
		}
	},
	currentArea: function(areaName, toBlurOld){
		// summary:
		//		Set current area to the one areaName refers.
		// areaName: String
		var idx, cai = this._currentAreaIdx;
		if(lang.isString(areaName) && (idx = array.indexOf(this._areaQueue, areaName)) >= 0){
			if(cai != idx){
				this.tabbingOut = false;
				if(toBlurOld && cai >= 0 && cai < this._areaQueue.length){
					this._areas[this._areaQueue[cai]].onBlur();
				}
				this._currentAreaIdx = idx;
			}
		}else{
			return (cai < 0 || cai >= this._areaQueue.length) ?
				new _FocusArea({}, this) :
				this._areas[this._areaQueue[this._currentAreaIdx]];
		}
		return null;
	},
	placeArea: function(name, pos, otherAreaName){
		// summary:
		//		Place the area referred by *name* at some logical position relative to an existing area.
		// example:
		//		placeArea("myarea","before"|"after",...)
		//		placeArea("myarea","below"|"above",...)
		if(!this._areas[name]){ return; }
		var idx = array.indexOf(this._areaQueue,otherAreaName);
		switch(pos){
			case "after":
				if(idx >= 0){ ++idx; }
				//intentional drop through
			case "before":
				if(idx >= 0){
					this._areaQueue.splice(idx,0,name);
					break;
				}
				//intentional drop through
			default:
				this._areaQueue.push(name);
				break;
			case "above":
				var isAbove = true;
				//intentional drop through
			case "below":
				var otherArea = this._areas[otherAreaName];
				if(otherArea){
					if(isAbove){
						otherArea._evtStack.push(name);
					}else{
						otherArea._evtStack.splice(0,0,name);
					}
				}
		}
	},
	ignoreArea: function(name){
		this._areaQueue = array.filter(this._areaQueue,function(areaName){
			return areaName != name;
		});
	},
	focusArea: function(/* int|string|areaObj */areaId,evt){
		var idx;
		if(typeof areaId == "number"){
			idx = areaId < 0 ? this._areaQueue.length + areaId : areaId;
		}else{
			idx = array.indexOf(this._areaQueue,
				lang.isString(areaId) ? areaId : (areaId && areaId.name));
		}
		if(idx < 0){ idx = 0; }
		var step = idx - this._currentAreaIdx;
		this._gridBlured = false;
		if(step){
			this.tab(step, evt);
		}else{
			this.currentArea().onFocus(evt, step);
		}
	},
	tab: function(step,evt){
		//console.log("===========tab",step,"curArea",this._currentAreaIdx,"areaCnt",this._areaQueue.length);
		this._gridBlured = false;
		this.tabbingOut = false;
		if(step === 0){
			return;
		}
		var cai = this._currentAreaIdx;
		var dir = step > 0 ? 1:-1;
		if(cai < 0 || cai >= this._areaQueue.length){
			cai = (this._currentAreaIdx += step);
		}else{
			var nextArea = this._areas[this._areaQueue[cai]].onBlur(evt,step);
			if(nextArea === true){
				cai = (this._currentAreaIdx += step);
			}else if(lang.isString(nextArea) && this._areas[nextArea]){
				cai = this._currentAreaIdx = array.indexOf(this._areaQueue,nextArea);
			}
		}
		//console.log("target area:",cai);
		for(; cai >= 0 && cai < this._areaQueue.length; cai += dir){
			this._currentAreaIdx = cai;
			if(this._areaQueue[cai] && this._areas[this._areaQueue[cai]].onFocus(evt,step)){
				//console.log("final target area:",this._currentAreaIdx);
				return;
			}
		}
		//console.log("tab out");
		this.tabbingOut = true;
		if(step < 0){
			this._currentAreaIdx = -1;
			dijitFocus.focus(this.grid.domNode);
		}else{
			this._currentAreaIdx = this._areaQueue.length;
			dijitFocus.focus(this.grid.lastFocusNode);
		}
	},
	_onMouseEvent: function(type, evt){
		var lowercase = type.toLowerCase(),
			handlers = this["_" + lowercase + "MouseEventHandlers"],
			res = array.map(handlers, function(areaName){
				return {
					"area": areaName,
					"idx": this._areas[areaName][lowercase + "MouseEventPlanner"](evt, handlers)
				};
			}, this).sort(function(a, b){
				return b.idx - a.idx;
			}),
			resHandlers = array.map(res, function(handler){
				return res.area;
			}),
			i = res.length;
		while(--i >= 0){
			if(this._areas[res[i].area]["on" + type + "MouseEvent"](evt, resHandlers) === false){
				return;
			}
		}
	},
	contentMouseEvent: function(evt){
		this._onMouseEvent("Content", evt);
	},
	headerMouseEvent: function(evt){
		this._onMouseEvent("Header", evt);
	},
	initFocusView: function(){
		// summary:
		//		Overwritten
		this.focusView = this.grid.views.getFirstScrollingView() || this.focusView || this.grid.views.views[0];
		this._bindAreaEvents();
	},
	isNavHeader: function(){
		// summary:
		//		Overwritten
		//		Check whether currently navigating among column headers.
		// returns:
		//		true - focus is on a certain column header | false otherwise
		return this._areaQueue[this._currentAreaIdx] == "header";
	},
	previousKey: function(e){
		// summary:
		//		Overwritten
		this.tab(-1,e);
	},
	nextKey: function(e){
		// summary:
		//		Overwritten
		this.tab(1,e);
	},
	setFocusCell: function(/* Object */inCell, /* Integer */inRowIndex){
		// summary:
		//		Overwritten - focuses the given grid cell
		if(inCell){
			this.currentArea(this.grid.edit.isEditing() ? "editableCell" : "content", true);
			//This is very slow when selecting cells!
			//this.focusGridView();
			this._focusifyCellNode(false);
			this.cell = inCell;
			this.rowIndex = inRowIndex;
			this._focusifyCellNode(true);
		}
		this.grid.onCellFocus(this.cell, this.rowIndex);
	},
	doFocus: function(e){
		// summary:
		//		Overwritten
		//		trap focus only for grid dom node
		//		do not focus for scrolling if grid is about to blur
		if(e && e.target == e.currentTarget && !this.tabbingOut){
			if(this._gridBlured){
				this._gridBlured = false;
				if(this._currentAreaIdx < 0 || this._currentAreaIdx >= this._areaQueue.length){
					this.focusArea(0, e);
				}else{
					this.focusArea(this._currentAreaIdx, e);
				}
			}
		}else{
			this.tabbingOut = false;
		}
		event.stop(e);
	},
	_doBlur: function(){
		this._gridBlured = true;
	},
	doLastNodeFocus: function(e){
		// summary:
		//		Overwritten
		if(this.tabbingOut){
			this.tabbingOut = false;
		}else{
			this.focusArea(-1, e);
		}
	},
	_delayedHeaderFocus: function(){
		// summary:
		//		Overwritten
		if(this.isNavHeader() && !has('ie')){
			this.focusHeader();
		}
	},
	_delayedCellFocus: function(){
		// summary:
		//		Overwritten
		
		//If focus header here, the page will scroll to grid when the grid is created.
		//this.focusArea("header");
	},
	_changeMenuBindNode: function(oldBindNode, newBindNode){
		var hm = this.grid.headerMenu;
		if(hm && this._contextMenuBindNode == oldBindNode){
			hm.unBindDomNode(oldBindNode);
			hm.bindDomNode(newBindNode);
			this._contextMenuBindNode = newBindNode;
		}
	},
	//---------------Header Area------------------------------------------
	focusHeader: function(evt, step){ //need a further look why these changes to parent's
		// summary:
		//		Overwritten
		var didFocus = false;
		this.inherited(arguments);
		if(this._colHeadNode && html.style(this._colHeadNode, 'display') != "none"){
			dijitFocus.focus(this._colHeadNode);
			this._stopEvent(evt);
			didFocus = true;
		}
		return didFocus;
	},
	_blurHeader: function(evt,step){
		// summary:
		//		Overwritten
		if(this._colHeadNode){
			html.removeClass(this._colHeadNode, this.focusClass);
		}
		html.removeAttr(this.grid.domNode,"aria-activedescendant");
		// reset contextMenu onto viewsHeaderNode so right mouse on header will invoke (see focusHeader)
		this._changeMenuBindNode(this.grid.domNode,this.grid.viewsHeaderNode);
		//moved here from nextKey
		this._colHeadNode = this._colHeadFocusIdx = null;
		return true;
	},
	_navHeader: function(rowStep, colStep, evt){
		var colDir = colStep < 0 ? -1 : 1,
			savedIdx = array.indexOf(this._findHeaderCells(), this._colHeadNode);
		if(savedIdx >= 0 && (evt.shiftKey && evt.ctrlKey)){
			this.colSizeAdjust(evt, savedIdx, colDir * 5);
			return;
		}
		this.move(rowStep, colStep);
	},
	_onHeaderKeyDown: function(e, isBubble){
		if(isBubble){
			var dk = keys;
			switch(e.keyCode){
				case dk.ENTER:
				case dk.SPACE:
					var colIdx = this.getHeaderIndex();
					if(colIdx >= 0 && !this.grid.pluginMgr.isFixedCell(e.cell)/*TODO*/){
						this.grid.setSortIndex(colIdx, null, e);
						event.stop(e);
					}
					break;
			}
		}
		return true;
	},
	_setActiveColHeader: function(){
		// summary:
		//		Overwritten
		this.inherited(arguments);
		//EDG now will decorate event on header key events, if no focus, the cell will be wrong
		dijitFocus.focus(this._colHeadNode);
	},
	//---------------Content Area------------------------------------------
	findAndFocusGridCell: function(){
		// summary:
		//		Overwritten
		this._focusContent();
	},
	_focusContent: function(evt,step){
		var didFocus = true;
		var isEmpty = (this.grid.rowCount === 0); // If grid is empty this.grid.rowCount == 0
		if(this.isNoFocusCell() && !isEmpty){
			//skip all the hidden cells
			for(var i = 0, cell = this.grid.getCell(0); cell && cell.hidden; cell = this.grid.getCell(++i)){}
			this.setFocusIndex(0, cell ? i : 0);
		}else if(this.cell && !isEmpty){
			if(this.focusView && !this.focusView.rowNodes[this.rowIndex]){
				// if rowNode for current index is undefined (likely as a result of a sort and because of #7304)
				// scroll to that row
				this.grid.scrollToRow(this.rowIndex);
				this.focusGrid();
			}else{
				this.setFocusIndex(this.rowIndex, this.cell.index);
			}
		}else{
			didFocus = false;
		}
		if(didFocus){ this._stopEvent(evt); }
		return didFocus;
	},
	_blurContent: function(evt,step){
		this._focusifyCellNode(false);
		return true;
	},
	_navContent: function(rowStep, colStep, evt){
		if((this.rowIndex === 0 && rowStep < 0) || (this.rowIndex === this.grid.rowCount - 1 && rowStep > 0)){
			return;
		}
		this._colHeadNode = null;
		this.move(rowStep, colStep, evt);
		if(evt){
			event.stop(evt);
		}
	},
	_onContentKeyDown: function(e, isBubble){
		if(isBubble){
			var dk = keys, s = this.grid.scroller;
			switch(e.keyCode){
				case dk.ENTER:
				case dk.SPACE:
					var g = this.grid;
					if(g.indirectSelection){ break; }
					g.selection.clickSelect(this.rowIndex, connect.isCopyKey(e), e.shiftKey);
					g.onRowClick(e);
					event.stop(e);
					break;
				case dk.PAGE_UP:
					if(this.rowIndex !== 0){
						if(this.rowIndex != s.firstVisibleRow + 1){
							this._navContent(s.firstVisibleRow - this.rowIndex, 0);
						}else{
							this.grid.setScrollTop(s.findScrollTop(this.rowIndex - 1));
							this._navContent(s.firstVisibleRow - s.lastVisibleRow + 1, 0);
						}
						event.stop(e);
					}
					break;
				case dk.PAGE_DOWN:
					if(this.rowIndex + 1 != this.grid.rowCount){
						event.stop(e);
						if(this.rowIndex != s.lastVisibleRow - 1){
							this._navContent(s.lastVisibleRow - this.rowIndex - 1, 0);
						}else{
							this.grid.setScrollTop(s.findScrollTop(this.rowIndex + 1));
							this._navContent(s.lastVisibleRow - s.firstVisibleRow - 1, 0);
						}
						event.stop(e);
					}
					break;
			}
		}
		return true;
	},
	//------------------editable content area-------------------------
	_blurFromEditableCell: false,
	_isNavigating: false,
	_navElems: null,
	_focusEditableCell: function(evt,step){
		var didFocus = false;
		if(this._isNavigating){
			didFocus = true;
		}else if(this.grid.edit.isEditing() && this.cell){
			if(this._blurFromEditableCell || !this._blurEditableCell(evt, step)){
				this.setFocusIndex(this.rowIndex,this.cell.index);
				didFocus = true;
			}
			this._stopEvent(evt);
		}
		return didFocus;
	},
	_applyEditableCell: function(){
		try{
			this.grid.edit.apply();
		}catch(e){
			console.warn("_FocusManager._applyEditableCell() error:", e);
		}
	},
	_blurEditableCell: function(evt,step){
		this._blurFromEditableCell = false;
		if(this._isNavigating){
			var toBlur = true;
			if(evt){
				var elems = this._navElems;
				var firstElem = elems.lowest || elems.first;
				var lastElem = elems.last || elems.highest || firstElem;
				var target = has('ie') ? evt.srcElement : evt.target;
				toBlur = target == (step > 0 ? lastElem : firstElem);
			}
			if(toBlur){
				this._isNavigating = false;
				html.setSelectable(this.cell.getNode(this.rowIndex), false);
				return "content";
			}
			return false;
		}else if(this.grid.edit.isEditing() && this.cell){
			if(!step || typeof step != "number"){ return false; }
			var dir = step > 0 ? 1 : -1;
			var cc = this.grid.layout.cellCount;
			for(var cell, col = this.cell.index + dir; col >= 0 && col < cc; col += dir){
				cell = this.grid.getCell(col);
				if(cell.editable){
					this.cell = cell;
					this._blurFromEditableCell = true;
					return false;
				}
			}
			if((this.rowIndex > 0 || dir == 1) && (this.rowIndex < this.grid.rowCount || dir == -1)){
				this.rowIndex += dir;
				//this.cell = this.grid.getCell(0); //There must be an editable cell, so this is not necessary.
				for(col = dir > 0 ? 0 : cc - 1; col >= 0 && col < cc; col += dir){
					cell = this.grid.getCell(col);
					if(cell.editable){
						this.cell = cell;
						break;
					}
				}
				this._applyEditableCell();
				return "content";
			}
		}
		return true;
	},
	_initNavigatableElems: function(){
		this._navElems = dijitA11y._getTabNavigable(this.cell.getNode(this.rowIndex));
	},
	_onEditableCellKeyDown: function(e, isBubble){
		var dk = keys,
			g = this.grid,
			edit = g.edit,
			editApplied = false,
			toPropagate = true;
		switch(e.keyCode){
			case dk.ENTER:
				if(isBubble && edit.isEditing()){
					this._applyEditableCell();
					editApplied = true;
					event.stop(e);
				}
				//intentional drop through
			case dk.SPACE:
				if(!isBubble && this._isNavigating){
					toPropagate = false;
					break;
				}
				if(isBubble){
					if(!this.cell.editable && this.cell.navigatable){
						this._initNavigatableElems();
						var toFocus = this._navElems.lowest || this._navElems.first;
						if(toFocus){
							this._isNavigating = true;
							html.setSelectable(this.cell.getNode(this.rowIndex), true);
							dijitFocus.focus(toFocus);
							event.stop(e);
							this.currentArea("editableCell", true);
							break;
						}
					}
					if(!editApplied && !edit.isEditing() && !g.pluginMgr.isFixedCell(this.cell)){
						edit.setEditCell(this.cell, this.rowIndex);
					}
					if(editApplied){
						this.currentArea("content", true);
					}else if(this.cell.editable && g.canEdit()){
						this.currentArea("editableCell", true);
					}
				}
				break;
			case dk.PAGE_UP:
			case dk.PAGE_DOWN:
				if(!isBubble && edit.isEditing()){
					//prevent propagating to content area
					toPropagate = false;
				}
				break;
			case dk.ESCAPE:
				if(!isBubble){
					edit.cancel();
					this.currentArea("content", true);
				}
		}
		return toPropagate;
	},
	_onEditableCellMouseEvent: function(evt){
		if(evt.type == "click"){
			var cell = this.cell || evt.cell;
			if(cell && !cell.editable && cell.navigatable){
				this._initNavigatableElems();
				if(this._navElems.lowest || this._navElems.first){
					var target = has('ie') ? evt.srcElement : evt.target;
					if(target != cell.getNode(evt.rowIndex)){
						this._isNavigating = true;
						this.focusArea("editableCell", evt);
						html.setSelectable(cell.getNode(evt.rowIndex), true);
						dijitFocus.focus(target);
						return false;
					}
				}
			}else if(this.grid.singleClickEdit){
				this.currentArea("editableCell");
				return false;
			}
		}
		return true;
	}
});
});
},
'dojox/grid/enhanced/plugins/_SelectionPreserver':function(){
define([
	"dojo/_base/declare",
	"dojo/_base/lang",
	"dojo/_base/connect",
	'../../_SelectionPreserver'
], function(declare, lang, connect, _SelectionPreserver){

return declare("dojox.grid.enhanced.plugins._SelectionPreserver", _SelectionPreserver, {
	// summary:
	//		Preserve selections across various user actions.
	//
	// description:
	//		Extends dojox.grid._SelectionPreserver adding a bit more support to make selection persistence working well
	//		with various EnhancedGrid features, e.g. filtering, nested sorting, pagination, select all etc.
	//
	//		Precondition - Identifier(id) is required for store, as id is used for differentiating row items.
	//		Known issue - The preserved selections might be inaccurate if some unloaded rows are previously selected by range(e.g.SHIFT + click)
	//
	// example:
	// |	//To turn on this - set 'keepSelection' attribute to true
	// |	<div dojoType="dojox.grid.EnhancedGrid" keepSelection = true .../>
	
	constructor: function(selection){
		var grid = this.grid;
		grid.onSelectedById = this.onSelectedById;
		this._oldClearData = grid._clearData;
		var self = this;
		grid._clearData = function(){
			self._updateMapping(!grid._noInternalMapping);
			self._trustSelection = [];
			self._oldClearData.apply(grid, arguments);
		};
		this._connects.push(
			connect.connect(selection, 'selectRange', lang.hitch(this, '_updateMapping', true, true, false)),
			connect.connect(selection, 'deselectRange', lang.hitch(this, '_updateMapping', true, false, false)),
			connect.connect(selection, 'deselectAll', lang.hitch(this, '_updateMapping', true, false, true))
		);
	},
	destroy: function(){
		this.inherited(arguments);
		this.grid._clearData = this._oldClearData;
	},
	reset: function(){
		this.inherited(arguments);
		this._idMap = [];
		this._trustSelection = [];
		this._defaultSelected = false;
	},
	_reSelectById: function(item, index){
		// summary:
		//		Overwritten
		var s = this.selection, g = this.grid;
		if(item && g._hasIdentity){
			var id = g.store.getIdentity(item);
			if(this._selectedById[id] === undefined){
				if(!this._trustSelection[index]){
					s.selected[index] = this._defaultSelected;
				}
			}else{
				s.selected[index] = this._selectedById[id];
			}
			this._idMap.push(id);
			g.onSelectedById(id, index, s.selected[index]);
		}
	},
	_selectById: function(toSelect, inItemOrIndex){
		// summary:
		//		Overwritten
		if(!this.inherited(arguments)){
			this._trustSelection[inItemOrIndex] = true;
		}
	},
	onSelectedById: function(id, rowIndex, value){},
	
	_updateMapping: function(trustSelection, isSelect, isForAll, from, to){
		// summary:
		//		This function try to keep the selection info updated when range selection is performed.
		//
		//		1. Calculate how many unloaded rows are there;
		//		2. update _selectedById data if grid.selection._selected can be trusted, so loaded but unselected rows can
		//			be properly recorded.
		var s = this.selection, g = this.grid, flag = 0, unloaded = 0, i, id;
		for(i = g.rowCount - 1; i >= 0; --i){
			if(!g._by_idx[i]){
				++unloaded;
				flag += s.selected[i] ? 1 : -1;
			}else{
				id = g._by_idx[i].idty;
				if(id && (trustSelection || this._selectedById[id] === undefined)){
					this._selectedById[id] = !!s.selected[i];
				}
			}
		}
		if(unloaded){
			this._defaultSelected = flag > 0;
		}
		if(!isForAll && from !== undefined && to !== undefined){
			isForAll = !g.usingPagination && Math.abs(to - from + 1) === g.rowCount;
		}
		// When deselectAll, make sure every thing is deselected, even if it was selected but not loaded now.
		// This occurs only when pagination's "All" is used.
		if(isForAll && (!g.usingPagination || g.selectionMode === 'single')){
			for(i = this._idMap.length - 1; i >= 0; --i){
				this._selectedById[this._idMap[i]] = isSelect;
			}
		}
	}
});
});

},
'dojox/mdnd/AreaManager':function(){
define(["dojo/_base/kernel",
	"dojo/_base/declare",
	"dojo/_base/connect",
	"dojo/_base/window",
	"dojo/_base/array",
	"dojo/_base/sniff",
	"dojo/_base/lang",
	"dojo/query",
	"dojo/topic", // topic.publish()
	"dojo/dom-class",
	"dojo/dom-geometry",
	"dojo/dom-construct",
	"dijit/registry",
	"dijit/_Widget",
	"./Moveable"
],function(dojo, declare, connect, win, array, sniff, lang, query, topic, domClass, geom, domConstruct, registry, _Widget, Moveable){
	var am = declare(
		"dojox.mdnd.AreaManager",
		null,
	{
		// summary:
		//		Drag And Drop manager
	
		// autoRefresh: Boolean
		//		Enable the refresh of registered areas on drag start.
		autoRefresh: true,
	
	
		// areaClass: String
		//		CSS class enabled an area if areaClass is defined
		areaClass: "dojoxDndArea",
	
		// dragHandleClass: String
		//		CSS class enabled a drag handle.
		dragHandleClass: "dojoxDragHandle",
	
		constructor: function(){
			// summary:
			//		Constructor of AreaManager class.
			//		Initialize arrays, connects and subscribes.
	
			//console.log("dojox.mdnd.AreaManager ::: constructor");
			this._areaList = [];
			this.resizeHandler = connect.connect(dojo.global,"onresize", this, function(){
				this._dropMode.updateAreas(this._areaList);
			});
			
			this._oldIndexArea = this._currentIndexArea = this._oldDropIndex = this._currentDropIndex = this._sourceIndexArea = this._sourceDropIndex = -1;
		},
	
		init: function(){
			// summary:
			//		Initialize the manager by calling the registerByClass method
	
			//console.log("dojox.mdnd.AreaManager ::: init");
			this.registerByClass();
		},
	
		registerByNode: function(/*DOMNode*/area, /*Boolean*/notInitAreas){
			// summary:
			//		To register Dnd Area : insert the DndArea using the specific sort of dropMode.
			// area:
			//		a DOM node corresponding to the Dnd Area
			// notInitAreas:
			//		if false or undefined, init the areas.
	
			//console.log("dojox.mdnd.AreaManager ::: registerByNode", area);
			var index = this._getIndexArea(area);
			if(area && index == -1){
				var acceptType = area.getAttribute("accept");
				var accept = (acceptType) ? acceptType.split(/\s*,\s*/) : ["text"];
				var obj = {
					'node': area,
					'items': [],
					'coords': {},
					'margin': null,
					'accept': accept,
					'initItems': false
				};
				array.forEach(this._getChildren(area), function(item){
					this._setMarginArea(obj, item);
					obj.items.push(this._addMoveableItem(item));
				}, this);
				this._areaList = this._dropMode.addArea(this._areaList, obj);
				if(!notInitAreas){
					this._dropMode.updateAreas(this._areaList);
				}
				connect.publish("/dojox/mdnd/manager/register",[area]);
			}
		},
	
		registerByClass: function(){
			// summary:
			//		Register all Dnd Areas identified by the attribute areaClass :
			//		insert Dnd Areas using the specific sort of dropMode.
	
			//console.log("dojox.mdnd.AreaManager ::: registerByClass");
			query('.'+this.areaClass).forEach(function(area){
				this.registerByNode(area, true);
			}, this);
			this._dropMode.updateAreas(this._areaList);
		},
	
		unregister: function(/*DOMNode*/area){
			// summary:
			//		Unregister a D&D Area and its children into the AreaManager.
			// area:
			//		A node corresponding to the D&D Area.
			// returns:
			//		True if the area is found and unregistered.
	
			//console.log("dojox.mdnd.AreaManager ::: unregister");
			var index = this._getIndexArea(area);
			if(index != -1){
				array.forEach(this._areaList[index].items, function(item){
					this._deleteMoveableItem(item);
				}, this);
				this._areaList.splice(index,1);
				// refresh target area
				this._dropMode.updateAreas(this._areaList);
				return true; // Boolean
			}
			return false; // Boolean
		},
	
		_addMoveableItem: function(/*DOMNode*/node){
			// summary:
			//		Create a draggable item with a DOM node.
			// node:
			//		A child of the D&D Area.
			// returns:
			//		The draggable item.
			// tags:
			//		protected
	
			//console.log("dojox.mdnd.AreaManager ::: _addMoveableItem");
			node.setAttribute("tabIndex", "0");
			var handle = this._searchDragHandle(node);
			var moveable = new Moveable({ 'handle': handle, 'skip': true }, node);
			// add a css style :
			domClass.add(handle || node, "dragHandle");
			var type = node.getAttribute("dndType");
			var item = {
				'item': moveable,
				'type': type ? type.split(/\s*,\s*/) : ["text"],
				'handlers': [connect.connect(moveable, "onDragStart", this, "onDragStart")]
			}
			// connect to the uninitialize method of dijit._Widget to delete a moveable before a destruct
			if(registry && registry.byNode){
				var widget = registry.byNode(node);
				if(widget){
					item.type = widget.dndType ? widget.dndType.split(/\s*,\s*/) : ["text"];
					item.handlers.push(
						connect.connect(widget, "uninitialize", this, function(){
							this.removeDragItem(node.parentNode, moveable.node);
						})
					);
				}
			}
			return item; // Object
		},
	
		_deleteMoveableItem: function(/*Object*/ objItem){
			// summary:
			//		Delete the Moveable object associated with a node.
			// item:
			//		A moveable Object.
			// tags:
			//		protected
	
			//console.log("dojox.mdnd.AreaManager ::: _deleteMoveableItem", objItem);
			// disconnect the handle
			array.forEach(objItem.handlers, function(handler){
				connect.disconnect(handler);
			});
			// delete css style :
			var node = objItem.item.node,
				handle = this._searchDragHandle(node);
			domClass.remove(handle || node, "dragHandle");
			// call destroy of Moveable class
			objItem.item.destroy();
		},
	
		_getIndexArea: function(/*DOMNode*/area){
			// summary:
			//		Get the index of an area.
			// area:
			//		A moveable Object.
			// returns:
			//		area index or -1
			// tags:
			//		protected
	
			//console.log("dojox.mdnd.AreaManager ::: _getIndexArea");
			if(area){
				for(var i = 0; i < this._areaList.length; i++){
					if(this._areaList[i].node === area){
						return i;	// Integer
					}
				}
			}
			return -1;	// Integer
		},
	
		_searchDragHandle: function(/*DOMNode*/node){
			// summary:
			//		Return the node which contains the first specific CSS class handle.
			// node:
			//		A child of the D&D Area.
			// returns:
			//		The drag handle node.
			// tags:
			//		protected
	
			//console.log("dojox.mdnd.AreaManager ::: _searchDragHandle");
			if(node){
				var cssArray = this.dragHandleClass.split(' '),
					length = cssArray.length,
					queryCss = "";
				array.forEach(cssArray, function(css, i){
					queryCss += "." + css;
					if(i != length - 1){
						queryCss += ", ";
					}
				});
				return query(queryCss, node)[0]; // DomNode
			}
		},
	
		addDragItem: function(/*DOMNode*/area, /*DOMNode*/node, /*Integer*/index, /*Boolean*/notCheckParent){
			// summary:
			//		To add an item programmatically.
			// area:
			//		a node corresponding to the D&D Area
			// node:
			//		the node which has to be treated.
			// index:
			//		the place in the area
			// noCheckParent:
			//		if true, doesn't check if node has a parent.
			// returns:
			//		True if the node has been inserted else false.
	
			//console.log("dojox.mdnd.AreaManager ::: addDragItem");
			var add = true;
			if(!notCheckParent){
				add = area && node && (node.parentNode === null || (node.parentNode && node.parentNode.nodeType !== 1));
			}
			if(add){
				var indexArea = this._getIndexArea(area);
				if(indexArea !== -1){
					var item = this._addMoveableItem(node),
						items = this._areaList[indexArea].items;
					if(0 <= index && index < items.length){
						var firstListChild = items.slice(0, index),
							lastListChild = items.slice(index, items.length);
						firstListChild[firstListChild.length] = item;
						this._areaList[indexArea].items = firstListChild.concat(lastListChild);
						area.insertBefore(node, items[index].item.node);
					}
					else{
						this._areaList[indexArea].items.push(item);
						area.appendChild(node);
					}
					this._setMarginArea(this._areaList[indexArea], node);
					this._areaList[indexArea].initItems = false;
					return true;	// Boolean
				}
			}
			return false;	// Boolean
		},
	
		removeDragItem: function(/*DOMNode*/area, /*DOMNode*/node){
			// summary:
			//		Delete a moveable item programmatically. The node is removed from the area.
			// area:
			//		A node corresponding to the DndArea.
			// node:
			//		The node which has to be treated.
			// returns:
			//		the removed node
	
			//console.log("dojox.mdnd.AreaManager ::: removeDragItem");
			var index = this._getIndexArea(area);
			if(area && index !== -1){
				var items = this._areaList[index].items;
				for(var j = 0; j < items.length; j++){
					if(items[j].item.node === node){
						this._deleteMoveableItem(items[j]);
						// delete item of the array
						items.splice(j, 1);
						return area.removeChild(node); // Object
					}
				}
			}
			return null;
		},
	
		_getChildren: function(/*DOMNode*/area){
			// summary:
			//		Get the children of a D&D area.
			// area:
			//		A DnD area.
			// returns:
			//		The children of a DnD area
			// tags:
			//		protected
	
			//console.log("dojox.mdnd.AreaManager ::: _getChildren");
			var children = [];
			array.forEach(area.childNodes, function(child){
				// delete \n
				if(child.nodeType == 1){
					if(registry && registry.byNode){
						var widget = registry.byNode(child);
						if(widget){
							if(!widget.dragRestriction){
								children.push(child);
							}
						}
						else{
							children.push(child);
						}
					}
					else{
						children.push(child);
					}
				}
			});
			return children;	//Array
		},
	
		_setMarginArea: function(/*Object*/area,/*DOMNode*/node){
			// summary:
			//		Set the value of margin in the data type of areaManager
			//		only when the margin has never been computed.
			// area:
			//		The object of a D&D Area.
			// node:
			//		The node which contains margins
			// tags:
			//		protected
	
			//console.log("dojox.mdnd.AreaManager ::: _setMarginArea");
			if(area && area.margin === null && node){
				area.margin = geom.getMarginExtents(node);
			}
		},
	
		findCurrentIndexArea: function(/*Object*/coords, /*Object*/size){
			// summary:
			//		find the nearest target area according to coordinates.
			//		Coordinates are representing by an object : for example, {'x':10,'y':10}
			// coords:
			//		an object encapsulating X and Y position
			// size:
			//		an object encapsulating the area size
			// returns:
			//		an index of area
	
			//console.log("dojox.mdnd.AreaManager ::: findCurrentIndexArea");
			this._oldIndexArea = this._currentIndexArea;
			this._currentIndexArea = this._dropMode.getTargetArea(this._areaList, coords, this._currentIndexArea);
			if(this._currentIndexArea != this._oldIndexArea){
				if(this._oldIndexArea != -1){
					this.onDragExit(coords, size);
				}
				if(this._currentIndexArea != -1){
					this.onDragEnter(coords, size);
				}
			}
			return this._currentIndexArea;	//Integer
		},
	
		_isAccepted: function(/*Array*/ type, /*Array*/ accept){
			// summary:
			//		True if user can drop widget on this node.
			// type:
			//		Array containing item type
			// accept:
			//		Array containing types
			this._accept = false;
			for(var i = 0; i < accept.length; ++i){
				for(var j = 0; j < type.length;++j){
					if(type[j] == accept[i]){
						this._accept = true;
						break;
					}
				}
			}
		},
	
		onDragStart: function(/*DOMNode*/node, /*Object*/coords, /*Object*/size){
			// summary:
			//		Initialize the drag (see dojox.mdnd.Moveable.initOffsetDrag())
			// node:
			//		The node which is about to be dragged
			// coords:
			//		an object encapsulating X and Y position
			// size:
			//		an object encapsulating width and height values
			// tags:
			//		callback
	
			//console.log("dojox.mdnd.AreaManager ::: onDragStart");
			if(this.autoRefresh){
				this._dropMode.updateAreas(this._areaList);
			}
	
			// Create the cover :
			var _html = (sniff("webkit")) ? dojo.body() : dojo.body().parentNode;
			if(!this._cover){
				this._cover = domConstruct.create('div', {
					'class': "dndCover"
				});
				this._cover2 = lang.clone(this._cover);
				domClass.add(this._cover2, "dndCover2");
			}
			var h = _html.scrollHeight+"px";
			this._cover.style.height = this._cover2.style.height = h;
			dojo.body().appendChild(this._cover);
			dojo.body().appendChild(this._cover2);
	
			this._dragStartHandler = connect.connect(node.ownerDocument, "ondragstart", dojo, "stopEvent");
			// to know the source
			this._sourceIndexArea = this._lastValidIndexArea = this._currentIndexArea = this._getIndexArea(node.parentNode);
			// delete the dragItem into the source area
			var sourceArea = this._areaList[this._sourceIndexArea];
			var children = sourceArea.items;
			for(var i = 0; i < children.length; i++){
				if(children[i].item.node == node){
					this._dragItem = children[i];
					this._dragItem.handlers.push(connect.connect(this._dragItem.item, "onDrag", this, "onDrag"));
					this._dragItem.handlers.push(connect.connect(this._dragItem.item, "onDragEnd", this, "onDrop"));
					children.splice(i,1);
					this._currentDropIndex = this._sourceDropIndex = i;
					break;
				}
			}
			var nodeRef = null;
			if(this._sourceDropIndex !== sourceArea.items.length){
				nodeRef = sourceArea.items[this._sourceDropIndex].item.node;
			}
			// IE7 OPTIMIZATION
			if(sniff("ie")> 7){
				// connect these events on the cover
				this._eventsIE7 = [
					connect.connect(this._cover, "onmouseover", dojo, "stopEvent"),
					connect.connect(this._cover, "onmouseout", dojo, "stopEvent"),
					connect.connect(this._cover, "onmouseenter", dojo, "stopEvent"),
					connect.connect(this._cover, "onmouseleave", dojo, "stopEvent")
				];
			}
	
			var s = node.style;
			s.left = coords.x+"px";
			s.top = coords.y+"px";
			// attach the node to the cover
			if(s.position == "relative" || s.position == ""){
				s.position = "absolute"; // enforcing the absolute mode
			}
			this._cover.appendChild(node);
	
			this._dropIndicator.place(sourceArea.node, nodeRef, size);
			// add a style to place the _dragNode in foreground
			domClass.add(node, "dragNode");
			// A dragged node is always draggable in this source area.
			this._accept = true;
			connect.publish("/dojox/mdnd/drag/start",[node, sourceArea, this._sourceDropIndex]);
		},
	
		onDragEnter: function(/*Object*/coords, /*Object*/size){
			// summary:
			//		Optionally called by the getTargetArea method of TargetFinder class.
			// coords:
			//		coordinates of the dragged Node.
			// size:
			//		size of the dragged Node.
			// tags:
			//		callback
	
			//console.log("dojox.mdnd.AreaManager ::: onDragEnter", coords, size);
			if(this._currentIndexArea === this._sourceIndexArea){
				this._accept = true;
			}
			else{
				this._isAccepted(this._dragItem.type, this._areaList[this._currentIndexArea].accept);
			}
		},
	
		onDragExit: function(/*Object*/coords, /*Object*/size){
			// summary:
			//		Optionally called by the getTargetArea method of TargetFinder class.
			// coords:
			//		coordinates of the dragged Node.
			// size:
			//		size of the dragged Node.
			// tags:
			//		callback
	
			//console.log("dojox.mdnd.AreaManager ::: onDragExit");
			this._accept = false;
		},
	
		onDrag: function(/*DOMNode*/node, /*Object*/coords, /*Object*/size, /*Object*/mousePosition){
			// summary:
			//		Occurs when the dojo.dnd.Moveable.onDrag is fired.
			//		Search the nearest target area and called the placeDropIndicator
			// node:
			//		The node which is dragged
			// coords:
			//		an object encapsulating X and Y position
			// size:
			//		an object encapsulating width and height values
			// mousePosition:
			//		coordinates of mouse
			// tags:
			//		callback
	
			//console.log("dojox.mdnd.AreaManager ::: onDrag", node, ",", coords,size);
			var coordinates = this._dropMode.getDragPoint(coords, size, mousePosition);
			this.findCurrentIndexArea(coordinates, size);
			if(this._currentIndexArea !== -1 && this._accept){
				this.placeDropIndicator(coordinates, size);
			}
		},
	
		placeDropIndicator: function(/*Object*/coords, /*Object*/size){
			// summary:
			//		Search the right place to insert the dropIndicator and display the dropIndicator.
			// coords:
			//		an object encapsulating X and Y position
			// size:
			//		an object encapsulating width and height values
			// returns:
			//		the current drop index
	
			//console.log("dojox.mdnd.AreaManager ::: placeDropIndicator");
			//keep old drop Index
			this._oldDropIndex = this._currentDropIndex;
			// calculate all children marker (see VerticalDropMode.initItems())
			var area = this._areaList[this._currentIndexArea];
			if(!area.initItems){
				this._dropMode.initItems(area);
			}
			//get the index where the drop has to be placed.
			this._currentDropIndex = this._dropMode.getDropIndex(area, coords);
			if(!(this._currentIndexArea === this._oldIndexArea && this._oldDropIndex === this._currentDropIndex)){
				this._placeDropIndicator(size);
			}
			return this._currentDropIndex;	//Integer
		},
	
		_placeDropIndicator: function(/*Object*/size){
			// summary:
			//		place the dropIndicator
			// size:
			//		an object encapsulating width and height values
			// tags:
			//		protected
	
			var oldArea = this._areaList[this._lastValidIndexArea];
			var currentArea = this._areaList[this._currentIndexArea];
			//refresh the previous area after moving out the drop indicator
			this._dropMode.refreshItems(oldArea, this._oldDropIndex, size, false);
			// place dropIndicator
			var node = null;
			if(this._currentDropIndex != -1){
				node = currentArea.items[this._currentDropIndex].item.node;
			}
			this._dropIndicator.place(currentArea.node, node);
			this._lastValidIndexArea = this._currentIndexArea;
			//refresh the current area after placing the drop indicator
			this._dropMode.refreshItems(currentArea, this._currentDropIndex, size, true);
		},
	
		onDropCancel: function(){
			// summary:
			//		Cancel the drop.
			//		The dragNode returns into the source.
			// tags:
			//		callback
	
			//console.log("dojox.mdnd.AreaManager ::: onDropCancel");
			if(!this._accept){
				var index = this._getIndexArea(this._dropIndicator.node.parentNode);
				if(index != -1){
					this._currentIndexArea = index;
				}
				else{
					// case if the dropIndicator is in the area which has been unregistered during the drag.
					// chose by default the first area.
					this._currentIndexArea = 0;
				}
			}
		},
	
		onDrop: function(/*DOMNode*/node){
			// summary:
			//		Drop the dragged item where the dropIndicator is displayed.
			// node:
			//		The node which is about to be dropped
			// tags:
			//		callback
	
			//console.log("dojox.mdnd.AreaManager ::: onDrop");
			//dropCancel
			this.onDropCancel();
			var targetArea = this._areaList[this._currentIndexArea];
			domClass.remove(node, "dragNode");
			var style = node.style;
			style.position = "relative";
			style.left = "0";
			style.top = "0";
			style.width = "auto";
			if(targetArea.node == this._dropIndicator.node.parentNode){
				targetArea.node.insertBefore(node, this._dropIndicator.node);
			}
			else{
				// case if the dropIndicator is in the area which has been unregistered during the drag.
				targetArea.node.appendChild(node);
				this._currentDropIndex = targetArea.items.length;
			}
			// add child into the new target area.
			var indexChild = this._currentDropIndex;
			if(indexChild == -1){
				indexChild = targetArea.items.length;
			}
			var children = targetArea.items;
			var firstListArea = children.slice(0, indexChild);
			var lastListArea = children.slice(indexChild, children.length);
			firstListArea[firstListArea.length] = this._dragItem;
			targetArea.items = firstListArea.concat(lastListArea);
	
			this._setMarginArea(targetArea, node);
			array.forEach(this._areaList, function(obj){
				obj.initItems = false;
			});
			// disconnect onDrop handler
			connect.disconnect(this._dragItem.handlers.pop());
			connect.disconnect(this._dragItem.handlers.pop());
			this._resetAfterDrop();
			// remove the cover
			if(this._cover){
				dojo.body().removeChild(this._cover);
				dojo.body().removeChild(this._cover2);
			}
			connect.publish("/dojox/mdnd/drop",[node, targetArea, indexChild]);
		},
	
		_resetAfterDrop: function(){
			// summary:
			//		reset manager properties after dropping an item
			// tags:
			//		protected
	
			this._accept = false;
			this._dragItem = null;
			this._currentDropIndex = -1;
			this._currentIndexArea = -1;
			this._oldDropIndex = -1;
			this._sourceIndexArea = -1;
			this._sourceDropIndex = -1;
			this._dropIndicator.remove();
			if(this._dragStartHandler){
				connect.disconnect(this._dragStartHandler);
			}
			if(sniff("ie") > 7){
				array.forEach(this._eventsIE7, connect.disconnect);
			}
		},
	
		destroy: function(){
			// summary:
			//		Destroy the component.
	
			//console.log("dojox.mdnd.AreaManager ::: destroy");
			//see implementation of unregister()
			while(this._areaList.length > 0){
				if(!this.unregister(this._areaList[0].node)){
					throw new Error("Error while destroying AreaManager");
				}
			}
			connect.disconnect(this.resizeHandler);
			this._dropIndicator.destroy();
			this._dropMode.destroy();
			if(dojox.mdnd.autoScroll){
				dojox.mdnd.autoScroll.destroy();
			}
			if(this.refreshListener){
				connect.unsubscribe(this.refreshListener);
			}
			// destroy the cover
			if(this._cover){
				domConstruct.destroy(this._cover);
				domConstruct.destroy(this._cover2);
				delete this._cover;
				delete this._cover2;
			}
		}
	});
	
	if(_Widget){
		//	Add a new property to widget
		lang.extend(_Widget, {
			// dndType: String
			//		Defines a type of widget.
			dndType : "text"
		});
	}

	// TODO for 2.0 (or earlier): these values should be set on "am", the export of this module, not in dojox.mdnd
	dojox.mdnd._areaManager = null;
	dojox.mdnd.areaManager = function(){
		// summary:
		//		Returns the current areaManager, creates one if it is not created yet.
		if(!dojox.mdnd._areaManager){
			dojox.mdnd._areaManager = new dojox.mdnd.AreaManager();
		}
		return dojox.mdnd._areaManager;	// Object
	};
	return am;
});
},
'dojox/mdnd/Moveable':function(){
define([
	"dojo/_base/kernel",
	"dojo/_base/declare",
	"dojo/_base/array",
	"dojo/_base/connect",
	"dojo/_base/event",
	"dojo/_base/sniff",
	"dojo/dom",
	"dojo/dom-geometry",
	"dojo/dom-style",
	"dojo/_base/window"
],function(dojo, declare, array, connect, event, sniff, dom, geom, domStyle){
	return declare(
		"dojox.mdnd.Moveable",
		null,
	{
		// summary:
		//		Allow end-users to track a DOM node into the web page
	
		// handle: DOMNode
		//		The node on which the user clicks to drag the main node.
		handle: null,
		
		// skip: Boolean
		//		A flag to control a drag action if a form element has been focused.
		//		If true, the drag action is not executed.
		skip: true,
	
		// dragDistance: Integer
		//		The user clicks on the handle, but the drag action will really begin
		//		if he tracks the main node to more than 3 pixels.
		dragDistance: 3,
		
		constructor: function(/*Object*/params, /*DOMNode*/node){
			// summary:
			//		Configure parameters and listen to mousedown events from handle
			//		node.
			// params:
			//		Hash of parameters
			// node:
			//		The draggable node
	
			//console.log("dojox.mdnd.Moveable ::: constructor");
			this.node = dom.byId(node);
			
			this.d = this.node.ownerDocument;
			
			if(!params){ params = {}; }
			this.handle = params.handle ? dom.byId(params.handle) : null;
			if(!this.handle){ this.handle = this.node; }
			this.skip = params.skip;
			this.events = [
				connect.connect(this.handle, "onmousedown", this, "onMouseDown")
			];
			if(dojox.mdnd.autoScroll){
				this.autoScroll = dojox.mdnd.autoScroll;
			}
			
		},
		
		isFormElement: function(/*DOMEvent*/ e){
			// summary:
			//		identify the type of target node associated with a DOM event.
			// e:
			//		a DOM event
			// returns:
			//		if true, the target is one of those specific nodes.
	
			//console.log("dojox.mdnd.Moveable ::: isFormElement");
			var t = e.target;
			if(t.nodeType == 3 /*TEXT_NODE*/){
				t = t.parentNode;
			}
			return " a button textarea input select option ".indexOf(" " + t.tagName.toLowerCase() + " ") >= 0;	// Boolean
		},
		
		onMouseDown: function(/*DOMEvent*/e){
			// summary:
			//		Occurs when the user clicks on the handle node.
			//		Skip the drag action if a specific node is targeted.
			//		Listens to mouseup and mousemove events on to the HTML document.
			// e:
			//		a DOM event
			// tags:
			//		callback
	
			//console.log("dojox.mdnd.Moveable ::: onMouseDown");
			if(this._isDragging){ return;}
			var isLeftButton = (e.which || e.button) == 1;
			if(!isLeftButton){
				return;
			}
			if(this.skip && this.isFormElement(e)){ return; }
			if(this.autoScroll){
				this.autoScroll.setAutoScrollNode(this.node);
				this.autoScroll.setAutoScrollMaxPage();
			}
			this.events.push(connect.connect(this.d, "onmouseup", this, "onMouseUp"));
			this.events.push(connect.connect(this.d, "onmousemove", this, "onFirstMove"));
			this._selectStart = connect.connect(dojo.body(), "onselectstart", event.stop);
			this._firstX = e.clientX;
			this._firstY = e.clientY;
			event.stop(e);
		},
		
		onFirstMove: function(/*DOMEvent*/e){
			// summary:
			//		Occurs when the user moves the mouse after clicking on the
			//		handle.
			//		Determinate when the drag action will have to begin (see
			//		dragDistance).
			// e:
			//		A DOM event
			// tags:
			//		callback
	
			//console.log("dojox.mdnd.Moveable ::: onFirstMove");
			event.stop(e);
			var d = (this._firstX - e.clientX) * (this._firstX - e.clientX)
					+ (this._firstY - e.clientY) * (this._firstY - e.clientY);
			if(d > this.dragDistance * this.dragDistance){
				this._isDragging = true;
				connect.disconnect(this.events.pop());
				domStyle.set(this.node, "width", geom.getContentBox(this.node).w + "px");
				this.initOffsetDrag(e);
				this.events.push(connect.connect(this.d, "onmousemove", this, "onMove"));
			}
		},
		
		initOffsetDrag: function(/*DOMEvent*/e){
			// summary:
			//		Initialize the gap between main node coordinates and the clicked point.
			//		Call the onDragStart method.
			// e:
			//		A DOM event
	
			//console.log("dojox.mdnd.Moveable ::: initOffsetDrag");
			this.offsetDrag = { 'l': e.pageX, 't': e.pageY };
			var s = this.node.style;
			var position = geom.position(this.node, true);
			/*if(s.position == "relative" || s.position == ""){
				s.position = "absolute"; // enforcing the absolute mode
			}*/
			this.offsetDrag.l = position.x - this.offsetDrag.l;
			this.offsetDrag.t = position.y - this.offsetDrag.t;
			var coords = {
				'x': position.x,
				'y': position.y
			};
			this.size = {
				'w': position.w,
				'h': position.h
			};
			// method to catch
			this.onDragStart(this.node, coords, this.size);
		},
		
		onMove: function(/*DOMEvent*/e){
			// summary:
			//		Occurs when the user moves the mouse.
			//		Calls the onDrag method.
			// e:
			//		a DOM event
			// tags:
			//		callback
	
			//console.log("dojox.mdnd.Moveable ::: onMove");
			event.stop(e);
			// hack to avoid too many calls to onMove in IE8 causing sometimes slowness
			if(sniff("ie") == 8 && new Date() - this.date < 20){
				return;
			}
			if(this.autoScroll){
				this.autoScroll.checkAutoScroll(e);
			}
			var coords = {
				'x': this.offsetDrag.l + e.pageX,
				'y': this.offsetDrag.t + e.pageY
			};
			var s = this.node.style;
			s.left = coords.x + "px";
			s.top = coords.y + "px";
			
			// method to catch
			this.onDrag(this.node, coords, this.size, {'x':e.pageX, 'y':e.pageY});
			if(sniff("ie") == 8){
				this.date = new Date();
			}
		},
		
		onMouseUp: function(/*DOMEvent*/e){
			// summary:
			//		Occurs when the user releases the mouse
			//		Calls the onDragEnd method.
			// e:
			//		a DOM event
	
			if (this._isDragging){
				event.stop(e);
				this._isDragging = false;
				if(this.autoScroll){
					this.autoScroll.stopAutoScroll();
				}
				delete this.onMove;
				this.onDragEnd(this.node);
				this.node.focus();
			}
			connect.disconnect(this.events.pop());
			connect.disconnect(this.events.pop());
		},
		
		onDragStart: function(/*DOMNode*/node, /*Object*/coords, /*Object*/size){
			// summary:
			//		Stub function.
			//		Notes : border box model
			// node:
			//		a DOM node
			// coords:
			//		absolute position of the main node
			// size:
			//		an object encapsulating width an height values
			// tags:
			//		callback
	
		},
		
		onDragEnd: function(/*DOMNode*/node){
			// summary:
			//		Stub function
			//		Notes : Coordinates don't contain margins
			// node:
			//		a DOM node
			// tags:
			//		callback
	
		},
		
		onDrag: function(/*DOMNode*/node, /*Object*/coords, /*Object*/size, /*Object*/mousePosition){
			// summary:
			//		Stub function.
			//		Notes : border box model for size value, margin box model for coordinates
			// node:
			//		a DOM node
			// coords:
			//		position of the main node (equals to css left/top properties)
			// size:
			//		an object encapsulating width and height values
			// mousePosition:
			//		coordiantes of mouse
			// tags:
			//		callback
	
		},
	
		destroy: function(){
			// summary:
			//		Delecte associated events
	
			// console.log("dojox.mdnd.Moveable ::: destroy");
			array.forEach(this.events, connect.disconnect);
			this.events = this.node = null;
		}
	});
});

},
'dojox/mdnd/DropIndicator':function(){
define(["dojo/_base/kernel",
	"dojo/_base/declare",
	"dojo/dom-class",
	"dojo/dom-construct",
	"./AreaManager"
], function(dojo, declare, domClass, domConstruct){
	var di = declare(
		"dojox.mdnd.DropIndicator",
		null,
	{
		// summary:
		//		DropIndicator managment for DnD.
	
		// node: DOMNode
		//		the drop indicator node
		node : null,
			
		constructor: function(){
			//console.log("dojox.mdnd.DropIndicator ::: constructor");
			var dropIndicator = document.createElement("div");
			var subDropIndicator = document.createElement("div");
			dropIndicator.appendChild(subDropIndicator);
			domClass.add(dropIndicator, "dropIndicator");
			this.node = dropIndicator;
		},
		
		place: function(/*Node*/area, /*Node*/nodeRef, /*Object*/size){
			// summary:
			//		Place the DropIndicator in the right place
			// area:
			//		the dnd targer area node
			// nodeRef:
			//		node where the dropIndicator have to be placed into the area
			// dragNode:
			//		the node which is dragged
			// returns:
			//		the node inserted or null if it crashes
	
			//console.log("dojox.mdnd.DropIndicator ::: place");
			if(size){
				this.node.style.height = size.h + "px";
			}
			try{
				if(nodeRef){
					area.insertBefore(this.node, nodeRef);
				}
				else{
					// empty target area or last node => appendChild
					area.appendChild(this.node);
				}
				return this.node;	// DOMNode
			}catch(e){
				return null;
			}
		},
		
		remove: function(){
			// summary:
			//		remove the DropIndicator (not destroy)
	
			//console.log("dojox.mdnd.DropIndicator ::: remove");
			if(this.node){
				//FIX : IE6 problem
				this.node.style.height = "";
				if(this.node.parentNode){
					this.node.parentNode.removeChild(this.node);
				}
			}
		},
		 
		destroy: function(){
			// summary:
			//		destroy the dropIndicator
	
			//console.log("dojox.mdnd.DropIndicator ::: destroy");
			if(this.node){
				if(this.node.parentNode){
					this.node.parentNode.removeChild(this.node);
				}
				domConstruct.destroy(this.node);
				delete this.node;
			}
		}
	});

	dojox.mdnd.areaManager()._dropIndicator = new dojox.mdnd.DropIndicator();
	
	return di;
});

},
'dojox/mdnd/dropMode/DefaultDropMode':function(){
define([
	"dojo/_base/kernel",
	"dojo/_base/declare",
	"dojo/_base/array",
	"dojo/dom-geometry",
	"dojox/mdnd/AreaManager"
],function(dojo, declare, array, geom){
	var ddm = declare("dojox.mdnd.dropMode.DefaultDropMode", null, {
		// summary:
		//		Enabled a type of calcul for Dnd.
		//		Default class to find the nearest target.
	
		// _oldXPoint: Integer
		//		used to save a X position
		_oldXPoint: null,
	
		// _oldYPoint: Integer
		//		used to save a Y position
		_oldYPoint: null,
	
		// _oldBehaviour: String
		//		see `getDragPoint`
		_oldBehaviour: "up",
	
		addArea: function(/*Array*/areas, /*Object*/object){
			// summary:
			//		Add a DnD Area into an array sorting by the x position.
			// areas:
			//		array of areas
			// object:
			//		data type of a DndArea
			// returns:
			//		a sorted area
	
			//console.log("dojox.mdnd.dropMode.DefaultDropMode ::: addArea");
			var length =  areas.length;
			var position = geom.position(object.node, true);
			object.coords = {'x':position.x, 'y':position.y};
			if (length == 0) {
				areas.push(object);
			}else{
				var x =  object.coords.x;
				for (var i = 0; i < length; i++) {
					if (x < areas[i].coords.x) {
						for (var j = length-1; j >= i; j--)
							areas[j + 1] = areas[j];
						areas[i] = object;
						break;
					}
				}
				if (i == length)
					areas.push(object);
			}
			return areas;	// Array
		},
	
		updateAreas: function(/*Array*/areaList){
			// summary:
			//		Refresh intervals between areas to determinate the nearest area to drop an item.
			//		Algorithm :
			//		the marker should be the vertical line passing by the
			//		central point between two contiguous areas.
			//		Note:
			//		If the page has only one targetArea, it's not necessary to calculate coords.
			// areaList:
			//		array of areas
	
			//console.log("dojox.mdnd.dropMode.DefaultDropMode ::: initAreas");
			var length = areaList.length;
			if (length > 1){
				var currentRight, nextLeft;
				for (var i = 0; i < length; i++) {
					var area = areaList[i];
					var nextArea;
					area.coords.x1 = -1;
					area.coords.x2 = -1;
					if (i == 0) {
						nextArea = areaList[i+1];
						this._updateArea(area);
						this._updateArea(nextArea);
						currentRight = area.coords.x + area.node.offsetWidth;
						nextLeft =  nextArea.coords.x;
						area.coords.x2 = currentRight + (nextLeft-currentRight)/2;
					}
					else if (i == length-1) {
						area.coords.x1 = areaList[i-1].coords.x2;
					}else{
						nextArea = areaList[i+1];
						this._updateArea(nextArea);
						currentRight = area.coords.x + area.node.offsetWidth;
						nextLeft =  nextArea.coords.x;
						area.coords.x1 = areaList[i-1].coords.x2;
						area.coords.x2 = currentRight + (nextLeft-currentRight)/2;
					}
				}
			}
		},
	
		_updateArea : function(/*Object*/area){
			// summary:
			//		update the DnD area object (i.e. update coordinates of its DOM node)
			// area:
			//		the DnD area
			// tags:
			//		protected
	
			//console.log("dojox.mdnd.dropMode.DefaultDropMode  ::: _updateArea");
			var position = geom.position(area.node, true);
			area.coords.x = position.x;
			area.coords.y = position.y;
		},
	
		initItems: function(/*Object*/area){
			// summary:
			//		initialize the horizontal line in order to determinate the drop zone.
			// area:
			//		the DnD area
	
			//console.log("dojox.mdnd.dropMode.DefaultDropMode ::: initItems");
			array.forEach(area.items, function(obj){
				//get the vertical middle of the item
				var node = obj.item.node;
				var position = geom.position(node, true);
				var y = position.y + position.h/2;
				obj.y = y;
			});
			area.initItems = true;
		},
	
		refreshItems: function(/*Object*/area, /*Integer*/indexItem, /*Object*/size, /*Boolean*/added){
			// summary:
			//		take into account the drop indicator DOM element in order to compute horizontal lines
			// area:
			//		a DnD area object
			// indexItem:
			//		index of a draggable item
			// size:
			//		dropIndicator size
			// added:
			//		boolean to know if a dropIndicator has been added or deleted
	
			//console.log("dojox.mdnd.dropMode.DefaultDropMode ::: refreshItems");
			if (indexItem == -1) {
				return;
			}else if(area && size && size.h){
				var height = size.h;
				if (area.margin){
					height += area.margin.t;
				}
				var length = area.items.length;
				for (var i=indexItem; i<length; i++){
					var item = area.items[i];
					if (added) {
						item.y += height;
					}else{
						item.y -= height;
					}
				}
			}
		},
	
		getDragPoint: function(/*Object*/coords, /*Object*/size, /*Object*/mousePosition){
			// summary:
			//		return coordinates of the draggable item
			// description:
			//		return for:
			//
			//		- X point : the middle
			//	  	- Y point : search if the user goes up or goes down with his mouse.
			//	  	- Up : top of the draggable item
			//	  	- Down : bottom of the draggable item
			// coords:
			//		an object encapsulating X and Y position
			// size:
			//		an object encapsulating width and height values
			// mousePosition:
			//		coordinates of mouse
			// returns:
			//		an object of coordinates
			//		example : {'x':10,'y':10}
	
			//console.log("dojox.mdnd.dropMode.DefaultDropMode ::: getDragPoint");
			var y = coords.y;
			if (this._oldYPoint){
				if (y > this._oldYPoint) {
					this._oldBehaviour = "down";
					y += size.h;
				}
				else
					if (y <= this._oldYPoint) {
						this._oldBehaviour = "up";
					}
			}
			this._oldYPoint = y;
			return {
				'x': coords.x + (size.w / 2),
				'y': y
				};	// Object
		},
	
		getTargetArea: function(/*Array*/areaList, /*Object*/ coords, /*integer*/currentIndexArea ){
			// summary:
			//		get the nearest DnD area.
			//		Coordinates are basically provided by the ``getDragPoint`` method.
			// areaList:
			//		a list of DnD areas objects
			// coords:
			//		coordinates [x,y] of the dragItem
			// currentIndexArea:
			//		an index representing the active DnD area
			// returns:
			//		the index of the DnD area
	
			//console.log("dojox.mdnd.dropMode.DefaultDropMode ::: getTargetArea");
			var index = 0;
			var x = coords.x;
			var end = areaList.length;
			if (end > 1) {
				var start = 0, direction = "right", compute = false;
				if (currentIndexArea == -1 || arguments.length<3) {
					// first time : Need to search the nearest area in all areas.
					compute = true;
				}
				else {
					// check if it's always the same area
					if (this._checkInterval(areaList, currentIndexArea, x)){
						index = currentIndexArea;
					}else{
						if (this._oldXPoint < x){
							start = currentIndexArea + 1;
						}else{
							start = currentIndexArea - 1;
							end = 0;
							direction = "left";
						}
						compute = true;
					}
				}
				if (compute) {
					if (direction === "right") {
						for (var i = start; i < end; i++) {
							if (this._checkInterval(areaList, i, x)) {
								index = i;
								break;
							}
						}
					}else{
						for (var i = start; i >= end; i--) {
							if (this._checkInterval(areaList, i, x)) {
								index = i;
								break;
							}
						}
					}
				}
			}
			this._oldXPoint = x;
			return index;	// Integer
		},
	
		_checkInterval: function(/*Array*/areaList, /*Integer*/index, /*Coord*/x){
			// summary:
			//		check if the dragNode is in the interval.
			//		The x coordinate is basically provided by the ``getDragPoint`` method.
			// areaList:
			//		a list of DnD areas objects
			// index:
			//		index of a DnD area (to get the interval)
			// x:
			//		coordinate x, of the dragNode
			// returns:
			//		true if the dragNode is in interval
			// tags:
			//		protected
	
			var coords = areaList[index].coords;
			if (coords.x1 == -1) {
				if (x <= coords.x2) {
					return true;
				}
			}
			else
				if (coords.x2 == -1) {
					if (x > coords.x1) {
						return true;
					}
				}
				else {
					if (coords.x1 < x && x <= coords.x2) {
						return true;
					}
				}
			return false;	// Boolean
		},
	
		getDropIndex: function(/*Object*/ targetArea, /*Object*/ coords){
			// summary:
			//		Return the index where the drop has to be placed.
			// targetArea:
			//		a DnD area object
			// coords:
			//		coordinates [x,y] of the draggable item
			// returns:
			//		a number
			//		or -1 if the area has no children or the drop index represents the last position in to the area
	
			//console.log("dojox.mdnd.dropMode.DefaultDropMode ::: getDropIndex");
			var length = targetArea.items.length;
			var coordinates = targetArea.coords;
			var y = coords.y;
			if (length > 0) {
				// course all children in the target area.
				for (var i = 0; i < length; i++) {
					// compare y value with y value of children
					if (y < targetArea.items[i].y) {
						return i;	// Integer
					}
					else {
						if (i == length-1) {
							return -1;
						}
					}
				}
			}
			return -1;
		},
	
		destroy: function(){
			//	can be overwritten.
		}
	});
	
	//------------
	//Singleton
	//------------
	dojox.mdnd.areaManager()._dropMode = new dojox.mdnd.dropMode.DefaultDropMode();
	return ddm;
});

},
'dojox/widget/Standby':function(){
define(["dojo/_base/kernel",
	"dojo/_base/declare",
	"dojo/_base/array",
	"dojo/_base/event",
	"dojo/_base/sniff",
	"dojo/dom",
	"dojo/dom-attr",
	"dojo/dom-construct",
	"dojo/dom-geometry",
	"dojo/dom-style",
	"dojo/window",
	"dojo/_base/window",
	"dojo/_base/fx",
	"dojo/fx",
	"dijit/_Widget",
	"dijit/_TemplatedMixin",
	"dijit/registry"],

function(kernel,
		declare,
		array,
		event,
		has,
		dom,
		attr,
		construct,
		geometry,
		domStyle,
		window,
		baseWindow,
		baseFx,
		fx,
		_Widget,
		_TemplatedMixin,
		registry) {

kernel.experimental("dojox.widget.Standby");

return declare("dojox.widget.Standby", [_Widget, _TemplatedMixin],{
	// summary:
	//		A widget designed to act as a Standby/Busy/Disable/Blocking widget to indicate a
	//		particular DOM node is processing and cannot be clicked on at this time.
	//		This widget uses absolute positioning to apply the overlay and image.

	// image: String
	//		A URL to an image to center within the blocking overlay.
	//		The default is a basic spinner.
	image: require.toUrl("dojox/widget/Standby/images/loading.gif").toString(),

	// imageText: String
	//		Text to set on the ALT tag of the image.
	//		The default is 'Please wait...'
	imageText: "Please Wait...", // TODO: i18n

	// text: String
	//		Text/HTML to display in the center of the overlay
	//		This is used if image center is disabled.
	//		Defaults to 'Please Wait...'
	text: "Please wait...",

	// centerIndicator: String
	//		Property to define if the image and its alt text should be used, or
	//		a simple Text/HTML node should be used.  Allowable values are 'image'
	//		and 'text'.
	//		Default is 'image'.
	centerIndicator: "image",
	
	// target: DOMNode||DOMID(String)||WidgetID(String)
	//		The target to overlay when active.  Can be a widget id, a
	//		dom id, or a direct node reference.
	target: "",

	// color:	String
	//		The color to set the overlay.  Should be in #XXXXXX form.
	//		Default color for the translucent overlay is light gray.
	color: "#C0C0C0",

	// duration: Integer
	//		Integer defining how long the show and hide effects should take in milliseconds.
	//		Defaults to 500
	duration: 500,
	
	// zIndex: String
	//		Control that lets you specify if the zIndex for the overlay
	//		should be auto-computed based off parent zIndex, or should be set
	//		to a particular value.  This is useful when you want to overlay
	//		things in digit.Dialogs, you can specify a base zIndex to append from.
	zIndex: "auto",
	
	// opacity: float
	//		The opacity to make the overlay when it is displayed/faded in.
	//		The default is 0.75.  This does not affect the image opacity, only the
	//		overlay.
	opacity: 0.75,	
	
	// templateString: [protected] String
	//		The template string defining out the basics of the widget.  No need for an external
	//		file.
	templateString:
		"<div>" +
			"<div style=\"display: none; opacity: 0; z-index: 9999; " +
				"position: absolute; cursor:wait;\" dojoAttachPoint=\"_underlayNode\"></div>" +
			"<img src=\"${image}\" style=\"opacity: 0; display: none; z-index: -10000; " +
				"position: absolute; top: 0px; left: 0px; cursor:wait;\" "+
				"dojoAttachPoint=\"_imageNode\">" +
			"<div style=\"opacity: 0; display: none; z-index: -10000; position: absolute; " +
				"top: 0px;\" dojoAttachPoint=\"_textNode\"></div>" +
		"</div>",

	// _underlayNode: [private] DOMNode
	//		The node that is the translucent underlay for the
	//		image that blocks access to the target.
	_underlayNode: null,

	// _imageNode: [private] DOMNode
	//		The image node where we attach and define the image to display.
	_imageNode: null,

	// _textNode: [private] DOMNode
	//		The div to attach text/HTML in the overlay center item.
	_textNode: null,

	// _centerNode: [private] DOMNode
	//		Which node to use as the center node, the image or the text node.
	_centerNode: null,

	// _displayed: [private] Boolean
	//		Flag to indicate if the overlay is displayed or not.
	_displayed: false,

	// _resizeCheck: [private] Object
	//		Handle to interval function that checks the target for changes.
	_resizeCheck: null,

	// _started: [private] Boolean
	//		Trap flag to ensure startup only processes once.
	_started: false,

	// _parent: [private] DOMNode
	//		Wrapping div for the widget, also used for IE 7 in dealing with the
	//		zoom issue.
	_parent: null,

	startup: function(args){
		// summary:
		//		Over-ride of the basic widget startup function.
		//		Configures the target node and sets the image to use.
		if(!this._started){
			if(typeof this.target === "string"){
				var w = registry.byId(this.target);
				this.target = w ? w.domNode : dom.byId(this.target);
			}

			if(this.text){
				this._textNode.innerHTML = this.text;
			}
			if(this.centerIndicator === "image"){
				this._centerNode = this._imageNode;
				attr.set(this._imageNode, "src", this.image);
				attr.set(this._imageNode, "alt", this.imageText);
			}else{
				this._centerNode = this._textNode;
			}
			domStyle.set(this._underlayNode, {
				display: "none",
				backgroundColor: this.color
			});
			domStyle.set(this._centerNode, "display", "none");
			this.connect(this._underlayNode, "onclick", "_ignore");

			//Last thing to do is move the widgets parent, if any, to the current document body.
			//Avoids having to deal with parent relative/absolute mess.  Otherwise positioning
			//tends to go goofy.
			if(this.domNode.parentNode && this.domNode.parentNode != baseWindow.body()){
				baseWindow.body().appendChild(this.domNode);
			}

			//IE 7 has a horrible bug with zoom, so we have to create this node
			//to cross-check later.  Sigh.
			if(has("ie") == 7){
				this._ieFixNode = construct.create("div");
				domStyle.set(this._ieFixNode, {
					opacity: "0",
					zIndex: "-1000",
					position: "absolute",
					top: "-1000px"
				});
				baseWindow.body().appendChild(this._ieFixNode);
			}
			this.inherited(arguments);
		}		
	},

	show: function(){
		// summary:
		//		Function to display the blocking overlay and busy/status icon or text.
		if(!this._displayed){
			if(this._anim){
				this._anim.stop();
				delete this._anim;
			}
			this._displayed = true;
			this._size();
			this._disableOverflow();
			this._fadeIn();
		}
	},

	hide: function(){
		// summary:
		//		Function to hide the blocking overlay and status icon or text.
		if(this._displayed){
			if(this._anim){
				this._anim.stop();
				delete this._anim;
			}
			this._size();
			this._fadeOut();
			this._displayed = false;
			if(this._resizeCheck !== null){
				clearInterval(this._resizeCheck);
				this._resizeCheck = null;
			}
		}
	},

	isVisible: function(){
		// summary:
		//		Helper function so you can test if the widget is already visible or not.
		// returns:
		//		boolean indicating if the widget is in 'show' state or not.
		return this._displayed; // boolean
	},

	onShow: function(){
		// summary:
		//		Event that fires when the display of the Standby completes.
	},

	onHide: function(){
		// summary:
		//		Event that fires when the display of the Standby completes.
	},

	uninitialize: function(){
		// summary:
		//		Over-ride to hide the widget, which clears intervals, before cleanup.
		this._displayed = false;
		if(this._resizeCheck){
			clearInterval(this._resizeCheck);
		}
		domStyle.set(this._centerNode, "display", "none");
		domStyle.set(this._underlayNode, "display", "none");
		if(has("ie") == 7 && this._ieFixNode){
			baseWindow.body().removeChild(this._ieFixNode);
			delete this._ieFixNode;
		}
		if(this._anim){
			this._anim.stop();
			delete this._anim;
		}
		this.target = null;
		this._imageNode = null;
		this._textNode = null;
		this._centerNode = null;
		this.inherited(arguments);
	},

	_size: function(){
		// summary:
		//		Internal function that handles resizing the overlay and
		//		centering of the image on window resizing.
		// tags:
		//		private
		if(this._displayed){
			var dir = attr.get(baseWindow.body(), "dir");
			if(dir){dir = dir.toLowerCase();}
			var _ie7zoom;
			var scrollers = this._scrollerWidths();

			var target = this.target;

			//Show the image and make sure the zIndex is set high.
			var curStyle = domStyle.get(this._centerNode, "display");
			domStyle.set(this._centerNode, "display", "block");
			var box = geometry.position(target, true);
			if(target === baseWindow.body() || target === baseWindow.doc){
				// Target is the whole doc, so scale to viewport.
				box = window.getBox();
				box.x = box.l;
				box.y = box.t;
			}

			var cntrIndicator = geometry.getMarginBox(this._centerNode);
			domStyle.set(this._centerNode, "display", curStyle);

			//IE has a horrible zoom bug.  So, we have to try and account for
			//it and fix up the scaling.
			if(this._ieFixNode){
				_ie7zoom = -this._ieFixNode.offsetTop / 1000;
				box.x = Math.floor((box.x + 0.9) / _ie7zoom);
				box.y = Math.floor((box.y + 0.9) / _ie7zoom);
				box.w = Math.floor((box.w + 0.9) / _ie7zoom);
				box.h = Math.floor((box.h + 0.9) / _ie7zoom);
			}

			//Figure out how to zIndex this thing over the target.
			var zi = domStyle.get(target, "zIndex");
			var ziUl = zi;
			var ziIn = zi;

			if(this.zIndex === "auto"){
				if(zi != "auto"){
					ziUl = parseInt(ziUl, 10) + 1;
					ziIn = parseInt(ziIn, 10) + 2;
				}else{
					//We need to search up the chain to see if there
					//are any parent zIndexs to overlay.
					var cNode = target;
					if(cNode && cNode !== baseWindow.body() && cNode !== baseWindow.doc){
						cNode = target.parentNode;
						var oldZi = -100000;
						while(cNode && cNode !== baseWindow.body()){
							zi = domStyle.get(cNode, "zIndex");
							if(!zi || zi === "auto"){
								cNode = cNode.parentNode;
							}else{
								var newZi = parseInt(zi, 10);
								if(oldZi < newZi){
									oldZi = newZi;
									ziUl = newZi + 1;
									ziIn = newZi + 2;
								}
								// Keep looking until we run out, we want the highest zIndex.
								cNode = cNode.parentNode;
							}
						}
					}
				}
			}else{
				ziUl = parseInt(this.zIndex, 10) + 1;
				ziIn = parseInt(this.zIndex, 10) + 2;
			}

			domStyle.set(this._centerNode, "zIndex", ziIn);
			domStyle.set(this._underlayNode, "zIndex", ziUl);


			var pn = target.parentNode;
			if(pn && pn !== baseWindow.body() &&
				target !== baseWindow.body() &&
				target !== baseWindow.doc){
				
				// If the parent is the body tag itself,
				// we can avoid all this, the body takes
				// care of overflow for me.  Besides, browser
				// weirdness with height and width on body causes
				// problems with this sort of intersect testing
				// anyway.
				var obh = box.h;
				var obw = box.w;
				var pnBox = geometry.position(pn, true);

				//More IE zoom corrections.  Grr.
				if(this._ieFixNode){
					_ie7zoom = -this._ieFixNode.offsetTop / 1000;
					pnBox.x = Math.floor((pnBox.x + 0.9) / _ie7zoom);
					pnBox.y = Math.floor((pnBox.y + 0.9) / _ie7zoom);
					pnBox.w = Math.floor((pnBox.w + 0.9) / _ie7zoom);
					pnBox.h = Math.floor((pnBox.h + 0.9) / _ie7zoom);
				}
				
				//Shift the parent width/height a bit if scollers are present.
				pnBox.w -= pn.scrollHeight > pn.clientHeight &&
					pn.clientHeight > 0 ? scrollers.v: 0;
				pnBox.h -= pn.scrollWidth > pn.clientWidth &&
					pn.clientWidth > 0 ? scrollers.h: 0;

				//RTL requires a bit of massaging in some cases
				//(and differently depending on browser, ugh!)
				//WebKit and others still need work.
				if(dir === "rtl"){
					if(has("opera")){
						box.x += pn.scrollHeight > pn.clientHeight &&
							pn.clientHeight > 0 ? scrollers.v: 0;
						pnBox.x += pn.scrollHeight > pn.clientHeight &&
							pn.clientHeight > 0 ? scrollers.v: 0;
					}else if(has("ie")){
						pnBox.x += pn.scrollHeight > pn.clientHeight &&
							pn.clientHeight > 0 ? scrollers.v: 0;
					}else if(has("webkit")){
						//TODO:  FIX THIS!
					}
				}

				//Figure out if we need to adjust the overlay to fit a viewable
				//area, then resize it, we saved the original height/width above.
				//This is causing issues on IE.  Argh!
				if(pnBox.w < box.w){
					//Scale down the width if necessary.
					box.w = box.w - pnBox.w;
				}
				if(pnBox.h < box.h){
					//Scale down the width if necessary.
					box.h = box.h - pnBox.h;
				}

				//Look at the y positions and see if we intersect with the
				//viewport borders.  Will have to do computations off it.
				var vpTop = pnBox.y;
				var vpBottom = pnBox.y + pnBox.h;
				var bTop = box.y;
				var bBottom = box.y + obh;
				var vpLeft = pnBox.x;
				var vpRight = pnBox.x + pnBox.w;
				var bLeft = box.x;
				var bRight = box.x + obw;
				var delta;
				//Adjust the height now
				if(bBottom > vpTop &&
					bTop < vpTop){
					box.y = pnBox.y;
					//intersecting top, need to do some shifting.
					delta = vpTop - bTop;
					var visHeight = obh - delta;
					//If the visible height < viewport height,
					//We need to shift it.
					if(visHeight < pnBox.h){
						box.h = visHeight;
					}else{
						//Deal with horizontal scrollbars if necessary.
						box.h -= 2*(pn.scrollWidth > pn.clientWidth &&
							pn.clientWidth > 0? scrollers.h: 0);
					}
				}else if(bTop < vpBottom && bBottom > vpBottom){
					//Intersecting bottom, just figure out how much
					//overlay to show.
					box.h = vpBottom - bTop;
				}else if(bBottom <= vpTop || bTop >= vpBottom){
					//Outside view, hide it.
					box.h = 0;
				}

				//adjust width
				if(bRight > vpLeft && bLeft < vpLeft){
					box.x = pnBox.x;
					//intersecting left, need to do some shifting.
					delta = vpLeft - bLeft;
					var visWidth = obw - delta;
					//If the visible width < viewport width,
					//We need to shift it.
					if(visWidth < pnBox.w){
						box.w = visWidth;
					}else{
						//Deal with horizontal scrollbars if necessary.
						box.w -= 2*(pn.scrollHeight > pn.clientHeight &&
							pn.clientHeight > 0? scrollers.w:0);
					}
				}else if(bLeft < vpRight && bRight > vpRight){
					//Intersecting right, just figure out how much
					//overlay to show.
					box.w = vpRight - bLeft;
				}else if(bRight <= vpLeft || bLeft >= vpRight){
					//Outside view, hide it.
					box.w = 0;
				}
			}

			if(box.h > 0 && box.w > 0){
				//Set position and size of the blocking div overlay.
				domStyle.set(this._underlayNode, {
					display: "block",
					width: box.w + "px",
					height: box.h + "px",
					top: box.y + "px",
					left: box.x + "px"
				});

				var styles = ["borderRadius", "borderTopLeftRadius",
					"borderTopRightRadius","borderBottomLeftRadius",
					"borderBottomRightRadius"];
				this._cloneStyles(styles);
				if(!has("ie")){
					//Browser specific styles to try and clone if non-IE.
					styles = ["MozBorderRadius", "MozBorderRadiusTopleft",
						"MozBorderRadiusTopright","MozBorderRadiusBottomleft",
						"MozBorderRadiusBottomright","WebkitBorderRadius",
						"WebkitBorderTopLeftRadius", "WebkitBorderTopRightRadius",
						"WebkitBorderBottomLeftRadius","WebkitBorderBottomRightRadius"
					];
					this._cloneStyles(styles, this);
				}
				var cntrIndicatorTop = (box.h/2) - (cntrIndicator.h/2);
				var cntrIndicatorLeft = (box.w/2) - (cntrIndicator.w/2);
				//Only show the image if there is height and width room.
				if(box.h >= cntrIndicator.h && box.w >= cntrIndicator.w){
					domStyle.set(this._centerNode, {
						top: (cntrIndicatorTop + box.y) + "px",
						left: (cntrIndicatorLeft + box.x) + "px",
						display: "block"
					});
				}else{
					domStyle.set(this._centerNode, "display", "none");
				}
			}else{
				//Target has no size, display nothing on it!
				domStyle.set(this._underlayNode, "display", "none");
				domStyle.set(this._centerNode, "display", "none");
			}
			if(this._resizeCheck === null){
				//Set an interval timer that checks the target size and scales as needed.
				//Checking every 10th of a second seems to generate a fairly smooth update.
				var self = this;
				this._resizeCheck = setInterval(function(){self._size();}, 100);
			}
		}
	},

	_cloneStyles: function(list){
		// summary:
		//		Internal function to clone a set of styles from the target to
		//		the underlay.
		// list: Array
		//		An array of style names to clone.
		//
		// tags:
		//		private
		array.forEach(list, function(s){
			domStyle.set(this._underlayNode, s, domStyle.get(this.target, s));
		}, this);
	},

	_fadeIn: function(){
		// summary:
		//		Internal function that does the opacity style fade in animation.
		// tags:
		//		private
		var self = this;
		var underlayNodeAnim = baseFx.animateProperty({
			duration: self.duration,
			node: self._underlayNode,
			properties: {opacity: {start: 0, end: self.opacity}}
		});
		var imageAnim = baseFx.animateProperty({
			duration: self.duration,
			node: self._centerNode,
			properties: {opacity: {start: 0, end: 1}},
			onEnd: function(){
				self.onShow();
				delete self._anim;
			}
		});
		this._anim = fx.combine([underlayNodeAnim,imageAnim]);
		this._anim.play();
	},

	_fadeOut: function(){
		// summary:
		//		Internal function that does the opacity style fade out animation.
		// tags:
		//		private
		var self = this;
		var underlayNodeAnim = baseFx.animateProperty({
			duration: self.duration,
			node: self._underlayNode,
			properties: {opacity: {start: self.opacity, end: 0}},
			onEnd: function(){
				domStyle.set(this.node,{"display":"none", "zIndex": "-1000"});
			}
		});
		var imageAnim = baseFx.animateProperty({
			duration: self.duration,
			node: self._centerNode,
			properties: {opacity: {start: 1, end: 0}},
			onEnd: function(){
				domStyle.set(this.node,{"display":"none", "zIndex": "-1000"});
				self.onHide();
				self._enableOverflow();
				delete self._anim;
			}
		});
		this._anim = fx.combine([underlayNodeAnim,imageAnim]);
		this._anim.play();
	},

	_ignore: function(e){
		// summary:
		//		Function to ignore events that occur on the overlay.
		// event: Event
		//		The event to halt
		// tags:
		//		private
		if(e){
			event.stop(e);
		}
	},

	_scrollerWidths: function(){
		// summary:
		//		This function will calculate the size of the vertical and
		//		horizontaol scrollbars.
		// returns:
		//		Object of form: {v: Number, h: Number} where v is vertical scrollbar width
		//		and h is horizontal scrollbar width.
		// tags:
		//		private
		var div = construct.create("div");
		domStyle.set(div, {
			position: "absolute",
			opacity: 0,
			overflow: "hidden",
			width: "50px",
			height: "50px",
			zIndex: "-100",
			top: "-200px",
			padding: "0px",
			margin: "0px"
		});
		var iDiv = construct.create("div");
		domStyle.set(iDiv, {
			width: "200px",
			height: "10px"
		});
		div.appendChild(iDiv);
		baseWindow.body().appendChild(div);

		//Figure out content size before and after
		//scrollbars are there, then just subtract to
		//get width.
		var b = geometry.getContentBox(div);
		domStyle.set(div, "overflow", "scroll");
		var a = geometry.getContentBox(div);
		baseWindow.body().removeChild(div);
		return { v: b.w - a.w, h: b.h - a.h };
	},

	/* The following are functions that tie into _Widget.attr() */

	_setTextAttr: function(text){
		// summary:
		//		Function to allow widget.attr to set the text displayed in center
		//		if using text display.
		// text: String
		//		The text to set.
		this._textNode.innerHTML = text;
		this.text = text;
	},

	_setColorAttr: function(c){
		// summary:
		//		Function to allow widget.attr to set the color used for the translucent
		//		div overlay.
		// c: String
		//		The color to set the background underlay to in #XXXXXX format..
		domStyle.set(this._underlayNode, "backgroundColor", c);
		this.color = c;
	},

	_setImageTextAttr: function(text){
		// summary:
		//		Function to allow widget.attr to set the ALT text text displayed for
		//		the image (if using image center display).
		// text: String
		//		The text to set.
		attr.set(this._imageNode, "alt", text);
		this.imageText = text;
	},

	_setImageAttr: function(url){
		// summary:
		//		Function to allow widget.attr to set the url source for the center image
		// text: String
		//		The url to set for the image.
		attr.set(this._imageNode, "src", url);
		this.image = url;
	},

	_setCenterIndicatorAttr: function(indicator){
		// summary:
		//		Function to allow widget.attr to set the node used for the center indicator,
		//		either the image or the text.
		// indicator: String
		//		The indicator to use, either 'image' or 'text'.
		this.centerIndicator = indicator;
		if(indicator === "image"){
			this._centerNode = this._imageNode;
			domStyle.set(this._textNode, "display", "none");
		}else{
			this._centerNode = this._textNode;
			domStyle.set(this._imageNode, "display", "none");
		}
	},

	_disableOverflow: function(){
		 // summary:
		 //		Function to disable scrollbars on the body.  Only used if the overlay
		 //		targets the body or the document.
		 if(this.target === baseWindow.body() || this.target === baseWindow.doc){
			 // Store the overflow state we have to restore later.
			 // IE had issues, so have to check that it's defined.  Ugh.
			 this._overflowDisabled = true;
			 var body = baseWindow.body();
			 if(body.style && body.style.overflow){
				 this._oldOverflow = domStyle.get(body, "overflow");
			 }else{
				 this._oldOverflow = "";
			 }
			 if(has("ie") && !has("quirks")){
				 // IE will put scrollbars in anyway, html (parent of body)
				 // also controls them in standards mode, so we have to
				 // remove them, argh.
				 if(body.parentNode &&
					body.parentNode.style &&
					body.parentNode.style.overflow){
					 this._oldBodyParentOverflow = body.parentNode.style.overflow;
				 }else{
					 try{
						this._oldBodyParentOverflow = domStyle.get(body.parentNode, "overflow");
					 }catch(e){
						 this._oldBodyParentOverflow = "scroll";
					 }
				 }
				 domStyle.set(body.parentNode, "overflow", "hidden");
			 }
			 domStyle.set(body, "overflow", "hidden");
		 }
	},

	_enableOverflow: function(){
		 // summary:
		 //		Function to restore scrollbars on the body.  Only used if the overlay
		 //		targets the body or the document.
		 if(this._overflowDisabled){
			delete this._overflowDisabled;
			var body = baseWindow.body();
			// Restore all the overflow.
			if(has("ie") && !has("quirks")){
				body.parentNode.style.overflow = this._oldBodyParentOverflow;
				delete this._oldBodyParentOverflow;
			}
			domStyle.set(body, "overflow", this._oldOverflow);
			if(has("webkit")){
				//Gotta poke WebKit, or scrollers don't come back. :-(
				var div = construct.create("div", { style: {
						height: "2px"
					}
				});
				body.appendChild(div);
				setTimeout(function(){
					body.removeChild(div);
				}, 0);
			}
			delete this._oldOverflow;
		}
	}
});

});

},
'dijit/Toolbar':function(){
define([
	"require",
	"dojo/_base/declare", // declare
	"dojo/has",
	"dojo/keys", // keys.LEFT_ARROW keys.RIGHT_ARROW
	"dojo/ready",
	"./_Widget",
	"./_KeyNavContainer",
	"./_TemplatedMixin"
], function(require, declare, has, keys, ready, _Widget, _KeyNavContainer, _TemplatedMixin){

	// module:
	//		dijit/Toolbar


	// Back compat w/1.6, remove for 2.0
	if(has("dijit-legacy-requires")){
		ready(0, function(){
			var requires = ["dijit/ToolbarSeparator"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	return declare("dijit.Toolbar", [_Widget, _TemplatedMixin, _KeyNavContainer], {
		// summary:
		//		A Toolbar widget, used to hold things like `dijit/Editor` buttons

		templateString:
			'<div class="dijit" role="toolbar" tabIndex="${tabIndex}" data-dojo-attach-point="containerNode">' +
			'</div>',

		baseClass: "dijitToolbar",

		_onLeftArrow: function(){
			this.focusPrev();
		},

		_onRightArrow: function(){
			this.focusNext();
		}
	});
});

},
'dijit/form/Select':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-class", // domClass.add domClass.remove domClass.toggle
	"dojo/dom-geometry", // domGeometry.setMarginBox
	"dojo/i18n", // i18n.getLocalization
	"dojo/keys",
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/sniff", // has("ie")
	"./_FormSelectWidget",
	"../_HasDropDown",
	"../DropDownMenu",
	"../MenuItem",
	"../MenuSeparator",
	"../Tooltip",
	"../_KeyNavMixin",
	"../registry", // registry.byNode
	"dojo/text!./templates/Select.html",
	"dojo/i18n!./nls/validate"
], function(array, declare, domAttr, domClass, domGeometry, i18n, keys, lang, on, has,
			_FormSelectWidget, _HasDropDown, DropDownMenu, MenuItem, MenuSeparator, Tooltip, _KeyNavMixin, registry, template){

	// module:
	//		dijit/form/Select

	var _SelectMenu = declare("dijit.form._SelectMenu", DropDownMenu, {
		// summary:
		//		An internally-used menu for dropdown that allows us a vertical scrollbar

		// Override Menu.autoFocus setting so that opening a Select highlights the current value.
		autoFocus: true,

		buildRendering: function(){
			this.inherited(arguments);

			this.domNode.setAttribute("role", "listbox");
		},

		postCreate: function(){
			this.inherited(arguments);

			// stop mousemove from selecting text on IE to be consistent with other browsers
			this.own(on(this.domNode, "selectstart", function(evt){
				evt.preventDefault();
				evt.stopPropagation();
			}));
		},

		focus: function(){
			// summary:
			//		Overridden so that the previously selected value will be focused instead of only the first item
			var found = false,
				val = this.parentWidget.value;
			if(lang.isArray(val)){
				val = val[val.length - 1];
			}
			if(val){ // if focus selected
				array.forEach(this.parentWidget._getChildren(), function(child){
					if(child.option && (val === child.option.value)){ // find menu item widget with this value
						found = true;
						this.focusChild(child, false); // focus previous selection
					}
				}, this);
			}
			if(!found){
				this.inherited(arguments); // focus first item by default
			}
		}
	});

	var Select = declare("dijit.form.Select" + (has("dojo-bidi") ? "_NoBidi" : ""), [_FormSelectWidget, _HasDropDown, _KeyNavMixin], {
		// summary:
		//		This is a "styleable" select box - it is basically a DropDownButton which
		//		can take a `<select>` as its input.

		baseClass: "dijitSelect dijitValidationTextBox",

		templateString: template,

		_buttonInputDisabled: has("ie") ? "disabled" : "", // allows IE to disallow focus, but Firefox cannot be disabled for mousedown events

		// required: Boolean
		//		Can be true or false, default is false.
		required: false,

		// state: [readonly] String
		//		"Incomplete" if this select is required but unset (i.e. blank value), "" otherwise
		state: "",

		// message: String
		//		Currently displayed error/prompt message
		message: "",

		// tooltipPosition: String[]
		//		See description of `dijit/Tooltip.defaultPosition` for details on this parameter.
		tooltipPosition: [],

		// emptyLabel: string
		//		What to display in an "empty" dropdown
		emptyLabel: "&#160;", // &nbsp;

		// _isLoaded: Boolean
		//		Whether or not we have been loaded
		_isLoaded: false,

		// _childrenLoaded: Boolean
		//		Whether or not our children have been loaded
		_childrenLoaded: false,

		// labelType: String
		//		Specifies how to interpret the labelAttr in the data store items.
		//		Can be "html" or "text".
		labelType: "html",

		_fillContent: function(){
			// summary:
			//		Set the value to be the first, or the selected index
			this.inherited(arguments);
			// set value from selected option
			if(this.options.length && !this.value && this.srcNodeRef){
				var si = this.srcNodeRef.selectedIndex || 0; // || 0 needed for when srcNodeRef is not a SELECT
				this._set("value", this.options[si >= 0 ? si : 0].value);
			}
			// Create the dropDown widget
			this.dropDown = new _SelectMenu({ id: this.id + "_menu", parentWidget: this });
			domClass.add(this.dropDown.domNode, this.baseClass.replace(/\s+|$/g, "Menu "));
		},

		_getMenuItemForOption: function(/*_FormSelectWidget.__SelectOption*/ option){
			// summary:
			//		For the given option, return the menu item that should be
			//		used to display it.  This can be overridden as needed
			if(!option.value && !option.label){
				// We are a separator (no label set for it)
				return new MenuSeparator({ownerDocument: this.ownerDocument});
			}else{
				// Just a regular menu option
				var click = lang.hitch(this, "_setValueAttr", option);
				var item = new MenuItem({
					option: option,
					label: (this.labelType === 'text' ? (option.label || '').toString()
						.replace(/&/g, '&amp;').replace(/</g, '&lt;') :
						option.label) || this.emptyLabel,
					onClick: click,
					ownerDocument: this.ownerDocument,
					dir: this.dir,
					textDir: this.textDir,
					disabled: option.disabled || false
				});
				item.focusNode.setAttribute("role", "option");
				return item;
			}
		},

		_addOptionItem: function(/*_FormSelectWidget.__SelectOption*/ option){
			// summary:
			//		For the given option, add an option to our dropdown.
			//		If the option doesn't have a value, then a separator is added
			//		in that place.
			if(this.dropDown){
				this.dropDown.addChild(this._getMenuItemForOption(option));
			}
		},

		_getChildren: function(){
			if(!this.dropDown){
				return [];
			}
			return this.dropDown.getChildren();
		},

		focus: function(){
			// Override _KeyNavMixin::focus(), which calls focusFirstChild().
			// We just want the standard form widget behavior.
			if(!this.disabled && this.focusNode.focus){
				try{
					this.focusNode.focus();
				}catch(e){
					/*squelch errors from hidden nodes*/
				}
			}
		},

		focusChild: function(/*dijit/_WidgetBase*/ widget){
			// summary:
			//		Sets the value to the given option, used during search by letter.
			// widget:
			//		Reference to option's widget
			// tags:
			//		protected
			if(widget){
				this.set('value', widget.option);
			}
		},

		_getFirst: function(){
			// summary:
			//		Returns the first child widget.
			// tags:
			//		abstract extension
			var children = this._getChildren();
			return children.length ? children[0] : null;
		},

		_getLast: function(){
			// summary:
			//		Returns the last child widget.
			// tags:
			//		abstract extension
			var children = this._getChildren();
			return children.length ? children[children.length-1] : null;
		},

		childSelector: function(/*DOMNode*/ node){
			// Implement _KeyNavMixin.childSelector, to identify focusable child nodes.
			// If we allowed a dojo/query dependency from this module this could more simply be a string "> *"
			// instead of this function.

			var node = registry.byNode(node);
			return node && node.getParent() == this.dropDown;
		},

		onKeyboardSearch: function(/*dijit/_WidgetBase*/ item, /*Event*/ evt, /*String*/ searchString, /*Number*/ numMatches){
			// summary:
			//		When a key is pressed that matches a child item,
			//		this method is called so that a widget can take appropriate action is necessary.
			// tags:
			//		protected
			if(item){
				this.focusChild(item);
			}
		},

		_loadChildren: function(/*Boolean*/ loadMenuItems){
			// summary:
			//		Resets the menu and the length attribute of the button - and
			//		ensures that the label is appropriately set.
			// loadMenuItems: Boolean
			//		actually loads the child menu items - we only do this when we are
			//		populating for showing the dropdown.

			if(loadMenuItems === true){
				// this.inherited destroys this.dropDown's child widgets (MenuItems).
				// Avoid this.dropDown (Menu widget) having a pointer to a destroyed widget (which will cause
				// issues later in _setSelected). (see #10296)
				if(this.dropDown){
					delete this.dropDown.focusedChild;
					this.focusedChild = null;
				}
				if(this.options.length){
					this.inherited(arguments);
				}else{
					// Drop down menu is blank but add one blank entry just so something appears on the screen
					// to let users know that they are no choices (mimicing native select behavior)
					array.forEach(this._getChildren(), function(child){
						child.destroyRecursive();
					});
					var item = new MenuItem({
						ownerDocument: this.ownerDocument,
						label: this.emptyLabel
					});
					this.dropDown.addChild(item);
				}
			}else{
				this._updateSelection();
			}

			this._isLoaded = false;
			this._childrenLoaded = true;

			if(!this._loadingStore){
				// Don't call this if we are loading - since we will handle it later
				this._setValueAttr(this.value, false);
			}
		},

		_refreshState: function(){
			if(this._started){
				this.validate(this.focused);
			}
		},

		startup: function(){
			this.inherited(arguments);
			this._refreshState(); // after all _set* methods have run
		},

		_setValueAttr: function(value){
			this.inherited(arguments);
			domAttr.set(this.valueNode, "value", this.get("value"));
			this._refreshState();	// to update this.state
		},

		_setNameAttr: "valueNode",

		_setDisabledAttr: function(/*Boolean*/ value){
			this.inherited(arguments);
			this._refreshState();	// to update this.state
		},

		_setRequiredAttr: function(/*Boolean*/ value){
			this._set("required", value);
			this.focusNode.setAttribute("aria-required", value);
			this._refreshState();	// to update this.state
		},

		_setOptionsAttr: function(/*Array*/ options){
			this._isLoaded = false;
			this._set('options', options);
		},

		_setDisplay: function(/*String*/ newDisplay){
			// summary:
			//		sets the display for the given value (or values)

			var lbl = (this.labelType === 'text' ? (newDisplay || '')
					.replace(/&/g, '&amp;').replace(/</g, '&lt;') :
					newDisplay) || this.emptyLabel;
			this.containerNode.innerHTML = '<span role="option" class="dijitReset dijitInline ' + this.baseClass.replace(/\s+|$/g, "Label ") + '">' + lbl + '</span>';
		},

		validate: function(/*Boolean*/ isFocused){
			// summary:
			//		Called by oninit, onblur, and onkeypress, and whenever required/disabled state changes
			// description:
			//		Show missing or invalid messages if appropriate, and highlight textbox field.
			//		Used when a select is initially set to no value and the user is required to
			//		set the value.

			var isValid = this.disabled || this.isValid(isFocused);
			this._set("state", isValid ? "" : (this._hasBeenBlurred ? "Error" : "Incomplete"));
			this.focusNode.setAttribute("aria-invalid", isValid ? "false" : "true");
			var message = isValid ? "" : this._missingMsg;
			if(message && this.focused && this._hasBeenBlurred){
				Tooltip.show(message, this.domNode, this.tooltipPosition, !this.isLeftToRight());
			}else{
				Tooltip.hide(this.domNode);
			}
			this._set("message", message);
			return isValid;
		},

		isValid: function(/*Boolean*/ /*===== isFocused =====*/){
			// summary:
			//		Whether or not this is a valid value.  The only way a Select
			//		can be invalid is when it's required but nothing is selected.
			return (!this.required || this.value === 0 || !(/^\s*$/.test(this.value || ""))); // handle value is null or undefined
		},

		reset: function(){
			// summary:
			//		Overridden so that the state will be cleared.
			this.inherited(arguments);
			Tooltip.hide(this.domNode);
			this._refreshState();	// to update this.state
		},

		postMixInProperties: function(){
			// summary:
			//		set the missing message
			this.inherited(arguments);
			this._missingMsg = i18n.getLocalization("dijit.form", "validate", this.lang).missingMessage;
		},

		postCreate: function(){
			this.inherited(arguments);

			// stop mousemove from selecting text on IE to be consistent with other browsers
			this.own(on(this.domNode, "selectstart", function(evt){
				evt.preventDefault();
				evt.stopPropagation();
			}));

			this.domNode.setAttribute("aria-expanded", "false");

			// Prevent _KeyNavMixin from calling stopPropagation() on left and right arrow keys, thus breaking
			// navigation when Select inside Toolbar.
			var keyNavCodes = this._keyNavCodes;
			delete keyNavCodes[keys.LEFT_ARROW];
			delete keyNavCodes[keys.RIGHT_ARROW];
		},

		_setStyleAttr: function(/*String||Object*/ value){
			this.inherited(arguments);
			domClass.toggle(this.domNode, this.baseClass.replace(/\s+|$/g, "FixedWidth "), !!this.domNode.style.width);
		},

		isLoaded: function(){
			return this._isLoaded;
		},

		loadDropDown: function(/*Function*/ loadCallback){
			// summary:
			//		populates the menu
			this._loadChildren(true);
			this._isLoaded = true;
			loadCallback();
		},

		destroy: function(preserveDom){
			if(this.dropDown && !this.dropDown._destroyed){
				this.dropDown.destroyRecursive(preserveDom);
				delete this.dropDown;
			}
			Tooltip.hide(this.domNode);	// in case Select (or enclosing Dialog) destroyed while tooltip shown
			this.inherited(arguments);
		},

		_onFocus: function(){
			this.validate(true);	// show tooltip if second focus of required tooltip, but no selection
			// Note: not calling superclass _onFocus() to avoid _KeyNavMixin::_onFocus() setting tabIndex --> -1
		},

		_onBlur: function(){
			Tooltip.hide(this.domNode);
			this.inherited(arguments);
			this.validate(false);
		}
	});

	if(has("dojo-bidi")){
		Select = declare("dijit.form.Select", Select, {
			_setDisplay: function(/*String*/ newDisplay){
				this.inherited(arguments);
				this.applyTextDir(this.containerNode);
			}
		});
	}

	Select._Menu = _SelectMenu;	// for monkey patching

	// generic event helper to ensure the dropdown items are loaded before the real event handler is called
	function _onEventAfterLoad(method){
		return function(evt){
			if(!this._isLoaded){
				this.loadDropDown(lang.hitch(this, method, evt));
			}else{
				this.inherited(method, arguments);
			}
		};
	}
	Select.prototype._onContainerKeydown = _onEventAfterLoad("_onContainerKeydown");
	Select.prototype._onContainerKeypress = _onEventAfterLoad("_onContainerKeypress");

	return Select;
});

},
'dijit/form/_FormSelectWidget':function(){
define([
	"dojo/_base/array", // array.filter array.forEach array.map array.some
	"dojo/_base/Deferred",
	"dojo/aspect", // aspect.after
	"dojo/data/util/sorter", // util.sorter.createSortFunction
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"dojo/dom-class", // domClass.toggle
	"dojo/_base/kernel",	// _scopeName
	"dojo/_base/lang", // lang.delegate lang.isArray lang.isObject lang.hitch
	"dojo/query", // query
	"dojo/when",
	"dojo/store/util/QueryResults",
	"./_FormValueWidget"
], function(array, Deferred, aspect, sorter, declare, dom, domClass, kernel, lang, query, when,
			QueryResults, _FormValueWidget){

	// module:
	//		dijit/form/_FormSelectWidget

	/*=====
	var __SelectOption = {
		// value: String
		//		The value of the option.  Setting to empty (or missing) will
		//		place a separator at that location
		// label: String
		//		The label for our option.  It can contain html tags.
		// selected: Boolean
		//		Whether or not we are a selected option
		// disabled: Boolean
		//		Whether or not this specific option is disabled
	};
	=====*/

	var _FormSelectWidget = declare("dijit.form._FormSelectWidget", _FormValueWidget, {
		// summary:
		//		Extends _FormValueWidget in order to provide "select-specific"
		//		values - i.e., those values that are unique to `<select>` elements.
		//		This also provides the mechanism for reading the elements from
		//		a store, if desired.

		// multiple: [const] Boolean
		//		Whether or not we are multi-valued
		multiple: false,

		// options: __SelectOption[]
		//		The set of options for our select item.  Roughly corresponds to
		//		the html `<option>` tag.
		options: null,

		// store: dojo/store/api/Store
		//		A store to use for getting our list of options - rather than reading them
		//		from the `<option>` html tags.   Should support getIdentity().
		//		For back-compat store can also be a dojo/data/api/Identity.
		store: null,
		_setStoreAttr: function(val){
			if(this._created){		// don't repeat work that will happen in postCreate()
				this._deprecatedSetStore(val);
			}
		},

		// query: object
		//		A query to use when fetching items from our store
		query: null,
		_setQueryAttr: function(query){
			if(this._created){		// don't repeat work that will happen in postCreate()
				this._deprecatedSetStore(this.store, this.selectedValue, {query: query});
			}
		},

		// queryOptions: object
		//		Query options to use when fetching from the store
		queryOptions: null,
		_setQueryOptionsAttr: function(queryOptions){
			if(this._created){		// don't repeat work that will happen in postCreate()
				this._deprecatedSetStore(this.store, this.selectedValue, {queryOptions: queryOptions});
			}
		},

		// labelAttr: String?
		//		The entries in the drop down list come from this attribute in the dojo.store items.
		//		If ``store`` is set, labelAttr must be set too, unless store is an old-style
		//		dojo.data store rather than a new dojo/store.
		labelAttr: "",

		// onFetch: Function
		//		A callback to do with an onFetch - but before any items are actually
		//		iterated over (i.e. to filter even further what you want to add)
		onFetch: null,

		// sortByLabel: Boolean
		//		Flag to sort the options returned from a store by the label of
		//		the store.
		sortByLabel: true,


		// loadChildrenOnOpen: Boolean
		//		By default loadChildren is called when the items are fetched from the
		//		store.  This property allows delaying loadChildren (and the creation
		//		of the options/menuitems) until the user clicks the button to open the
		//		dropdown.
		loadChildrenOnOpen: false,

		// onLoadDeferred: [readonly] dojo.Deferred
		//		This is the `dojo.Deferred` returned by setStore().
		//		Calling onLoadDeferred.then() registers your
		//		callback to be called only once, when the prior setStore completes.
		onLoadDeferred: null,

		getOptions: function(/*anything*/ valueOrIdx){
			// summary:
			//		Returns a given option (or options).
			// valueOrIdx:
			//		If passed in as a string, that string is used to look up the option
			//		in the array of options - based on the value property.
			//		(See dijit/form/_FormSelectWidget.__SelectOption).
			//
			//		If passed in a number, then the option with the given index (0-based)
			//		within this select will be returned.
			//
			//		If passed in a dijit/form/_FormSelectWidget.__SelectOption, the same option will be
			//		returned if and only if it exists within this select.
			//
			//		If passed an array, then an array will be returned with each element
			//		in the array being looked up.
			//
			//		If not passed a value, then all options will be returned
			//
			// returns:
			//		The option corresponding with the given value or index.
			//		null is returned if any of the following are true:
			//
			//		- A string value is passed in which doesn't exist
			//		- An index is passed in which is outside the bounds of the array of options
			//		- A dijit/form/_FormSelectWidget.__SelectOption is passed in which is not a part of the select

			// NOTE: the compare for passing in a dijit/form/_FormSelectWidget.__SelectOption checks
			//		if the value property matches - NOT if the exact option exists
			// NOTE: if passing in an array, null elements will be placed in the returned
			//		array when a value is not found.
			var opts = this.options || [];

			if(valueOrIdx == null){
				return opts; // __SelectOption[]
			}
			if(lang.isArray(valueOrIdx)){
				return array.map(valueOrIdx, "return this.getOptions(item);", this); // __SelectOption[]
			}
			if(lang.isString(valueOrIdx)){
				valueOrIdx = { value: valueOrIdx };
			}
			if(lang.isObject(valueOrIdx)){
				// We were passed an option - so see if it's in our array (directly),
				// and if it's not, try and find it by value.

				if(!array.some(opts, function(option, idx){
					for(var a in valueOrIdx){
						if(!(a in option) || option[a] != valueOrIdx[a]){ // == and not === so that 100 matches '100'
							return false;
						}
					}
					valueOrIdx = idx;
					return true; // stops iteration through opts
				})){
					valueOrIdx = -1;
				}
			}
			if(valueOrIdx >= 0 && valueOrIdx < opts.length){
				return opts[valueOrIdx]; // __SelectOption
			}
			return null; // null
		},

		addOption: function(/*__SelectOption|__SelectOption[]*/ option){
			// summary:
			//		Adds an option or options to the end of the select.  If value
			//		of the option is empty or missing, a separator is created instead.
			//		Passing in an array of options will yield slightly better performance
			//		since the children are only loaded once.
			array.forEach(lang.isArray(option) ? option : [option], function(i){
				if(i && lang.isObject(i)){
					this.options.push(i);
				}
			}, this);
			this._loadChildren();
		},

		removeOption: function(/*String|__SelectOption|Number|Array*/ valueOrIdx){
			// summary:
			//		Removes the given option or options.  You can remove by string
			//		(in which case the value is removed), number (in which case the
			//		index in the options array is removed), or select option (in
			//		which case, the select option with a matching value is removed).
			//		You can also pass in an array of those values for a slightly
			//		better performance since the children are only loaded once.
			//		For numeric option values, specify {value: number} as the argument.
			var oldOpts = this.getOptions(lang.isArray(valueOrIdx) ? valueOrIdx : [valueOrIdx]);
			array.forEach(oldOpts, function(option){
				// We can get null back in our array - if our option was not found.  In
				// that case, we don't want to blow up...
				if(option){
					this.options = array.filter(this.options, function(node){
						return (node.value !== option.value || node.label !== option.label);
					});
					this._removeOptionItem(option);
				}
			}, this);
			this._loadChildren();
		},

		updateOption: function(/*__SelectOption|__SelectOption[]*/ newOption){
			// summary:
			//		Updates the values of the given option.  The option to update
			//		is matched based on the value of the entered option.  Passing
			//		in an array of new options will yield better performance since
			//		the children will only be loaded once.
			array.forEach(lang.isArray(newOption) ? newOption : [newOption], function(i){
				var oldOpt = this.getOptions({ value: i.value }), k;
				if(oldOpt){
					for(k in i){
						oldOpt[k] = i[k];
					}
				}
			}, this);
			this._loadChildren();
		},

		setStore: function(store, selectedValue, fetchArgs){
			kernel.deprecated(this.declaredClass+"::setStore(store, selectedValue, fetchArgs) is deprecated. Use set('query', fetchArgs.query), set('queryOptions', fetchArgs.queryOptions), set('store', store), or set('value', selectedValue) instead.", "", "2.0");
			this._deprecatedSetStore(store, selectedValue, fetchArgs);
		},

		_deprecatedSetStore: function(store, selectedValue, fetchArgs){
			// summary:
			//		Sets the store you would like to use with this select widget.
			//		The selected value is the value of the new store to set.  This
			//		function returns the original store, in case you want to reuse
			//		it or something.
			// store: dojo/store/api/Store
			//		The dojo.store you would like to use - it MUST implement getIdentity()
			//		and MAY implement observe().
			//		For backwards-compatibility this can also be a data.data store, in which case
			//		it MUST implement dojo/data/api/Identity,
			//		and MAY implement dojo/data/api/Notification.
			// selectedValue: anything?
			//		The value that this widget should set itself to *after* the store
			//		has been loaded
			// fetchArgs: Object?
			//		Hash of parameters to set filter on store, etc.
			//
			//		- query: new value for Select.query,
			//		- queryOptions: new value for Select.queryOptions,
			//		- onFetch: callback function for each item in data (Deprecated)
			var oStore = this.store;
			fetchArgs = fetchArgs || {};

			if(oStore !== store){
				// Our store has changed, so cancel any listeners on old store (remove for 2.0)
				var h;
				while((h = this._notifyConnections.pop())){
					h.remove();
				}

				// For backwards-compatibility, accept dojo.data store in addition to dojo.store.store.  Remove in 2.0.
				if(!store.get){
					lang.mixin(store, {
						_oldAPI: true,
						get: function(id){
							// summary:
							//		Retrieves an object by it's identity. This will trigger a fetchItemByIdentity.
							//		Like dojo.store.DataStore.get() except returns native item.
							var deferred = new Deferred();
							this.fetchItemByIdentity({
								identity: id,
								onItem: function(object){
									deferred.resolve(object);
								},
								onError: function(error){
									deferred.reject(error);
								}
							});
							return deferred.promise;
						},
						query: function(query, options){
							// summary:
							//		Queries the store for objects.   Like dojo/store/DataStore.query()
							//		except returned Deferred contains array of native items.
							var deferred = new Deferred(function(){
								if(fetchHandle.abort){
									fetchHandle.abort();
								}
							});
							deferred.total = new Deferred();
							var fetchHandle = this.fetch(lang.mixin({
								query: query,
								onBegin: function(count){
									deferred.total.resolve(count);
								},
								onComplete: function(results){
									deferred.resolve(results);
								},
								onError: function(error){
									deferred.reject(error);
								}
							}, options));
							return new QueryResults(deferred);
						}
					});

					if(store.getFeatures()["dojo.data.api.Notification"]){
						this._notifyConnections = [
							aspect.after(store, "onNew", lang.hitch(this, "_onNewItem"), true),
							aspect.after(store, "onDelete", lang.hitch(this, "_onDeleteItem"), true),
							aspect.after(store, "onSet", lang.hitch(this, "_onSetItem"), true)
						];
					}
				}
				this._set("store", store);			// Our store has changed, so update our notifications
			}

			// Remove existing options (if there are any)
			if(this.options && this.options.length){
				this.removeOption(this.options);
			}

			// Cancel listener for updates to old (dojo.data) store
			if(this._queryRes && this._queryRes.close){
				this._queryRes.close();
			}

			// Cancel listener for updates to new (dojo.store) store
			if(this._observeHandle && this._observeHandle.remove){
				this._observeHandle.remove();
				this._observeHandle = null;
			}

			// If user has specified new query and query options along with this new store, then use them.
			if(fetchArgs.query){
				this._set("query", fetchArgs.query);
			}
			if(fetchArgs.queryOptions){
				this._set("queryOptions", fetchArgs.queryOptions);
			}

			// Add our new options
			if(store && store.query){
				this._loadingStore = true;
				this.onLoadDeferred = new Deferred();

				// Run query
				// Save result in this._queryRes so we can cancel the listeners we register below
				this._queryRes = store.query(this.query, this.queryOptions);
				when(this._queryRes, lang.hitch(this, function(items){

					if(this.sortByLabel && !fetchArgs.sort && items.length){
						if(store.getValue){
							// Old dojo.data API to access items, remove for 2.0
							items.sort(sorter.createSortFunction([
								{
									attribute: store.getLabelAttributes(items[0])[0]
								}
							], store));
						}else{
							// TODO: remove sortByLabel completely for 2.0?  It can be handled by queryOptions: {sort: ... }.
							var labelAttr = this.labelAttr;
							items.sort(function(a, b){
								return a[labelAttr] > b[labelAttr] ? 1 : b[labelAttr] > a[labelAttr] ? -1 : 0;
							});
						}
					}

					if(fetchArgs.onFetch){
						items = fetchArgs.onFetch.call(this, items, fetchArgs);
					}

					// TODO: Add these guys as a batch, instead of separately
					array.forEach(items, function(i){
						this._addOptionForItem(i);
					}, this);

					// Register listener for store updates
					if(this._queryRes.observe){
						// observe returns yet another handle that needs its own explicit gc
						this._observeHandle = this._queryRes.observe(lang.hitch(this, function(object, deletedFrom, insertedInto){
							if(deletedFrom == insertedInto){
								this._onSetItem(object);
							}else{
								if(deletedFrom != -1){
									this._onDeleteItem(object);
								}
								if(insertedInto != -1){
									this._onNewItem(object);
								}
							}
						}), true);
					}

					// Set our value (which might be undefined), and then tweak
					// it to send a change event with the real value
					this._loadingStore = false;
					this.set("value", "_pendingValue" in this ? this._pendingValue : selectedValue);
					delete this._pendingValue;

					if(!this.loadChildrenOnOpen){
						this._loadChildren();
					}else{
						this._pseudoLoadChildren(items);
					}
					this.onLoadDeferred.resolve(true);
					this.onSetStore();
				}), function(err){
					console.error('dijit.form.Select: ' + err.toString());
					this.onLoadDeferred.reject(err);
				});
			}
			return oStore;	// dojo/data/api/Identity
		},

		_setValueAttr: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
			// summary:
			//		set the value of the widget.
			//		If a string is passed, then we set our value from looking it up.
			if(!this._onChangeActive){
				priorityChange = null;
			}
			if(this._loadingStore){
				// Our store is loading - so save our value, and we'll set it when
				// we're done
				this._pendingValue = newValue;
				return;
			}
			if(newValue == null){
				return;
			}
			if(lang.isArray(newValue)){
				newValue = array.map(newValue, function(value){
					return lang.isObject(value) ? value : { value: value };
				}); // __SelectOption[]
			}else if(lang.isObject(newValue)){
				newValue = [newValue];
			}else{
				newValue = [
					{ value: newValue }
				];
			}
			newValue = array.filter(this.getOptions(newValue), function(i){
				return i && i.value;
			});
			var opts = this.getOptions() || [];
			if(!this.multiple && (!newValue[0] || !newValue[0].value) && !!opts.length){
				newValue[0] = opts[0];
			}
			array.forEach(opts, function(opt){
				opt.selected = array.some(newValue, function(v){
					return v.value === opt.value;
				});
			});
			var val = array.map(newValue, function(opt){
				return opt.value;
			});

			if(typeof val == "undefined" || typeof val[0] == "undefined"){
				return;
			} // not fully initialized yet or a failed value lookup
			var disp = array.map(newValue, function(opt){
				return opt.label;
			});
			this._setDisplay(this.multiple ? disp : disp[0]);
			this.inherited(arguments, [ this.multiple ? val : val[0], priorityChange ]);
			this._updateSelection();
		},

		_getDisplayedValueAttr: function(){
			// summary:
			//		returns the displayed value of the widget
			var ret = array.map([].concat(this.get('selectedOptions')), function(v){
				if(v && "label" in v){
					return v.label;
				}else if(v){
					return v.value;
				}
				return null;
			}, this);
			return this.multiple ? ret : ret[0];
		},

		_setDisplayedValueAttr: function(label){
			// summary:
			//		Sets the displayed value of the widget
			this.set('value', this.getOptions(typeof label == "string" ? { label: label } : label));
		},

		_loadChildren: function(){
			// summary:
			//		Loads the children represented by this widget's options.
			//		reset the menu to make it populatable on the next click
			if(this._loadingStore){
				return;
			}
			array.forEach(this._getChildren(), function(child){
				child.destroyRecursive();
			});
			// Add each menu item
			array.forEach(this.options, this._addOptionItem, this);

			// Update states
			this._updateSelection();
		},

		_updateSelection: function(){
			// summary:
			//		Sets the "selected" class on the item for styling purposes
			this.focusedChild = null;
			this._set("value", this._getValueFromOpts());
			var val = [].concat(this.value);
			if(val && val[0]){
				var self = this;
				array.forEach(this._getChildren(), function(child){
					var isSelected = array.some(val, function(v){
						return child.option && (v === child.option.value);
					});
					if(isSelected && !self.multiple){
						self.focusedChild = child;
					}
					domClass.toggle(child.domNode, this.baseClass.replace(/\s+|$/g, "SelectedOption "), isSelected);
					child.domNode.setAttribute("aria-selected", isSelected ? "true" : "false");
				}, this);
			}
		},

		_getValueFromOpts: function(){
			// summary:
			//		Returns the value of the widget by reading the options for
			//		the selected flag
			var opts = this.getOptions() || [];
			if(!this.multiple && opts.length){
				// Mirror what a select does - choose the first one
				var opt = array.filter(opts, function(i){
					return i.selected;
				})[0];
				if(opt && opt.value){
					return opt.value;
				}else{
					opts[0].selected = true;
					return opts[0].value;
				}
			}else if(this.multiple){
				// Set value to be the sum of all selected
				return array.map(array.filter(opts, function(i){
					return i.selected;
				}), function(i){
					return i.value;
				}) || [];
			}
			return "";
		},

		// Internal functions to call when we have store notifications come in
		_onNewItem: function(/*item*/ item, /*Object?*/ parentInfo){
			if(!parentInfo || !parentInfo.parent){
				// Only add it if we are top-level
				this._addOptionForItem(item);
			}
		},
		_onDeleteItem: function(/*item*/ item){
			var store = this.store;
			this.removeOption({value: store.getIdentity(item) });
		},
		_onSetItem: function(/*item*/ item){
			this.updateOption(this._getOptionObjForItem(item));
		},

		_getOptionObjForItem: function(item){
			// summary:
			//		Returns an option object based off the given item.  The "value"
			//		of the option item will be the identity of the item, the "label"
			//		of the option will be the label of the item.

			// remove getLabel() call for 2.0 (it's to support the old dojo.data API)
			var store = this.store,
				label = (this.labelAttr && this.labelAttr in item) ? item[this.labelAttr] : store.getLabel(item),
				value = (label ? store.getIdentity(item) : null);
			return {value: value, label: label, item: item}; // __SelectOption
		},

		_addOptionForItem: function(/*item*/ item){
			// summary:
			//		Creates (and adds) the option for the given item
			var store = this.store;
			if(store.isItemLoaded && !store.isItemLoaded(item)){
				// We are not loaded - so let's load it and add later.
				// Remove for 2.0 (it's the old dojo.data API)
				store.loadItem({item: item, onItem: function(i){
					this._addOptionForItem(i);
				},
					scope: this});
				return;
			}
			var newOpt = this._getOptionObjForItem(item);
			this.addOption(newOpt);
		},

		constructor: function(params /*===== , srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree

			//		Saves off our value, if we have an initial one set so we
			//		can use it if we have a store as well (see startup())
			this._oValue = (params || {}).value || null;
			this._notifyConnections = [];	// remove for 2.0
		},

		buildRendering: function(){
			this.inherited(arguments);
			dom.setSelectable(this.focusNode, false);
		},

		_fillContent: function(){
			// summary:
			//		Loads our options and sets up our dropdown correctly.  We
			//		don't want any content, so we don't call any inherit chain
			//		function.
			if(!this.options){
				this.options =
					this.srcNodeRef
						? query("> *", this.srcNodeRef).map(
						function(node){
							if(node.getAttribute("type") === "separator"){
								return { value: "", label: "", selected: false, disabled: false };
							}
							return {
								value: (node.getAttribute("data-" + kernel._scopeName + "-value") || node.getAttribute("value")),
								label: String(node.innerHTML),
								// FIXME: disabled and selected are not valid on complex markup children (which is why we're
								// looking for data-dojo-value above.  perhaps we should data-dojo-props="" this whole thing?)
								// decide before 1.6
								selected: node.getAttribute("selected") || false,
								disabled: node.getAttribute("disabled") || false
							};
						},
						this)
						: [];
			}
			if(!this.value){
				this._set("value", this._getValueFromOpts());
			}else if(this.multiple && typeof this.value == "string"){
				this._set("value", this.value.split(","));
			}
		},

		postCreate: function(){
			// summary:
			//		sets up our event handling that we need for functioning
			//		as a select
			this.inherited(arguments);

			// Make our event connections for updating state
			aspect.after(this, "onChange", lang.hitch(this, "_updateSelection"));

			//		Connects in our store, if we have one defined
			var store = this.store;
			if(store && (store.getIdentity || store.getFeatures()["dojo.data.api.Identity"])){
				// Temporarily set our store to null so that it will get set
				// and connected appropriately
				this.store = null;
				this._deprecatedSetStore(store, this._oValue, {query: this.query, queryOptions: this.queryOptions});
			}

			this._storeInitialized = true;
		},

		startup: function(){
			// summary:
			this._loadChildren();
			this.inherited(arguments);
		},

		destroy: function(){
			// summary:
			//		Clean up our connections

			var h;
			while((h = this._notifyConnections.pop())){
				h.remove();
			}

			// Cancel listener for store updates
			if(this._queryRes && this._queryRes.close){
				this._queryRes.close();
			}

			// Cancel listener for updates to new (dojo.store) store
			if(this._observeHandle && this._observeHandle.remove){
				this._observeHandle.remove();
				this._observeHandle = null;
			}

			this.inherited(arguments);
		},

		_addOptionItem: function(/*__SelectOption*/ /*===== option =====*/){
			// summary:
			//		User-overridable function which, for the given option, adds an
			//		item to the select.  If the option doesn't have a value, then a
			//		separator is added in that place.  Make sure to store the option
			//		in the created option widget.
		},

		_removeOptionItem: function(/*__SelectOption*/ /*===== option =====*/){
			// summary:
			//		User-overridable function which, for the given option, removes
			//		its item from the select.
		},

		_setDisplay: function(/*String or String[]*/ /*===== newDisplay =====*/){
			// summary:
			//		Overridable function which will set the display for the
			//		widget.  newDisplay is either a string (in the case of
			//		single selects) or array of strings (in the case of multi-selects)
		},

		_getChildren: function(){
			// summary:
			//		Overridable function to return the children that this widget contains.
			return [];
		},

		_getSelectedOptionsAttr: function(){
			// summary:
			//		hooks into this.attr to provide a mechanism for getting the
			//		option items for the current value of the widget.
			return this.getOptions({ selected: true });
		},

		_pseudoLoadChildren: function(/*item[]*/ /*===== items =====*/){
			// summary:
			//		a function that will "fake" loading children, if needed, and
			//		if we have set to not load children until the widget opens.
			// items:
			//		An array of items that will be loaded, when needed
		},

		onSetStore: function(){
			// summary:
			//		a function that can be connected to in order to receive a
			//		notification that the store has finished loading and all options
			//		from that store are available
		}
	});

	/*=====
	_FormSelectWidget.__SelectOption = __SelectOption;
	=====*/

	return _FormSelectWidget;
});

},
'dijit/form/NumberTextBox':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.hitch lang.mixin
	"dojo/i18n", // i18n.normalizeLocale, i18n.getLocalization
	"dojo/string", // string.rep
	"dojo/number", // number._realNumberRegexp number.format number.parse number.regexp
	"./RangeBoundTextBox"
], function(declare, lang, i18n, string, number, RangeBoundTextBox){

	// module:
	//		dijit/form/NumberTextBox

	// A private helper function to determine decimal information
	// Returns an object with "sep" and "places" properties
	var getDecimalInfo = function(constraints){
		var constraints = constraints || {},
			bundle = i18n.getLocalization("dojo.cldr", "number", i18n.normalizeLocale(constraints.locale)),
			pattern = constraints.pattern ? constraints.pattern : bundle[(constraints.type || "decimal")+"Format"];

		// The number of places in the constraint can be specified in several ways,
		// the resolution order is:
		//
		// 1. If constraints.places is a number, use that
		// 2. If constraints.places is a string, which specifies a range, use the range max (e.g. 0,4)
		// 3. If a pattern is specified, use the implicit number of places in the pattern.
		// 4. If neither constraints.pattern or constraints.places is specified, use the locale default pattern
		var places;
		if(typeof constraints.places == "number"){
			places = constraints.places;
		}else if(typeof constraints.places === "string" && constraints.places.length > 0){
			places = constraints.places.replace(/.*,/, "");
		}else{
			places = (pattern.indexOf(".") != -1 ? pattern.split(".")[1].replace(/[^#0]/g, "").length : 0);
		}

		return { sep: bundle.decimal, places: places };
	};

	var NumberTextBoxMixin = declare("dijit.form.NumberTextBoxMixin", null, {
		// summary:
		//		A mixin for all number textboxes
		// tags:
		//		protected

		// Override ValidationTextBox.pattern.... we use a reg-ex generating function rather
		// than a straight regexp to deal with locale (plus formatting options too?)
		pattern: function(constraints){
			// if focused, accept either currency data or NumberTextBox format
			return '(' + (this.focused && this.editOptions ? this._regExpGenerator(lang.delegate(constraints, this.editOptions)) + '|' : '')
				+ this._regExpGenerator(constraints) + ')';
		},

		/*=====
		// constraints: NumberTextBox.__Constraints
		//		Despite the name, this parameter specifies both constraints on the input
		//		(including minimum/maximum allowed values) as well as
		//		formatting options like places (the number of digits to display after
		//		the decimal point).
		constraints: {},
		======*/

		// value: Number
		//		The value of this NumberTextBox as a Javascript Number (i.e., not a String).
		//		If the displayed value is blank, the value is NaN, and if the user types in
		//		an gibberish value (like "hello world"), the value is undefined
		//		(i.e. get('value') returns undefined).
		//
		//		Symmetrically, set('value', NaN) will clear the displayed value,
		//		whereas set('value', undefined) will have no effect.
		value: NaN,

		// editOptions: [protected] Object
		//		Properties to mix into constraints when the value is being edited.
		//		This is here because we edit the number in the format "12345", which is
		//		different than the display value (ex: "12,345")
		editOptions: { pattern: '#.######' },

		/*=====
		_formatter: function(value, options){
			// summary:
			//		_formatter() is called by format().  It's the base routine for formatting a number,
			//		as a string, for example converting 12345 into "12,345".
			// value: Number
			//		The number to be converted into a string.
			// options: number.__FormatOptions?
			//		Formatting options
			// tags:
			//		protected extension

			return "12345";		// String
		},
		 =====*/
		_formatter: number.format,

		/*=====
		_regExpGenerator: function(constraints){
			// summary:
			//		Generate a localized regular expression as a string, according to constraints.
			// constraints: number.__ParseOptions
			//		Formatting options
			// tags:
			//		protected

			return "(\d*).(\d*)";	// string
		},
		=====*/
		_regExpGenerator: number.regexp,

		// _decimalInfo: Object
		// summary:
		//		An object containing decimal related properties relevant to this TextBox.
		// tags:
		//		private
		_decimalInfo: getDecimalInfo(),

		postMixInProperties: function(){
			this.inherited(arguments);
			this._set("type", "text"); // in case type="number" was specified which messes up parse/format
		},

		_setConstraintsAttr: function(/*Object*/ constraints){
			var places = typeof constraints.places == "number"? constraints.places : 0;
			if(places){ places++; } // decimal rounding errors take away another digit of precision
			if(typeof constraints.max != "number"){
				constraints.max = 9 * Math.pow(10, 15-places);
			}
			if(typeof constraints.min != "number"){
				constraints.min = -9 * Math.pow(10, 15-places);
			}
			this.inherited(arguments, [ constraints ]);
			if(this.focusNode && this.focusNode.value && !isNaN(this.value)){
				this.set('value', this.value);
			}
			// Capture decimal information based on the constraint locale and pattern.
			this._decimalInfo = getDecimalInfo(constraints);
		},

		_onFocus: function(){
			if(this.disabled || this.readOnly){ return; }
			var val = this.get('value');
			if(typeof val == "number" && !isNaN(val)){
				var formattedValue = this.format(val, this.constraints);
				if(formattedValue !== undefined){
					this.textbox.value = formattedValue;
				}
			}
			this.inherited(arguments);
		},

		format: function(/*Number*/ value, /*number.__FormatOptions*/ constraints){
			// summary:
			//		Formats the value as a Number, according to constraints.
			// tags:
			//		protected

			var formattedValue = String(value);
			if(typeof value != "number"){ return formattedValue; }
			if(isNaN(value)){ return ""; }
			// check for exponential notation that dojo/number.format() chokes on
			if(!("rangeCheck" in this && this.rangeCheck(value, constraints)) && constraints.exponent !== false && /\de[-+]?\d/i.test(formattedValue)){
				return formattedValue;
			}
			if(this.editOptions && this.focused){
				constraints = lang.mixin({}, constraints, this.editOptions);
			}
			return this._formatter(value, constraints);
		},

		/*=====
		_parser: function(value, constraints){
			// summary:
			//		Parses the string value as a Number, according to constraints.
			// value: String
			//		String representing a number
			// constraints: number.__ParseOptions
			//		Formatting options
			// tags:
			//		protected

			return 123.45;		// Number
		},
		=====*/
		_parser: number.parse,

		parse: function(/*String*/ value, /*number.__FormatOptions*/ constraints){
			// summary:
			//		Replaceable function to convert a formatted string to a number value
			// tags:
			//		protected extension

			var v = this._parser(value, lang.mixin({}, constraints, (this.editOptions && this.focused) ? this.editOptions : {}));
			if(this.editOptions && this.focused && isNaN(v)){
				v = this._parser(value, constraints); // parse w/o editOptions: not technically needed but is nice for the user
			}
			return v;
		},

		_getDisplayedValueAttr: function(){
			var v = this.inherited(arguments);
			return isNaN(v) ? this.textbox.value : v;
		},

		filter: function(/*Number*/ value){
			// summary:
			//		This is called with both the display value (string), and the actual value (a number).
			//		When called with the actual value it does corrections so that '' etc. are represented as NaN.
			//		Otherwise it dispatches to the superclass's filter() method.
			//
			//		See `dijit/form/TextBox.filter()` for more details.
			if(value == null  /* or undefined */ || typeof value == "string" && value ==''){
				return NaN;
			}else if(typeof value == "number" && !isNaN(value) && value != 0){
				value = number.round(value, this._decimalInfo.places);
			}
			return this.inherited(arguments, [value]);
		},

		serialize: function(/*Number*/ value, /*Object?*/ options){
			// summary:
			//		Convert value (a Number) into a canonical string (ie, how the number literal is written in javascript/java/C/etc.)
			// tags:
			//		protected
			return (typeof value != "number" || isNaN(value)) ? '' : this.inherited(arguments);
		},

		_setBlurValue: function(){
			var val = lang.hitch(lang.delegate(this, { focused: true }), "get")('value'); // parse with editOptions
			this._setValueAttr(val, true);
		},

		_setValueAttr: function(/*Number*/ value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			// summary:
			//		Hook so set('value', ...) works.
			if(value !== undefined && formattedValue === undefined){
				formattedValue = String(value);
				if(typeof value == "number"){
					if(isNaN(value)){ formattedValue = '' }
					// check for exponential notation that number.format chokes on
					else if(("rangeCheck" in this && this.rangeCheck(value, this.constraints)) || this.constraints.exponent === false || !/\de[-+]?\d/i.test(formattedValue)){
						formattedValue = undefined; // lets format compute a real string value
					}
				}else if(!value){ // 0 processed in if branch above, ''|null|undefined flows through here
					formattedValue = '';
					value = NaN;
				}else{ // non-numeric values
					value = undefined;
				}
			}
			this.inherited(arguments, [value, priorityChange, formattedValue]);
		},

		_getValueAttr: function(){
			// summary:
			//		Hook so get('value') works.
			//		Returns Number, NaN for '', or undefined for unparseable text
			var v = this.inherited(arguments); // returns Number for all values accepted by parse() or NaN for all other displayed values

			// If the displayed value of the textbox is gibberish (ex: "hello world"), this.inherited() above
			// returns NaN; this if() branch converts the return value to undefined.
			// Returning undefined prevents user text from being overwritten when doing _setValueAttr(_getValueAttr()).
			// A blank displayed value is still returned as NaN.
			if(isNaN(v) && this.textbox.value !== ''){
				if(this.constraints.exponent !== false && /\de[-+]?\d/i.test(this.textbox.value) && (new RegExp("^"+number._realNumberRegexp(lang.delegate(this.constraints))+"$").test(this.textbox.value))){	// check for exponential notation that parse() rejected (erroneously?)
					var n = Number(this.textbox.value);
					return isNaN(n) ? undefined : n; // return exponential Number or undefined for random text (may not be possible to do with the above RegExp check)
				}else{
					return undefined; // gibberish
				}
			}else{
				return v; // Number or NaN for ''
			}
		},

		isValid: function(/*Boolean*/ isFocused){
			// Overrides dijit/form/RangeBoundTextBox.isValid() to check that the editing-mode value is valid since
			// it may not be formatted according to the regExp validation rules
			if(!this.focused || this._isEmpty(this.textbox.value)){
				return this.inherited(arguments);
			}else{
				var v = this.get('value');
				if(!isNaN(v) && this.rangeCheck(v, this.constraints)){
					if(this.constraints.exponent !== false && /\de[-+]?\d/i.test(this.textbox.value)){ // exponential, parse doesn't like it
						return true; // valid exponential number in range
					}else{
						return this.inherited(arguments);
					}
				}else{
					return false;
				}
			}
		},

		_isValidSubset: function(){
			// Overrides dijit/form/ValidationTextBox._isValidSubset()
			//
			// The inherited method only checks that the computed regex pattern is valid, which doesn't
			// take into account that numbers are a special case. Specifically:
			//
			//  (1) An arbitrary amount of leading or trailing zero's can be ignored.
			//  (2) Since numeric input always occurs in the order of most significant to least significant
			//      digits, the maximum and minimum possible values for partially inputted numbers can easily
			//      be determined by using the number of remaining digit spaces available.
			//
			// For example, if an input has a maxLength of 5, and a min value of greater than 100, then the subset
			// is invalid if there are 3 leading 0s. It remains valid for the first two.
			//
			// Another example is if the min value is 1.1. Once a value of 1.0 is entered, no additional trailing digits
			// could possibly satisify the min requirement.
			//
			// See ticket #17923
			var hasMinConstraint = (typeof this.constraints.min == "number"),
				hasMaxConstraint = (typeof this.constraints.max == "number"),
				curVal = this.get('value');

			// If there is no parsable number, or there are no min or max bounds, then we can safely
			// skip all remaining checks
			if(isNaN(curVal) || (!hasMinConstraint && !hasMaxConstraint)){
				return this.inherited(arguments);
			}

			// This block picks apart the values in the text box to be used later to compute the min and max possible
			// values based on the current value and the remaining available digits.
			//
			// Warning: The use of a "num|0" expression, can be confusing. See the link below
			// for an explanation.
			//
			// http://stackoverflow.com/questions/12125421/why-does-a-shift-by-0-truncate-the-decimal
			var integerDigits = curVal|0,
				valNegative = curVal < 0,
				// Check if the current number has a decimal based on its locale
				hasDecimal = this.textbox.value.indexOf(this._decimalInfo.sep) != -1,
				// Determine the max digits based on the textbox length. If no length is
				// specified, chose a huge number to account for crazy formatting.
				maxDigits = this.maxLength || 20,
				// Determine the remaining digits, based on the max digits
				remainingDigitsCount = maxDigits - this.textbox.value.length,
				// avoid approximation issues by capturing the decimal portion of the value as the user-entered string
				fractionalDigitStr = hasDecimal ? this.textbox.value.split(this._decimalInfo.sep)[1].replace(/[^0-9]/g, "") : "";

			// Create a normalized value string in the form of #.###
			var normalizedValueStr = hasDecimal ? integerDigits+"."+fractionalDigitStr : integerDigits+"";

			// The min and max values for the field can be determined using the following
			// logic:
			//
			//  If the number is positive:
			//      min value = the current value
			//      max value = the current value with 9s appended for all remaining possible digits
			//  else
			//      min value = the current value with 9s appended for all remaining possible digits
			//      max value = the current value
			//
			var ninePaddingStr = string.rep("9", remainingDigitsCount),
			    minPossibleValue = curVal,
			    maxPossibleValue = curVal;
			if (valNegative){
				minPossibleValue = Number(normalizedValueStr+ninePaddingStr);
			} else{
				maxPossibleValue = Number(normalizedValueStr+ninePaddingStr);
			}

			return !((hasMinConstraint && maxPossibleValue < this.constraints.min)
					|| (hasMaxConstraint && minPossibleValue > this.constraints.max));
		}
	});

	var NumberTextBox = declare("dijit.form.NumberTextBox", [RangeBoundTextBox, NumberTextBoxMixin], {
		// summary:
		//		A TextBox for entering numbers, with formatting and range checking
		// description:
		//		NumberTextBox is a textbox for entering and displaying numbers, supporting
		//		the following main features:
		//
		//		1. Enforce minimum/maximum allowed values (as well as enforcing that the user types
		//			a number rather than a random string)
		//		2. NLS support (altering roles of comma and dot as "thousands-separator" and "decimal-point"
		//			depending on locale).
		//		3. Separate modes for editing the value and displaying it, specifically that
		//			the thousands separator character (typically comma) disappears when editing
		//			but reappears after the field is blurred.
		//		4. Formatting and constraints regarding the number of places (digits after the decimal point)
		//			allowed on input, and number of places displayed when blurred (see `constraints` parameter).

		baseClass: "dijitTextBox dijitNumberTextBox"
	});

	NumberTextBox.Mixin = NumberTextBoxMixin;	// for monkey patching

	/*=====
	 NumberTextBox.__Constraints = declare([RangeBoundTextBox.__Constraints, number.__FormatOptions, number.__ParseOptions], {
		 // summary:
		 //		Specifies both the rules on valid/invalid values (minimum, maximum,
		 //		number of required decimal places), and also formatting options for
		 //		displaying the value when the field is not focused.
		 // example:
		 //		Minimum/maximum:
		 //		To specify a field between 0 and 120:
		 //	|		{min:0,max:120}
		 //		To specify a field that must be an integer:
		 //	|		{fractional:false}
		 //		To specify a field where 0 to 3 decimal places are allowed on input:
		 //	|		{places:'0,3'}
	 });
	 =====*/

	return NumberTextBox;
});

},
'dijit/form/DateTextBox':function(){
define([
	"dojo/_base/declare", // declare
	"../Calendar",
	"./_DateTimeTextBox"
], function(declare, Calendar, _DateTimeTextBox){

	// module:
	//		dijit/form/DateTextBox

	return declare("dijit.form.DateTextBox", _DateTimeTextBox, {
		// summary:
		//		A validating, serializable, range-bound date text box with a drop down calendar
		// example:
		// |	new DateTextBox({value: new Date(2009, 0, 20)})
		// example:
		// |	<input data-dojo-type='dijit/form/DateTextBox' value='2009-01-20'>

		baseClass: "dijitTextBox dijitComboBox dijitDateTextBox",
		popupClass: Calendar,
		_selector: "date",

		// Prevent scrollbar on Calendar dropdown.  On iPad it often gets a scrollbar unnecessarily because Viewport
		// thinks the keyboard is showing.  Even if the keyboard is showing, it disappears when the calendar gets focus.
		maxHeight: Infinity,

		// value: Date
		//		The value of this widget as a JavaScript Date object, with only year/month/day specified.
		//		If specified in markup, use the format specified in `stamp.fromISOString`.
		//		set("value", ...) accepts either a Date object or a string.
		value: new Date("")	// value.toString()="NaN"
	});
});

},
'dojox/layout/TableContainer':function(){
define(["dojo/_base/kernel", "dojo/_base/lang", "dojo/_base/declare", "dojo/dom-class", "dojo/dom-construct", 
		"dojo/_base/array", "dojo/dom-prop", "dojo/dom-style", "dijit/_WidgetBase", "dijit/layout/_LayoutWidget"],
function(kernel, lang, declare, domClass, domConstruct, arrayUtil, domProp, domStyle, _WidgetBase, _LayoutWidget){

kernel.experimental("dojox.layout.TableContainer");

var TableContainer = declare("dojox.layout.TableContainer", _LayoutWidget, {
	// summary:
	//		A container that lays out its child widgets in a table layout.
	//
	// description:
	//		The TableContainer lays out child widgets in a Table layout.
	//		Each widget can specify a "label" or a "title" parameter.
	//		This label is displayed either above or to the left of
	//		a widget depending on whether the "orientation" attribute
	//		is "horiz" or "vert", for horizontal and vertical respectively.
	//		The number of columns is configured using the "cols" attribute.
	//		The width of labels can be configured using the "labelWidth" parameter.
	//
	// example:
	// |	<div dojoType="dojox.layout.TableContainer" orientation="vert" cols="3>
	// |		<div dojoType="dijit.form.TextInput" value="John" label="First Name:"></div>
	// |		<div dojoType="dijit.form.CheckBox" label="Is Student?:"></div>
	// |		<div dojoType="dojox.form.DateTextBox" label="Date Of Birth:"></div>
	// |	</div>
	//

	cols: 1,
	
	// labelWidth: Number|String
	//		Defines the width of a label.  If the value is a number, it is
	//		treated as a pixel value.  The other valid value is a percentage,
	//		e.g. "50%"
	labelWidth: "100",

	// showLabels: Boolean
	//		True if labels should be displayed, false otherwise.
	showLabels: true,

	// orientation: String
	//		Either "horiz" or "vert" for label orientation.
	orientation: "horiz",
	
	// spacing: Number
	//		The cell spacing to apply to the table.
	spacing: 1,

	// customClass: String
	//		A CSS class that will be applied to child elements.  For example, if
	//		the class is "myClass", the table will have "myClass-table" applied to it,
	//		each label TD will have "myClass-labelCell" applied, and each
	//		widget TD will have "myClass-valueCell" applied.
	customClass: "",

	postCreate: function(){
		this.inherited(arguments);
		this._children = [];
		
		// If the orientation, customClass or cols attributes are changed,
		// layout the widgets again.
		this.connect(this, "set", function(name, value){
			if(value && (name == "orientation" || name == "customClass" || name == "cols")) {
				this.layout();
			}
		});
	},

	startup: function() {
		if(this._started) {
			return;
		}
		this.inherited(arguments);
		if(this._initialized) {
			return;
		}
		var children = this.getChildren();
		if(children.length < 1) {
			return;
		}
		this._initialized = true;

		domClass.add(this.domNode, "dijitTableLayout");

		// Call startup on all child widgets
		arrayUtil.forEach(children, function(child){
			if(!child.started && !child._started) {
				child.startup();
			}
		});
		this.layout();
		this.resize();
	},

	resize: function(){
		// summary:
		//		Resizes all children.  This widget itself
		//		does not resize, as it takes up 100% of the
		//		available width.
		arrayUtil.forEach(this.getChildren(), function(child){
			if(typeof child.resize == "function") {
				child.resize();
			}
		});
	},

	layout: function(){
		// summary:
		//		Lays out the child widgets.
		if(!this._initialized){
			return;
		}

		var children = this.getChildren();

		var childIds = {};
		var _this = this;

		function addCustomClass(node, type, count) {
			if(_this.customClass != "") {
				var clazz = _this.customClass+ "-" + (type || node.tagName.toLowerCase());
				domClass.add(node, clazz);

				if(arguments.length > 2) {
					domClass.add(node, clazz + "-" + count);
				}
			}
		}

		// Find any new children that have been added since the last layout() call
		arrayUtil.forEach(this._children, lang.hitch(this, function(child){
			childIds[child.id] = child;
		}));

		arrayUtil.forEach(children, lang.hitch(this, function(child, index){
			if(!childIds[child.id]) {
				// Add pre-existing children to the start of the array
				this._children.push(child);
			}
		}));

		// Create the table.  It fills the width of it's container.
		var table = domConstruct.create("table", {
			"width": "100%",
			 "class": "tableContainer-table tableContainer-table-" + this.orientation,
			 "cellspacing" : this.spacing
			},
			this.domNode);

		var tbody = domConstruct.create("tbody");
		table.appendChild(tbody);

		addCustomClass(table, "table", this.orientation);

		var width = Math.floor(100 / this.cols) + "%";

		var labelRow = domConstruct.create("tr", {}, tbody);
		var childRow = (!this.showLabels || this.orientation == "horiz")
						? labelRow : domConstruct.create("tr", {}, tbody);
		var maxCols = this.cols * (this.showLabels ? 2 : 1);
		var numCols = 0;

		// Iterate over the children, adding them to the table.
		arrayUtil.forEach(this._children, lang.hitch(this, function(child, index){
			
			var colspan = child.colspan || 1;
			
			if(colspan > 1) {
				colspan = this.showLabels ?
					Math.min(maxCols - 1, colspan * 2 -1): Math.min(maxCols, colspan);
			}

			// Create a new row if we need one
			if(numCols + colspan - 1 + (this.showLabels ? 1 : 0)>= maxCols) {
				numCols = 0;
				labelRow = domConstruct.create("tr", {}, tbody);
				childRow = this.orientation == "horiz" ? labelRow : domConstruct.create("tr", {}, tbody);
			}
			var labelCell;
			
			// If labels should be visible, add them
			if(this.showLabels) {
				labelCell = domConstruct.create("td", {"class": "tableContainer-labelCell"}, labelRow);

				// If the widget should take up both the label and value,
				// then just set the class on it.
				if(child.spanLabel) {
					domProp.set(labelCell, this.orientation == "vert" ? "rowspan" : "colspan", 2);
				}
				else {
					// Add the custom label class to the label cell
					addCustomClass(labelCell, "labelCell");
					var labelProps = {"for": child.get("id")};
					var label = domConstruct.create("label", labelProps, labelCell);

					if(Number(this.labelWidth) > -1 ||
						String(this.labelWidth).indexOf("%") > -1) {
							
						// Set the width of the label cell with either a pixel or percentage value
						domStyle.set(labelCell, "width",
							String(this.labelWidth).indexOf("%") < 0
								? this.labelWidth + "px" : this.labelWidth);
					}

					label.innerHTML = child.get("label") || child.get("title");
				}
			}
			var childCell;

			if(child.spanLabel && labelCell) {
				childCell = labelCell;
			} else {
				 childCell = domConstruct.create("td", {
				 	"class" : "tableContainer-valueCell"
				}, childRow);
			}
			if(colspan > 1) {
				domProp.set(childCell, "colspan", colspan);
			}
			
			// Add the widget cell's custom class, if one exists.
			addCustomClass(childCell, "valueCell", index);

			childCell.appendChild(child.domNode);
			numCols += colspan + (this.showLabels ? 1 : 0);
		}));

		if(this.table)	 {
			this.table.parentNode.removeChild(this.table);
		}
		// Refresh the layout of any child widgets, allowing them to resize
		// to their new parent.
		arrayUtil.forEach(children, function(child){
			if(typeof child.layout == "function") {
				child.layout();
			}
		});
		this.table = table;
		this.resize();
	},
	
	destroyDescendants: function(/*Boolean*/ preserveDom){
		// summary:
		//		Destroys all the widgets inside this.containerNode,
		//		but not this widget itself
		arrayUtil.forEach(this._children, function(child){ child.destroyRecursive(preserveDom); });
	},
	
	_setSpacingAttr: function(value) {
		// summary:
		//		Sets the spacing attribute.
		this.spacing = value;
		if(this.table) {
			this.table.cellspacing = Number(value);
		}
	}
});

TableContainer.ChildWidgetProperties = {
	// summary:
	//		Properties to be set on children of TableContainer

	// label: String
	//		The label to display for a given widget
	label: "",
	
	// title: String
	//		The label to display for a given widget.  This is interchangeable
	//		with the 'label' parameter, as some widgets already have a use
	//		for the 'label', and this can be used instead to avoid conflicts.
	title: "",
	
	// spanLabel: Boolean
	//		Setting spanLabel to true makes the widget take up both the
	//		label and value cells. Defaults to false.
	spanLabel: false,
	
	// colspan: Number
	//		The number of columns this widget should span.
	colspan: 1
};

// Add to widget base for benefit of parser.   Remove for 2.0.   Also, hide from doc viewer.
lang.extend(_WidgetBase, /*===== {} || =====*/ TableContainer.ChildWidgetProperties);

return TableContainer;
});

},
'dojox/form/Uploader':function(){
define([
	"dojo/_base/kernel",
	"dojo/_base/declare",
	"dojo/_base/lang",
	"dojo/_base/array",
	"dojo/_base/connect",
	"dojo/_base/window",
	"dojo/dom-style",
	"dojo/dom-class",
	"dojo/dom-geometry",
	"dojo/dom-attr",
	"dojo/dom-construct",
	"dojo/dom-form",
	"dijit",
	"dijit/form/Button",
	"./uploader/_Base",
	"./uploader/_HTML5",
	"./uploader/_IFrame",
	"./uploader/_Flash",
	"dojo/i18n!./nls/Uploader",
	"dojo/text!./resources/Uploader.html"
],function(kernel, declare, lang, array, connect, win, domStyle, domClass, domGeometry, domAttr, domConstruct,
		   domForm, dijit, Button, Base, HTML5, IFrame, Flash, res, template){

	// TODO:
	//		i18n
	//		label via innerHTML
	//		Doc and or test what can be extended.
	//		Doc custom file events
	//		Use new FileReader() for thumbnails
	//		flashFieldName should default to Flash
	//		get('value'); and set warning
	//		Make it so URL can change (current set to Flash on build)
	//

	return declare("dojox.form.Uploader", [Base, Button, HTML5, IFrame, Flash], {
		// summary:
		//		A widget that creates a stylable file-input button, with optional multi-file selection,
		//		using only HTML elements. Non-HTML5 browsers have fallback options of Flash or an iframe.
		//
		// description:
		//		A bare-bones, stylable file-input button, with optional multi-file selection. The list
		//		of files is not displayed, that is for you to handle by connecting to the onChange
		//		event, or use the dojox.form.uploader.FileList.
		//
		//		Uploader without plugins does not have any ability to upload - it is for use in forms
		//		where you handle the upload either by a standard POST or with Ajax using an iFrame. This
		//		class is for convenience of multiple files only. No progress events are available.
		//
		//		If the browser supports a file-input with the "multiple" attribute, that will be used.
		//		If the browser does not support "multiple" (ergo, IE) multiple inputs are used,
		//		one for each selection.
		//
		//		Version: 1.6
	
	
		// uploadOnSelect: Boolean
		//		If true, uploads immediately after a file has been selected. If false,
		//		waits for upload() to be called.
		uploadOnSelect:false,
	
		// tabIndex: Number|String
		//		The tab order in the DOM.
		tabIndex:0,
	
		// multiple: Boolean
		//		If true and flash mode, multiple files may be selected from the dialog.
		multiple:false,
	
		// label: String
		//		The text used in the button that when clicked, opens a system Browse Dialog.
		label:res.label,
	
		// url: String
		//		The url targeted for upload. An absolute URL is preferred. Relative URLs are
		//		changed to absolute.
		url:"",
	
		// name: String
		//		The name attribute needs to end with square brackets: [] as this is the standard way
		//		of handling an attribute "array". This requires a slightly different technique on the
		//		server.
		name:"uploadedfile",
	
		// flashFieldName: String
		//		If set, this will be the name of the field of the flash uploaded files that the server
		//		is expecting. If not set, "Flash" is appended to the "name" property.
		flashFieldName:"",
		
		//	force: String
		//		options: form, html5, iframe, flash
		//		Empty string defaults to html5 if available, and iframe if not.
		// 		Use "flash" to always use Flash (and hopefully force the user to download the plugin
		//		if they don't have it).
		//		Use "iframe" to always use an iframe, and never flash nor html5. Sometimes preferred
		//		for consistent results.
		//		Use "form" to not use ajax and post to a page.
		force:"",
	
		// uploadType: String [readonly]
		//		The type of uploader being used. As an alternative to determining the upload type on the
		//		server based on the fieldName, this property could be sent to the server to help
		//		determine what type of parsing should be used.
		//		This is set based on the force property and what features are available in the browser.
		uploadType:"",
	
		// showInput: String [const]
		//		Position to show an input which shows selected filename(s). Possible
		//		values are "before", "after", which specifies where the input should
		//		be placed with reference to the containerNode which contains the
		//		label). By default, this is empty string (no such input will be
		//		shown). Specify showInput="before" to mimic the look&feel of a
		//		native file input element.
		showInput: "",
		
		//	focusedClass: String
		//		The class applied to the button when it is focused (via TAB key)
		focusedClass:"dijitButtonHover",
	
		_nameIndex:0,
	
		templateString: template,
	
		baseClass: 'dijitUploader '+Button.prototype.baseClass,
	
		postMixInProperties: function(){
			this._inputs = [];
			this._cons = [];
			this.force = this.force.toLowerCase();
			if(this.supports("multiple")){
				this.uploadType = this.force === 'form' ? 'form' : 'html5';
			}else{
				this.uploadType = this.force === 'flash' ? 'flash' : 'iframe';
			}
			
			this.inherited(arguments);
		},
		buildRendering: function(){
			this.inherited(arguments);
			domStyle.set(this.domNode, {
				overflow:"hidden",
				position:"relative"
			});
			this._buildDisplay();
			//change the button node not occupy tabIndex: the real file input
			//will have tabIndex set
			domAttr.set(this.titleNode, 'tabIndex', -1);
		},
		_buildDisplay: function(){
			if(this.showInput){
				this.displayInput = domConstruct.create('input', {
					  'class':'dijitUploadDisplayInput',
					  'tabIndex':-1, 'autocomplete':'off',
					  'role':'presentation'},
					this.containerNode, this.showInput);
				//schedule the attachpoint to be cleaned up on destroy
				this._attachPoints.push('displayInput');
				this.connect(this,'onChange', function(files){
					var i=0,l=files.length, f, r=[];
					while((f=files[i++])){
						if(f && f.name){
							r.push(f.name);
						}
					}
					this.displayInput.value = r.join(', ');
				});
				this.connect(this,'reset', function(){
					this.displayInput.value = '';
				});
			}
		},
	
		startup: function(){
			if(this._buildInitialized){
				return;
			}
			this._buildInitialized = true;
			this._getButtonStyle(this.domNode);
			this._setButtonStyle();
			this.inherited(arguments);
		},
	
		/*************************
		 *	   Public Events	 *
		 *************************/
	
		onChange: function(/*Array*/ fileArray){
			// summary:
			//		stub to connect
			//		Fires when files are selected
			//		Event is an array of last files selected
		},
	
		onBegin: function(/*Array*/ dataArray){
			// summary:
			//		Fires when upload begins
		},
	
		onProgress: function(/*Object*/ customEvent){
			// summary:
			//		Stub to connect
			//		Fires on upload progress. Event is a normalized object of common properties
			//		from HTML5 uploaders and the Flash uploader. Will not fire for IFrame.
			// customEvent:
			//		- bytesLoaded: Number:
			//			Amount of bytes uploaded so far of entire payload (all files)
			//		- bytesTotal: Number:
			//			Amount of bytes of entire payload (all files)
			//		- type: String:
			//			Type of event (progress or load)
			//		- timeStamp: Number:
			//			Timestamp of when event occurred
		},
	
		onComplete: function(/*Object*/ customEvent){
			// summary:
			//		stub to connect
			//		Fires when all files have uploaded
			//		Event is an array of all files
			this.reset();
		},
	
		onCancel: function(){
			// summary:
			//		Stub to connect
			//		Fires when dialog box has been closed
			//		without a file selection
		},
	
		onAbort: function(){
			// summary:
			//		Stub to connect
			//		Fires when upload in progress was canceled
		},
	
		onError: function(/*Object or String*/ evtObject){
			// summary:
			//		Fires on errors
	
			// FIXME: Unsure of a standard form of error events
		},
	
		/*************************
		 *	   Public Methods	 *
		 *************************/
	
		upload: function(/*Object?*/ formData){				
			// summary:
			//		When called, begins file upload. Only supported with plugins.
			formData = formData || {};
			formData.uploadType = this.uploadType;
			this.inherited(arguments);
		},
	
		submit: function(/*form Node?*/ form){
			// summary:
			//		If Uploader is in a form, and other data should be sent along with the files, use
			//		this instead of form submit.
			form = !!form ? form.tagName ? form : this.getForm() : this.getForm();
			var data = domForm.toObject(form);
			data.uploadType = this.uploadType;
			this.upload(data);
		},
	
		reset: function(){
			// summary:
			//		Resets entire input, clearing all files.
			//		NOTE:
			//		Removing individual files is not yet supported, because the HTML5 uploaders can't
			//		be edited.
			//		TODO:
			//		Add this ability by effectively, not uploading them
			//
			delete this._files;
			this._disconnectButton();
			array.forEach(this._inputs, domConstruct.destroy);
			this._inputs = [];
			this._nameIndex = 0;
			this._createInput();
		},
	
		getFileList: function(){
			// summary:
			//		Returns a list of selected files.
	
			var fileArray = [];
			if(this.supports("multiple")){
				array.forEach(this._files, function(f, i){
					fileArray.push({
						index:i,
						name:f.name,
						size:f.size,
						type:f.type
					});
				}, this);
			}else{
				array.forEach(this._inputs, function(n, i){
					if(n.value){
						fileArray.push({
							index:i,
							name:n.value.substring(n.value.lastIndexOf("\\")+1),
							size:0,
							type:n.value.substring(n.value.lastIndexOf(".")+1)
						});
					}
				}, this);
	
			}
			return fileArray; // Array
		},
	
		/*********************************************
		 *	   Private Property. Get off my lawn.	 *
		 *********************************************/
	
		_getValueAttr: function(){
			// summary:
			//		Internal. To get disabled use: uploader.get("disabled");
			return this.getFileList();
		},
	
		_setValueAttr: function(disabled){
			console.error("Uploader value is read only");
		},
	
		_setDisabledAttr: function(disabled){
			// summary:
			//		Internal. To set disabled use: uploader.set("disabled", true);
			if(this.disabled == disabled || !this.inputNode){ return; }
			this.inherited(arguments);
			domStyle.set(this.inputNode, "display", disabled ? "none" : "");
		},
	
		_getButtonStyle: function(node){
			this.btnSize = {w:domStyle.get(node,'width'), h:domStyle.get(node,'height')};
		},
	
		_setButtonStyle: function(){
			this.inputNodeFontSize = Math.max(2, Math.max(Math.ceil(this.btnSize.w / 60), Math.ceil(this.btnSize.h / 15)));
			this._createInput();
		},
	
		_getFileFieldName: function(){
			var name;
			if(this.supports("multiple") && this.multiple){
				name = this.name+"s[]";
			}else{
				// <=IE8
				name = this.name + (this.multiple ? this._nameIndex : "");
			}
			return name;
		},
	
		_createInput: function(){
			if(this._inputs.length){
				domStyle.set(this.inputNode, {
					top:"500px"
				});
				this._disconnectButton();
				this._nameIndex++;
			}
			var name = this._getFileFieldName();
			// reset focusNode to the inputNode, so when the button is clicked,
			// the focus is properly moved to the input element
			this.focusNode = this.inputNode = domConstruct.create("input", {type:"file", name:name, "aria-labelledby":this.id+"_label"}, this.domNode, "first");
			if(this.supports("multiple") && this.multiple){
				domAttr.set(this.inputNode, "multiple", true);
			}
			this._inputs.push(this.inputNode);
	
			domStyle.set(this.inputNode, {
				position:"absolute",
				fontSize:this.inputNodeFontSize+"em",
				top:"-3px",
				right:"-3px",
				opacity:0
			});
			this._connectButton();
		},
	
		_connectButton: function(){
			this._cons.push(connect.connect(this.inputNode, "change", this, function(evt){
				this._files = this.inputNode.files;
				this.onChange(this.getFileList(evt));
				if(!this.supports("multiple") && this.multiple) this._createInput();
			}));
	
			if(this.tabIndex > -1){
				this.inputNode.tabIndex = this.tabIndex;
	
				this._cons.push(connect.connect(this.inputNode, "focus", this, function(){
					domClass.add(this.domNode, this.focusedClass);
				}));
				this._cons.push(connect.connect(this.inputNode, "blur", this, function(){
					domClass.remove(this.domNode, this.focusedClass);
				}));
			}
		},
	
		_disconnectButton: function(){
			array.forEach(this._cons, connect.disconnect);
			this._cons.splice(0,this._cons.length);
		}
	});

});

},
'dojox/form/uploader/_Base':function(){
define([
	"dojo/dom-form",
	"dojo/dom-style",
	"dojo/dom-construct",
	"dojo/dom-attr",
	"dojo/has",
	"dojo/_base/declare",
	"dojo/_base/event",
	"dijit/_Widget",
	"dijit/_TemplatedMixin",
	"dijit/_WidgetsInTemplateMixin"
],function(domForm, domStyle, domConstruct, domAttr, has, declare, event, Widget, TemplatedMixin, WidgetsInTemplateMixin){

has.add('FormData', function(){return !!window.FormData;});
has.add('xhr-sendAsBinary', function(){var xhr=window.XMLHttpRequest && new window.XMLHttpRequest(); return xhr && !!xhr.sendAsBinary;});
has.add('file-multiple', function(){return !!({'true':1,'false':1}[domAttr.get(document.createElement('input',{type:"file"}), 'multiple')]);});


return declare("dojox.form.uploader._Base", [Widget, TemplatedMixin, WidgetsInTemplateMixin], {
	// summary:
	//		The Base class used for dojox/form/Uploader and dojox/form/uploader/FileList.
	//
	//		Should not be used as a standalone. To be mixed in with other classes.
	//
	getForm: function(){
		// summary:
		//		Finds the parent form of the Uploader, if it exists.

		if(!this.form){
			var n = this.domNode;
			while(n && n.tagName && n !== document.body){
				if(n.tagName.toLowerCase() == "form"){
					this.form = n;
					break;
				}
				n = n.parentNode;
			}
		}
		return this.form // Node;
	},

	getUrl: function(){
		// summary:
		//		Finds the URL to upload to, whether it be the action in the parent form, this.url or
		//		this.uploadUrl

		if(this.uploadUrl) this.url = this.uploadUrl;
		if(this.url) return this.url;
		if(this.getForm()) this.url = this.form.action;
		return this.url; // String
	},


	connectForm: function(){
		// summary:
		//		Internal. Connects to form if there is one.

		this.url = this.getUrl();
		if(!this._fcon && !!this.getForm()){
			this._fcon = true;
			this.connect(this.form, "onsubmit", function(evt){
				console.log('SUBMIT')
				event.stop(evt);
				this.submit(this.form);
			});
		}
	},

	supports: function(what){
		// summary:
		//		Does feature testing for uploader capabilities. (No browser sniffing - yay)

		switch(what){
			case "multiple":
				if(this.force == "flash" || this.force == "iframe") return false;
				return has("file-multiple");
			case "FormData":
				return has(what);
			case "sendAsBinary":
				return has("xhr-sendAsBinary");
		}
		return false; // Boolean
	},
	getMimeType: function(){
		// summary:
		//		Returns the mime type that should be used in an HTML5 upload form. Return result
		//		may change as the current use is very generic.
		return "application/octet-stream"; //image/gif
	},
	getFileType: function(/*String*/ name){
		// summary:
		//		Gets the extension of a file
		return name.substring(name.lastIndexOf(".")+1).toUpperCase(); // String
	},
	convertBytes: function(bytes){
		// summary:
		//		Converts bytes. Returns an object with all conversions. The "value" property is
		//		considered the most likely desired result.

		var kb = Math.round(bytes/1024*100000)/100000;
		var mb = Math.round(bytes/1048576*100000)/100000;
		var gb = Math.round(bytes/1073741824*100000)/100000;
		var value = bytes;
		if(kb>1) value = kb.toFixed(1)+" kb";
		if(mb>1) value = mb.toFixed(1)+" mb";
		if(gb>1) value = gb.toFixed(1)+" gb";
		return {
			kb:kb,
			mb:mb,
			gb:gb,
			bytes:bytes,
			value: value
		}; // Object
	}
});
});

},
'dojox/form/uploader/_HTML5':function(){
define([
	"dojo/_base/declare",
	"dojo/_base/lang",
	"dojo/_base/array",
	"dojo"
],function(declare, lang, arrayUtil, dojo){

	return declare("dojox.form.uploader._HTML5", [], {
		// summary:
		//		A mixin for dojox/form/Uploader that adds HTML5 multiple-file upload capabilities and
		//		progress events.
		//
		// description:
		//		Note that this does not add these capabilities to browsers that don't support them.
		//		For IE8 or older browsers, _IFrame or _Flash mixins will be used.
		//
		
		// debug message:
		errMsg:"Error uploading files. Try checking permissions",
	
		// Overwrites "form" and could possibly be overwritten again by iframe or flash plugin.
		uploadType:"html5",
		
		postMixInProperties: function(){
			this.inherited(arguments);
			if(this.uploadType === "html5"){ }
		},
	
		postCreate: function(){
			this.connectForm();
			this.inherited(arguments);
			if(this.uploadOnSelect){
				this.connect(this, "onChange", function(data){
					this.upload(data[0]);
				});
			}
		},
	
		_drop: function(e){
			dojo.stopEvent(e);
			var dt = e.dataTransfer;
			this._files = dt.files;
			this.onChange(this.getFileList());
		},
		/*************************
		 *	   Public Methods	 *
		 *************************/
	
		upload: function(/*Object ? */ formData){
			// summary:
			//		See: dojox.form.Uploader.upload
				
			this.onBegin(this.getFileList());
			this.uploadWithFormData(formData);
		},
	
		addDropTarget: function(node, /*Boolean?*/ onlyConnectDrop){
			// summary:
			//		Add a dom node which will act as the drop target area so user
			//		can drop files to this node.
			// description:
			//		If onlyConnectDrop is true, dragenter/dragover/dragleave events
			//		won't be connected to dojo.stopEvent, and they need to be
			//		canceled by user code to allow DnD files to happen.
			//		This API is only available in HTML5 plugin (only HTML5 allows
			//		DnD files).
			if(!onlyConnectDrop){
				this.connect(node, 'dragenter', dojo.stopEvent);
				this.connect(node, 'dragover', dojo.stopEvent);
				this.connect(node, 'dragleave', dojo.stopEvent);
			}
			this.connect(node, 'drop', '_drop');
		},
		
		uploadWithFormData: function(/*Object*/ data){
			// summary:
			//		Used with WebKit and Firefox 4+
			//		Upload files using the much friendlier FormData browser object.
			// tags:
			//		private
	
			if(!this.getUrl()){
				console.error("No upload url found.", this); return;
			}
			var fd = new FormData(), fieldName=this._getFileFieldName();
			arrayUtil.forEach(this._files, function(f, i){
				fd.append(fieldName, f);
			}, this);
	
			if(data){
				data.uploadType = this.uploadType;
				for(var nm in data){
					fd.append(nm, data[nm]);
				}
			}
	
			var xhr = this.createXhr();
			xhr.send(fd);
		},
	
		_xhrProgress: function(evt){
			if(evt.lengthComputable){
				var o = {
					bytesLoaded:evt.loaded,
					bytesTotal:evt.total,
					type:evt.type,
					timeStamp:evt.timeStamp
				};
				if(evt.type == "load"){
					// 100%
					o.percent = "100%";
					o.decimal = 1;
				}else{
					o.decimal = evt.loaded / evt.total;
					o.percent = Math.ceil((evt.loaded / evt.total)*100)+"%";
				}
				this.onProgress(o);
			}
		},
	
		createXhr: function(){
			var xhr = new XMLHttpRequest();
			var timer;
			xhr.upload.addEventListener("progress", lang.hitch(this, "_xhrProgress"), false);
			xhr.addEventListener("load", lang.hitch(this, "_xhrProgress"), false);
			xhr.addEventListener("error", lang.hitch(this, function(evt){
				this.onError(evt);
				clearInterval(timer);
			}), false);
			xhr.addEventListener("abort", lang.hitch(this, function(evt){
				this.onAbort(evt);
				clearInterval(timer);
			}), false);
			xhr.onreadystatechange = lang.hitch(this, function(){
				if(xhr.readyState === 4){
	//				console.info("COMPLETE")
					clearInterval(timer);
					try{
						this.onComplete(JSON.parse(xhr.responseText.replace(/^\{\}&&/,'')));
					}catch(e){
						var msg = "Error parsing server result:";
						console.error(msg, e);
						console.error(xhr.responseText);
						this.onError(msg, e);
					}
				}
			});
			xhr.open("POST", this.getUrl());
			xhr.setRequestHeader("Accept","application/json");
			
			timer = setInterval(lang.hitch(this, function(){
				try{
					if(typeof(xhr.statusText)){} // accessing this error throws an error. Awesomeness.
				}catch(e){
					//this.onError("Error uploading file."); // not always an error.
					clearInterval(timer);
				}
			}),250);
	
			return xhr;
		}
	
	});

});

},
'dojox/form/uploader/_IFrame':function(){
define([
	"dojo/query",
	"dojo/dom-construct",
	"dojo/_base/declare",
	"dojo/_base/lang",
	"dojo/_base/array",
	"dojo/dom-form",
	"dojo/request/iframe"
],function(query, domConstruct, declare, lang, arrayUtil, domForm, request){
	

	return declare("dojox.form.uploader._IFrame", [], {
		// summary:
		//		A mixin for dojox/form/Uploader that adds Ajax upload capabilities via an iframe.
		//
		// description:
		//		Only supported by IE, due to the specific iFrame hack used.  Progress events are not
		//		supported.
		//		
		//
	
		postMixInProperties: function(){
			this.inherited(arguments);
			if(this.uploadType === "iframe"){
				this.uploadType = "iframe";
				this.upload = this.uploadIFrame;
			}
		},
	
		uploadIFrame: function(data){
			// summary:
			//		Internal. You could use this, but you should use upload() or submit();
			//		which can also handle the post data.
	
			var
				formObject = {},
				sendForm,
				form = this.getForm(),
				url = this.getUrl(),
				self = this;
			data = data || {};
			data.uploadType = this.uploadType;
			
			// create a temp form for which to send data
			//enctype can't be changed once a form element is created
			sendForm = domConstruct.place('<form enctype="multipart/form-data" method="post"></form>', this.domNode);
			arrayUtil.forEach(this._inputs, function(n, i){
				// don't send blank inputs
				if(n.value !== ''){
					sendForm.appendChild(n);
					formObject[n.name] = n.value;
				}
			}, this);
			
			
			// add any extra data as form inputs		
			if(data){
				//formObject = domForm.toObject(form);
				for(nm in data){
					if(formObject[nm] === undefined){
						domConstruct.create('input', {name:nm, value:data[nm], type:'hidden'}, sendForm);
					}
				}
			}
	
			
			request.post(url, {
				form: sendForm,
				handleAs: "json",
				content: data
			}).then(function(result){
				domConstruct.destroy(sendForm);
				if(result["ERROR"] || result["error"]){
					self.onError(result);
				}else{
					self.onComplete(result);
				}
			}, function(err){
				console.error('error parsing server result', err);
				domConstruct.destroy(sendForm); 
				self.onError(err);
			});
		}
	});
});

},
'dojo/request/iframe':function(){
define([
	'module',
	'require',
	'./watch',
	'./util',
	'./handlers',
	'../_base/lang',
	'../io-query',
	'../query',
	'../has',
	'../dom',
	'../dom-construct',
	'../_base/window',
	'../NodeList-dom'/*=====,
	'../request',
	'../_base/declare' =====*/
], function(module, require, watch, util, handlers, lang, ioQuery, query, has, dom, domConstruct, win/*=====, NodeList, request, declare =====*/){
	var mid = module.id.replace(/[\/\.\-]/g, '_'),
		onload = mid + '_onload';

	if(!win.global[onload]){
		win.global[onload] = function(){
			var dfd = iframe._currentDfd;
			if(!dfd){
				iframe._fireNextRequest();
				return;
			}

			var response = dfd.response,
				options = response.options,
				formNode = dom.byId(options.form) || dfd._tmpForm;

			if(formNode){
				// remove all the hidden content inputs
				var toClean = dfd._contentToClean;
				for(var i=0; i<toClean.length; i++){
					var key = toClean[i];
					//Need to cycle over all nodes since we may have added
					//an array value which means that more than one node could
					//have the same .name value.
					for(var j=0; j<formNode.childNodes.length; j++){
						var childNode = formNode.childNodes[j];
						if(childNode.name === key){
							domConstruct.destroy(childNode);
							break;
						}
					}
				}

				// restore original action + target
				dfd._originalAction && formNode.setAttribute('action', dfd._originalAction);
				if(dfd._originalMethod){
					formNode.setAttribute('method', dfd._originalMethod);
					formNode.method = dfd._originalMethod;
				}
				if(dfd._originalTarget){
					formNode.setAttribute('target', dfd._originalTarget);
					formNode.target = dfd._originalTarget;
				}
			}

			if(dfd._tmpForm){
				domConstruct.destroy(dfd._tmpForm);
				delete dfd._tmpForm;
			}

			dfd._finished = true;
		};
	}

	function create(name, onloadstr, uri){
		if(win.global[name]){
			return win.global[name];
		}

		if(win.global.frames[name]){
			return win.global.frames[name];
		}

		if(!uri){
			if(has('config-useXDomain') && !has('config-dojoBlankHtmlUrl')){
				console.warn('dojo/request/iframe: When using cross-domain Dojo builds,' +
					' please save dojo/resources/blank.html to your domain and set dojoConfig.dojoBlankHtmlUrl' +
					' to the path on your domain to blank.html');
			}
			uri = (has('config-dojoBlankHtmlUrl')||require.toUrl('dojo/resources/blank.html'));
		}

		var frame = domConstruct.place(
			'<iframe id="'+name+'" name="'+name+'" src="'+uri+'" onload="'+onloadstr+
			'" style="position: absolute; left: 1px; top: 1px; height: 1px; width: 1px; visibility: hidden">',
			win.body());

		win.global[name] = frame;

		return frame;
	}

	function setSrc(_iframe, src, replace){
		var frame = win.global.frames[_iframe.name];

		if(frame.contentWindow){
			// We have an iframe node instead of the window
			frame = frame.contentWindow;
		}

		try{
			if(!replace){
				frame.location = src;
			}else{
				frame.location.replace(src);
			}
		}catch(e){
			console.log('dojo/request/iframe.setSrc: ', e);
		}
	}

	function doc(iframeNode){
		if(iframeNode.contentDocument){
			return iframeNode.contentDocument;
		}
		var name = iframeNode.name;
		if(name){
			var iframes = win.doc.getElementsByTagName('iframe');
			if(iframeNode.document && iframes[name].contentWindow && iframes[name].contentWindow.document){
				return iframes[name].contentWindow.document;
			}else if(win.doc.frames[name] && win.doc.frames[name].document){
				return win.doc.frames[name].document;
			}
		}
		return null;
	}

	function createForm(){
		return domConstruct.create('form', {
			name: mid + '_form',
			style: {
				position: 'absolute',
				top: '-1000px',
				left: '-1000px'
			}
		}, win.body());
	}

	function fireNextRequest(){
		// summary:
		//		Internal method used to fire the next request in the queue.
		var dfd;
		try{
			if(iframe._currentDfd || !iframe._dfdQueue.length){
				return;
			}
			do{
				dfd = iframe._currentDfd = iframe._dfdQueue.shift();
			}while(dfd && (dfd.canceled || (dfd.isCanceled && dfd.isCanceled())) && iframe._dfdQueue.length);

			if(!dfd || dfd.canceled || (dfd.isCanceled && dfd.isCanceled())){
				iframe._currentDfd = null;
				return;
			}

			var response = dfd.response,
				options = response.options,
				c2c = dfd._contentToClean = [],
				formNode = dom.byId(options.form),
				notify = util.notify,
				data = options.data || null,
				queryStr;

			if(!dfd._legacy && options.method === 'POST' && !formNode){
				formNode = dfd._tmpForm = createForm();
			}else if(options.method === 'GET' && formNode && response.url.indexOf('?') > -1){
				queryStr = response.url.slice(response.url.indexOf('?') + 1);
				data = lang.mixin(ioQuery.queryToObject(queryStr), data);
			}

			if(formNode){
				if(!dfd._legacy){
					var parentNode = formNode;
					do{
						parentNode = parentNode.parentNode;
					}while(parentNode && parentNode !== win.doc.documentElement);

					// Append the form node or some browsers won't work
					if(!parentNode){
						formNode.style.position = 'absolute';
						formNode.style.left = '-1000px';
						formNode.style.top = '-1000px';
						win.body().appendChild(formNode);
					}

					if(!formNode.name){
						formNode.name = mid + '_form';
					}
				}

				// if we have things in data, we need to add them to the form
				// before submission
				if(data){
					var createInput = function(name, value){
						domConstruct.create('input', {
							type: 'hidden',
							name: name,
							value: value
						}, formNode);
						c2c.push(name);
					};
					for(var x in data){
						var val = data[x];
						if(lang.isArray(val) && val.length > 1){
							for(var i=0; i<val.length; i++){
								createInput(x, val[i]);
							}
						}else{
							if(!formNode[x]){
								createInput(x, val);
							}else{
								formNode[x].value = val;
							}
						}
					}
				}

				//IE requires going through getAttributeNode instead of just getAttribute in some form cases,
				//so use it for all.  See #2844
				var actionNode = formNode.getAttributeNode('action'),
					methodNode = formNode.getAttributeNode('method'),
					targetNode = formNode.getAttributeNode('target');

				if(response.url){
					dfd._originalAction = actionNode ? actionNode.value : null;
					if(actionNode){
						actionNode.value = response.url;
					}else{
						formNode.setAttribute('action', response.url);
					}
				}

				if(!dfd._legacy){
					dfd._originalMethod = methodNode ? methodNode.value : null;
					if(methodNode){
						methodNode.value = options.method;
					}else{
						formNode.setAttribute('method', options.method);
					}
				}else{
					if(!methodNode || !methodNode.value){
						if(methodNode){
							methodNode.value = options.method;
						}else{
							formNode.setAttribute('method', options.method);
						}
					}
				}

				dfd._originalTarget = targetNode ? targetNode.value : null;
				if(targetNode){
					targetNode.value = iframe._iframeName;
				}else{
					formNode.setAttribute('target', iframe._iframeName);
				}
				formNode.target = iframe._iframeName;

				notify && notify.emit('send', response, dfd.promise.cancel);
				iframe._notifyStart(response);
				formNode.submit();
			}else{
				// otherwise we post a GET string by changing URL location for the
				// iframe

				var extra = '';
				if(response.options.data){
					extra = response.options.data;
					if(typeof extra !== 'string'){
						extra = ioQuery.objectToQuery(extra);
					}
				}
				var tmpUrl = response.url + (response.url.indexOf('?') > -1 ? '&' : '?') + extra;
				notify && notify.emit('send', response, dfd.promise.cancel);
				iframe._notifyStart(response);
				iframe.setSrc(iframe._frame, tmpUrl, true);
			}
		}catch(e){
			dfd.reject(e);
		}
	}

	// dojo/request/watch handlers
	function isValid(response){
		return !this.isFulfilled();
	}
	function isReady(response){
		return !!this._finished;
	}
	function handleResponse(response, error){
		if(!error){
			try{
				var options = response.options,
					doc = iframe.doc(iframe._frame),
					handleAs = options.handleAs;

				if(handleAs !== 'html'){
					if(handleAs === 'xml'){
						// IE6-8 have to parse the XML manually. See http://bugs.dojotoolkit.org/ticket/6334
						if(doc.documentElement.tagName.toLowerCase() === 'html'){
							query('a', doc.documentElement).orphan();
							var xmlText = doc.documentElement.innerText;
							xmlText = xmlText.replace(/>\s+</g, '><');
							response.text = lang.trim(xmlText);
						}else{
							response.data = doc;
						}
					}else{
						// 'json' and 'javascript' and 'text'
						response.text = doc.getElementsByTagName('textarea')[0].value; // text
					}
					handlers(response);
				}else{
					response.data = doc;
				}
			}catch(e){
				error = e;
			}
		}

		if(error){
			this.reject(error);
		}else if(this._finished){
			this.resolve(response);
		}else{
			this.reject(new Error('Invalid dojo/request/iframe request state'));
		}
	}
	function last(response){
		this._callNext();
	}

	var defaultOptions = {
		method: 'POST'
	};
	function iframe(url, options, returnDeferred){
		var response = util.parseArgs(url, util.deepCreate(defaultOptions, options), true);
		url = response.url;
		options = response.options;

		if(options.method !== 'GET' && options.method !== 'POST'){
			throw new Error(options.method + ' not supported by dojo/request/iframe');
		}

		if(!iframe._frame){
			iframe._frame = iframe.create(iframe._iframeName, onload + '();');
		}

		var dfd = util.deferred(response, null, isValid, isReady, handleResponse, last);
		dfd._callNext = function(){
			if(!this._calledNext){
				this._calledNext = true;
				iframe._currentDfd = null;
				iframe._fireNextRequest();
			}
		};
		dfd._legacy = returnDeferred;

		iframe._dfdQueue.push(dfd);
		iframe._fireNextRequest();

		watch(dfd);

		return returnDeferred ? dfd : dfd.promise;
	}

	/*=====
	iframe = function(url, options){
		// summary:
		//		Sends a request using an iframe element with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/iframe.__Options?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	iframe.__BaseOptions = declare(request.__BaseOptions, {
		// form: DOMNode?
		//		A form node to use to submit data to the server.
		// data: String|Object?
		//		Data to transfer. When making a GET request, this will
		//		be converted to key=value parameters and appended to the
		//		URL.
	});
	iframe.__MethodOptions = declare(null, {
		// method: String?
		//		The HTTP method to use to make the request. Must be
		//		uppercase. Only `"GET"` and `"POST"` are accepted.
		//		Default is `"POST"`.
	});
	iframe.__Options = declare([iframe.__BaseOptions, iframe.__MethodOptions]);

	iframe.get = function(url, options){
		// summary:
		//		Send an HTTP GET request using an iframe element with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/iframe.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	iframe.post = function(url, options){
		// summary:
		//		Send an HTTP POST request using an iframe element with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/iframe.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	=====*/
	iframe.create = create;
	iframe.doc = doc;
	iframe.setSrc = setSrc;

	// TODO: Make these truly private in 2.0
	iframe._iframeName = mid + '_IoIframe';
	iframe._notifyStart = function(){};
	iframe._dfdQueue = [];
	iframe._currentDfd = null;
	iframe._fireNextRequest = fireNextRequest;

	util.addCommonMethods(iframe, ['GET', 'POST']);

	return iframe;
});

},
'dojox/form/uploader/_Flash':function(){
define([
	"dojo/dom-form",
	"dojo/dom-style",
	"dojo/dom-construct",
	"dojo/dom-attr",
	"dojo/_base/declare",
	"dojo/_base/config",
	"dojo/_base/connect",
	"dojo/_base/lang",
	"dojo/_base/array",
	"dojox/embed/Flash"
],function(domForm, domStyle, domConstruct, domAttr, declare, config, connect, lang, arrayUtil, embedFlash){


	return declare("dojox.form.uploader._Flash", [], {
		// summary:
		//		A mixin for dojox/form/Uploader that utilizes a Flash SWF for handling to upload in IE.
		//		All other browsers will use the HTML5 plugin, unless force="flash" is used, then Flash
		//		will be used in all browsers. force="flash"	is provided because Flash has some features
		//		that HTML5 does not yet have. But it is still not recommended because of the many problems
		//		that Firefox and Webkit have with the Flash plugin.
		//
		// description:
		//		All properties and methods listed here are specific to the Flash version only.
		//
		//
		// swfPath:String
		//		Path to SWF. Can be overwritten or provided in djConfig.
		swfPath:config.uploaderPath || require.toUrl("dojox/form/resources/uploader.swf"),

		// preventCache: Boolean
		//		If true, then flash request is sent with a value that changes with each request (timestamp)
		preventCache: true,
	
		// skipServerCheck: Boolean
		//		If true, will not verify that the server was sent the correct format.
		//		This can be safely set to true. The purpose of the server side check
		//		is mainly to show the dev if they've implemented the different returns
		//		correctly.
		skipServerCheck:true,
	
		// serverTimeout:Number (milliseconds)
		//		The amount of time given to the uploaded file
		//		to wait for a server response. After this amount
		//		of time, the onComplete is fired but with a 'server timeout'
		//		error in the returned item.
		serverTimeout: 2000,
	
		// isDebug: Boolean
		//		If true, outputs traces from the SWF to console. What exactly gets passed
		//		is very relative, and depends upon what traces have been left in the DEFT SWF.
		isDebug:false,
	
		// devMode: Boolean.
		//		Re-implemented. devMode increases the logging, adding style tracing from the SWF.
		devMode:false,
	
		// deferredUploading: Number (1 - X)
		//		(Flash only) throttles the upload to a certain amount of files at a time.
		//		By default, Flash uploads file one at a time to the server, but in parallel.
		//		Firefox will try to queue all files at once, leading to problems. Set this
		//		to the amount to upload in parallel at a time.
		//		Generally, 1 should work fine, but you can experiment with queuing more than
		//		one at a time.
		//		This is of course ignored if selectMultipleFiles equals false.
		deferredUploading:0,
	
		postMixInProperties: function(){
			if(this.uploadType === 'flash'){
				this._files = [];
				this._fileMap = {};
				this._createInput = this._createFlashUploader;
				this.getFileList = this.getFlashFileList;
				this.reset = this.flashReset;
				this.upload = this.uploadFlash;
				this.fieldname = "flashUploadFiles"; ///////////////////// this.name
			}
			this.inherited(arguments);
		},
	
		/*************************
		 *	   Public Events	 *
		 *************************/
	
		onReady: function(/*dojox/form/FileUploader*/ uploader){
			// summary:
			//		Stub - Fired when embedFlash has created the
			//		Flash object, but it has not necessarilly finished
			//		downloading, and is ready to be communicated with.
		},
	
		onLoad: function(/*dojox/form/FileUploader*/ uploader){
			// summary:
			//		Stub - SWF has been downloaded 100%.
		},
	
		onFileChange: function(fileArray){
			// summary:
			//		Stub - Flash-specific event. Fires on each selection of files
			//		and only provides the files selected on that event - not all files
			//		selected, as with HTML5
		},
	
		onFileProgress: function(fileArray){
			// summary:
			//		Stub - Flash-specific event. Fires on progress of upload
			//		and only provides a file-specific event
		},
	
	
		/*************************
		 *	   Public Methods	 *
		 *************************/
	
		getFlashFileList: function(){
			// summary:
			//		Returns list of currently selected files
			return this._files; // Array
		},
	
		flashReset: function(){
			this.flashMovie.reset();
			this._files = [];
			this._fileMap = {};
		},
	
		/*************************
		 *	   Private Methods	 *
		 *************************/
	
		uploadFlash: function(/*Object ? */ formData){
			// summary:
			//		Uploads selected files. Alias "upload()" should be used instead.
			// tags:
			//		private
			this.onBegin(this.getFileList());
			formData = formData || {};
			formData.returnType = "F";
			formData.uploadType = this.uploadType;
			console.log('flas upload', formData);
			this.flashMovie.doUpload(formData);
		},
	
		_change: function(fileArray){
			this._files = this._files.concat(fileArray);
			arrayUtil.forEach(fileArray, function(f){
				f.bytesLoaded = 0;
				f.bytesTotal = f.size;
				this._fileMap[f.name+"_"+f.size] = f;
			}, this);
			this.onChange(this._files);
			this.onFileChange(fileArray);
		},
		_complete: function(fileArray){
			var o = this._getCustomEvent();
			o.type = "load";
			this.onComplete(fileArray);
		},
		_progress: function(f){
			this._fileMap[f.name+"_"+f.bytesTotal].bytesLoaded = f.bytesLoaded;
			var o = this._getCustomEvent();
			this.onFileProgress(f);
			this.onProgress(o);
		},
		_error: function(err){
			this.onError(err);
		},
		_onFlashBlur: function(fileArray){
			//console.log("UploaderFlash._onFlashBlur");
		},
	
		_getCustomEvent: function(){
			var o = {
				bytesLoaded:0,
				bytesTotal:0,
				type:"progress",
				timeStamp:new Date().getTime()
			};
	
	
			for(var nm in this._fileMap){
				o.bytesTotal += this._fileMap[nm].bytesTotal;
				o.bytesLoaded += this._fileMap[nm].bytesLoaded;
			}
			o.decimal = o.bytesLoaded / o.bytesTotal;
			o.percent = Math.ceil((o.bytesLoaded / o.bytesTotal)*100)+"%";
			return o; // Object
		},
	
		_connectFlash: function(){
			// summary:
			//		Subscribing to published topics coming from the
			//		Flash uploader.
	
			// Sacrificing some readability for compactness. this.id
			// will be on the beginning of the topic, so more than
			// one uploader can be on a page and can have unique calls.
	
			this._subs = [];
			this._cons = [];
	
			var doSub = lang.hitch(this, function(s, funcStr){
				this._subs.push(connect.subscribe(this.id + s, this, funcStr));
			});
	
			doSub("/filesSelected", "_change");
			doSub("/filesUploaded", "_complete");
			doSub("/filesProgress", "_progress");
			doSub("/filesError", "_error");
			doSub("/filesCanceled", "onCancel");
			doSub("/stageBlur", "_onFlashBlur");
	
			this.connect(this.domNode, "focus", function(){
				// TODO: some kind of indicator that the Flash button is in focus
				this.flashMovie.focus();
				this.flashMovie.doFocus();
			});
			if(this.tabIndex>=0){
				domAttr.set(this.domNode, "tabIndex", this.tabIndex);
			}
		},
		_createFlashUploader: function(){
			// summary:
			//		Internal. Creates Flash Uploader
	
			var w = this.btnSize.w;
			var h = this.btnSize.h;
			if(!w){
				// FIXME: Commit this
				setTimeout(dojo.hitch(this, function(){
					this._getButtonStyle(this.domNode);
					this._createFlashUploader();
				}), 200);
				return;
			}
			var url = this.getUrl();
			if(url){
				if(url.toLowerCase().indexOf("http")<0 && url.indexOf("/")!=0){
					// Appears to be a relative path. Attempt to
					// convert it to absolute, so it will better
					// target the SWF.
					var loc = window.location.href.split("/");
					loc.pop();
					loc = loc.join("/")+"/";
					url = loc+url;
				}
			}else{
				console.warn("Warning: no uploadUrl provided.");
			}
	
			this.inputNode = domConstruct.create("div", {className:"dojoxFlashNode"}, this.domNode, "first");
			domStyle.set(this.inputNode, {
				position:"absolute",
				top:"-2px",
				width:w+"px",
				height:h+"px",
				opacity:0
			});
	
	
	
			var args = {
				expressInstall:true,
				path: (this.swfPath.uri || this.swfPath) + ((this.preventCache)?("?cb_" + (new Date().getTime())):""),
				width: w,
				height: h,
				allowScriptAccess:"always",
				allowNetworking:"all",
				vars: {
					uploadDataFieldName: this.flashFieldName || this.name+"Flash",
					uploadUrl: url,
					uploadOnSelect: this.uploadOnSelect,
					deferredUploading:this.deferredUploading || 0,
					selectMultipleFiles: this.multiple,
					id: this.id,
					isDebug: this.isDebug,
					noReturnCheck: this.skipServerCheck,
					serverTimeout:this.serverTimeout
				},
				params: {
					scale:"noscale",
					//wmode:"transparent",
					wmode:"opaque",
					allowScriptAccess:"always",
					allowNetworking:"all"
				}
	
			};
	
			this.flashObject = new embedFlash(args, this.inputNode);
			this.flashObject.onError = lang.hitch(function(msg){
				console.error("Flash Error: " + msg);
			});
			this.flashObject.onReady = lang.hitch(this, function(){
				this.onReady(this);
			});
			this.flashObject.onLoad = lang.hitch(this, function(mov){
				this.flashMovie = mov;
				this.flashReady = true;
	
				this.onLoad(this);
			});
			this._connectFlash();
		}
	});
});

},
'dojox/embed/Flash':function(){
define([
	"dojo/_base/lang",
	"dojo/_base/unload",
	"dojo/_base/array",
	"dojo/query",
	"dojo/has",
	"dojo/dom",
	"dojo/on",
	"dojo/window",
	"dojo/string"
], function(lang,unload,array,query,has,dom,on,win,stringUtil) {

	// module:
	//		dojox/embed/Flash
	// summary:
	//		Base functionality to insert a flash movie into
	//		a document on the fly.
	// example:
	//	|	var movie=new Flash({ args }, containerNode);


	var fMarkup, fVersion;
	var minimumVersion = 9; // anything below this will throw an error (may overwrite)
	var keyBase = "dojox-embed-flash-", keyCount=0;
	var _baseKwArgs = {
		expressInstall: false,
		width: 320,
		height: 240,
		swLiveConnect: "true",
		allowScriptAccess: "sameDomain",
		allowNetworking:"all",
		style: null,
		redirect: null
	};

	function prep(kwArgs){
		kwArgs = lang.delegate(_baseKwArgs, kwArgs);

		if(!("path" in kwArgs)){
			console.error("dojox.embed.Flash(ctor):: no path reference to a Flash movie was provided.");
			return null;
		}

		if(!("id" in kwArgs)){
			kwArgs.id = (keyBase + keyCount++);
		}
		return kwArgs;
	}

	if(has('ie')) {
		fMarkup = function(kwArgs){
			kwArgs = prep(kwArgs);
			if(!kwArgs){ return null; }

			var p;
			var path = kwArgs.path;
			if(kwArgs.vars){
				var a = [];
				for(p in kwArgs.vars){
					a.push(encodeURIComponent(p) + '=' + encodeURIComponent(kwArgs.vars[p]));
				}
				kwArgs.params.FlashVars = a.join("&");
				delete kwArgs.vars;
			}
			var s = '<object id="' + stringUtil.escape(String(kwArgs.id)) + '" '
				+ 'classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" '
				+ 'width="' + stringUtil.escape(String(kwArgs.width)) + '" '
				+ 'height="' + stringUtil.escape(String(kwArgs.height)) + '"'
				+ ((kwArgs.style)?' style="' + stringUtil.escape(String(kwArgs.style)) + '"':'')
				+ '>'
				+ '<param name="movie" value="' + stringUtil.escape(String(path)) + '" />';
			if(kwArgs.params){
				for(p in kwArgs.params){
					s += '<param name="' + stringUtil.escape(p) + '" value="' + stringUtil.escape(String(kwArgs.params[p])) + '" />';
				}
			}
			s += '</object>';
			return { id: kwArgs.id, markup: s };
		};

		fVersion = (function(){
			var testVersion = 10, testObj = null;
			while(!testObj && testVersion > 7){
				try {
					testObj = new ActiveXObject("ShockwaveFlash.ShockwaveFlash." + testVersion--);
				}catch(e){ }
			}
			if(testObj){
				var v = testObj.GetVariable("$version").split(" ")[1].split(",");
				return {
					major: (v[0]!=null) ? parseInt(v[0]) : 0,
					minor: (v[1]!=null) ? parseInt(v[1]) : 0,
					rev: (v[2]!=null) ? parseInt(v[2]) : 0
				};
			}
			return { major: 0, minor: 0, rev: 0 };
		})();

		//	attach some cleanup for IE, thanks to deconcept :)
		unload.addOnWindowUnload(function(){
			console.warn('***************UNLOAD');
			var dummy = function(){};
			var objs = query("object").
				reverse().
				style("display", "none").
				forEach(function(i){
					for(var p in i){
						if((p != "FlashVars") && typeof i[p] == "function"){
							try{
								i[p] = dummy;
							}catch(e){}
						}
					}
				});
		});

	} else {
		//	*** Sane browsers branch ******************************************************************
		fMarkup = function(kwArgs){
			kwArgs = prep(kwArgs);
			if(!kwArgs){ return null; }

			var p;
			var path = kwArgs.path;
			if(kwArgs.vars){
				var a = [];
				for(p in kwArgs.vars){
					a.push(encodeURIComponent(p) + '=' + encodeURIComponent(kwArgs.vars[p]));
				}
				kwArgs.params.flashVars = a.join("&");
				delete kwArgs.vars;
			}
			var s = '<embed type="application/x-shockwave-flash" '
				+ 'src="' + stringUtil.escape(String(path)) + '" '
				+ 'id="' + stringUtil.escape(String(kwArgs.id)) + '" '
				+ 'width="' + stringUtil.escape(String(kwArgs.width)) + '" '
				+ 'height="' + stringUtil.escape(String(kwArgs.height)) + '"'
				+ ((kwArgs.style)?' style="' + stringUtil.escape(String(kwArgs.style)) + '" ':'')

				+ 'pluginspage="' + window.location.protocol + '//www.adobe.com/go/getflashplayer" ';
			if(kwArgs.params){
				for(p in kwArgs.params){
					s += ' ' + stringUtil.escape(p) + '="' + stringUtil.escape(String(kwArgs.params[p])) + '"';
				}
			}
			s += ' />';
			return { id: kwArgs.id, markup: s };
		};

		fVersion=(function(){
			var plugin = navigator.plugins["Shockwave Flash"];
			if(plugin && plugin.description){
				var v = plugin.description.replace(/([a-zA-Z]|\s)+/, "").replace(/(\s+r|\s+b[0-9]+)/, ".").split(".");
				return {
					major: (v[0]!=null) ? parseInt(v[0]) : 0,
					minor: (v[1]!=null) ? parseInt(v[1]) : 0,
					rev: (v[2]!=null) ? parseInt(v[2]) : 0
				};
			}
			return { major: 0, minor: 0, rev: 0 };
		})();
	}


/*=====
var __flashArgs = {
	// path: String
	//		The URL of the movie to embed.
	// id: String?
	//		A unique key that will be used as the id of the created markup.  If you don't
	//		provide this, a unique key will be generated.
	// width: Number?
	//		The width of the embedded movie; the default value is 320px.
	// height: Number?
	//		The height of the embedded movie; the default value is 240px
	// minimumVersion: Number?
	//		The minimum targeted version of the Flash Player (defaults to 9)
	// style: String?
	//		Any CSS style information (i.e. style="background-color:transparent") you want
	//		to define on the markup.
	// params: Object?
	//		A set of key/value pairs that you want to define in the resultant markup.
	// vars: Object?
	//		A set of key/value pairs that the Flash movie will interpret as FlashVars.
	// expressInstall: Boolean?
	//		Whether or not to include any kind of expressInstall info. Default is false.
	// redirect: String?
	//		A url to redirect the browser to if the current Flash version is not supported.
};
=====*/

	//	the main entry point
	var Flash = function(/*__flashArgs*/ kwArgs, /*DOMNode*/ node){
		// summary:
		//		Create a wrapper object around a Flash movie; this is the DojoX equivilent
		//		to SWFObject.
		//
		// description:
		//		Creates a wrapper object around a Flash movie.  Wrapper object will
		//		insert the movie reference in node; when the browser first starts
		//		grabbing the movie, onReady will be fired; when the movie has finished
		//		loading, it will fire onLoad.
		//
		//		If your movie uses ExternalInterface, you should use the onLoad event
		//		to do any kind of proxy setup (see dojox.embed.Flash.proxy); this seems
		//		to be the only consistent time calling EI methods are stable (since the
		//		Flash movie will shoot several methods into the window object before
		//		EI callbacks can be used properly).
		//
		// kwArgs: __flashArgs
		//		The various arguments that will be used to help define the Flash movie.
		// node: DomNode
		//		The node where the embed object will be placed
		//
		// example:
		//		Embed a flash movie in a document using the new operator, and get a reference to it.
		//	|	var movie = new dojox.embed.Flash({
		//	|		path: "path/to/my/movie.swf",
		//	|		width: 400,
		//	|		height: 300
		//	|	}, myWrapperNode, "testLoaded");
		//
		// example:
		//		Embed a flash movie in a document without using the new operator.
		//	|	var movie = dojox.embed.Flash({
		//	|		path: "path/to/my/movie.swf",
		//	|		width: 400,
		//	|		height: 300,
		//	|		style: "position:absolute;top:0;left:0"
		//	|	}, myWrapperNode, "testLoaded");

		// File can only be run from a server, due to SWF dependency.
		if(location.href.toLowerCase().indexOf("file://")>-1){
			throw new Error("dojox.embed.Flash can't be run directly from a file. To instatiate the required SWF correctly it must be run from a server, like localHost.");
		}

		// available: Number
		//		If there is a flash player available, and if so what version.
		this.available = fVersion.major;

		// minimumVersion: Number
		//		The minimum version of Flash required to run this movie.
		this.minimumVersion = kwArgs.minimumVersion || minimumVersion;

		// id: String
		//		The id of the DOMNode to be used for this movie.  Can be used with dojo.byId to get a reference.
		this.id = null;

		// movie: FlashObject
		//		A reference to the movie itself.
		this.movie = null;

		// domNode: DOMNode
		//		A reference to the DOMNode that contains this movie.
		this.domNode = null;
		if(node){
			node = dom.byId(node);
		}
		// setTimeout Fixes #8743 - creating double SWFs
		// also allows time for code to attach to onError
		setTimeout(lang.hitch(this, function(){
			if(kwArgs.expressInstall || this.available && this.available >= this.minimumVersion){
				if(kwArgs && node){
					this.init(kwArgs, node);
				}else{
					this.onError("embed.Flash was not provided with the proper arguments.");
				}
			}else{
				if(!this.available){
					this.onError("Flash is not installed.");
				}else{
					this.onError("Flash version detected: "+this.available+" is out of date. Minimum required: "+this.minimumVersion);
				}
			}
		}), 100);
	};

	lang.extend(Flash, {
		onReady: function(/*HTMLObject*/ movie){
			// summary:
			//		Stub function for you to attach to when the movie reference is first
			//		pushed into the document.
		},
		onLoad: function(/*HTMLObject*/ movie){
			// summary:
			//		Stub function for you to attach to when the movie has finished downloading
			//		and is ready to be manipulated.
		},
		onError: function(msg){

		},
		_onload: function(){
			// summary:
			//	Internal. Cleans up before calling onLoad.
			clearInterval(this._poller);
			delete this._poller;
			delete this._pollCount;
			delete this._pollMax;
			this.onLoad(this.movie);
		},
		init: function(/*__flashArgs*/ kwArgs, /*DOMNode?*/ node){
			// summary:
			//		Initialize (i.e. place and load) the movie based on kwArgs.
			this.destroy();		//	ensure we are clean first.
			node = dom.byId(node || this.domNode);
			if(!node){ throw new Error("dojox.embed.Flash: no domNode reference has been passed."); }

			// vars to help determine load status
			var p = 0, testLoaded=false;
			this._poller = null; this._pollCount = 0; this._pollMax = 15; this.pollTime = 100;

			if(Flash.initialized){

				this.id = Flash.place(kwArgs, node);
				this.domNode = node;

				setTimeout(lang.hitch(this, function(){
					this.movie = this.byId(this.id, kwArgs.doc);
					this.onReady(this.movie);

					this._poller = setInterval(lang.hitch(this, function(){

						// catch errors if not quite ready.
						try{
							p = this.movie.PercentLoaded();
						}catch(e){
							console.warn("this.movie.PercentLoaded() failed", e, this.movie);
						}

						if(p == 100){
							// if percent = 100, movie is fully loaded and we're communicating
							this._onload();

						}else if(p==0 && this._pollCount++ > this._pollMax){
							// after several attempts, we're not past zero.
							clearInterval(this._poller);
							throw new Error("Building SWF failed.");
						}
					}), this.pollTime);
				}), 1);
			}
		},
		_destroy: function(){
			// summary:
			//		Kill the movie and reset all the properties of this object.
			try{
				this.domNode.removeChild(this.movie);
			}catch(e){}
			this.id = this.movie = this.domNode = null;
		},
		destroy: function(){
			// summary:
			//		Public interface for destroying all the properties in this object.
			//		Will also clean all proxied methods.
			if(!this.movie){ return; }

			//	remove any proxy functions
			var test = lang.delegate({
				id: true,
				movie: true,
				domNode: true,
				onReady: true,
				onLoad: true
			});
			for(var p in this){
				if(!test[p]){
					delete this[p];
				}
			}

			//	poll the movie
			if(this._poller){
				//	wait until onLoad to destroy
				on(this, "Load", this, "_destroy");
			} else {
				this._destroy();
			}
		},
		byId: function (movieName, doc){
			// summary:
			//		Gets Flash movie by id.
			// description:
			//		Probably includes methods for outdated
			//		browsers, but this should catch all cases.
			// movieName: String
			//		The name of the SWF
			// doc: Object
			//		The document, if not current window
			//		(not fully supported)
			// example:
			//	|	var movie = dojox.embed.Flash.byId("myId");

			doc = doc || document;
			if(doc.embeds[movieName]){
				return doc.embeds[movieName];
			}
			if(doc[movieName]){
				return doc[movieName];
			}
			if(window[movieName]){
				return window[movieName];
			}
			if(document[movieName]){
				return document[movieName];
			}
			return null;
		}
	});

	//	expose information through the constructor function itself.
	lang.mixin(Flash, {
		// summary:
		//		A singleton object used internally to get information
		//		about the Flash player available in a browser, and
		//		as the factory for generating and placing markup in a
		//		document.
		//
		// minSupported: Number
		//		The minimum supported version of the Flash Player, defaults to 8.
		// available: Number
		//		Used as both a detection (i.e. if(dojox.embed.Flash.available){ })
		//		and as a variable holding the major version of the player installed.
		// supported: Boolean
		//		Whether or not the Flash Player installed is supported by dojox.embed.
		// version: Object
		//		The version of the installed Flash Player; takes the form of
		//		{ major, minor, rev }.  To get the major version, you'd do this:
		//		var v=dojox.embed.Flash.version.major;
		// initialized: Boolean
		//		Whether or not the Flash engine is available for use.
		// onInitialize: Function
		//		A stub you can connect to if you are looking to fire code when the
		//		engine becomes available.  A note: DO NOT use this event to
		//		place a movie in a document; it will usually fire before DOMContentLoaded
		//		is fired, and you will get an error.  Use dojo.addOnLoad instead.
		minSupported : 8,
		available: fVersion.major,
		supported: (fVersion.major >= fVersion.required),
		minimumRequired: fVersion.required,
		version: fVersion,
		initialized: false,
		onInitialize: function(){
			Flash.initialized = true;
		},
		__ie_markup__: function(kwArgs){
			return fMarkup(kwArgs);
		},
		proxy: function(/*Flash*/ obj, /*Array|String*/ methods){
			// summary:
			//		Create the set of passed methods on the Flash object
			//		so that you can call that object directly, as opposed to having to
			//		delve into the internal movie to do this.  Intended to make working
			//		with Flash movies that use ExternalInterface much easier to use.
			//
			// example:
			//		Create "setMessage" and "getMessage" methods on foo.
			//	|	var foo = new Flash(args, someNode);
			//	|	dojo.connect(foo, "onLoad", lang.hitch(foo, function(){
			//	|		Flash.proxy(this, [ "setMessage", "getMessage" ]);
			//	|		this.setMessage("Flash.proxy is pretty cool...");
			//	|		console.log(this.getMessage());
			//	|	}));
			array.forEach((methods instanceof Array ? methods : [ methods ]), function(item){
				this[item] = lang.hitch(this, function(){
					return (function(){
						return eval(this.movie.CallFunction(
							'<invoke name="' + item + '" returntype="javascript">'
							+ '<arguments>'
							+ array.map(arguments, function(item){
								// FIXME:
								//		investigate if __flash__toXML will
								//		accept direct application via map()
								//		(e.g., does it ignore args past the
								//		first? or does it blow up?)
								return __flash__toXML(item);
							}).join("")
							+ '</arguments>'
							+ '</invoke>'
						));
					}).apply(this, arguments||[]);
				});
			}, obj);
		}
	});

	Flash.place = function(kwArgs, node){
		var o = fMarkup(kwArgs);
		node = dom.byId(node);
		if(!node){
			node = win.doc.createElement("div");
			node.id = o.id+"-container";
			win.body().appendChild(node);
		}
		if(o){
			node.innerHTML = o.markup;
			return o.id;
		}
		return null;
	}
	Flash.onInitialize();

	lang.setObject("dojox.embed.Flash", Flash);

	return Flash;
});

},
'dijit/_Templated':function(){
define([
	"./_WidgetBase",
	"./_TemplatedMixin",
	"./_WidgetsInTemplateMixin",
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.extend lang.isArray
	"dojo/_base/kernel" // kernel.deprecated
], function(_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, array, declare, lang, kernel){

	// module:
	//		dijit/_Templated

	// These arguments can be specified for widgets which are used in templates.
	// Since any widget can be specified as sub widgets in template, mix it
	// into the base widget class.  (This is a hack, but it's effective.)
	// Remove for 2.0.   Also, hide from API doc parser.
	lang.extend(_WidgetBase, /*===== {} || =====*/ {
		waiRole: "",
		waiState:""
	});

	return declare("dijit._Templated", [_TemplatedMixin, _WidgetsInTemplateMixin], {
		// summary:
		//		Deprecated mixin for widgets that are instantiated from a template.
		//		Widgets should use _TemplatedMixin plus if necessary _WidgetsInTemplateMixin instead.

		// widgetsInTemplate: [protected] Boolean
		//		Should we parse the template to find widgets that might be
		//		declared in markup inside it?  False by default.
		widgetsInTemplate: false,

		constructor: function(){
			kernel.deprecated(this.declaredClass + ": dijit._Templated deprecated, use dijit._TemplatedMixin and if necessary dijit._WidgetsInTemplateMixin", "", "2.0");
		},

		_processNode: function(baseNode, getAttrFunc){
			var ret = this.inherited(arguments);

			// Do deprecated waiRole and waiState
			var role = getAttrFunc(baseNode, "waiRole");
			if(role){
				baseNode.setAttribute("role", role);
			}
			var values = getAttrFunc(baseNode, "waiState");
			if(values){
				array.forEach(values.split(/\s*,\s*/), function(stateValue){
					if(stateValue.indexOf('-') != -1){
						var pair = stateValue.split('-');
						baseNode.setAttribute("aria-"+pair[0], pair[1]);
					}
				});
			}

			return ret;
		}
	});
});

},
'dijit/form/CheckBox':function(){
define([
	"require",
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/has",		// has("dijit-legacy-requires")
	"dojo/query", // query
	"dojo/ready",
	"./ToggleButton",
	"./_CheckBoxMixin",
	"dojo/text!./templates/CheckBox.html",
	"dojo/NodeList-dom", // NodeList.addClass/removeClass
	"../a11yclick"	// template uses ondijitclick
], function(require, declare, domAttr, has, query, ready, ToggleButton, _CheckBoxMixin, template){

	// module:
	//		dijit/form/CheckBox

	// Back compat w/1.6, remove for 2.0
	if(has("dijit-legacy-requires")){
		ready(0, function(){
			var requires = ["dijit/form/RadioButton"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	return declare("dijit.form.CheckBox", [ToggleButton, _CheckBoxMixin], {
		// summary:
		//		Same as an HTML checkbox, but with fancy styling.
		//
		// description:
		//		User interacts with real html inputs.
		//		On onclick (which occurs by mouse click, space-bar, or
		//		using the arrow keys to switch the selected radio button),
		//		we update the state of the checkbox/radio.
		//
		//		There are two modes:
		//
		//		1. High contrast mode
		//		2. Normal mode
		//
		//		In case 1, the regular html inputs are shown and used by the user.
		//		In case 2, the regular html inputs are invisible but still used by
		//		the user. They are turned quasi-invisible and overlay the background-image.

		templateString: template,

		baseClass: "dijitCheckBox",

		_setValueAttr: function(/*String|Boolean*/ newValue, /*Boolean*/ priorityChange){
			// summary:
			//		Handler for value= attribute to constructor, and also calls to
			//		set('value', val).
			// description:
			//		During initialization, just saves as attribute to the `<input type=checkbox>`.
			//
			//		After initialization,
			//		when passed a boolean, controls whether or not the CheckBox is checked.
			//		If passed a string, changes the value attribute of the CheckBox (the one
			//		specified as "value" when the CheckBox was constructed
			//		(ex: `<input data-dojo-type="dijit/CheckBox" value="chicken">`).
			//
			//		`widget.set('value', string)` will check the checkbox and change the value to the
			//		specified string.
			//
			//		`widget.set('value', boolean)` will change the checked state.

			if(typeof newValue == "string"){
				this.inherited(arguments);
				newValue = true;
			}
			if(this._created){
				this.set('checked', newValue, priorityChange);
			}
		},
		_getValueAttr: function(){
			// summary:
			//		Hook so get('value') works.
			// description:
			//		If the CheckBox is checked, returns the value attribute.
			//		Otherwise returns false.
			return this.checked && this._get("value");
		},

		// Override behavior from Button, since we don't have an iconNode or valueNode
		_setIconClassAttr: null,
		_setNameAttr: "focusNode",

		postMixInProperties: function(){
			this.inherited(arguments);

			// Need to set initial checked state via node.setAttribute so that form submit works
			// and IE8 radio button tab order is preserved.
			// domAttr.set(node, "checked", bool) doesn't work on IE until node has been attached
			// to <body>, see #8666
			this.checkedAttrSetting = "";
		},

		 _fillContent: function(){
			// Override Button::_fillContent() since it doesn't make sense for CheckBox,
			// since CheckBox doesn't even have a container
		},

		_onFocus: function(){
			if(this.id){
				query("label[for='"+this.id+"']").addClass("dijitFocusedLabel");
			}
			this.inherited(arguments);
		},

		_onBlur: function(){
			if(this.id){
				query("label[for='"+this.id+"']").removeClass("dijitFocusedLabel");
			}
			this.inherited(arguments);
		}
	});
});

},
'dijit/form/_CheckBoxMixin':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-attr" // domAttr.set
], function(declare, domAttr){

	// module:
	//		dijit/form/_CheckBoxMixin

	return declare("dijit.form._CheckBoxMixin", null, {
		// summary:
		//		Mixin to provide widget functionality corresponding to an HTML checkbox
		//
		// description:
		//		User interacts with real html inputs.
		//		On onclick (which occurs by mouse click, space-bar, or
		//		using the arrow keys to switch the selected radio button),
		//		we update the state of the checkbox/radio.
		//

		// type: [private] String
		//		type attribute on `<input>` node.
		//		Overrides `dijit/form/Button.type`.  Users should not change this value.
		type: "checkbox",

		// value: String
		//		As an initialization parameter, equivalent to value field on normal checkbox
		//		(if checked, the value is passed as the value when form is submitted).
		value: "on",

		// readOnly: Boolean
		//		Should this widget respond to user input?
		//		In markup, this is specified as "readOnly".
		//		Similar to disabled except readOnly form values are submitted.
		readOnly: false,

		// aria-pressed for toggle buttons, and aria-checked for checkboxes
		_aria_attr: "aria-checked",

		_setReadOnlyAttr: function(/*Boolean*/ value){
			this._set("readOnly", value);
			domAttr.set(this.focusNode, 'readOnly', value);
		},

		// Override dijit/form/Button._setLabelAttr() since we don't even have a containerNode.
		// Normally users won't try to set label, except when CheckBox or RadioButton is the child of a dojox/layout/TabContainer
		_setLabelAttr: undefined,

		_getSubmitValue: function(/*String*/ value){
			return (value == null || value === "") ? "on" : value;
		},

		_setValueAttr: function(newValue){
			newValue = this._getSubmitValue(newValue);	// "on" to match browser native behavior when value unspecified
			this._set("value", newValue);
			domAttr.set(this.focusNode, "value", newValue);
		},

		reset: function(){
			this.inherited(arguments);
			// Handle unlikely event that the <input type=checkbox> value attribute has changed
			this._set("value", this._getSubmitValue(this.params.value));
			domAttr.set(this.focusNode, 'value', this.value);
		},

		_onClick: function(/*Event*/ e){
			// summary:
			//		Internal function to handle click actions - need to check
			//		readOnly, since button no longer does that check.
			if(this.readOnly){
				e.stopPropagation();
				e.preventDefault();
				return false;
			}
			return this.inherited(arguments);
		}
	});
});

},
'dijit/form/SimpleTextarea':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add
	"dojo/sniff", // has("ie") has("opera")
	"./TextBox"
], function(declare, domClass, has, TextBox){

	// module:
	//		dijit/form/SimpleTextarea

	return declare("dijit.form.SimpleTextarea", TextBox, {
		// summary:
		//		A simple textarea that degrades, and responds to
		//		minimal LayoutContainer usage, and works with dijit/form/Form.
		//		Doesn't automatically size according to input, like Textarea.
		//
		// example:
		//	|	<textarea data-dojo-type="dijit/form/SimpleTextarea" name="foo" value="bar" rows=30 cols=40></textarea>
		//
		// example:
		//	|	new SimpleTextarea({ rows:20, cols:30 }, "foo");

		baseClass: "dijitTextBox dijitTextArea",

		// rows: Number
		//		The number of rows of text.
		rows: "3",

		// rows: Number
		//		The number of characters per line.
		cols: "20",

		templateString: "<textarea ${!nameAttrSetting} data-dojo-attach-point='focusNode,containerNode,textbox' autocomplete='off'></textarea>",

		postMixInProperties: function(){
			// Copy value from srcNodeRef, unless user specified a value explicitly (or there is no srcNodeRef)
			// TODO: parser will handle this in 2.0
			if(!this.value && this.srcNodeRef){
				this.value = this.srcNodeRef.value;
			}
			this.inherited(arguments);
		},

		buildRendering: function(){
			this.inherited(arguments);
			if(has("ie") && this.cols){ // attribute selectors is not supported in IE6
				domClass.add(this.textbox, "dijitTextAreaCols");
			}
		},

		filter: function(/*String*/ value){
			// Override TextBox.filter to deal with newlines... specifically (IIRC) this is for IE which writes newlines
			// as \r\n instead of just \n
			if(value){
				value = value.replace(/\r/g, "");
			}
			return this.inherited(arguments);
		},

		_onInput: function(/*Event?*/ e){
			// Override TextBox._onInput() to enforce maxLength restriction
			if(this.maxLength){
				var maxLength = parseInt(this.maxLength);
				var value = this.textbox.value.replace(/\r/g, '');
				var overflow = value.length - maxLength;
				if(overflow > 0){
					var textarea = this.textbox;
					if(textarea.selectionStart){
						var pos = textarea.selectionStart;
						var cr = 0;
						if(has("opera")){
							cr = (this.textbox.value.substring(0, pos).match(/\r/g) || []).length;
						}
						this.textbox.value = value.substring(0, pos - overflow - cr) + value.substring(pos - cr);
						textarea.setSelectionRange(pos - overflow, pos - overflow);
					}else if(this.ownerDocument.selection){ //IE
						textarea.focus();
						var range = this.ownerDocument.selection.createRange();
						// delete overflow characters
						range.moveStart("character", -overflow);
						range.text = '';
						// show cursor
						range.select();
					}
				}
			}
			this.inherited(arguments);
		}
	});
});

},
'dijit/form/Textarea':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-style", // domStyle.set
	"./_ExpandingTextAreaMixin",
	"./SimpleTextarea"
], function(declare, domStyle, _ExpandingTextAreaMixin, SimpleTextarea){

	// module:
	//		dijit/form/Textarea

	return declare("dijit.form.Textarea", [SimpleTextarea, _ExpandingTextAreaMixin], {
		// summary:
		//		A textarea widget that adjusts it's height according to the amount of data.
		//
		// description:
		//		A textarea that dynamically expands/contracts (changing it's height) as
		//		the user types, to display all the text without requiring a scroll bar.
		//
		//		Takes nearly all the parameters (name, value, etc.) that a vanilla textarea takes.
		//		Rows is not supported since this widget adjusts the height.


		// TODO: for 2.0, rename this to ExpandingTextArea, and rename SimpleTextarea to TextArea

		baseClass: "dijitTextBox dijitTextArea dijitExpandingTextArea",

		// Override SimpleTextArea.cols to default to width:100%, for backward compatibility
		cols: "",

		buildRendering: function(){
			this.inherited(arguments);

			// tweak textarea style to reduce browser differences
			domStyle.set(this.textbox, { overflowY: 'hidden', overflowX: 'auto', boxSizing: 'border-box', MsBoxSizing: 'border-box', WebkitBoxSizing: 'border-box', MozBoxSizing: 'border-box' });
		}
	});
});

},
'dijit/form/_ExpandingTextAreaMixin':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-construct", // domConstruct.create
	"dojo/has",
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/_base/window", // win.body
	"../Viewport"
], function(declare, domConstruct, has, lang, on, win, Viewport){

	// module:
	//		dijit/form/_ExpandingTextAreaMixin

	// feature detection, true for mozilla and webkit
	has.add("textarea-needs-help-shrinking", function(){
		var body = win.body(),	// note: if multiple documents exist, doesn't matter which one we use
			te = domConstruct.create('textarea', {
			rows:"5",
			cols:"20",
			value: ' ',
			style: {zoom:1, fontSize:"12px", height:"96px", overflow:'hidden', visibility:'hidden', position:'absolute', border:"5px solid white", margin:"0", padding:"0", boxSizing: 'border-box', MsBoxSizing: 'border-box', WebkitBoxSizing: 'border-box', MozBoxSizing: 'border-box' }
		}, body, "last");
		var needsHelpShrinking = te.scrollHeight >= te.clientHeight;
		body.removeChild(te);
		return needsHelpShrinking;
	});

	return declare("dijit.form._ExpandingTextAreaMixin", null, {
		// summary:
		//		Mixin for textarea widgets to add auto-expanding capability

		_setValueAttr: function(){
			this.inherited(arguments);
			this.resize();
		},

		postCreate: function(){
			this.inherited(arguments);
			var textarea = this.textbox;
			textarea.style.overflowY = "hidden";
			this.own(on(textarea, "focus, resize", lang.hitch(this, "_resizeLater")));
		},

		startup: function(){ 
			this.inherited(arguments);
			this.own(Viewport.on("resize", lang.hitch(this, "_resizeLater")));
			this._resizeLater();
		},

		_onInput: function(e){
			this.inherited(arguments);
			this.resize();
		},

		_estimateHeight: function(){
			// summary:
			//		Approximate the height when the textarea is invisible with the number of lines in the text.
			//		Fails when someone calls setValue with a long wrapping line, but the layout fixes itself when the user clicks inside so . . .
			//		In IE, the resize event is supposed to fire when the textarea becomes visible again and that will correct the size automatically.
			//
			var textarea = this.textbox;
			// #rows = #newlines+1
			textarea.rows = (textarea.value.match(/\n/g) || []).length + 1;
		},

		_resizeLater: function(){
			this.defer("resize");
		},

		resize: function(){
			// summary:
			//		Resizes the textarea vertically (should be called after a style/value change)

			var textarea = this.textbox;

			function textareaScrollHeight(){
				var empty = false;
				if(textarea.value === ''){
					textarea.value = ' ';
					empty = true;
				}
				var sh = textarea.scrollHeight;
				if(empty){ textarea.value = ''; }
				return sh;
			}

			if(textarea.style.overflowY == "hidden"){ textarea.scrollTop = 0; }
			if(this.busyResizing){ return; }
			this.busyResizing = true;
			if(textareaScrollHeight() || textarea.offsetHeight){
				var newH = textareaScrollHeight() + Math.max(textarea.offsetHeight - textarea.clientHeight, 0);
				var newHpx = newH + "px";
				if(newHpx != textarea.style.height){
					textarea.style.height = newHpx;
					textarea.rows = 1; // rows can act like a minHeight if not cleared
				}
				if(has("textarea-needs-help-shrinking")){
					var	origScrollHeight = textareaScrollHeight(),
						newScrollHeight = origScrollHeight,
						origMinHeight = textarea.style.minHeight,
						decrement = 4, // not too fast, not too slow
						thisScrollHeight,
						origScrollTop = textarea.scrollTop;
					textarea.style.minHeight = newHpx; // maintain current height
					textarea.style.height = "auto"; // allow scrollHeight to change
					while(newH > 0){
						textarea.style.minHeight = Math.max(newH - decrement, 4) + "px";
						thisScrollHeight = textareaScrollHeight();
						var change = newScrollHeight - thisScrollHeight;
						newH -= change;
						if(change < decrement){
							break; // scrollHeight didn't shrink
						}
						newScrollHeight = thisScrollHeight;
						decrement <<= 1;
					}
					textarea.style.height = newH + "px";
					textarea.style.minHeight = origMinHeight;
					textarea.scrollTop = origScrollTop;
				}
				textarea.style.overflowY = textareaScrollHeight() > textarea.clientHeight ? "auto" : "hidden";
				if(textarea.style.overflowY == "hidden"){ textarea.scrollTop = 0; }
			}else{
				// hidden content of unknown size
				this._estimateHeight();
			}
			this.busyResizing = false;
		}
	});
});

},
'dijit/form/RadioButton':function(){
define([
	"dojo/_base/declare", // declare
	"./CheckBox",
	"./_RadioButtonMixin"
], function(declare, CheckBox, _RadioButtonMixin){

	// module:
	//		dijit/form/RadioButton

	return declare("dijit.form.RadioButton", [CheckBox, _RadioButtonMixin], {
		// summary:
		//		Same as an HTML radio, but with fancy styling.

		baseClass: "dijitRadio"
	});
});

},
'dijit/form/_RadioButtonMixin':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/_base/lang", // lang.hitch
	"dojo/query!css2", // query
	"../registry"    // registry.getEnclosingWidget
], function(array, declare, domAttr, lang, query, registry){

	// module:
	//		dijit/form/_RadioButtonMixin

	return declare("dijit.form._RadioButtonMixin", null, {
		// summary:
		//		Mixin to provide widget functionality for an HTML radio button

		// type: [private] String
		//		type attribute on `<input>` node.
		//		Users should not change this value.
		type: "radio",

		_getRelatedWidgets: function(){
			// Private function needed to help iterate over all radio buttons in a group.
			var ary = [];
			query("input[type=radio]", this.focusNode.form || this.ownerDocument).forEach(// can't use name= since query doesn't support [] in the name
				lang.hitch(this, function(inputNode){
					if(inputNode.name == this.name && inputNode.form == this.focusNode.form){
						var widget = registry.getEnclosingWidget(inputNode);
						if(widget){
							ary.push(widget);
						}
					}
				})
			);
			return ary;
		},

		_setCheckedAttr: function(/*Boolean*/ value){
			// If I am being checked then have to deselect currently checked radio button
			this.inherited(arguments);
			if(!this._created){
				return;
			}
			if(value){
				array.forEach(this._getRelatedWidgets(), lang.hitch(this, function(widget){
					if(widget != this && widget.checked){
						widget.set('checked', false);
					}
				}));
			}
		},

		_getSubmitValue: function(/*String*/ value){
			return value == null ? "on" : value;
		},

		_onClick: function(/*Event*/ e){
			if(this.checked || this.disabled){ // nothing to do
				e.stopPropagation();
				e.preventDefault();
				return false;
			}
			if(this.readOnly){ // ignored by some browsers so we have to resync the DOM elements with widget values
				e.stopPropagation();
				e.preventDefault();
				array.forEach(this._getRelatedWidgets(), lang.hitch(this, function(widget){
					domAttr.set(this.focusNode || this.domNode, 'checked', widget.checked);
				}));
				return false;
			}
			return this.inherited(arguments);
		}
	});
});

},
'dijit/form/FilteringSelect':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.mixin
	"dojo/when",
	"./MappedTextBox",
	"./ComboBoxMixin"
], function(declare, lang, when, MappedTextBox, ComboBoxMixin){

	// module:
	//		dijit/form/FilteringSelect

	return declare("dijit.form.FilteringSelect", [MappedTextBox, ComboBoxMixin], {
		// summary:
		//		An enhanced version of the HTML SELECT tag, populated dynamically
		//
		// description:
		//		An enhanced version of the HTML SELECT tag, populated dynamically. It works
		//		very nicely with very large data sets because it can load and page data as needed.
		//		It also resembles ComboBox, but does not allow values outside of the provided ones.
		//		If OPTION tags are used as the data provider via markup, then the
		//		OPTION tag's child text node is used as the displayed value when selected
		//		while the OPTION tag's value attribute is used as the widget value on form submit.
		//		To set the default value when using OPTION tags, specify the selected
		//		attribute on 1 of the child OPTION tags.
		//
		//		Similar features:
		//
		//		- There is a drop down list of possible values.
		//		- You can only enter a value from the drop down list.  (You can't
		//			enter an arbitrary value.)
		//		- The value submitted with the form is the hidden value (ex: CA),
		//			not the displayed value a.k.a. label (ex: California)
		//
		//		Enhancements over plain HTML version:
		//
		//		- If you type in some text then it will filter down the list of
		//			possible values in the drop down list.
		//		- List can be specified either as a static list or via a javascript
		//			function (that can get the list from a server)

		// required: Boolean
		//		True (default) if user is required to enter a value into this field.
		required: true,

		_lastDisplayedValue: "",

		_isValidSubset: function(){
			return this._opened;
		},

		isValid: function(){
			// Overrides ValidationTextBox.isValid()
			return !!this.item || (!this.required && this.get('displayedValue') == ""); // #5974
		},

		_refreshState: function(){
			if(!this.searchTimer){ // state will be refreshed after results are returned
				this.inherited(arguments);
			}
		},

		_callbackSetLabel: function(
						/*Array*/ result,
						/*Object*/ query,
						/*Object*/ options,
						/*Boolean?*/ priorityChange){
			// summary:
			//		Callback from dojo.store after lookup of user entered value finishes

			// setValue does a synchronous lookup,
			// so it calls _callbackSetLabel directly,
			// and so does not pass dataObject
			// still need to test against _lastQuery in case it came too late
			if((query && query[this.searchAttr] !== this._lastQuery) || (!query && result.length && this.store.getIdentity(result[0]) != this._lastQuery)){
				return;
			}
			if(!result.length){
				//#3268: don't modify display value on bad input
				//#3285: change CSS to indicate error
				this.set("value", '', priorityChange || (priorityChange === undefined && !this.focused), this.textbox.value, null);
			}else{
				this.set('item', result[0], priorityChange);
			}
		},

		_openResultList: function(/*Object*/ results, /*Object*/ query, /*Object*/ options){
			// Callback when a data store query completes.
			// Overrides ComboBox._openResultList()

			// #3285: tap into search callback to see if user's query resembles a match
			if(query[this.searchAttr] !== this._lastQuery){
				return;
			}
			this.inherited(arguments);

			if(this.item === undefined){ // item == undefined for keyboard search
				// If the search returned no items that means that the user typed
				// in something invalid (and they can't make it valid by typing more characters),
				// so flag the FilteringSelect as being in an invalid state
				this.validate(true);
			}
		},

		_getValueAttr: function(){
			// summary:
			//		Hook for get('value') to work.

			// don't get the textbox value but rather the previously set hidden value.
			// Use this.valueNode.value which isn't always set for other MappedTextBox widgets until blur
			return this.valueNode.value;
		},

		_getValueField: function(){
			// Overrides ComboBox._getValueField()
			return "value";
		},

		_setValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange, /*String?*/ displayedValue, /*item?*/ item){
			// summary:
			//		Hook so set('value', value) works.
			// description:
			//		Sets the value of the select.
			//		Also sets the label to the corresponding value by reverse lookup.
			if(!this._onChangeActive){ priorityChange = null; }

			if(item === undefined){
				if(value === null || value === ''){
					value = '';
					if(!lang.isString(displayedValue)){
						this._setDisplayedValueAttr(displayedValue||'', priorityChange);
						return;
					}
				}

				var self = this;
				this._lastQuery = value;
				when(this.store.get(value), function(item){
					self._callbackSetLabel(item? [item] : [], undefined, undefined, priorityChange);
				});
			}else{
				this.valueNode.value = value;
				this.inherited(arguments, [value, priorityChange, displayedValue, item]);
			}
		},

		_setItemAttr: function(/*item*/ item, /*Boolean?*/ priorityChange, /*String?*/ displayedValue){
			// summary:
			//		Set the displayed valued in the input box, and the hidden value
			//		that gets submitted, based on a dojo.data store item.
			// description:
			//		Users shouldn't call this function; they should be calling
			//		set('item', value)
			// tags:
			//		private
			this.inherited(arguments);
			this._lastDisplayedValue = this.textbox.value;
		},

		_getDisplayQueryString: function(/*String*/ text){
			return text.replace(/([\\\*\?])/g, "\\$1");
		},

		_setDisplayedValueAttr: function(/*String*/ label, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so set('displayedValue', label) works.
			// description:
			//		Sets textbox to display label. Also performs reverse lookup
			//		to set the hidden value.  label should corresponding to item.searchAttr.

			if(label == null){ label = ''; }

			// This is called at initialization along with every custom setter.
			// Usually (or always?) the call can be ignored.   If it needs to be
			// processed then at least make sure that the XHR request doesn't trigger an onChange()
			// event, even if it returns after creation has finished
			if(!this._created){
				if(!("displayedValue" in this.params)){
					return;
				}
				priorityChange = false;
			}

			// Do a reverse lookup to map the specified displayedValue to the hidden value.
			// Note that if there's a custom labelFunc() this code
			if(this.store){
				this.closeDropDown();
				var query = lang.clone(this.query); // #6196: populate query with user-specifics

				// Generate query
				var qs = this._getDisplayQueryString(label), q;
				if(this.store._oldAPI){
					// remove this branch for 2.0
					q = qs;
				}else{
					// Query on searchAttr is a regex for benefit of dojo/store/Memory,
					// but with a toString() method to help dojo/store/JsonRest.
					// Search string like "Co*" converted to regex like /^Co.*$/i.
					q = this._patternToRegExp(qs);
					q.toString = function(){ return qs; };
				}
				this._lastQuery = query[this.searchAttr] = q;

				// If the label is not valid, the callback will never set it,
				// so the last valid value will get the warning textbox.   Set the
				// textbox value now so that the impending warning will make
				// sense to the user
				this.textbox.value = label;
				this._lastDisplayedValue = label;
				this._set("displayedValue", label);	// for watch("displayedValue") notification
				var _this = this;
				var options = {
					queryOptions: {
						ignoreCase: this.ignoreCase,
						deep: true
					}
				};
				lang.mixin(options, this.fetchProperties);
				this._fetchHandle = this.store.query(query, options);
				when(this._fetchHandle, function(result){
					_this._fetchHandle = null;
					_this._callbackSetLabel(result || [], query, options, priorityChange);
				}, function(err){
					_this._fetchHandle = null;
					if(!_this._cancelingQuery){	// don't treat canceled query as an error
						console.error('dijit.form.FilteringSelect: ' + err.toString());
					}
				});
			}
		},

		undo: function(){
			this.set('displayedValue', this._lastDisplayedValue);
		}
	});
});

},
'dojo/store/Observable':function(){
define(["../_base/kernel", "../_base/lang", "../when", "../_base/array" /*=====, "./api/Store" =====*/
], function(kernel, lang, when, array /*=====, Store =====*/){

// module:
//		dojo/store/Observable

var Observable = function(/*Store*/ store){
	// summary:
	//		The Observable store wrapper takes a store and sets an observe method on query()
	//		results that can be used to monitor results for changes.
	//
	// description:
	//		Observable wraps an existing store so that notifications can be made when a query
	//		is performed.
	//
	// example:
	//		Create a Memory store that returns an observable query, and then log some
	//		information about that query.
	//
	//	|	var store = Observable(new Memory({
	//	|		data: [
	//	|			{id: 1, name: "one", prime: false},
	//	|			{id: 2, name: "two", even: true, prime: true},
	//	|			{id: 3, name: "three", prime: true},
	//	|			{id: 4, name: "four", even: true, prime: false},
	//	|			{id: 5, name: "five", prime: true}
	//	|		]
	//	|	}));
	//	|	var changes = [], results = store.query({ prime: true });
	//	|	var observer = results.observe(function(object, previousIndex, newIndex){
	//	|		changes.push({previousIndex:previousIndex, newIndex:newIndex, object:object});
	//	|	});
	//
	//		See the Observable tests for more information.

	var undef, queryUpdaters = [], revision = 0;
	// a Comet driven store could directly call notify to notify observers when data has
	// changed on the backend
	// create a new instance
	store = lang.delegate(store);
	
	store.notify = function(object, existingId){
		revision++;
		var updaters = queryUpdaters.slice();
		for(var i = 0, l = updaters.length; i < l; i++){
			updaters[i](object, existingId);
		}
	};
	var originalQuery = store.query;
	store.query = function(query, options){
		options = options || {};
		var results = originalQuery.apply(this, arguments);
		if(results && results.forEach){
			var nonPagedOptions = lang.mixin({}, options);
			delete nonPagedOptions.start;
			delete nonPagedOptions.count;

			var queryExecutor = store.queryEngine && store.queryEngine(query, nonPagedOptions);
			var queryRevision = revision;
			var listeners = [], queryUpdater;
			results.observe = function(listener, includeObjectUpdates){
				if(listeners.push(listener) == 1){
					// first listener was added, create the query checker and updater
					queryUpdaters.push(queryUpdater = function(changed, existingId){
						when(results, function(resultsArray){
							var atEnd = resultsArray.length != options.count;
							var i, l, listener;
							if(++queryRevision != revision){
								throw new Error("Query is out of date, you must observe() the query prior to any data modifications");
							}
							var removedObject, removedFrom = -1, insertedInto = -1;
							if(existingId !== undef){
								// remove the old one
								for(i = 0, l = resultsArray.length; i < l; i++){
									var object = resultsArray[i];
									if(store.getIdentity(object) == existingId){
										removedObject = object;
										removedFrom = i;
										if(queryExecutor || !changed){// if it was changed and we don't have a queryExecutor, we shouldn't remove it because updated objects would be eliminated
											resultsArray.splice(i, 1);
										}
										break;
									}
								}
							}
							if(queryExecutor){
								// add the new one
								if(changed &&
										// if a matches function exists, use that (probably more efficient)
										(queryExecutor.matches ? queryExecutor.matches(changed) : queryExecutor([changed]).length)){

									var firstInsertedInto = removedFrom > -1 ? 
										removedFrom : // put back in the original slot so it doesn't move unless it needs to (relying on a stable sort below)
										resultsArray.length;
									resultsArray.splice(firstInsertedInto, 0, changed); // add the new item
									insertedInto = array.indexOf(queryExecutor(resultsArray), changed); // sort it
									// we now need to push the change back into the original results array
									resultsArray.splice(firstInsertedInto, 1); // remove the inserted item from the previous index
									
									if((options.start && insertedInto == 0) ||
										(!atEnd && insertedInto == resultsArray.length)){
										// if it is at the end of the page, assume it goes into the prev or next page
										insertedInto = -1;
									}else{
										resultsArray.splice(insertedInto, 0, changed); // and insert into the results array with the correct index
									}
								}
							}else if(changed){
								// we don't have a queryEngine, so we can't provide any information
								// about where it was inserted or moved to. If it is an update, we leave it's position alone, other we at least indicate a new object
								if(existingId !== undef){
									// an update, keep the index the same
									insertedInto = removedFrom;
								}else if(!options.start){
									// a new object
									insertedInto = store.defaultIndex || 0;
									resultsArray.splice(insertedInto, 0, changed);
								}
							}
							if((removedFrom > -1 || insertedInto > -1) &&
									(includeObjectUpdates || !queryExecutor || (removedFrom != insertedInto))){
								var copyListeners = listeners.slice();
								for(i = 0;listener = copyListeners[i]; i++){
									listener(changed || removedObject, removedFrom, insertedInto);
								}
							}
						});
					});
				}
				var handle = {};
				// TODO: Remove cancel in 2.0.
				handle.remove = handle.cancel = function(){
					// remove this listener
					var index = array.indexOf(listeners, listener);
					if(index > -1){ // check to make sure we haven't already called cancel
						listeners.splice(index, 1);
						if(!listeners.length){
							// no more listeners, remove the query updater too
							queryUpdaters.splice(array.indexOf(queryUpdaters, queryUpdater), 1);
						}
					}
				};
				return handle;
			};
		}
		return results;
	};
	var inMethod;
	function whenFinished(method, action){
		var original = store[method];
		if(original){
			store[method] = function(value){
				var originalId;
				if(method === 'put'){
					originalId = store.getIdentity(value);
				}
				if(inMethod){
					// if one method calls another (like add() calling put()) we don't want two events
					return original.apply(this, arguments);
				}
				inMethod = true;
				try{
					var results = original.apply(this, arguments);
					when(results, function(results){
						action((typeof results == "object" && results) || value, originalId);
					});
					return results;
				}finally{
					inMethod = false;
				}
			};
		}
	}
	// monitor for updates by listening to these methods
	whenFinished("put", function(object, originalId){
		store.notify(object, originalId);
	});
	whenFinished("add", function(object){
		store.notify(object);
	});
	whenFinished("remove", function(id){
		store.notify(undefined, id);
	});

	return store;
};

lang.setObject("dojo.store.Observable", Observable);

return Observable;
});

},
'dojo/store/JsonRest':function(){
define(["../_base/xhr", "../_base/lang", "../json", "../_base/declare", "./util/QueryResults" /*=====, "./api/Store" =====*/
], function(xhr, lang, JSON, declare, QueryResults /*=====, Store =====*/){

// No base class, but for purposes of documentation, the base class is dojo/store/api/Store
var base = null;
/*===== base = Store; =====*/

/*=====
var __HeaderOptions = {
		// headers: Object?
		//		Additional headers to send along with the request.
	},
	__PutDirectives = declare(Store.PutDirectives, __HeaderOptions),
	__QueryOptions = declare(Store.QueryOptions, __HeaderOptions);
=====*/

return declare("dojo.store.JsonRest", base, {
	// summary:
	//		This is a basic store for RESTful communicating with a server through JSON
	//		formatted data. It implements dojo/store/api/Store.

	constructor: function(options){
		// summary:
		//		This is a basic store for RESTful communicating with a server through JSON
		//		formatted data.
		// options: dojo/store/JsonRest
		//		This provides any configuration information that will be mixed into the store
		this.headers = {};
		declare.safeMixin(this, options);
	},

	// headers: Object
	//		Additional headers to pass in all requests to the server. These can be overridden
	//		by passing additional headers to calls to the store.
	headers: {},

	// target: String
	//		The target base URL to use for all requests to the server. This string will be
	//		prepended to the id to generate the URL (relative or absolute) for requests
	//		sent to the server
	target: "",

	// idProperty: String
	//		Indicates the property to use as the identity property. The values of this
	//		property should be unique.
	idProperty: "id",

	// rangeParam: String
	//		Use a query parameter for the requested range. If this is omitted, than the
	//		Range header will be used. Independent of this, the X-Range header is always set.

	// sortParam: String
	//		The query parameter to used for holding sort information. If this is omitted, than
	//		the sort information is included in a functional query token to avoid colliding
	//		with the set of name/value pairs.

	// ascendingPrefix: String
	//		The prefix to apply to sort attribute names that are ascending
	ascendingPrefix: "+",

	// descendingPrefix: String
	//		The prefix to apply to sort attribute names that are ascending
	descendingPrefix: "-",
	 
	_getTarget: function(id){
		// summary:
		//		If the target has no trailing '/', then append it.
		// id: Number
		//		The identity of the requested target
		var target = this.target;
		if(typeof id != "undefined"){
			if(target.charAt(target.length-1) == '/'){
				target += id;
			}else{
				target += '/' + id;
			}
		}
		return target;
	},
					
	get: function(id, options){
		// summary:
		//		Retrieves an object by its identity. This will trigger a GET request to the server using
		//		the url `this.target + id`.
		// id: Number
		//		The identity to use to lookup the object
		// options: Object?
		//		HTTP headers. For consistency with other methods, if a `headers` key exists on this object, it will be
		//		used to provide HTTP headers instead.
		// returns: Object
		//		The object in the store that matches the given id.
		options = options || {};
		var headers = lang.mixin({ Accept: this.accepts }, this.headers, options.headers || options);
		return xhr("GET", {
			url: this._getTarget(id),
			handleAs: "json",
			headers: headers
		});
	},

	// accepts: String
	//		Defines the Accept header to use on HTTP requests
	accepts: "application/javascript, application/json",

	getIdentity: function(object){
		// summary:
		//		Returns an object's identity
		// object: Object
		//		The object to get the identity from
		// returns: Number
		return object[this.idProperty];
	},

	put: function(object, options){
		// summary:
		//		Stores an object. This will trigger a PUT request to the server
		//		if the object has an id, otherwise it will trigger a POST request.
		// object: Object
		//		The object to store.
		// options: __PutDirectives?
		//		Additional metadata for storing the data.  Includes an "id"
		//		property if a specific id is to be used.
		// returns: dojo/_base/Deferred
		options = options || {};
		var id = ("id" in options) ? options.id : this.getIdentity(object);
		var hasId = typeof id != "undefined";
		return xhr(hasId && !options.incremental ? "PUT" : "POST", {
				url: this._getTarget(id),
				postData: JSON.stringify(object),
				handleAs: "json",
				headers: lang.mixin({
					"Content-Type": "application/json",
					Accept: this.accepts,
					"If-Match": options.overwrite === true ? "*" : null,
					"If-None-Match": options.overwrite === false ? "*" : null
				}, this.headers, options.headers)
			});
	},

	add: function(object, options){
		// summary:
		//		Adds an object. This will trigger a PUT request to the server
		//		if the object has an id, otherwise it will trigger a POST request.
		// object: Object
		//		The object to store.
		// options: __PutDirectives?
		//		Additional metadata for storing the data.  Includes an "id"
		//		property if a specific id is to be used.
		options = options || {};
		options.overwrite = false;
		return this.put(object, options);
	},

	remove: function(id, options){
		// summary:
		//		Deletes an object by its identity. This will trigger a DELETE request to the server.
		// id: Number
		//		The identity to use to delete the object
		// options: __HeaderOptions?
		//		HTTP headers.
		options = options || {};
		return xhr("DELETE", {
			url: this._getTarget(id),
			headers: lang.mixin({}, this.headers, options.headers)
		});
	},

	query: function(query, options){
		// summary:
		//		Queries the store for objects. This will trigger a GET request to the server, with the
		//		query added as a query string.
		// query: Object
		//		The query to use for retrieving objects from the store.
		// options: __QueryOptions?
		//		The optional arguments to apply to the resultset.
		// returns: dojo/store/api/Store.QueryResults
		//		The results of the query, extended with iterative methods.
		options = options || {};

		var headers = lang.mixin({ Accept: this.accepts }, this.headers, options.headers);

		var hasQuestionMark = this.target.indexOf("?") > -1;
		if(query && typeof query == "object"){
			query = xhr.objectToQuery(query);
			query = query ? (hasQuestionMark ? "&" : "?") + query: "";
		}
		if(options.start >= 0 || options.count >= 0){
			headers["X-Range"] = "items=" + (options.start || '0') + '-' +
				(("count" in options && options.count != Infinity) ?
					(options.count + (options.start || 0) - 1) : '');
			if(this.rangeParam){
				query += (query || hasQuestionMark ? "&" : "?") + this.rangeParam + "=" + headers["X-Range"];
				hasQuestionMark = true;
			}else{
				headers.Range = headers["X-Range"];
			}
		}
		if(options && options.sort){
			var sortParam = this.sortParam;
			query += (query || hasQuestionMark ? "&" : "?") + (sortParam ? sortParam + '=' : "sort(");
			for(var i = 0; i<options.sort.length; i++){
				var sort = options.sort[i];
				query += (i > 0 ? "," : "") + (sort.descending ? this.descendingPrefix : this.ascendingPrefix) + encodeURIComponent(sort.attribute);
			}
			if(!sortParam){
				query += ")";
			}
		}
		var results = xhr("GET", {
			url: this.target + (query || ""),
			handleAs: "json",
			headers: headers
		});
		results.total = results.then(function(){
			var range = results.ioArgs.xhr.getResponseHeader("Content-Range");
			if (!range){
				// At least Chrome drops the Content-Range header from cached replies.
				range = results.ioArgs.xhr.getResponseHeader("X-Content-Range");
			}
			return range && (range = range.match(/\/(.*)/)) && +range[1];
		});
		return QueryResults(results);
	}
});

});
},
'dijit/form/Form':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/sniff", // has("ie")
	"../_Widget",
	"../_TemplatedMixin",
	"./_FormMixin",
	"../layout/_ContentPaneResizeMixin"
], function(declare, domAttr, kernel, has, _Widget, _TemplatedMixin, _FormMixin, _ContentPaneResizeMixin){

	// module:
	//		dijit/form/Form


	return declare("dijit.form.Form", [_Widget, _TemplatedMixin, _FormMixin, _ContentPaneResizeMixin], {
		// summary:
		//		Widget corresponding to HTML form tag, for validation and serialization
		//
		// example:
		//	|	<form data-dojo-type="dijit/form/Form" id="myForm">
		//	|		Name: <input type="text" name="name" />
		//	|	</form>
		//	|	// Example assumes you have required dijit/registry
		//	|	myObj = {name: "John Doe"};
		//	|	registry.byId('myForm').set('value', myObj);
		//	|
		//	|	myObj=registry.byId('myForm').get('value');

		// HTML <FORM> attributes

		// name: String?
		//		Name of form for scripting.
		name: "",

		// action: String?
		//		Server-side form handler.
		action: "",

		// method: String?
		//		HTTP method used to submit the form, either "GET" or "POST".
		method: "",

		// encType: String?
		//		Encoding type for the form, ex: application/x-www-form-urlencoded.
		encType: "",

		// accept-charset: String?
		//		List of supported charsets.
		"accept-charset": "",

		// accept: String?
		//		List of MIME types for file upload.
		accept: "",

		// target: String?
		//		Target frame for the document to be opened in.
		target: "",

		templateString: "<form data-dojo-attach-point='containerNode' data-dojo-attach-event='onreset:_onReset,onsubmit:_onSubmit' ${!nameAttrSetting}></form>",

		postMixInProperties: function(){
			// Setup name=foo string to be referenced from the template (but only if a name has been specified)
			// Unfortunately we can't use _setNameAttr to set the name due to IE limitations, see #8660
			this.nameAttrSetting = this.name ? ("name='" + this.name + "'") : "";
			this.inherited(arguments);
		},

		execute: function(/*Object*/ /*===== formContents =====*/){
			// summary:
			//		Deprecated: use submit()
			// tags:
			//		deprecated
		},

		onExecute: function(){
			// summary:
			//		Deprecated: use onSubmit()
			// tags:
			//		deprecated
		},

		_setEncTypeAttr: function(/*String*/ value){
			domAttr.set(this.domNode, "encType", value);
			if(has("ie")){
				this.domNode.encoding = value;
			}
			this._set("encType", value);
		},

		reset: function(/*Event?*/ e){
			// summary:
			//		restores all widget values back to their init values,
			//		calls onReset() which can cancel the reset by returning false

			// create fake event so we can know if preventDefault() is called
			var faux = {
				returnValue: true, // the IE way
				preventDefault: function(){ // not IE
					this.returnValue = false;
				},
				stopPropagation: function(){
				},
				currentTarget: e ? e.target : this.domNode,
				target: e ? e.target : this.domNode
			};
			// if return value is not exactly false, and haven't called preventDefault(), then reset
			if(!(this.onReset(faux) === false) && faux.returnValue){
				this.inherited(arguments, []);
			}
		},

		onReset: function(/*Event?*/ /*===== e =====*/){
			// summary:
			//		Callback when user resets the form. This method is intended
			//		to be over-ridden. When the `reset` method is called
			//		programmatically, the return value from `onReset` is used
			//		to compute whether or not resetting should proceed
			// tags:
			//		callback
			return true; // Boolean
		},

		_onReset: function(e){
			this.reset(e);
			e.stopPropagation();
			e.preventDefault();
			return false;
		},

		_onSubmit: function(e){
			var fp = this.constructor.prototype;
			// TODO: remove this if statement beginning with 2.0
			if(this.execute != fp.execute || this.onExecute != fp.onExecute){
				kernel.deprecated("dijit.form.Form:execute()/onExecute() are deprecated. Use onSubmit() instead.", "", "2.0");
				this.onExecute();
				this.execute(this.getValues());
			}
			if(this.onSubmit(e) === false){ // only exactly false stops submit
				e.stopPropagation();
				e.preventDefault();
			}
		},

		onSubmit: function(/*Event?*/ /*===== e =====*/){
			// summary:
			//		Callback when user submits the form.
			// description:
			//		This method is intended to be over-ridden, but by default it checks and
			//		returns the validity of form elements. When the `submit`
			//		method is called programmatically, the return value from
			//		`onSubmit` is used to compute whether or not submission
			//		should proceed
			// tags:
			//		extension

			return this.isValid(); // Boolean
		},

		submit: function(){
			// summary:
			//		programmatically submit form if and only if the `onSubmit` returns true
			if(!(this.onSubmit() === false)){
				this.containerNode.submit();
			}
		}
	});
});

},
'dijit/ToolbarSeparator':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"./_Widget",
	"./_TemplatedMixin"
], function(declare, dom, _Widget, _TemplatedMixin){

	// module:
	//		dijit/ToolbarSeparator


	return declare("dijit.ToolbarSeparator", [_Widget, _TemplatedMixin], {
		// summary:
		//		A spacer between two `dijit.Toolbar` items

		templateString: '<div class="dijitToolbarSeparator dijitInline" role="presentation"></div>',

		buildRendering: function(){
			this.inherited(arguments);
			dom.setSelectable(this.domNode, false);
		},

		isFocusable: function(){
			// summary:
			//		This widget isn't focusable, so pass along that fact.
			// tags:
			//		protected
			return false;
		}
	});
});

},
'Sage/Link':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define, MasterPageLinks */
define([
    'Sage/UI/Dialogs',
    'Sage/Utility',
    'Sage/Services/ActivityService',
    'Sage/Services/EntityService',
    'dojo/string',
    'Sage/MainView/EntityMgr/EntityWizard/EntityWizardController'

],
function (dialogs, utility, ActivityService, EntityService, dojoString, entityWizardController) {
    Sage.namespace('Link');
    Sage.Link = {
        entityDetail: function (kind, id) {
            var kindUC = kind.toUpperCase();
            switch (kindUC) {
                case 'ACTIVITY':
                    this.editActivity(id);
                    break;
                case 'HISTORY':
                    this.editHistory(id);
                    break;
                default:
                    //if we are in detail mode for the entity requested, just navigate to that entity
                    if (utility.getModeId() === 'detail') {
                        var clientEntityContextSvc = Sage.Services.getService('ClientEntityContext');
                        var eContext = clientEntityContextSvc.getContext();
                        if (eContext.EntityType === kind || eContext.EntityType === 'Sage.Entity.Interfaces.I' + kind) {
                            clientEntityContextSvc.navigateSLXGroupEntity(id);
                            return;
                        }
                    }
                            if (utility.isEQEnabled() && kind.toUpperCase() == 'QUOTE')
                            {
                               Sage.Utility.showDetailForm(kind,id);
                            }
                            else{
                                var url = dojoString.substitute('${0}.aspx?entityid=${1}&modeid=Detail', [kind, id]);
                                document.location = url;
                            }
                    break;
            }
        },
        toListView: function (kind) {
            var url;
            if (typeof kind !== 'undefined') {
                url = kind + '.aspx?modeid=list';
            } else {
                url = document.location.href.replace("#", "");
                if (url.indexOf("?") > -1) {
                    var halves = url.split("?");
                    url = halves[0];
                }
                url += "?modeid=list";
            }
            document.location = url;
        },
        toActivityListView: function (tabid) {
            if (document.location.href.toLowerCase().indexOf('activitymanager.aspx') < 1) {
                var url = 'ActivityManager.aspx' + ((tabid) ? '?tabId=' + tabid : '');
                // IE8 fix - as the page is leaving and the rest of the dojo event handling 
                // code is running, wild things start happening and IE ends up back where it started,
                // but with bad errors...
                window.setTimeout(function () {
                    document.location = url;
                }, 5);
            } else {
                if (tabid) {
                    var s = Sage.Services.getService('ClientGroupContext');
                    s.setCurrentGroup(tabid);
                }
            }
        },
        schedule: function (type) {

            if (type === 'CompleteActivity') {
                Sage.ClientLinkHandler.request({ request: 'Schedule', type: type });
                return;
            }

            var activityService = Sage.Services.getService('ActivityService');
            if (!activityService) {
                Sage.Services.addService('ActivityService', new ActivityService());
                activityService = Sage.Services.getService('ActivityService');
            }
            activityService.scheduleActivity({ type: type });
        },

        newNote: function () {

            var activityService = Sage.Services.getService('ActivityService');
            if (!activityService) {
                Sage.Services.addService('ActivityService', new ActivityService());
                activityService = Sage.Services.getService('ActivityService');
            }
            activityService.insertNote();

            //Sage.ClientLinkHandler.request({ request: 'New', type: 'Note' });
        },

        scheduleActivity: function (args) {
            console.warn('ToDo: this method - Sage.Link.scheduleActivity seems to have been used for various purposes, passing various bits of information in the args parameter.  This needs to be fixed for each call...');
            this.schedule(args);
        },

        schedulePhoneCall: function () {
            this.schedule('PhoneCall');
        },

        scheduleMeeting: function () {
            this.schedule('Meeting');
        },

        scheduleToDo: function () {
            this.schedule('ToDo');
        },

        schedulePersonalActivity: function () {
            this.schedule('PersonalActivity');
        },

        scheduleCompleteActivity: function () {
            this.schedule('CompleteActivity');
        },

        scheduleEvent: function (args) {
            var activityService = Sage.Services.getService('ActivityService');
            activityService.scheduleEvent(args);
        },


        editEvent: function (id) {
            var activityService = Sage.Services.getService('ActivityService');
            activityService.editEvent(id);
        },

        deleteEvent: function (id) {
            var activityService = Sage.Services.getService('ActivityService');
            activityService.deleteEvent(id);
        },

        editActivity: function (id, isRecurring, memberId) {
            var activityService = Sage.Services.getService('ActivityService');
            if (!activityService) {
                Sage.Services.addService('ActivityService', new ActivityService());
                activityService = Sage.Services.getService('ActivityService');
            }
            memberId = memberId || '';
            activityService.editActivity(id, isRecurring, memberId);
        },
        editActivityIfConfirmed: function (id, isRecurring) {
            var activityService = Sage.Services.getService('ActivityService');
            activityService.editActivityIfConfirmed(id, isRecurring);
        },
        editEntityOptions: function (id, isRecurring) {
            var entityService = Sage.Services.getService('EntityService');
            entityService.editEntityOptions(id, isRecurring);
        },
        editActivityOccurrence: function (id, recurDate) {
            Sage.ClientLinkHandler.request({ request: 'EditActivityOccurrence', id: id, recurDate: recurDate });
        },

        editHistory: function (id, args) {
            var activityService = Sage.Services.getService('ActivityService');
            if (!activityService) {
                Sage.Services.addService('ActivityService', new ActivityService());
                activityService = Sage.Services.getService('ActivityService');
            }
            activityService.editHistory(id);

        },

        completeActivity: function (id, isRecurring) {
            var activityService = Sage.Services.getService('ActivityService');
            activityService.completeActivity(id, isRecurring);
        },

        completeNewActivity: function (type, args) {
            var activityService = Sage.Services.getService('ActivityService');
            activityService.completeNewActivity(type, args);
        },

        completeActivityOccurrence: function (id, recurDate) {
            var activityService = Sage.Services.getService('ActivityService');
            activityService.completeActivityOccurrence(id, recurDate);
        },

        deleteActivity: function (id, callback) {
            var activityService = Sage.Services.getService('ActivityService');
            activityService.deleteActivity(id, false, callback);
        },

        deleteActivityOccurrence: function (id) {
            var activityService = Sage.Services.getService('ActivityService');
            activityService.deleteActivity(id);
        },
        confirmActivityFor: function (actId, userId) {
            var activityService = Sage.Services.getService('ActivityService');
            activityService.confirmActivityFor(actId, userId);
        },
        editConfirmation: function (id) {
            var activityService = Sage.Services.getService('ActivityService');
            activityService.editConfirmation(id);
        },
        acceptConfirmation: function (id) {
            var activityService = Sage.Services.getService('ActivityService');
            activityService.acceptConfirmation({ id: id });
        },
        declineConfirmation: function (id) {
            var activityService = Sage.Services.getService('ActivityService');
            activityService.declineConfirmation(id);
        },
        deleteConfirmation: function (id) {
            var activityService = Sage.Services.getService('ActivityService');
            activityService.deleteConfirmation(id);
        },
        scheduleLitRequest: function () {
            var activityService = Sage.Services.getService('ActivityService');
            activityService.scheduleLitRequest();
        },
        deleteLitRequest: function (id) {
            var activityService = Sage.Services.getService('ActivityService');
            activityService.deleteLitRequest(id);
        },
        goToLitRequest: function (id) {
            var activityService = Sage.Services.getService('ActivityService');
            activityService.goToLitRequest(id);
        },
        goToActivityAssociation: function (association, id) {
            var activityService = Sage.Services.getService('ActivityService');
            activityService.goToActivityAssociation(association, id);
        },

        mergeRecords: function () {
            var panel = dijit.byId('list');
            if (panel) {
                var selectionInfo = panel.getSelectionInfo();

                if (selectionInfo.selectionCount === 2) {
                    var contextService = Sage.Services.getService("SelectionContextService");
                    contextService.setSelectionContext(selectionInfo.key, selectionInfo, this.mergeRecordsSelectionInfoCallback);
                    Sage.ClientLinkHandler.request({ request: 'MergeRecords', selectionInfoKey: selectionInfo.key });
                }
                else {
                    dialogs.showInfo(MasterPageLinks.Merge_Account_SelectionError);
                }
            }
        },
        mergeRecordsSelectionInfoCallback: function () {
            // client-side action
        },
        removeDeletedConfirmation: function (id) {
            Sage.ClientLinkHandler.request({ request: 'RemoveDeletedConfirmation', id: id });
        },
        getHelpUrl: function (topic, subsystem) {
            var urlfmt;
            /*if(subsystem) {
            urlfmt = dojoString.substitute('help/Subsystems/${0}/${0}_CSH.htm#${1}', [subsystem, topic]);
            return urlfmt;
            }*/

            urlfmt = utility.getClientContextByKey('WebHelpUrlFmt');
            if (urlfmt === '') {
                urlfmt = 'help/WebClient_CSH.htm#${0}';
            }
            return dojoString.substitute(urlfmt, [topic]);
        },
        getHelpUrlTarget: function () {
            var target = utility.getClientContextByKey('WebHelpLinkTarget');
            return (target === '') ? 'MCWebHelp' : target;
        },
        editSecurityProfile: function (childId, parentId, securityProfileId) {
            Sage.ClientLinkHandler.request({ request: 'Administration', type: 'EditSecurityProfile', selectionInfoKey: childId + ',' + parentId + ',' + securityProfileId });
        },
        getTeamMemberLink: function (entityType, entityId) {
            if (entityType.toLowerCase() == "user")
                Sage.ClientLinkHandler.request({ request: 'Administration', type: 'RedirectToUser', kind: entityType, id: entityId });
            else
                window.location.href = entityType + ".aspx?entityId=" + entityId;
        },
        redirectUrl: function (requestOptions, resourceKind) {
            var service = Sage.Data.SDataServiceRegistry.getSDataService('dynamic');
            var request = new Sage.SData.Client.SDataServiceOperationRequest(service)
                .setResourceKind(resourceKind)
                .setOperationName(requestOptions.businessRuleMethod);

            request.execute(requestOptions.entry, {
                success: function (result) {
                    window.location.href = result.response.Result;
                },
                failure: function (result) {
                    Sage.UI.Dialogs.showError(result);
                }
            });
        },
        createNewEntity: function () {
            var entityWizard = new entityWizardController();
            entityWizard.startWizard();
        },
        ClearSystemOptionsCache: function () {
            var svc = Sage.Services.getService('SystemOptions');
            if (svc) {
                svc.clearCache();
            }
        }
    };
    window.Link = Sage.Link;
    return Sage.Link;
});

},
'Sage/Services/ActivityService':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */

define([
        'Sage/UI/Dialogs',
        'Sage/MainView/ActivityMgr/ActivityEditor',
        'Sage/MainView/ActivityMgr/EditEventEditor',
        'Sage/MainView/ActivityMgr/QuickCompleteEditor',
        'Sage/Services/ActivityActionProcessor',
        'Sage/Services/ActivityAction',
        'Sage/MainView/ActivityMgr/HistoryEditor',
        'Sage/MainView/ActivityMgr/OccurrenceOrSeriesQueryDlg',
        'Sage/Data/SingleEntrySDataStore',
        'Sage/Data/SDataServiceRegistry',
        'dojo/string',
        'Sage/Utility',
        'dojo/i18n!./nls/ActivityService',
        'dojo/_base/declare',
        'dojo/topic',
        'dojo/_base/lang'
],

function (
    Dialogs,
    ActivityEditor,
    EditEventEditor,
    QuickCompleteEditor,
    ActivityActionProcessor,
    ActivityAction,
    HistoryEditor,
    OccurrenceOrSeriesQueryDlg,
    SingleEntrySDataStore,
    sDataServiceRegistry,
    dString,
    sageUtility,
    nlsActivityService,
    declare,
    topic,
    lang
) {

    var activityService = declare('Sage.Services.ActivityService', null, {
        _defaultActivitManagerTabId: null,
        _activityEditor: false,
        _eventEditor: false,
        _historyEditor: false,
        _editOccSeriesDlg: false,
        _deleteOccSeriesDlg: false,
        _compOccSeriesDlg: false,
        _processor: false,
        _actCompleteQueue: false,
        _histCompleteQueue: [],

        //add these constructors as properties so they can be changed by customizations:
        activityEditorType: ActivityEditor,
        eventEditorType: EditEventEditor,
        historyEditorType: HistoryEditor,

        constructor: function () {
            dojo.mixin(this, nlsActivityService);

        },
        _ensureEditor: function () {
            if (!this._activityEditor) {
                this._activityEditor = new this.activityEditorType({ id: 'activityEditor' });
                this.onActivityEditorCreated(this._activityEditor);
           }
        },
        onActivityEditorCreated: function (editor) { },
        _ensureEventEditor: function () {
            if (!this._eventEditor) {
                this._eventEditor = new this.eventEditorType();
                this.onEventEditorCreated(this._eventEditor);
            }
        },
        onEventEditorCreated: function (editor) { },
        _ensureHistoryEditor: function () {
            if (!this._historyEditor) {
                this._historyEditor = new this.historyEditorType({ id: 'historyEditor' });
                this.onHistoryEditorCreated(this._historyEditor);
            }
        },
        onHistoryEditorCreated: function (editor) { },
        _ensureProcessor: function () {
            if (!this._processor) {
                this._processor = new ActivityActionProcessor();
            }
        },
        _getIdFromGridSelection: function () {
            var selectedItem = this.getSelectedItem();
            if (!selectedItem) {
                return false;
            }
            if (selectedItem.hasCompositeKey) {
                //Coming from User Activity entity
                return selectedItem.entity.Activity['$key'];
            } else {
                return selectedItem.id;
            }
        },
        _getRecurringFromGridSelection: function () {
            var isRecurring = false,
                selectedItem = this.getSelectedItem();
            if (selectedItem && selectedItem.entity) {
                if (selectedItem.entity.hasOwnProperty('Activity')) {
                    isRecurring = selectedItem.entity.Activity["Recurring"] === true;
                    if ((isRecurring) && (selectedItem.entity.Activity['RecurIterations'] < 0)) {
                        isRecurring = false; // reoccurnces that have no ending.
                    }
                } else {
                    isRecurring = selectedItem.entity["Recurring"] === true;
                    if ((isRecurring) && (selectedItem.entity['RecurIterations'] < 0)) {
                        isRecurring = false; // reoccurnces that have no ending.
                    }
                }
            }
            return isRecurring;
        },
        editActivity: function (id, isRecurring, memberId) {
            if (!id) {
                id = this._getIdFromGridSelection();
                isRecurring = this._getRecurringFromGridSelection();
            }
            if (!id) { return; }
            if ((id.length === 12) && ((typeof isRecurring === 'undefined') || isRecurring === null)) {

                this._resolveActivityOccurence(id, memberId);
                return;
            }
            if (id.length === 12 && !isRecurring) {
                this._ensureEditor();
                this._activityEditor.set('mode', 'Update');
                this._activityEditor.set('activityId', id);
                this._activityEditor.set('activityMemberId', memberId);
                this._activityEditor.show();
            } else {
                this.editOccurrenceOrSeriesQuery(id, memberId);
            }
        },
        _resolveActivityOccurence: function(id, memberId) {

            var req = new Sage.SData.Client.SDataResourceCollectionRequest(sDataServiceRegistry.getSDataService('dynamic'));
            req.setResourceKind('activities');
            req.setQueryArg('select', 'Recurring');
            req.setQueryArg('where', dString.substitute('Id eq \'${0}\'', [id]));
            req.setQueryArg('precedence', '0');
            req.read({
                success: function(activities) {
                    var Recurring;
                    if (activities['$resources'] && activities['$resources'].length > 0) {
                        Recurring = activities['$resources'][0].Recurring;
                        if (Recurring) {
                            this.editActivity(id, true, memberId);
                        } else {
                            this.editActivity(id, false, memberId);
                        }
                    }
                },
                failure: function() {
                    console.warn('could not find activity :' + id );
                },
                scope: this
            });

        },
        editOccurrence: function (id, startDate, memberId) {
            this._ensureEditor();
            this._activityEditor.set('mode', 'Update');
            this._activityEditor.set('activityId', id);
            this._activityEditor.set('activityMemberId', memberId);
            this._activityEditor.show();
        },
        editOccurrenceOrSeriesQuery: function (id, memberId) {
            if (!this._editOccSeriesDlg) {
                this._editOccSeriesDlg = new OccurrenceOrSeriesQueryDlg({ id: 'editOccSeriesQuery', mode: 'edit' });
                dojo.connect(this._editOccSeriesDlg, 'onSelectSeries', this, function (actid, mId) {
                    this.editActivity(actid.substring(0, 12), false, mId);
                });
                dojo.connect(this._editOccSeriesDlg, 'onSelectOccurrence', this, function (actid, startDate, mId) {
                    this.editOccurrence(actid, startDate, mId);
                });
            }
            this._editOccSeriesDlg.set('activityMemberId', memberId);
            this._editOccSeriesDlg.set('activityId', id);
            this._editOccSeriesDlg.show();
        },

        editTempActivity: function (id) {
            this._ensureEditor();
            this._activityEditor.set('mode', 'deleteOnCancel');
            this._activityEditor.set('activityId', id);
            this._activityEditor.show();
        },

        completeOccurrenceOrSeriesQuery: function (id) {
            if (!this._compOccSeriesDlg) {
                this._compOccSeriesDlg = new OccurrenceOrSeriesQueryDlg({ id: 'compOccSeriesQuery', mode: 'complete' });
                dojo.connect(this._compOccSeriesDlg, 'onSelectSeries', this, function (id) { this.completeActivity(id.substring(0, 12), false); });
                dojo.connect(this._compOccSeriesDlg, 'onSelectOccurrence', this, this.completeActivityOccurrence);
            }
            this._compOccSeriesDlg.set('activityId', id);
            this._compOccSeriesDlg.show();
        },
        scheduleActivity: function (args) {
            var type = args['type'] || args['Type'];
            if (type === 'CompleteActivity') {
                this.scheduleCompletedActivity(type, args);
                return;
            }

            this._ensureEditor();
            this._activityEditor.set('mode', 'New ' + args['type'] || 'Meeting');
            if (args.hasOwnProperty('preConfigured')) {
                this._activityEditor.show(args.preConfigured);
            } else {
                this.getActivityEntityContext(this._activityEditor, function (editor, context) {
                    editor.show(context);
                });
            }

        },
        completeActivityOccurrence: function (id, startDate) {
            this._ensureEditor();
            if (id.indexOf(';') < 0) {
                var select = ['StartDate'];
                var store = new SingleEntrySDataStore({
                        include: [],
                        select: select,
                        resourceKind: 'activities',
                        service: sDataServiceRegistry.getSDataService('system')
                    });

                if (id !== '') {
                    store.fetch({
                        predicate: '"' + id + '"',
                        onComplete: function (activity) {
                            if (activity) {

                                var timeValue = (sageUtility.Convert.toDateFromString(activity.StartDate) / 1000) + 62135596800;
                                var activityId = activity['$key'] + ";" + timeValue;
                                this._activityEditor.set('mode', 'Complete');
                                this._activityEditor.set('activityId', activityId);
                                this._activityEditor.show();
                            }
                        },
                        scope: this
                    });
                }
            } else {
                this._activityEditor.set('mode', 'Complete');
                this._activityEditor.set('activityId', id);
                this._activityEditor.show();
            }
        },
        completeActivity: function (id, isRecurring) {
            var selectionContext = this._getSelectionContext(id, this.txtActivity, this.txtActivities);
            if (selectionContext.count > 1) {
                this.completeActivitiesInSelectionContext(selectionContext);
            } else {
                if (selectionContext.id) {
                    var selid = selectionContext.id;
                    if (selectionContext.selectionInfo && selectionContext.selectionInfo.selections[0].entity) {
                        var entity = selectionContext.selectionInfo.selections[0].entity;
                        if (selectionContext.selectionInfo.hasCompositeKey) {
                            //in this case we are looking at a list of UserActivities...
                            selid = entity["Activity"]["$key"];
                        }
                        if (selid.length === 12) {
                            //in case we are looking at a list of UserActivities...
                            if (entity.hasOwnProperty('Activity')) {
                                entity = entity.Activity;
                            }
                            isRecurring = entity['Recurring'] === true;
                            if ((isRecurring) && (entity['RecurIterations'] < 0)) {
                                isRecurring = false; // reoccurnces that have no ending.
                            }
                        }
                    }
                    if (selid.length === 12 && !isRecurring) {
                        this._ensureEditor();
                        this._activityEditor.set('mode', 'Complete');
                        this._activityEditor.set('activityId', selid);
                        this._activityEditor.show();
                    } else {
                        this.completeOccurrenceOrSeriesQuery(selid);
                    }
                }
            }
        },
        _quickCompleteConnections: [],
        completeActivitiesInSelectionContext: function (selectionContext) {
            if (selectionContext.count < 1) {
                return;
            }
            this._actCompleteQueue = selectionContext; //.selectionInfo.selections;
            var config = {
                selectionContext: selectionContext
            };
            var qce = new QuickCompleteEditor(config);
            this._quickCompleteConnections.push(dojo.connect(qce, 'onCompleteIndividually', this, '_completeActivitiesInQueue'));
            this._quickCompleteConnections.push(dojo.connect(qce, 'onCompleteNow', this, '_completeActivitiesNow'));
            this._quickCompleteConnections.push(dojo.connect(qce, 'onCompleteAsScheduled', this, '_completeActivitiesAsScheduled'));
            this._quickCompleteConnections.push(dojo.connect(qce, 'onCancel', this, function () { this._actCompleteQueue = false; }));
            this._quickCompleteConnections.push(dojo.connect(qce._dialog, 'onHide', this, '_quickCompleteHide'));
            qce.show();
        },
        _actEditorHideConnection: null,
        _quickCompleteHide: function () {
            if (!this._completingActivitiesIndividually) {
                this._actCompleteQueue = false;
            }
            dojo.forEach(this._quickCompleteConnections, function (connection) {
                dojo.disconnect(connection);
            });
            this._quickCompleteConnections = [];
        },
        _completingActivitiesIndividually: false,
        _completeActivitiesInQueue: function () {
            this._completingActivitiesIndividually = true;
            this._ensureEditor();
            this._actEditorHideConnection = dojo.connect(this._activityEditor, 'onHide', this, this._completeNextActivityInQueue);
            this._completeNextActivityInQueue();
        },
        _completeNextActivityInQueue: function () {
            var nextActivity = this._actCompleteQueue.selectionInfo.selections.pop();
            var id = nextActivity.id;
            var recurring = false;
            if (nextActivity.entity) {
                var activity = nextActivity.entity.hasOwnProperty('Activity') ? nextActivity.entity['Activity'] : nextActivity.entity;
                if (this._actCompleteQueue.selectionInfo.hasCompositeKey) {
                    id = nextActivity.entity["Activity"]["$key"];
                }
                recurring = (id.length > 12 || activity['Recurring'] === true);
            }
            this.completeActivity(id, recurring);
            if (this._actCompleteQueues.selectionInfo.selections.length < 1) {
                dojo.disconnect(this._actEditorHideConnection);
                this._completingActivitiesIndividually = false;
            }
        },
        _completeActivitiesAsScheduled: function (options) {
            var args = {
                selectionInfo: options.selectionContext.selectionInfo,
                mode: 'asScheduled',
                note: options.note,
                result: options.result,
                resultCode: options.resultCode
            };

            var action = new ActivityAction();
            action.set('OperationName', "completeActivities");
            action.set('PublishMap', "/entity/activity/change");
            action.set('args', args);
            action.execute({
                success: function (result) {
                    topic.publish("/entity/activity/bulkComplete", "true");
                },
                failure: function () {
                    Dialogs.showError(this.txtErrorActionMsg);
                }

            });

        },
        _completeActivitiesNow: function (options) {
            var args = {
                selectionInfo: options.selectionContext.selectionInfo,
                mode: 'completeNow',
                note: options.note,
                result: options.result,
                resultCode: options.resultCode

            };
            var action = new Sage.Services.ActivityAction();
            action.set('OperationName', "completeActivities");
            action.set('PublishMap', "/entity/activity/change");
            action.set('Args', args);
            action.execute({
                success: function (result) {
                    topic.publish("/entity/activity/bulkComplete", "true");
                },
                failure: function () {
                    Dialogs.showError(this.txtErrorActionMsg);
                }
            });
        },
        completeHistoriesInList: function (histIds) {
            if (histIds.length < 1) {
                return;
            }
            if (histIds.length === 1) {
                this.completeHistory(histIds[0]);
                return;
            }
            this._histCompleteQueue = histIds;
            var config = {
                selectionContext: {
                    count: histIds.length,
                    selectionInfo: { selectedIds: histIds }
                }
            };
            this._histCompleteQueue = histIds;
            var qce = new QuickCompleteEditor(config);
            this._quickCompleteConnections.push(dojo.connect(qce, 'onCompleteIndividually', this, '_completeHistoriesInQueue'));
            this._quickCompleteConnections.push(dojo.connect(qce, 'onCompleteNow', this, '_updateHistoriesFromQuickComplete'));
            this._quickCompleteConnections.push(dojo.connect(qce, 'onCompleteAsScheduled', this, '_updateHistoriesFromQuickComplete'));
            this._quickCompleteConnections.push(dojo.connect(qce, 'onCancel', this, '_cancelCompleteHistoryQueue'));
            this._quickCompleteConnections.push(dojo.connect(qce._dialog, 'onHide', this, '_quickCompleteHide'));
            qce.show();
        },
        completeHistory: function (historyId) {
            this._ensureHistoryEditor();
            this._historyEditor.set('historyId', historyId);
            this._historyEditor.set('mode', 'Complete');
            this._historyEditor.show();
        },
        _histEditorHideConnection: null,
        _quickHistoryCompleteHide: function () {
            dojo.forEach(this._histEditorHideConnection, function (connection) {
                dojo.disconnect(connection);
            });
            dojo.forEach(this._actEditorHideConnection, function (connection) {
                dojo.disconnect(connection);
            });
            this._histEditorHideConnection = false;
            this._actEditorHideConnection = false;
        },
        _completeHistoriesInQueue: function () {
            this._ensureHistoryEditor();
            this._historyEditor._doingFollowup = false;
            this._histEditorHideConnection = dojo.connect(this._historyEditor, 'onHide', this, this._completeNextHisotryInQueue);
            this._completeNextHisotryInQueue();
        },
        _completeNextHisotryInQueue: function (e) {
            if (this._histCompleteQueue.length < 1) {
                dojo.disconnect(this._histEditorHideConnection);
                dojo.disconnect(this._actEditorHideConnection);
                return;
            }
            if (this._historyEditor._doingFollowup) {
                //this._historyEditor._doingFollowup = false;
                this._ensureEditor();
                if (this._actEditorHideConnection) {
                    dojo.disconnect(this._actEditorHideConnection);
                }
                this._actEditorHideConnection = dojo.connect(this._activityEditor, 'onHide', this, this._followupCompleteNextHistoryInQueue);
                return;
            }
            var histid = this._histCompleteQueue.pop();
            var self = this;
            this.completeHistory(histid);

        },
        _followupCompleteNextHistoryInQueue: function () {
            this._historyEditor._doingFollowup = false;
            this._completeNextHisotryInQueue();
        },
        _cancelCompleteHistoryQueue: function () {
            this._deleteHistoryFromQuickComplete();
        },
        _deleteHistoryFromQuickComplete: function () {
            var doDelete = function (histId) {
                var store = new SingleEntrySDataStore({
                    resourceKind: 'history',
                    //select: ['LongNotes', 'Result'],
                    service: sDataServiceRegistry.getSDataService('dynamic')
                });
                store.fetch({
                    predicate: '"' + histId + '"',
                    onComplete: function (history) {
                        store.deleteEntity(history, this, null, null);
                    },
                    onError: function () { },
                    scope: this
                });
            };
            var count = this._histCompleteQueue.length;
            for (var i = 0; i < count; i++) {
                doDelete(this._histCompleteQueue.pop());
            }
        },
        _updateHistoriesFromQuickComplete: function (options) {
            //this._completingActivitiesIndividually = true;
            var doUpdate = function (histId) {
                var store = new SingleEntrySDataStore({
                    resourceKind: 'history',
                    select: ['LongNotes', 'Result','ResultCode'],
                    service: sDataServiceRegistry.getSDataService('dynamic')
                });
                store.fetch({
                    predicate: '"' + histId + '"',
                    onComplete: function (history) {
                        history.Result = options.result || history.Result;
                        history.ResultCode = options.resultCode || history.ResultCode;
                        history.LongNotes = (history.LongNotes) ? history.LongNotes + '\n' + options.note : options.note;
                        store.save({
                            scope: this,
                            success: function (hist) { dojo.publish('/entities/history/create', hist); },
                            failure: function () { }
                        });
                    },
                    onError: function () { },
                    scope: this
                });
            };
            var count = this._histCompleteQueue.length;
            for (var i = 0; i < count; i++) {
                doUpdate(this._histCompleteQueue.pop());
            }
        },
        completeNewActivity: function (type, args) {
            this._ensureEditor();
            if (!args || typeof args != 'object') {
                args = {};
            }
            args['Type'] = args['Type'] || type || 'atAppointment';
            this._activityEditor.set('mode', 'CompleteUnscheduled');
            this._activityEditor.show(args);
        },
        deleteActivity: function (id, isRecurring, callback) {
            var selectionContext = this._getSelectionContext(id, this.txtActivity, this.txtActivities);
            if (id) {
                if ((id.length === 12 && !isRecurring) || id.indexOf("ActivityId") > -1) {
                    this.deleteActivitiesInSelectionContext(selectionContext, callback);
                }
                else {
                    this.deleteOccurrenceOrSeriesQuery(id);
                }
                return;
            }
            if (selectionContext.count < 1) {
                return;
            }
            if (selectionContext.count > 1) {
                this.deleteActivitiesInSelectionContext(selectionContext);
            }
            else {
                var selectedItem = selectionContext.selectionInfo.selections[0];
                if (selectionContext.selectionInfo.hasCompositeKey) {
                    //Coming from User Activity entity
                    if (selectedItem.entity) {
                        id = selectedItem.entity["Activity"]["$key"];
                    }
                } else {
                    id = selectedItem.id;
                }
                isRecurring = false;
                if (selectedItem.entity) {
                    if (selectedItem.entity.hasOwnProperty('Activity')) {
                        isRecurring = selectedItem.entity.Activity["Recurring"] === true;
                    } else {
                        isRecurring = selectedItem.entity["Recurring"] === true;
                    }
                }
            }
            if (!id) { return; }
            if (id.length === 12 && !isRecurring) {
                this.deleteActivitiesInSelectionContext(selectionContext);
            } else {
                this.deleteOccurrenceOrSeriesQuery(id);
            }
        },
        deleteActivitiesInSelectionContext: function (selectionContext, onComplete, onCompleteScope) {
            if (selectionContext.count < 1) {
                return;
            }
            var actionDescription = this.txtActionDeleteActivites;
            var actionQuestion = String.format(this.txtActionDeleteActivitiesQuestion, selectionContext.count, selectionContext.name);
            var action = new ActivityAction();

            var args = {
                selectionInfo: selectionContext.selectionInfo
            };

            //Needed in Activity Calendar to remove the deleted event from calendar
            if (selectionContext.count === 1) {
                var selectedItem = selectionContext.selectionInfo.selections[0];
                if (selectedItem && selectedItem.id && selectedItem.id.indexOf("ActivityId") > -1) {
                    action.set('PublishMapWithId', "/entity/userActivity/delete");
                    action.set('ActivityId', selectedItem.id);
                } else if (selectedItem) {
                    action.set('PublishMapWithId', "/entity/activity/delete/single");
                    action.set('ActivityId', selectedItem.id);
                }
            }

            action.set('OperationName', "deleteActivities");
            action.set('PublishMap', "/entity/activity/delete");
            action.set('ActionDescription', actionDescription);
            action.set('ActionMessage', actionQuestion);
            action.set('Args', args);
            this._ensureProcessor();
            this._processor.set('Action', action);
            this._processor.set('SelectionContext', selectionContext);

            if (onComplete) {
                var connect = dojo.connect(this._processor, 'onActionComplete', this, function (result) {
                    dojo.disconnect(connect);
                    onComplete.call(onCompleteScope || this, result);
                });
            }
            this._processor.start();
        },

        declineMemberConfirmation: function (actObj, memberId) {
            if (actObj && memberId) {
                var payload = {
                    "$name": "DeclineMember",
                    "request": {
                        "entity": actObj,
                        "memberId": memberId
                    }
                };
                var request = new Sage.SData.Client.SDataServiceOperationRequest(sDataServiceRegistry.getSDataService('dynamic'))
                    .setResourceKind('activities')
                    .setOperationName('DeclineMember');
                request.execute(payload, {
                    success: function (ua) {
                        var activityData = dString.substitute("'ActivityId=${0};UserId=${1}'", [actObj.$key, memberId]);
                        topic.publish("/entity/userActivity/delete", activityData);
                    },
                    failure: function () {

                    },
                    scope: this
                });
            }
        },

        deleteOccurrenceOrSeriesQuery: function (id) {
            if (!this._deleteOccSeriesDlg) {
                this._deleteOccSeriesDlg = new OccurrenceOrSeriesQueryDlg({ id: 'deleteOccSeriesQuery', mode: 'delete' });
                dojo.connect(this._deleteOccSeriesDlg, 'onSelectOccurrence', this, function (id) { this.deleteOccurrence(id); });
                dojo.connect(this._deleteOccSeriesDlg, 'onSelectSeries', this, function (id) { this.deleteAllOccurrence(id); });
            }
            this._deleteOccSeriesDlg.set('activityId', id);
            this._deleteOccSeriesDlg.show();
        },
        deleteOccurrence: function (id) {
            var selectionContext = this._getSelectionContext(id, this.txtActivity, this.txtActivities);
            this.deleteActivitiesInSelectionContext(selectionContext);
        },
        deleteAllOccurrence: function (id) {
            var selectionContext = this._getSelectionContext(id, this.txtActivity, this.txtActivities);
            if (selectionContext.count < 1) {
                return;
            }
            var actionDescription = this.txtActionDeleteActivites;
            var actionQuestion = String.format(this.txtActionDeleteActivitiesQuestion, selectionContext.count, selectionContext.name);
            var action = new ActivityAction();

            var args = {
                selectionInfo: selectionContext.selectionInfo
            };

            //Needed in Activity Calendar to remove the deleted event from calendar
            if (selectionContext.count === 1) {
                var selectedItem = selectionContext.selectionInfo.selections[0];
                if (selectedItem) {
                    action.set('PublishMapWithId', "/entity/activity/delete/recurrence");
                    action.set('ActivityId', selectedItem.id);
                }
            }

            action.set('OperationName', "deleteAllOccurrence");
            action.set('PublishMap', "/entity/activity/delete");
            action.set('ActionDescription', actionDescription);
            action.set('ActionMessage', actionQuestion);
            action.set('Args', args);
            this._ensureProcessor();
            this._processor.set('Action', action);
            this._processor.set('SelectionContext', selectionContext);
            this._processor.start();

        },
        snooze: function (id, options) {
            var selectionContext = this._getSelectionContext(id, this.txtAlarm, this.txtAlarms);
            var actionDescription = this.txtActionSnoozeAlarm;
            var actionQeustion = String.format(this.txtActionSnoozeQuestion, selectionContext.count, selectionContext.name, options.name);
            var action = new ActivityAction();
            var args = {
                selectionInfo: selectionContext.selectionInfo,
                interval: options.interval,
                duration: options.duration
            };
            action.set('OperationName', "SnoozeAlarms");
            action.set('PublishMap', "/entity/UserActivity/change");
            action.set('ActionDescription', actionDescription);
            action.set('ActionMessage', actionQeustion);
            action.set('Args', args);
            this._ensureProcessor();
            this._processor.set('Action', action);
            this._processor.set('SelectionContext', selectionContext);
            this._processor.start();

        },

        snoozeAll: function (options) {

            var id = null;
            var selectionContext = this._getSelectionContext(id, this.txtAlarm, this.txtAlarms);
            selectionContext.mode = 'ALL';
            var actionDescription = this.txtActionSnoozeAlarm;
            var actionQeustion = String.format(this.txtActionSnoozeAllQuestion, selectionContext.name, options.name);
            var action = new ActivityAction();
            var args = {
                selectionInfo: selectionContext.selectionInfo,
                interval: options.interval,
                duration: options.duration
            };
            action.set('OperationName', "SnoozeAlarms");
            action.set('PublishMap', "/entity/UserActivity/change");
            action.set('ActionDescription', actionDescription);
            action.set('ActionMessage', actionQeustion);
            action.set('Args', args);
            this._ensureProcessor();
            this._processor.set('Action', action);
            this._processor.set('SelectionContext', selectionContext);
            this._processor.start();

        },

        dismissAlarm: function (id) {
            var selectionContext = this._getSelectionContext(id, this.txtAlarm, this.txtAlarms);
            var actionDescription = this.txtActionDismissAlarms;
            var actionQeustion = String.format(this.txtActionDismissAlarmsQuestion, selectionContext.count, selectionContext.name);
            var action = new ActivityAction();
            var args = {
                selectionInfo: selectionContext.selectionInfo

            };

            action.set('OperationName', "DismissAlarms");
            action.set('ActionDescription', actionDescription);
            action.set('ActionMessage', actionQeustion);
            action.set('PublishMap', "/entity/UserActivity/change");
            action.set('Args', args);

            this._ensureProcessor();
            this._processor.set('Action', action);
            this._processor.set('SelectionContext', selectionContext);
            this._processor.start();

        },

        scheduleCompletedActivity: function (activityType) {

            if (activityType) {
                this._ensureHistoryEditor();
                this._historyEditor.set('activityType', activityType);
                this._historyEditor.set('mode', 'New');
                this._historyEditor.set('historyId', '');
                this.getActivityEntityContext(this._historyEditor, function (scope, context) {
                    scope.show(context);
                });
            }
            else {
                alert('Show Schedule Completed Dialog');
            }
        },


        insertNote: function () {

            this._ensureHistoryEditor();
            this._historyEditor.set('activityType', 'Note');
            this._historyEditor.set('mode', 'New');
            this._historyEditor.set('historyId', '');
            this.getActivityEntityContext(this._historyEditor, function (scope, context) {
                scope.show(context);
            });
        },

        editHistory: function (historyId) {
            if (!historyId) {
                historyId = this.getSelectedId();
            }
            if (!historyId) { return; }
            this._ensureHistoryEditor();
            this._historyEditor.set('mode', 'Edit');
            this._historyEditor.set('historyId', historyId);
            this._historyEditor.show();
        },

        scheduleEvent: function (args) {
            this._ensureEventEditor();
            this._eventEditor.set('mode', 'New');
            this._eventEditor.set('eventId', '');
            this._eventEditor.show(args);
        },
        editEvent: function (id) {
            if (!id) {
                id = this.getSelectedId();
            }
            if (!id) { return; }
            this._ensureEventEditor();
            this._eventEditor.set('mode', 'Update');
            this._eventEditor.set('eventId', id);
            this._eventEditor.show();
        },
        deleteEvent: function (id) {
            var selectionContext = this._getSelectionContext(id, this.txtEvent, this.txtEvents);
            var actionDescription = this.txtActionDeleteEvents;
            var actionQeustion = String.format(this.txtActionDeleteEventsQuestion, selectionContext.count, selectionContext.name);
            var args = {
                selectionInfo: selectionContext.selectionInfo

            };

            var action = new ActivityAction();

            //Needed in Activity Calendar to remove the deleted event from calendar
            if (selectionContext.count === 1) {
                var selectedItem = selectionContext.selectionInfo.selections[0];
                if (selectedItem) {
                    action.set('PublishMapWithId', "/entity/event/delete/single");
                    action.set('ActivityId', selectedItem.id);
                }
            }

            action.set('OperationName', "deleteEvents");
            action.set('PublishMap', "/entity/event/delete");
            action.set('ActionDescription', actionDescription);
            action.set('ActionMessage', actionQeustion);
            action.set('Args', args);
            this._ensureProcessor();
            this._processor.set('Action', action);
            this._processor.set('SelectionContext', selectionContext);
            this._processor.start();

        },
        confirmActivityFor: function (actId, userId, callBack, callBackScope) {
            if (actId) {
                actId = actId.substring(0, 12);
            }
            var req = new Sage.SData.Client.SDataResourceCollectionRequest(sDataServiceRegistry.getSDataService('dynamic'));
            req.setResourceKind('userNotifications');
            //req.setResourceSelector('"' + actId + ';' + userId + '"');
            req.setQueryArg('where', dString.substitute('ActivityId eq \'${0}\' and ToUser.Id eq \'${1}\'', [actId, userId]));
            req.setQueryArg('precedence', '0');
            req.read({
                success: function (userNotifications) {
                    if (userNotifications['$resources'] && userNotifications['$resources'].length > 0) {
                        if (callBack) {
                            callBack.call(callBackScope || this, userNotifications['$resources'][0]['$key']);
                        } else {
                            this.editConfirmation(userNotifications['$resources'][0]['$key'], userId);
                        }
                    } else {
                        //No notifications, so go ahead and edit...
                        this.editActivity(actId, false); //assume not recurring, the scenario that reaches this code is rare anyway.
                    }
                },
                failure: function () {
                    console.warn('could not find notification information for activity:' + actId + ' and user: ' + userId);
                },
                scope: this
            });
        },
        editActivityIfConfirmed: function (activityid, isRecurring) {
            if (!activityid) {
                activityid = this._getIdFromGridSelection();
                isRecurring = this._getRecurringFromGridSelection();
            }
            //Note - only call this method if the data you have does not know if the current user has accepted
            // the activity.
            var currentUser = sageUtility.getClientContextByKey('userID');
            var predicate = dString.substitute('"${0};${1}"',
                [(activityid.indexOf(';') > 0) ? activityid.substring(0, 12) : activityid,
                  currentUser]);

            var req = new Sage.SData.Client.SDataSingleResourceRequest(sDataServiceRegistry.getSDataService('dynamic'))
                .setResourceKind('userActivities')
                .setResourceSelector(predicate);
            req.read({
                success: function (ua) {
                    if (ua.Status === 'asUnconfirmed') {
                        this.confirmActivityFor(activityid, currentUser);
                    } else {
                        this.editActivity(activityid, isRecurring);
                    }
                },
                failure: function () {
                    this.editActivity(activityid, isRecurring);
                },
                scope: this
            });
        },
        editConfirmation: function (id, memberId) {
            if (!id) {
                id = this.getSelectedId();
            }
            if (!id) { return; }
            this._ensureEditor();
            this._activityEditor.set('mode', 'Confirm');
            this._activityEditor.set('userNotificationId', id);
            this._activityEditor.set('activityMemberId', memberId);
            this._activityEditor.show();
        },
        acceptConfirmation: function (options) {
            var id = false;
            if (options) {
                // run business rule to accept the notification - notification entity and notes, etc. are in the options...
                if (options.id) {
                    id = options.id;
                } else if (options.notification) {
                    if (options.notes) {
                        options.notification.Notes = options.notes;
                    }
                    /*
                    to get the payload template:
                    http://localhost:6666/SlxClient/slxdata.ashx/slx/dynamic/-/userNotifications/$service/accept/$template?format=json
                    */
                    var payload = {
                        "$name": "Accept",
                        "request": {
                            "entity": options.notification,
                            "UserNotificationId": options.notification['$key']
                        }
                    };

                    var request = new Sage.SData.Client.SDataServiceOperationRequest(sDataServiceRegistry.getSDataService('dynamic'))
                        .setResourceKind('usernotifications')
                        .setOperationName('accept');
                    request.execute(payload, {
                        success: options.success || function () { },
                        failure: options.failure || function () { },
                        scope: options.scope || this
                    });
                    return;
                }
            }
            var selectionContext = this._getSelectionContext(id, this.txtConfirmation, this.txtConfirmations);
            if (selectionContext.count > 1) {
                // run silently to accept all selected items...
                var args = {
                    selectionInfo: selectionContext.selectionInfo,
                    mode: 'accept',
                    note: ''
                };
                var actionDescription = this.txtActionAcceptConfirmations;
                var actionQeustion = String.format(this.txtActionAcceptConfirmQuestion, selectionContext.count, selectionContext.name);
                var action = new ActivityAction();
                action.set('OperationName', "acceptConfirmations");
                action.set('PublishMap', "/entity/userNotification/change");
                action.set('ActionDescription', actionDescription);
                action.set('ActionMessage', actionQeustion);
                action.set('Args', args);
                this._ensureProcessor();
                this._processor.set('Action', action);
                this._processor.set('SelectionContext', selectionContext);
                this._processor.start();
            } else {
                //open editor to accept/decline the notification
                this.editConfirmation(selectionContext.id);
            }
        },
        declineConfirmation: function (options) {
            var id = false;
            if (options) {
                if (options.id) {
                    id = options.id;
                } else if (options.notification) {
                    // run business rule to decline the notification - notification entity and notes, etc. are in the options...
                    if (options.notes) {
                        options.notification.Notes = options.notes;
                    }
                    var payload = {
                        "$name": "Decline",
                        "request": {
                            "entity": options.notification,
                            "UserNotificationId": options.notification['$key']
                        }
                    };
                    var request = new Sage.SData.Client.SDataServiceOperationRequest(sDataServiceRegistry.getSDataService('dynamic'))
                        .setResourceKind('usernotifications')
                        .setOperationName('decline');
                    request.execute(payload, {
                        success: options.success || function () { },
                        failure: options.failure || function () { },
                        scope: options.scope || this
                    });
                    return;
                }
            }
            var selectionContext = this._getSelectionContext(id, this.txtConfirmation, this.txtConfirmations);
            if (selectionContext.count > 1) {
                // run silently to decline all selected items...
                var args = {
                    selectionInfo: selectionContext.selectionInfo,
                    mode: 'decline',
                    note: ''
                };
                var actionDescription = this.txtDeclineConfirmations;
                var actionQeustion = String.format(this.txtActionDeclineConfrimQuestion, selectionContext.count, selectionContext.name);
                var action = new ActivityAction();
                action.set('OperationName', "declineConfirmations");
                action.set('PublishMap', "/entity/userNotification/change");
                action.set('ActionDescription', actionDescription);
                action.set('ActionMessage', actionQeustion);
                action.set('Args', args);
                this._ensureProcessor();
                this._processor.set('Action', action);
                this._processor.set('SelectionContext', selectionContext);
                this._processor.start();
            } else {
                //open editor to accept/decline the notification
                this.editConfirmation(selectionContext.id);
            }
        },
        deleteConfirmation: function (id) {
            var selectionContext = this._getSelectionContext(id, this.txtConfirmation, this.txtConfirmations);
            var args = {
                selectionInfo: selectionContext.selectionInfo
            };
            var actionDescription = this.txtActionRemoveConfirmations;
            var actionQeustion = String.format(this.txtActionRemoveConfirmationsQuestion, selectionContext.count, selectionContext.name);
            var action = new ActivityAction();
            action.set('OperationName', "deleteConfirmations");
            action.set('PublishMap', "/entity/userNotification/change");
            action.set('ActionDescription', actionDescription);
            action.set('ActionMessage', actionQeustion);
            action.set('Args', args);
            this._ensureProcessor();
            this._processor.set('Action', action);
            this._processor.set('SelectionContext', selectionContext);
            this._processor.start();
        },

        goToActivityAssociation: function (association, id) {
            if (!id) {
                id = this.getSelectedId();
            }
            if (!id) {
                return;
            }
            this._getActivityAssociationId(association, id, function (result) {
                var entityId = '';
                switch (result.Association) {
                    case 'Account':
                        entityId = result.AccountId;
                        break;
                    case 'Contact':
                        entityId = result.ContactId;
                        break;
                    case 'Opportunity':
                        entityId = result.OpportunityId;
                        break;
                    case 'Lead':
                        entityId = result.LeadId;
                        break;
                    case 'Ticket':
                        entityId = result.TicketId;
                        break;
                    default:

                }
                if (!entityId) {
                    return;
                }
                Sage.Link.entityDetail(association, entityId);
            });
        },

        goToLitRequest: function (id) {
            if (!id) {
                id = this.getSelectedId();
            }
            if (!id) {
                return;
            }
            Sage.Link.entityDetail('LitRequest', id);
        },

        scheduleLitRequest: function () {
            var url = 'Literature.aspx?modeid=Insert';
            document.location.href = url;
        },

        deleteLitRequest: function (id) {
            var selectionContext = this._getSelectionContext(id, this.txtLiteratureRequest, this.txtLiteratureRequests);
            var actionDescription = this.txtActionDeleteLiteratureRequests;
            var actionQeustion = String.format(this.txtActionDeleteLiteratureRequestsQuestion, selectionContext.count, selectionContext.name);
            var action = new ActivityAction();
            var args = {
                selectionInfo: selectionContext.selectionInfo
            };
            action.set('Args', args);
            action.set('OperationName', "deleteLitRequests");
            action.set('ActionDescription', actionDescription);
            action.set('ActionMessage', actionQeustion);
            action.set('PublishMap', "/entity/litRequest/change");
            this._ensureProcessor();
            this._processor.set('Action', action);
            this._processor.set('SelectionContext', selectionContext);
            this._processor.start();
        },

        getActivityEntityContext: function (scope, callback) {

            var cec = Sage.Services.getService('ClientEntityContext');
            var entityContext = cec.getContext();
            var entityType = entityContext.EntityType;
            var entityId = entityContext.EntityId;
            var context = {};
            if ((entityId === '') || (entityId === 'Insert')) {
                if (callback) {
                    callback(scope, context);
                }
                return;
            }
            switch (entityType) {
                case 'Sage.Entity.Interfaces.IAccount':
                    this.getAccountContext(entityContext, scope, callback);
                    break;
                case 'Sage.Entity.Interfaces.IContact':
                    this.getContactContext(entityContext, scope, callback);
                    break;
                case 'Sage.Entity.Interfaces.IOpportunity':
                    this.getOpportunityContext(entityContext, scope, callback);
                    break;
                case 'Sage.Entity.Interfaces.ILead':
                    this.getLeadContext(entityContext, scope, callback);
                    break;
                case 'Sage.Entity.Interfaces.ITicket':
                    this.getTicketContext(entityContext, scope, callback);
                    break;
                case 'Sage.Entity.Interfaces.IReturn':
                    this.getReturnContext(entityContext, scope, callback);
                    break;
                default:
                    if (callback) {
                        callback(scope, context);
                    }
            }
        },

        getAccountContext: function (entityContext, scope, callback) {

            //look up the primary contact...
            var req = new Sage.SData.Client.SDataResourceCollectionRequest(sDataServiceRegistry.getSDataService('dynamic'));
            req.setResourceKind('accounts');
            var pathIdx = req.uri.pathSegments.length - 1;
            var resourceSegment = req.uri.getPathSegment(pathIdx);
            resourceSegment['predicate'] = '"' + entityContext.EntityId + '"';
            req.uri.setPathSegment(pathIdx + 1, 'Contacts');
            req.setQueryArg('select', 'NameLF,IsPrimary,WorkPhone');
            req.setQueryArg('orderby', 'IsPrimary desc');  //rather than selecting "where IsPrimary", do it this way so we at least get something - if there is one that is primary, it will come back, otherwise, we'll just get one.
            req.setQueryArg('count', '1');  //only need one...
            req.read({
                success: function (data) {

                    var context = {
                        AccountId: entityContext.EntityId,
                        AccountName: entityContext.Description,
                        ContactId: '',
                        ContactName: '',
                        PhoneNumber: ''
                    };

                    var contacts = data['$resources'];

                    if (contacts.length > 0) {
                        var primaryContact = contacts[0];
                        context.ContactId = sageUtility.getValue(primaryContact, '$key');
                        context.ContactName = sageUtility.getValue(primaryContact, 'NameLF');
                        context.PhoneNumber = sageUtility.getValue(primaryContact, 'WorkPhone');
                    }
                    if (callback) {
                        callback(scope, context);
                    }
                },
                failure: function () {

                    var context = {
                        AccountId: entityContext.EntityId,
                        AccountName: entityContext.Description,
                        ContactId: '',
                        ContactName: '',
                        PhoneNumber: ''
                    };

                    if (callback) {
                        callback(scope, context);
                    }
                },
                scope: this
            });
        },


        getContactContext: function (entityContext, scope, callback) {
            //look up the contact and account...
            var req = new Sage.SData.Client.SDataSingleResourceRequest(sDataServiceRegistry.getSDataService('dynamic'));
            req.setResourceKind('contacts');
            req.setResourceSelector('"' + entityContext.EntityId + '"');
            req.setQueryArg('select', 'NameLF,IsPrimary,WorkPhone,Account,AccountName');
            req.read({
                success: function (contact) {
                    var context = {
                        AccountId: sageUtility.getValue(contact, 'Account.$key'),
                        AccountName: sageUtility.getValue(contact, 'AccountName'),
                        ContactId: entityContext.EntityId,
                        ContactName: sageUtility.getValue(contact, 'NameLF'),
                        PhoneNumber: sageUtility.getValue(contact, 'WorkPhone')
                    };
                    if (callback) {
                        callback(scope, context);
                    }
                },
                failure: function () {
                    var context = {
                        AccountId: '',
                        AccountName: '',
                        ContactId: entityContext.EntityId,
                        ContactName: entityContext.Description,
                        PhoneNumber: ''
                    };

                    if (callback) {

                        callback(scope, context);
                    }
                },
                scope: this
            });
        },

        getOpportunityContext: function (entityContext, scope, callback) {
            var store = new SingleEntrySDataStore({
                include: ['Contacts', 'Account'],
                select: ['Description', 'Contacts/IsPrimary', 'Contacts/Contact/NameLF', 'Contacts/Contact/WorkPhone', 'Account/Id', 'Account/AccountName'],
                resourceKind: 'opportunities',
                service: sDataServiceRegistry.getSDataService('dynamic')
            });
            store.fetch({
                predicate: '"' + entityContext.EntityId + '"',
                onComplete: function (opp) {
                    var context = {
                        AccountId: opp.Account.$key,
                        AccountName: opp.Account.AccountName,
                        ContactId: '',
                        ContactName: '',
                        OpportunityId: entityContext.EntityId,
                        OpportunityName: opp.Description,
                        PhoneNumber: ''
                    };
                    var oppCons = opp.Contacts.$resources;
                    var isFirst = true;
                    for (var i = 0; i < oppCons.length; i++) {
                        if (oppCons[i].IsPrimary || isFirst) {
                            context['ContactId'] = oppCons[i].Contact.$key;
                            context['ContactName'] = oppCons[i].Contact.NameLF;
                            context['PhoneNumber'] = oppCons[i].Contact.WorkPhone || '';
                        }
                        isFirst = false;
                    }
                    if (callback) {
                        callback(scope, context);
                    }
                },
                onError: function () {
                    var context = {
                        AccountId: '',
                        AccountName: '',
                        ContactId: '',
                        ContactName: '',
                        OpportunityId: entityContext.EntityId,
                        OpportunityName: entityContext.Description,
                        PhoneNumber: ''
                    };
                    if (callback) {
                        callback(scope, context);
                    }
                },
                scope: this
            });
        },

        getLeadContext: function (entityContext, scope, callback) {
            var store = new SingleEntrySDataStore({
                include: [],
                select: ['LeadFullName', 'Company', 'WorkPhone'],
                resourceKind: 'leads',
                service: sDataServiceRegistry.getSDataService('dynamic')
            });
            store.fetch({
                predicate: '"' + entityContext.EntityId + '"',
                onComplete: function (entity) {
                    var context = {
                        LeadId: entityContext.EntityId,
                        LeadName: entity.LeadFullName,
                        AccountName: entity.Company,
                        PhoneNumber: entity.WorkPhone
                    };
                    if (callback) {
                        callback(scope, context);
                    }
                },
                onError: function () {
                    var context = {
                        LeadId: entityContext.EntityId,
                        LeadName: entityContext.Description,
                        AccountName: '',
                        PhoneNumber: ''
                    };
                    if (callback) {
                        callback(scope, context);
                    }
                },
                scope: this
            });
        },

        getTicketContext: function (entityContext, scope, callback) {
            //look up the contact and account...
            var req = new Sage.SData.Client.SDataResourceCollectionRequest(sDataServiceRegistry.getSDataService('dynamic'));
            req.setResourceKind('tickets');
            var pathIdx = req.uri.pathSegments.length - 1;
            var resourceSegment = req.uri.getPathSegment(pathIdx);
            resourceSegment['predicate'] = '"' + entityContext.EntityId + '"';
            // req.uri.setPathSegment(pathIdx + 1, 'Contacts');
            req.setQueryArg('select', 'Account,Account/AccountName,Contact,Contact/NameLF,Contact/WorkPhone');
            //req.setQueryArg('orderby', 'IsPrimary desc');  //rather than selecting "where IsPrimary", do it this way so we at least get something - if there is one that is primary, it will come back, otherwise, we'll just get one.
            //req.setQueryArg('count', '1');  //only need one...
            req.read({
                success: function (data) {
                    var context = {
                        AccountId: '',
                        AccountName: '',
                        ContactId: '',
                        ContactName: '',
                        TicketId: entityContext.EntityId,
                        TicketNumber: entityContext.Description,
                        PhoneNumber: ''
                    };
                    var contacts = data['$resources'];

                    if (contacts.length > 0) {
                        var contact = contacts[0];

                        context.AccountId = sageUtility.getValue(contact, 'Account.$key');
                        context.AccountName = sageUtility.getValue(contact, 'Account.AccountName');
                        context.ContactId = sageUtility.getValue(contact, 'Contact.$key');
                        context.ContactName = sageUtility.getValue(contact, 'Contact.NameLF');
                        context.PhoneNumber = sageUtility.getValue(contact, 'Contact.WorkPhone');
                    }
                    if (callback) {
                        callback(scope, context);
                    }

                },
                failure: function () {
                    var context = {
                        AccountId: '',
                        AccountName: '',
                        ContactId: '',
                        ContactName: '',
                        TicketId: entityContext.EntityId,
                        TicketNumber: entityContext.Description,
                        PhoneNumber: ''
                    };

                    if (callback) {

                        callback(scope, context);
                    }
                },
                scope: this
            });

        },

        getReturnContext: function (entityContext, scope, callback) {
            //look up the contact and account...
            var req = new Sage.SData.Client.SDataResourceCollectionRequest(sDataServiceRegistry.getSDataService('dynamic'));
            req.setResourceKind('returns');
            var pathIdx = req.uri.pathSegments.length - 1;
            var resourceSegment = req.uri.getPathSegment(pathIdx);
            resourceSegment['predicate'] = '"' + entityContext.EntityId + '"';
            req.setQueryArg('select', 'Account,Account/AccountName,ReturnedBy,ReturnedBy/NameLF,ReturnedBy/WorkPhone,Ticket,Ticket/TicketNumber');
            req.read({
                success: function (data) {
                    var context = {
                        AccountId: '',
                        AccountName: '',
                        ContactId: '',
                        ContactName: '',
                        TicketId: '',
                        TicketNumber: '',
                        PhoneNumber: ''
                    };
                    var returns = data['$resources'];

                    if (returns.length > 0) {
                        var rma = returns[0];

                        context.AccountId = sageUtility.getValue(rma, 'Account.$key');
                        context.AccountName = sageUtility.getValue(rma, 'Account.AccountName');
                        context.ContactId = sageUtility.getValue(rma, 'ReturnedBy.$key');
                        context.ContactName = sageUtility.getValue(rma, 'ReturnedBy.NameLF');
                        context.PhoneNumber = sageUtility.getValue(rma, 'ReturnedBy.WorkPhone');
                        context.TicketNumber = sageUtility.getValue(rma, 'Ticket.TicketNumber');
                        context.TicketId = sageUtility.getValue(rma, 'Ticket.$key');
                    }
                    if (callback) {
                        callback(scope, context);
                    }

                },
                failure: function () {
                    var context = {
                        AccountId: '',
                        AccountName: '',
                        ContactId: '',
                        ContactName: '',
                        TicketId: '',
                        TicketNumber: '',
                        PhoneNumber: ''
                    };

                    if (callback) {

                        callback(scope, context);
                    }
                },
                scope: this
            });

        },


        _getActivityAssociationId: function (association, activityId, callback) {

            //look up activity...
            var req = new Sage.SData.Client.SDataResourceCollectionRequest(sDataServiceRegistry.getSDataService('dynamic'));
            req.setResourceKind('activities');
            var pathIdx = req.uri.pathSegments.length - 1;
            var resourceSegment = req.uri.getPathSegment(pathIdx);
            resourceSegment['predicate'] = '"' + activityId + '"';
            req.setQueryArg('select', 'AccountId,ContactId,OpportunityId,TicketId,LeadId');
            req.read({
                success: function (data) {
                    var result = {
                        Association: association,
                        ActivityId: activityId,
                        AccountId: '',
                        ContactId: '',
                        OpportunityId: '',
                        TicketId: '',
                        LeadId: ''
                    };
                    var acts = data['$resources'];

                    if (acts.length > 0) {
                        var act = acts[0];

                        result.AccountId = sageUtility.getValue(act, 'AccountId');
                        result.ContactId = sageUtility.getValue(act, 'ContactId');
                        result.OpportunityId = sageUtility.getValue(act, 'OpportunityId');
                        result.TicketId = sageUtility.getValue(act, 'TicketId');
                        result.LeadId = sageUtility.getValue(act, 'LeadId');
                    }
                    if (callback) {
                        callback(result);
                    }

                },
                failure: function () {
                    var result = {
                        Association: association,
                        ActivityId: activityId,
                        AccountId: '',
                        ContactId: '',
                        OpportunityId: '',
                        TicketId: '',
                        LeadId: ''
                    };

                    if (callback) {
                        callback(result);
                    }
                },
                scope: this
            });
        },
        getActivityFreeBusyFor: function (scope, options, onSuccessCallback, onfailCallback) {
            var self = this;
            this.getResourceActivitiesFor(self, options,
            function (resourceData) {
                self.getUserActivitiesFor(self, options,
                function (userData) {
                    var freeBusyData = self._buildFreeBusyData(resourceData, userData);
                    if (onSuccessCallback) {
                        onSuccessCallback.call(scope, freeBusyData);
                    }
                },
                function (userData) {
                    if (onfailCallback) {
                        onfailCallback.call(scope, userData);
                    }
                });
            },
            function (data) {
                if (onfailCallback) {
                    onfailCallback.call(scope, data);
                }
            });
        },
        getResourceActivitiesFor: function (scope, options, onSuccessCallback, onfailCallback) {
            var select = ['Timeless',
                      'Type',
                      'StartDate',
                      'Duration',
                      'Description',
                      'Resources/Resource'
                     ];
            var include = ['$descriptors'];
            var resourceKind = 'activities';
            var service = sDataServiceRegistry.getSDataService('system');
            var isoStartDate = sageUtility.Convert.toIsoStringFromDate(options.startDate);
            var isoEndDate = sageUtility.Convert.toIsoStringFromDate(options.endDate);
            var self = this;
            var where = "(Resources.ResourceId in (" + options.quotedIds.join(',') + "))" + dojo.string.substitute("and (Timeless ne true) and (StartDate between @${0}@ and @${1}@)", [isoStartDate, isoEndDate]);
            var request = new Sage.SData.Client.SDataResourceCollectionRequest(service);
            if (options.select) {
                select = options.select;
            }
            request.setResourceKind(resourceKind);
            request.setQueryArg('select', select.join(','));
            request.setQueryArg('where', where);
            request.setQueryArg('include', include.join(','));
            request.uri.queryArgs['_expandRecurrences'] = options.expandRecurrences;
            request.read({
                success: function (data) {
                    if (onSuccessCallback) {
                        var resourceData = self._processResourceActivityData(data);
                        onSuccessCallback.call(scope, resourceData);
                    }
                },
                failure: dojo.hitch(scope, onfailCallback)
            });
        },
        getUserActivitiesFor: function (scope, options, onSuccessCallback, onfailCallback) {
            var select = ['Timeless',
                      'Type',
                      'StartDate',
                      'Duration',
                      'Description',
                      'Leader',
                      'UserActivities/User',
                      'UserActivities/Status'
                     ];

            var include = ['$descriptors'];
            var resourceKind = 'activities';
            var service = sDataServiceRegistry.getSDataService('system');
            var isoStartDate = sageUtility.Convert.toIsoStringFromDate(options.startDate);
            var isoEndDate = sageUtility.Convert.toIsoStringFromDate(options.endDate);
            var self = this;
            var where = "(UserActivities.UserId in (" + options.quotedIds.join(',') + ")) and (Type ne 'atLiterature') and (UserActivities.Status ne 'asDeclned')" + dojo.string.substitute("and (StartDate between @${0}@ and @${1}@)", [isoStartDate, isoEndDate]);
            var request = new Sage.SData.Client.SDataResourceCollectionRequest(service);
            if (options.timelessOnly) {
                where = where + ' and (Timeless eq true)';
            } else {
                if (!options.includeTimless) {
                    where = where + ' and (Timeless ne true)';
                }
            }
            if (options.select) {
                select = options.select;
            }
            request.setResourceKind(resourceKind);
            request.setQueryArg('select', select.join(','));
            request.setQueryArg('where', where);
            request.setQueryArg('include', include.join(','));
            request.uri.queryArgs['_expandRecurrences'] = options.expandRecurrences;
            request.read({
                success: function (data) {
                    var cleanList = self._processUserActivityData(data);
                    if (onSuccessCallback) {
                        onSuccessCallback.call(scope, cleanList);
                    }
                },
                failure: dojo.hitch(scope, onfailCallback)
            });
        },
        _processUserActivityData: function (actvityData) {
            var cleanData = [];
            cleanData['$resources'] = [];
            var data = actvityData['$resources'];
            var userActvityKey, userActView;
            if (data) {
                var cnt = data.length;
                for (var i = 0; i < cnt; i++) {
                    var userActivityFound = false;
                    var activityId = data[i]["$key"];
                    if (data[i].UserActivities) {
                        var userActivities = data[i].UserActivities.$resources;
                        var ln = userActivities.length;
                        for (var j = 0; j < ln; j++) {
                            var userId = data[i].UserActivities.$resources[j].User.$key;
                            userActvityKey = userId + ':' + activityId;
                            userActivityFound = cleanData[userActvityKey];
                            if (!userActivityFound) {
                                userActView = {
                                    $Key: userActvityKey,
                                    UserId: data[i].UserActivities.$resources[j].User.$key,
                                    ActivityId: activityId,
                                    UserActivity: data[i].UserActivities.$resources[j],
                                    Activity: data[i]
                                };
                                cleanData[userActvityKey] = userActView;
                                cleanData[userActvityKey] = userActvityKey;
                                cleanData['$resources'].push(userActView);
                                continue;
                            }

                        } //end for
                    } else {
                        //Personal Activities will not have User Activities
                        //Attach 'UserActvities.$resources' as this is the key on grid binding for userColor column
                        var uId = data[i].Leader.$key;
                        userActvityKey = uId + ':' + activityId;
                        data[i].UserActivities = [];
                        data[i].UserActivities.$resources = [];
                        var userObj = {};
                        userObj.$key = uId;
                        userObj.User = { $key: uId };
                        data[i].UserActivities.$resources.push(userObj);
                        userActView = {
                            $key: userActvityKey,
                            UserId: data[i].Leader.$key,
                            ActivityId: activityId,
                            UserActivity: data[i].UserActivities.$resources,
                            Activity: data[i]
                        };
                        userActivityFound = cleanData[userActvityKey];
                        if (!userActivityFound) {
                            cleanData[userActvityKey] = userActvityKey;
                            cleanData['$resources'].push(userActView);
                        }
                    }
                } //end for
            } //end if
            var resData = [];
            resData['$resources'] = cleanData['$resources'];
            return resData;
        },
        _processResourceActivityData: function (actvityData) {
            var cleanData = [];
            cleanData['$resources'] = [];
            var data = actvityData['$resources'];
            if (data) {
                var cnt = data.length;
                for (var i = 0; i < cnt; i++) {
                    var resourceFound = false;
                    var activityId = data[i]["$key"];
                    if (data[i].Resources) {
                        var Resources = data[i].Resources.$resources;
                        var ln = Resources.length;
                        for (var j = 0; j < ln; j++) {
                            var resourceId = data[i].Resources.$resources[j].Resource.$key;
                            var resourceActvitiyKey = resourceId + ':' + activityId;
                            resourceFound = cleanData[resourceActvitiyKey];
                            if (!resourceFound) {
                                var resourceActView = {
                                    $Key: resourceActvitiyKey,
                                    ResourceId: resourceId,
                                    ActivityId: activityId,
                                    ResourceActivity: data[i].Resources.$resources[j],
                                    Activity: data[i]
                                };
                                cleanData[resourceActvitiyKey] = resourceActView;
                                cleanData[resourceActvitiyKey] = resourceActvitiyKey;
                                cleanData['$resources'].push(resourceActView);
                                continue;
                            } //end if
                        } //end for
                    } //end if
                } //end for
            } //end if
            var resData = [];
            resData['$resources'] = cleanData['$resources'];
            return resData;
        },
        _buildFreeBusyData: function (resourceData, userData) {
            var rData = resourceData['$resources'];
            var uData = userData['$resources'];
            var vData = [];
            var i;
            var itemObj;
            vData['$resources'] = [];
            for (i = 0; i < uData.length; i++) {
                itemObj = {
                    id: uData[i].$key,
                    activityId: uData[i].ActivityId,
                    itemId: uData[i].UserId,
                    type: uData[i].Activity.Type,
                    startDate: uData[i].Activity.StartDate,
                    duration: uData[i].Activity.Duration,
                    timless: uData[i].Activity.Timeless,
                    description: uData[i].Activity.Description
                };
                vData['$resources'].push(itemObj);
            }
            for (i = 0; i < rData.length; i++) {
                itemObj = {
                    id: rData[i].$key,
                    activityId: rData[i].ActivityId,
                    itemId: rData[i].ResourceId,
                    type: rData[i].Activity.Type,
                    startDate: rData[i].Activity.StartDate,
                    duration: rData[i].Activity.Duration,
                    timless: rData[i].Activity.Timeless,
                    description: rData[i].Activity.Description
                };
                vData['$resources'].push(itemObj);
            }
            return vData;
        },
        getDefaultActivityManagerTabId: function () {
            if (!this._defaultActivitManagerTabId) {
                var optionsSvc = Sage.Services.getService('UserOptions');
                var self = this;
                if (optionsSvc) {
                    optionsSvc.get('DefaultView', 'ActivityAlarm', function (data) {
                        self._defaultActivitManagerTabId = self.getTabIdFromCode(data.value);
                    },
                    null,
                    this,
                    false
                    );
                }
            }
            return this._defaultActivitManagerTabId;
        },
        setDefaultActivityManagerTabId: function (tabId) {
            this._defaultActivitManagerTabId = tabId;
        },
        getTabIdFromCode: function (code) {
            var tabId = 'activities';
            switch (code) {
                case '0':
                    tabId = 'activities';
                    break;
                case '1':
                    tabId = 'allopen';
                    break;
                case '2':
                    tabId = 'pastdue';
                    break;
                case '3':
                    tabId = 'alarms';
                    break;
                case '4':
                    tabId = 'events';
                    break;
                case '5':
                    tabId = 'confirmations';
                    break;
                case '6':
                    tabId = 'literature';
                    break;
            }
            return tabId;
        },
        getSelectedId: function () {
            var selectionInfo = this.getSelectionInfo();
            var id = "";
            if (selectionInfo) {
                if (selectionInfo.hasCompositeKey) {
                    var entity = selectionInfo.selections[0].entity;
                    return entity["Activity"]["$key"];
                }
                if (selectionInfo.selections.length == 1) {
                    id = selectionInfo.selections[0].id;
                } else {
                    id = selectionInfo.selections[0].id;
                }
            }
            return id;
        },

        getSelectedItem: function () {
            var selectionInfo = this.getSelectionInfo();
            var selectedItem = { id: false, hasCompositeKey: false, entity: false };
            if (selectionInfo) {
                selectedItem.hasCompositeKey = selectionInfo.hasCompositeKey;
                selectedItem.entity = selectionInfo.entity;
                if (selectionInfo.selections.length == 1) {
                    selectedItem.id = selectionInfo.selections[0].id;
                    selectedItem.entity = selectionInfo.selections[0].entity;
                } else {
                    selectedItem.id = selectionInfo.selections[0].id;
                    selectedItem.entity = selectionInfo.selections[0].entity;
                }
            }
            return selectedItem;
        },


        getSelections: function () {
            var selectionInfo = this.getSelectionInfo();
            var selections = null;
            if (selectionInfo) {
                selections = selectionInfo.selections;
            }
            return selections;
        },
        prepareSelections: function () {
            return this.getSelectionInfo();
        },
        getSelectionInfo: function () {
            var selectionInfo = false;
            try {
                var panel = dijit.byId('list');
                if (panel) {
                    selectionInfo = panel.getSelectionInfo(true);
                }
            }
            catch (e) {
                Dialogs.alert(this.txtErrorActionMsg || "error getting selectionInfo");
            }
            return selectionInfo;
        },
        getTotalSelectionCount: function () {
            var count = 0;
            try {
                var panel = dijit.byId('list');
                if (panel) {
                    count = panel.getTotalSelectionCount();
                }
            }
            catch (e) {
            }
            return count;
        },

        verifySelection: function (selectionInfo) {
            if (selectionInfo !== null) {
                return (selectionInfo.selectionCount !== 0);
            }
            return false;
        },
        verifySingleSelection: function (selectionInfo) {
            if (selectionInfo !== null) {
                return (selectionInfo.selectionCount === 1);
            }
            return false;
        },
        setSelectionCount: function () {
            try {
                var panel = dijit.byId('list');
                if (panel) {
                    $("#selectionCount").text(panel.getTotalSelectionCount());
                }
            }
            catch (e) {
            }
        },

        refreshList: function (tabId) {
            try {
                var panel = dijit.byId('list');
                if (panel) {
                    var grpContextSvc = Sage.Services.getService('ClientGroupContext');
                    if (grpContextSvc) {
                        var ctx = grpContextSvc.getContext();
                        if (tabId === ctx.CurrentGroupID) {
                            panel.refreshView(tabId);
                        }
                    }
                }
            }
            catch (e) {
            }
        },
        _getSelectionContext: function (id, singularName, pluralName) {
            var selectionContext = {
                id: null,
                selectionInfo: null,
                count: 0,
                mode: 'select',
                name: null
            };
            if (!id) {
                selectionContext.selectionInfo = this.getSelectionInfo();
                selectionContext.count = selectionContext.selectionInfo.selectionCount;
                if (selectionContext.count === 1) {
                    selectionContext.id = selectionContext.selectionInfo.selectedIds[0];
                }
            } else {
                var selectedIds = [];
                var selections = [];
                selectedIds.push(id);
                selections.push({ rn: 0, id: id });
                var selectionInfo = {
                    key: '',
                    mode: 'singleSelect',
                    selectionCount: 1,
                    recordCount: 1,
                    sortDirection: '',
                    sortField: '',
                    keyField: '',
                    hasCompositeKey: id.indexOf("Activity") > -1 ? true : false,
                    ranges: [],
                    selections: selections,
                    selectedIds: selectedIds
                };
                selectionContext.selectionInfo = selectionInfo;
                selectionContext.id = id;
                selectionContext.count = 1;
            }
            selectionContext.name = (selectionContext.count > 1) ? pluralName : singularName;
            return selectionContext;
        },


        getActivityService: function () {
            var service = sDataServiceRegistry.getSDataService('dynamic');
            return service;
        }


    }); // end dojo declare

    /**
    * Make an instance of this service available to the
    * Sage.Services.getService method.
    */
    if (!Sage.Services.hasService('ActivityService')) {
        Sage.Services.addService('ActivityService', new activityService());
    }
    return activityService;
});


},
'Sage/MainView/ActivityMgr/ActivityEditor':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dijit/_Widget',
    'Sage/_Templated',
    'dojo/_base/declare',
    'Sage/Data/SingleEntrySDataStore',
    'Sage/MainView/BindingsManager',
    'Sage/Utility',
    'Sage/UI/Controls/_DialogHelpIconMixin',
    'dojo/_base/lang',
    'Sage/UI/_DialogLoadingMixin',
    'Sage/Utility/Activity',
    'dojo/date',
    'dojo/date/locale',
    'dojo/string',
    'Sage/UI/Dialogs',
    'dijit/Tooltip',
    'Sage/UI/AttachmentList',
    'Sage/Data/SDataServiceRegistry',
    'Sage/Utility/File',
    'Sage/Utility/File/Attachment',
    'Sage/UI/Controls/Lookup',
    'dojo/i18n!./nls/ActivityEditor',
    'dojo/text!./templates/ActivityEditor.html',
    'dojo/dom-class',
    'Sage/Utility/UserOptions',
    'dijit/focus',
    'dojo/aspect',
    'Sage/MainView/ActivityMgr/ActivityEditorAttendeesTab',
    'dijit/layout/ContentPane',
    'dojo/dom-style',
    'dojo/on',
    'dojo/dom-geometry',

    'dijit/Toolbar',
    'dijit/layout/TabContainer',
    'dijit/form/Textarea',
    'dojox/layout/TableContainer',
    'dijit/layout/BorderContainer',
    'dijit/form/ComboBox',
    'Sage/Services/UserOptions',
    'Sage/UI/Controls/SingleSelectPickList',
    'Sage/UI/Controls/DateTimePicker',
    'Sage/UI/Controls/Lookup',
    'Sage/MainView/ActivityMgr/RecurringEditor',
    'dijit/Dialog',
    'Sage/UI/Controls/DurationSelect',
    'Sage/Services/CalendarSecurityService'
],
function (_Widget, _Templated, declare, SingleEntrySDataStore, BindingsManager, utility, _DialogHelpIconMixin,
    dojoLang, _DialogLoadingMixin, activityUtility, dojoDate, locale, dString, sageDialogs, tooltip, AttachmentList,
    sDataServiceRegistry, fileUtility, attachmentUtility, Lookup, activityEditorStrings, template, domClass, userOptionsUtility, focusUtil, aspect,
    ActivityEditorAttendeesTab, ContentPane, domStyle, on, domGeometry) {
    var activityEditor = declare('Sage.MainView.ActivityMgr.ActivityEditor', [_Widget, _Templated], {
        activityId: '',
        activityMemberId: '',
        _memberSecurityData: [],
        mode: '',
        userNotificationId: '',
        id: '',
        activityType: '',
        _options: {},
        _dialog: false,
        _currentUserId: null,
        _originalLeaderId: false,
        _activityService: false,
        _activityData: false,
        _activityStore: false,
        _currentUserActivityData: false,
        _tempUAData: false,
        _currentUserActivityStore: false,
        _notificationData: false,
        _notificationStore: false,
        _notificationBindingMgr: false,
        _historyStore: false,
        _deleteAttendeeConnects: [],
        _attendeesData: [],
        _newAttendeesData: [],
        _attendeesForRemoval: [],
        _userActivitiesRequestCount: 0,
        _resourceRequestCount: 0,
        _resourceDeleteRequestCount: 0,
        _availabilityShowing: false,
        _bindingMgr: false,
        _uaBindingMgr: false,
        _activityChangeConnection: false,
        lup_Account: false,
        lup_Contact: false,
        lup_Opportunity: false,
        lup_Ticket: false,
        lup_Lead: false,
        lup_Leader: false,
        accountLookupConfig: {},
        contactLookupConfig: {},
        opportunityLookupConfig: {},
        ticketLookupConfig: {},
        leadLookupConfig: {},
        resourcesLookupConfig: {},
        _isBinding: false,
        _activitySaved: false,
        _userActivitiesSaved: false,
        _currentUserActivitySaved: false,
        _resourcesSaved: false,
        _resourcesRemoved: false,
        _attachmentsSaved: false,
        _completeAfterSaving: false,
        _attachmentList: false,
        _tempIdForAttachments: false,
        confirmationDisableList: ['pk_Regarding', 'tb_Location', 'dtp_startDate', 'sel_Duration', 'cb_Timeless', 'cb_Alarm', 'sel_AlarmDur', 'cb_AutoRollover', 'rdo_Contact', 'rdo_Lead', 'lup_Account', 'lup_Contact', 'lup_Opportunity', 'lup_Ticket', 'lup_Lead', 'ta_Notes', 'pk_Priority', 'lup_Leader', 'pk_Category'],
        noEditDisableList: ['pk_Regarding', 'tb_Location', 'dtp_startDate', 'sel_Duration', 'cb_Timeless', 'cb_AutoRollover', 'rdo_Contact', 'rdo_Lead', 'lup_Account', 'lup_Contact', 'lup_Opportunity', 'lup_Ticket', 'lup_Lead', 'pk_Priority', 'lup_Leader', 'pk_Category'], // 'cb_Alarm', 'btn_OK', 'sel_AlarmDur',
        _readOnlyMode: false,
        _isProcessing: false,
        _DHTMLXLibraryTimePattern:'',
        eventConnections: [],
        activityDefaultValues: {},
        widgetsInTemplate: true,
        widgetTemplate: new Simplate(eval(template)),
        constructor: function () {
            dojoLang.mixin(this, activityEditorStrings);
            this._preloadActivityOptions();
            this._activityService = sDataServiceRegistry.getSDataService('system');
            this._setupStore();
            this._currentUserId = utility.getClientContextByKey('userID') || '';
            this._currentUserId = this._currentUserId.trim();
            dojo.subscribe('/entity/attachment/create', this, this._updateActivityETag);
            dojo.subscribe('/entity/attachment/update', this, this._updateActivityETag);
            dojo.subscribe('/entity/attachment/delete', this, this._updateActivityETag);
        },
        destroy: function () {
            if (this._activityChangeConnection) {
                dojo.disconnect(this._activityChangeConnection);
                this._activityChangeConnection = false;
            }
            if (this._bindingMgr) {
                this._bindingMgr.destroy();
            }
            if (this._uaBindingMgr) {
                this._uaBindingMgr.destroy();
            }
            for (var i = 0; i < this.eventConnections.length; i++) {
                dojo.disconnect(this.eventConnections[i]);
            }
            this.lup_Account.destroy();
            this.lup_Contact.destroy();
            this.lup_Opportunity.destroy();
            this.lup_Ticket.destroy();
            this.lup_Lead.destroy();
            this.lup_Leader.destroy();
            this.eventConnections = [];
            this.inherited(arguments);
        },
        postCreate: function () {
            //set up tooltips for "complete" buttons.  Include change event handlers
            // to keep the tooltip showing the date/time that the completed date will be.
            this._asScheduledTooltip = new tooltip({
                connectId: [this.btn_asScheduled.id],
                label: ' ',
                position: ['below']
            });
            dojo.connect(this.dtp_scheduledDate, 'onChange', this, function () {
                this._asScheduledTooltip.set('label', locale.format(this.dtp_scheduledDate.get('value'), { selector: 'datetime', fullYear: true, locale: Sys.CultureInfo.CurrentCulture.name }));
            });

            this._nowTooltip = new tooltip({
                connectId: [this.btn_Now.id],
                label: ' ',
                position: ['below']
            });
            dojo.connect(this.dtp_completedDate, 'onChange', this, function () {
                this._nowTooltip.set('label', locale.format(this.dtp_completedDate.get('value'), { selector: 'datetime', fullYear: true, locale: Sys.CultureInfo.CurrentCulture.name }));
            });

            dojo.subscribe('/entity/activityAttendee/primaryChanged', this, this.primaryChanged);
            dojo.subscribe('/entity/activityAttendee/add', this, this._updateActivityAttendeeETag);
            dojo.subscribe('/entity/activityAttendee/delete', this, this._updateActivityAttendeeETag);
        },
        primaryChanged: function (currentEntity, type, checked) {
            var entity = dojoLang.clone(currentEntity);
            entity["attendeeTab"] = true;
            entity["$descriptor"] = entity["Name"];
            entity["$key"] = entity["EntityId"];
            if (entity.EntityType == "Contact") {
                if (!entity["Account"]) {
                    entity["Account"] = { "$key": entity["AccountId"], "AccountName": entity["AccountName"] || entity["Company"] };
                }
                entity["ContactId"] = entity["EntityId"];

                if (entity["PrimaryChecked"]) {
                    this.rdo_Contact.set('checked', true);
                    this.rdo_Lead.set('checked', false);
                    this.lup_Contact.set('selectedObject', entity);

                    //To preserve the checked entity between tab changes
                    this.attendeesTab._uncheckItem = entity;
                } else {
                    this.lup_Contact.set('selectedObject', null);
                }
            } else if (entity.EntityType == "Lead") {
                entity["Company"] = entity["AccountName"];
                entity["LeadFullName"] = entity["Name"];
                entity["LeadId"] = entity["EntityId"];
                if (entity["PrimaryChecked"]) {
                    this.rdo_Contact.set('checked', false);
                    this.rdo_Lead.set('checked', true);
                    this.lup_Lead.set('selectedObject', entity);

                    //To preserve the checked entity between tab changes
                    this.attendeesTab._uncheckItem = entity;
                } else {
                    this.lup_Lead.set('selectedObject', null);
                }
            }
        },
        isFirstOpen: true,
        show: function (mixinProperties) {
            this._isProcessing = false;
            this._dialog.set('refocus', false);
            this._dialog.show();
            if (this.isFirstOpen) {
                // create lookup controls...
                this.isFirstOpen = false;
                this._ensureLookupsCreated();
                this.connect(this._recurringEditor, 'onStartDateChanged', this._recurringStartDateChanged);
                this.connect(this._recurringEditor, 'onRecurPeriodChanged', this._recurringPeriodChanged);
                this.connect(this._dialog, 'onHide', this._cleanOnClose);
                this._ensureAttachmentList();
            }
            //Reset the duration selector.
            this.sel_AlarmDur.resetItems();
            this.activityDefaultValues = {};
            if (this.mode === 'New') {
                this.activityDefaultValues = mixinProperties || {};
                this._loadData();
            }
            if (this.mode === 'CompleteUnscheduled' && !this.historyId) {
                this.activityDefaultValues = mixinProperties || {};
                this._loadHistory();
            }
            if (!this._dialog._standby) {
                dojoLang.mixin(this._dialog, new _DialogLoadingMixin());
                if (!this._activityData && !this._notificationData) {
                    this._dialog.showLoading();
                }
            }

            // Create help icon
            if (!this._dialog.helpIcon) {
                dojoLang.mixin(this._dialog, new _DialogHelpIconMixin());
                this._dialog.createHelpIconByTopic(this._getHelpTopicByMode());
            }
            this._availabilityShowing = false;
            this.tc_EditActivity.selectChild(this.cp_General);
            this._dialog.resize();
        },
        hide: function () {
            this._dialog.hide();
        },
        _onDlgHide: function () {
            this.onHide();
        },
        onHide: function () {
            this.attendeesTab._dialogHide();
            this._cleanOnClose();
        },
        _cleanOnClose: function () {
            var svc = Sage.Services.getService('ClientEntityContext');
            svc.clearTemporaryContext();
            this.set('activityId', '');
            this.set('activityMemberId', '');
            if (this._activityStore) {
                this._activityStore.clearCache();
            }
            if (this._historyStore) {
                this._historyStore.clearCache();
            }

            //Making sure the tooltips are hidden when closing the dialog
            this._hideLookupTooltip(this.lup_Account);
            this._hideLookupTooltip(this.lup_Contact);
            this._hideLookupTooltip(this.lup_Opportunity);
            this._hideLookupTooltip(this.lup_Ticket);
            this._hideLookupTooltip(this.lup_Lead);
            this._hideLookupTooltip(this.lup_Leader);
        },
        _hideLookupTooltip: function (control) {
            if (control) {
                control.hideTooltip();
            }
        },
        _controllOnMouseEnter: function () {
        },
        // ... region - Activity data methods   .....................
        _updateActivityETag: function (attachment) {
            //listener for attachment record changes.
            if (attachment) {
                this._activityData.AttachmentCount++;
            } else {
                this._activityData.AttachmentCount--;
            }
            if (this._dialog.open && this.activityId) {
                var req = new Sage.SData.Client.SDataSingleResourceRequest(sDataServiceRegistry.getSDataService('system'));
                req.setResourceKind('activities');
                req.setResourceSelector('"' + this.activityId + '"');
                req.setQueryArg('precedence', '0');
                req.read({
                    success: function (activity) {
                        this._activityData['$etag'] = activity['$etag'];
                    },
                    scope: this
                });
            }
        },
        _updateActivityAttendeeETag: function (count) {
            if (this._dialog.open && this.activityId) {
                this.AttCount = count;
                var req = new Sage.SData.Client.SDataSingleResourceRequest(sDataServiceRegistry.getSDataService('system'));
                req.setResourceKind('activities');
                req.setResourceSelector('"' + this.activityId + '"');
                req.setQueryArg('precedence', '0');
                req.setQueryArg('select', 'details/AttendeeCount');
                req.read({
                    success: function (activity) {
                        this._activityData['$etag'] = activity['$etag'];
                        if (activity['Details']) {
                            this._activityData['Details']['AttendeeCount'] = activity['Details']['AttendeeCount'];
                        }
                    },
                    scope: this
                });
            }
        },
        _ensureAttendeesTab: function () {
            if (!this.attendeesTab || this.mode != this.attendeesTab.editorMode || this.activityId !== this.attendeesTab._activityId) {
                this._addAttendeesTab(this.mode);
                this.userNotificationId = null;
            }
        },
        _addAttendeesTab: function (mode) {
            if (this.attendeesTab) {
                dijit.byId(this.tc_EditActivity.id).removeChild(dijit.byId("attendeesTabPane"));
                if (dijit.byId(this.attendeesTab.lup_Lead.id)) {
                    dijit.byId(this.attendeesTab.lup_Lead.id).destroyRecursive();
                }
                if (dijit.byId(this.attendeesTab.lup_Contact.id)) {
                    dijit.byId(this.attendeesTab.lup_Contact.id).destroyRecursive();
                }
                dijit.byId("attendeesTabPane").destroyRecursive();
                this.attendeesTab = null;
            }
            var options = { editorMode: mode };
            var attendeesTab = this.attendeesTab = new ActivityEditorAttendeesTab(options);
            // Create a new ContentPane with the association tab as the contents
            var cp = new ContentPane({
                id: 'attendeesTabPane',
                title: this.tabNameParticipants,
                'class': 'tabContent remove-padding'
            }, attendeesTab.domNode);

            //Add Association ContentPane to table container that is already defined in the activity editor
            this.tc_EditActivity.addChild(cp);
            attendeesTab.actEditor = this;
            var editable = true;
            if ((this.mode === 'Confirm') || this._isOccurence()) {
                editable = false;
            }
            attendeesTab.startup(!editable);
            on(cp, 'show', function () {
                if (editable) {
                    attendeesTab.setToReadOnly(false);
                } else {
                    attendeesTab.setToReadOnly(true);
                }
                attendeesTab._tabShow();
            });
        },
        _getHelpTopicByMode: function () {
            switch (this.mode) {
                case 'Confirm':
                    return 'confirmnotifications';
                case 'Complete':
                case 'CompleteUnscheduled':
                    return 'completeactivity';
            }
            return 'activitydetailview';
        },
        _showCorrectButtonBar: function (mode) {
            if (mode === 'Confirm') {
                domClass.add(this.add_edit_buttons, 'display-none');
                domClass.add(this.complete_buttons, 'display-none');
                domClass.remove(this.confirmation_edit_buttons, 'display-none');
            } else if (mode === 'Complete' || mode === 'CompleteUnscheduled') {
                domClass.add(this.add_edit_buttons, 'display-none');
                domClass.add(this.confirmation_edit_buttons, 'display-none');
                domClass.remove(this.complete_buttons, 'display-none');
            } else {
                domClass.add(this.confirmation_edit_buttons, 'display-none');
                domClass.add(this.complete_buttons, 'display-none');
                domClass.remove(this.add_edit_buttons, 'display-none');
            }
        },
        _setModeAttr: function (mode) {
            var idx;
            this.mode = mode;
            //set correct button bar...
            this._showCorrectButtonBar(mode);

            if (mode === 'Confirm') {
                //disable activity controls...
                this._ensureLookupsCreated(); //sometimes this happens before they get created.
                this._bulkSetProperty(this, this.confirmationDisableList, 'disabled', true);
            } else {
                //re-enable activity controls...
                this._bulkSetProperty(this, this.confirmationDisableList, 'disabled', false);
            }
            if (mode.indexOf('New') === 0) {
                this.mode = 'New';
                var typename = mode.replace('New ', '').toLowerCase();
                switch (typename) {
                    case 'phonecall':
                    case 'atphonecall':
                        this.activityType = 'atPhoneCall';
                        break;
                    case 'meeting':
                    case 'atappointment':
                        this.activityType = 'atAppointment';
                        break;
                    case 'todo':
                    case 'attodo':
                        this.activityType = 'atToDo';
                        break;
                    case 'personalactivity':
                    case 'atpersonal':
                    case 'personal':
                        this.activityType = 'atPersonal';
                        break;
                    case 'letter':
                    case 'atletter':
                    case 'doc':
                    case 'atdoc':
                        this.activityType = 'atDoc';
                        break;
                    case 'fax':
                    case 'atfax':
                        this.activityType = 'atFax';
                        break;
                    default:
                        this.activityType = 'atAppointment';
                        break;
                }
                this._activityData = false;
                domClass.add(this.btn_Delete.domNode, 'display-none');
                domClass.add(this.btn_Complete.domNode, 'display-none');

                this._ensureAttendeesTab();
            } else {
                domClass.remove(this.btn_Delete.domNode, 'display-none');
                domClass.remove(this.btn_Complete.domNode, 'display-none');
            }
            if (mode === 'Complete' || mode === 'CompleteUnscheduled') { // show appropriate info for completing activities
                //date section
                domClass.add(this.dateSection_AddEdit.domNode, 'display-none');
                domClass.remove(this.dateSection_Complete.domNode, 'display-none');
                //result picklist
                domClass.remove(this.resultContainer.domNode, 'display-none');
                //Recurring tab
                idx = this.tc_EditActivity.getIndexOfChild(this.cp_Recurring);
                if (idx > 0) {
                    this.tc_EditActivity.removeChild(this.cp_Recurring);
                    window.setTimeout(dojo.hitch(this, function () { this._dialog.resize(); }, 10));
                }
                if (this._dialog.open) {
                    // if the dialog is open, we already have the activity record and
                    // the form is bound to it.  We won't be requesting the activity again
                    // so just run the initialization stuff...
                    this._setUI();
                    this._completeModeManualBind(); //sets default values on non-bound controls.
                }
                //set default follow-up activity values...
                var fupType = this._options.followUp.defaultFollowUpType;
                var setVal = (fupType === 'None') ? this.noneText : activityUtility.getActivityTypeName(fupType);
                this.sel_Followup.set('value', setVal);
                this.ck_coAttachments.set('checked', this._options.followUp.carryOverAttachments);
                this.ck_coNotes.set('checked', this._options.followUp.carryOverNotes);

                if (mode === 'CompleteUnscheduled') {
                    //MAA update
                    this._ensureAttendeesTab();
                }

            } else { // show appropriate information for adding, editing activities as well as displaying info for confirmations
                //date section
                domClass.add(this.dateSection_Complete.domNode, 'display-none');
                domClass.remove(this.dateSection_AddEdit.domNode, 'display-none');
                //result picklist
                domClass.add(this.resultContainer.domNode, 'display-none');
                //Recurring tab
                idx = this.tc_EditActivity.getIndexOfChild(this.cp_Recurring);
                if (idx < 0) {
                    var insIdx = this.tc_EditActivity.getIndexOfChild(this.cp_Attachments);
                    this.tc_EditActivity.addChild(this.cp_Recurring, insIdx);
                    window.setTimeout(dojo.hitch(this, function () { this._dialog.resize(); }, 10));
                }
            }
            if (this._dialog.helpIcon) {
                this._dialog.set('helpTopic', this._getHelpTopicByMode());
            }
        },
        _setActivityIdAttr: function (activityId) {
            activityId = activityId || '';
            this.activityId = activityId;
            this._activityData = false;
            if (activityId !== '') {
                this.historyId = '';
                this._loadData();
                //MAA update
                this._ensureAttendeesTab();
            }
        },
        _getActivityIdAttr: function () {
            return this.activityId;
        },
        _setActivityMemberIdAttr: function (memberId) {
            memberId = memberId || '';
            this.activityMemberId = memberId;
        },
        _getActivityMemberIdAttr: function () {
            return this.activityMemberId;
        },
        _setUserNotificationIdAttr: function (userNotificationId) {
            userNotificationId = userNotificationId || '';
            if (userNotificationId !== this.userNotificationId) {
                this.userNotificationId = userNotificationId;
                this.set('activityId', '');
                this._notificationData = false;
                this._loadNotification();
            }
            //MAA Update
            this._ensureAttendeesTab();
        },
        _getUserNotificationId: function () {
            return this.userNotificationId;
        },
        _setHistoryIdAttr: function (historyId) {
            historyId = historyId || '';
            if (this.historyId !== historyId) {
                this.historyId = historyId;
                this._activityData = false;
                if (historyId !== '') {
                    this.activityId = '';
                    this._loadHistory();
                }
            }
        },
        _getHistoryIdAttr: function () {
            return this.historyId;
        },
        _preloadActivityOptions: function () {
            this._options = {
                atAppointment: {
                    alarmLead: '15',
                    duration: '60',
                    autoRollover: false,
                    timeless: false
                },
                atPhoneCall: {
                    alarmLead: '15',
                    duration: '15',
                    autoRollover: false,
                    timeless: false
                },
                atToDo: {
                    alarmLead: 'none',
                    duration: '15',
                    autoRollover: false,
                    timeless: false
                },
                atPersonal: {
                    alarmLead: 'none',
                    duration: '5',
                    autoRollover: false,
                    timeless: false
                },
                followUp: {
                    defaultFollowUpType: 'None',
                    carryOverNotes: false,
                    carryOverAttachments: false
                },
                calendar: {
                    dayStartTime: '9',
                    dayEndTime: '6'
                }
            };
            var optionsSvc = Sage.Services.getService('UserOptions');
            if (optionsSvc) {
                optionsSvc.getByCategories(['ActivityMeetingOptions', 'ActivityPhoneOptions', 'ActivityToDoOptions', 'ActivityPersonalOptions', 'Calendar'], this._receivedOptions, this);
            }
        },
        _receivedOptions: function (data) {
            //set these up as easily accessible values...
            var followUpMap = {
                '0': 'None',
                '1': 'atPhoneCall',
                '2': 'atAppointment',
                '3': 'atToDo'
            };
            var opts = data['$resources'];
            for (var i = 0; i < opts.length; i++) {
                var opt = opts[i];
                var appliesTo = (opt.category === 'ActivityMeetingOptions') ? 'atAppointment' :
                (opt.category === 'ActivityPhoneOptions') ? 'atPhoneCall' :
                (opt.category === 'ActivityToDoOptions') ? 'atToDo' :
                (opt.category === 'ActivityPersonalOptions') ? 'atPersonal' : false;
                if (appliesTo && this._options[appliesTo] && opt.value) {
                    switch (opt.name) {
                        case 'AlarmLead':
                            this._options[appliesTo].alarmLead = (parseInt(opt.value, 10) > 0) ? opt.value : 'none';
                            break;
                        case 'Duration':
                            this._options[appliesTo].duration = opt.value;
                            break;
                        case 'Timeless':
                            var tval = opt.value.substring(0, 1).toUpperCase();
                            this._options[appliesTo].timeless = tval === 'T';
                            break;
                        case 'AutoRollover':
                            var arval = opt.value.substring(0, 1).toUpperCase();
                            this._options[appliesTo].autoRollover = arval === 'T';
                            break;
                    }
                } else if (opt.category === 'Calendar') {
                    switch (opt.name) {
                        case 'DayStartTime':
                            this._options.calendar.dayStartTime = userOptionsUtility.getConvertedOptionValue(opt['name'], opt['value']);
                            break;
                        case 'DayEndTime':
                            this._options.calendar.dayEndTime = userOptionsUtility.getConvertedOptionValue(opt['name'], opt['value']);
                            break;
                        case 'DefaultFollowUpType':
                            this._options.followUp.defaultFollowUpType = followUpMap[opt.value] || 'None';
                            break;
                        case 'CarryOverNotes':
                            var nval = opt.value.substring(0, 1).toUpperCase();
                            this._options.followUp.carryOverNotes = nval === 'T';
                            break;
                        case 'CarryOverAttachments':
                            var aval = opt.value.substring(0, 1).toUpperCase();
                            this._options.followUp.carryOverAttachments = aval === 'T';
                    }
                }
            }
        },
        _setupStore: function () {
            if (!this._activityStore) {
                this._activityStore = new SingleEntrySDataStore({
                    include: ['$descriptors'],
                    resourceKind: 'activities',
                    ignoreETag: true,
                    service: this._activityService
                });
            }
            if (!this._currentUserActivityStore) {
                this._currentUserActivityStore = new SingleEntrySDataStore({
                    include: ['$descriptors'],
                    select: ['Alarm', 'AlarmTime', 'Activity/StartDate'],
                    resourceKind: 'userActivities',
                    service: this._activityService
                });
            }
            if (!this._historyStore) {
                //used when completing unscheduled activities
                // and new history items created by mail merge or other processes
                this._historyStore = new SingleEntrySDataStore({
                    include: ['$descriptors'],
                    resourceKind: 'history',
                    service: sDataServiceRegistry.getSDataService('dynamic')
                });
            }
        },
        _resetDataProps: function () {
            this._activityData = false;
            this._currentUserActivityData = false;
            this._tempUAData = false;
            this._notificationData = false;
            this._attendeesData = [];
            this._attendeesForRemoval = [];
            this._newAttendeesData = [];
            this._userActivitiesRequestCount = 0;
            this._resourceRequestCount = 0;
            this._resourceDeleteRequestCount = 0;
            this._activitySaved = false;
            this._userActivitiesSaved = false;
            this._currentUserActivitySaved = false;
            this._resourcesSaved = false;
            this._resourcesRemoved = false;
            this._attachmentsSaved = false;
            this._originalLeaderId = false;
            if (this._attachmentList) {
                this._attachmentList.clearNewAttachments();
            }
            this._availabilityDataDateRange = {
                fromDate: false,
                toDate: false,
                users: []
            };
        },
        _loadData: function () {
            if (this._dialog._standby) {
                this._dialog.showLoading();
            }
            this._resetDataProps();
            if (this._activityStore) {
                if (this.mode === 'New') {
                    this._activityStore.newItem({
                        onComplete: function (act) {
                            Sage.Utility.setValue(act, 'Type', this.activityType);
                            this._receivedActivity(act);
                        },
                        onError: this._requestFailure,
                        scope: this
                    });
                } else {
                    this._activityStore.fetch({
                        predicate: '"' + this.activityId + '"',
                        onComplete: this._receivedActivity,
                        onError: this._requestFailure,
                        scope: this
                    });
                }
            }
        },
        _receivedActivity: function (activity) {
            this._activityData = activity;
            if ((this._currentUserActivityStore) && (this.mode !== 'New') && (this.mode != 'CompleteUnscheduled')) {
                //if it is a single occurrence of a recurring activity, the id will have a date code appended with semicolon.
                var id = this.activityId || activity.$key;
                id = (id.indexOf(';') > 0) ? id.substring(0, 12) : id;
                var membId = this.activityMemberId || this._currentUserId;
                this._currentUserActivityStore.fetch({
                    predicate: dString.substitute("'ActivityId=${0};UserId=${1}'", [id, membId]),
                    onComplete: this._receivedUserActivity,
                    onError: this._noUserActivity,
                    scope: this
                });
            }

            if (activity.AttachmentCount > 0) {
                this._activityData.Attachment = true;
            }
            this._tempIdForAttachments = false;
            var contextSvc = Sage.Services.getService('ClientEntityContext');
            var context = (this.historyId) ? {
                "EntityId": this.historyId,
                "EntityType": "Sage.Entity.Interfaces.IHistory",
                "Description": this._activityData.$descriptor,
                "EntityTableName": "HISTORY"
            } : {
                "EntityId": this.activityId,
                "EntityType": "Sage.Entity.Interfaces.IActivity",
                "Description": this._activityData.$descriptor,
                "EntityTableName": "ACTIVITY"
            };
            contextSvc.setTemporaryContext(context);

            if (this.mode !== 'New' && this.mode != 'CompleteUnscheduled') {
                this.activityType = activity.Type;
            } else {
                this._applyUserOptionsForNewActivity();
            }

            if (this.activityMemberId && this.activityMemberId !== this._currentUserId && !this._memberSecurityData[this.activityMemberId]) {
                this._checkSecurityAccess(this._currentUserId, this.activityMemberId, function (accessData) {
                    if (accessData) {
                        this._memberSecurityData[this.activityMemberId] = [];
                        this._memberSecurityData[this.activityMemberId].AllowAdd = accessData.AllowAdd;
                        this._memberSecurityData[this.activityMemberId].AllowEdit = accessData.AllowEdit;
                        this._memberSecurityData[this.activityMemberId].AllowDelete = accessData.AllowDelete;
                    }
                    this._setUIForActivityType(activity.Type);
                    this._bind();
                }, this);
            } else {
                this._setUIForActivityType(activity.Type);
                this._bind();
            }

            //save the original leader's id for later...
            if (this._activityData['Leader']) {
                this._originalLeaderId = this._activityData.Leader['$key'];
            } else {
                this._originalLeaderId = this._activityData['UserId'] || this._currentUserId;
            }
            if (this._dialog._standby) {
                this._dialog.hideLoading();
            }
            //MAA update
            this.attendeesTab._activityId = activity.$key;
            if (activity.details) {
                this._activityData.AttendeeCount = activity.details.AttendeeCount;
            }
            if (this.mode == 'Confirm') {
                this.attendeesTab._grid.refresh();
            }
        },
        _receivedUserActivity: function (userActivity) {
            if (this._dialog._standby) {
                this._dialog.hideLoading();
            }
            this._currentUserActivityData = userActivity;

            // if the activity is created in the LAN client, the ALARM and ALARMTIME values are null
            // apparently the LAN client handles this, so we have to too.
            if (userActivity.Alarm === null) {
                userActivity.Alarm = this._activityData.Alarm;
            }
            if (userActivity.AlarmTime === null) {
                userActivity.AlarmTime = this._activityData.AlarmTime;
            }
            this._tempUAData = {
                Alarm: userActivity.Alarm,
                AlarmTime: utility.Convert.toDateFromString(userActivity.AlarmTime)
            };
            this._bindUserActivity();
        },
        _loadNotification: function () {
            if (this._dialog._standby) {
                this._dialog.showLoading();
            }
            this._resetDataProps();
            if (!this._notificationStore) {
                this._notificationStore = new SingleEntrySDataStore({
                    include: ['Activity', '$descriptors'],
                    resourceKind: 'userNotifications',
                    service: sDataServiceRegistry.getSDataService('system')
                });
            }
            this._notificationStore.fetch({
                predicate: "'" + this.userNotificationId + "'",
                onComplete: this._receivedNotification,
                onError: this._requestFailure,
                scope: this
            });
        },
        _loadHistory: function () {
            if (this._dialog._standby) {
                this._dialog.showLoading();
            }
            this._resetDataProps();
            if (this._historyStore) {
                if (!this.historyId) {
                    this._historyStore.newItem({
                        onComplete: function (hist) {
                            this._receivedActivity(dojoLang.mixin(hist, this.activityDefaultValues));
                            this._formatHeader();
                        },
                        scope: this
                    });
                } else {
                    this._historyStore.fetch({
                        predicate: this.historyId,
                        onComplete: function (hist) {
                            this._receivedActivity(hist);
                            this._formatHeader();
                        },
                        onError: this._requestFailure,
                        scope: this
                    });
                }
            }
        },
        _receivedNotification: function (notification) {
            this._receivedActivity(notification.Activity || this._emptyActivity);
            this._notificationData = notification;
            this._formatHeader();
            this._bindUserNotification();
            if (notification.Type === 'New') {
                this._setUIAsUnConfirmed();
            } else {
                domClass.remove(this.otherConfButtons, 'display-none');
                domClass.add(this.newConfButtons, 'display-none');
                if (notification.Type === 'Confirm' || notification.Type === 'Decline') {
                    this.ta_confirmationResponse.set('disabled', true);
                    domClass.remove(this.responseLabel, 'display-none');
                    domClass.remove(this.ta_confirmationResponse.domNode, 'display-none');
                } else {
                    domClass.add(this.responseLabel, 'display-none');
                    domClass.add(this.ta_confirmationResponse.domNode, 'display-none');
                }
                if (notification.Type === 'Change') {
                    this._checkUserConfirmationStatus();
                }
            }
        },
        _checkUserConfirmationStatus: function () {
            var req = new Sage.SData.Client.SDataSingleResourceRequest(Sage.Data.SDataServiceRegistry.getSDataService('system'))
                .setResourceKind('userActivities')
                .setResourceSelector('"' + this._notificationData.Activity['$key'] + ';' + this._notificationData.ToUser['$key'] + '"');
            req.read({
                success: function (ua) {
                    if (ua.Status === 'asUnconfirmed') {
                        this._setUIAsUnConfirmed();
                    }
                },
                failure: function () {
                },
                scope: this
            });
        },
        _setUIAsUnConfirmed: function () {
            domClass.add(this.otherConfButtons, 'display-none');
            domClass.remove(this.newConfButtons, 'display-none');
            this.ta_confirmationResponse.set('disabled', false);
            domClass.remove(this.responseLabel, 'display-none');
            domClass.remove(this.ta_confirmationResponse.domNode, 'display-none');
        },
        _applyUserOptionsForNewActivity: function () {
            //set start and alarm time to user options.
            var newDate = activityUtility.roundDateToNextQuarterHour(new Date());
            //utility.setValue(this._activityData, 'StartDate', utility.Convert.toIsoStringFromDate(newDate));
            //set default values based on user options...
            var alarmdur = '15';
            if (this._options[this.activityType]) {
                var optset = this._options[this.activityType];
                utility.setValue(this._activityData, 'Duration', optset['duration'] || '60');
                alarmdur = optset['alarmLead'];
                utility.setValue(this._activityData, 'Rollover', optset['autoRollover']);
                utility.setValue(this._activityData, 'Timeless', optset['timeless']);

                if (this._activityData.Timeless) {
                    //Create Timeless Date.
                    newDate = new Date(newDate.getFullYear(), newDate.getMonth(), newDate.getDate(), 0, 0, 5);
                }
            }
            utility.setValue(this._activityData, 'StartDate', utility.Convert.toIsoStringFromDate(newDate));

            //override with preConfigured properties (from calendar, sales process, etc.)
            this._activityData = dojoLang.mixin(this._activityData, this.activityDefaultValues);

            //calculate alarm time based on current startdate
            if (alarmdur.toLowerCase() === 'none') {
                utility.setValue(this._activityData, 'Alarm', false);
                alarmdur = 15;
            } else {
                Sage.Utility.setValue(this._activityData, 'Alarm', true);
                alarmdur = parseInt(alarmdur, 10);
            }

            //get the date from the activity again, since it might have been overridden by default values...
            var d = utility.Convert.toDateFromString(utility.getValue(this._activityData, 'StartDate'));
            var alarmTime = this._getAlarmTime(d, alarmdur, this._activityData.Timeless);
            utility.setValue(this._activityData, 'AlarmTime', utility.Convert.toIsoStringFromDate(alarmTime));
            this.sel_AlarmDur.set('startTime', d);
            this.sel_AlarmDur.set('timeValue', alarmTime);
            var ldr = {
                '$key': this._currentUserId,
                '$descriptor': utility.getClientContextByKey('userPrettyName')
            };
            utility.setValue(this._activityData, 'Leader', ldr);

            if (this.activityDefaultValues.hasOwnProperty('carryOverAttachmentsFrom')) {
                window.setTimeout(dojo.hitch(this, function () {
                    this.doCarryOverAttachments(this.activityDefaultValues['carryOverAttachmentsFrom']);
                }, 1000));
            }

            if (this.activityDefaultValues.hasOwnProperty('carryOverParticipantsFrom')) {
                window.setTimeout(dojo.hitch(this, function () {
                    this._getHistoryAttendees(this.activityDefaultValues['carryOverParticipantsFrom']);
                }, 1000));
            }
        },
        _noUserActivity: function () {
            this._bindUserActivity();
        },
        _requestFailure: function (request) {
            if (this._dialog._standby) {
                this._dialog.hideLoading();
            }
            sageDialogs.showError(this.failedLoadingDataMsg);
            this.hide();
        },
        _createBindings: function () {
            if (this._bindingMgr) {
                this._bindingMgr.destroy();
                this._bindingMgr = false;
            }
            this._bindingMgr = new BindingsManager({
                defaultBinding: {
                    boundEntity: this._activityData
                },
                items: [
                    {
                        boundWidget: this.tb_Location,
                        entityProperty: 'Location'
                    }, {
                        boundWidget: this.pk_Regarding,
                        entityProperty: 'Description',
                        onChange: dojo.hitch(this, '_descriptionChanged')
                    }, {
                        boundWidget: this.pk_Category,
                        entityProperty: 'Category'
                    }, {
                        boundWidget: this.pk_Priority,
                        entityProperty: 'Priority'
                    }, {
                        boundWidget: this.ta_Notes,
                        entityProperty: 'LongNotes',
                        onChange: dojo.hitch(this, '_notesChanged')
                    }, {
                        boundWidget: this.dtp_startDate,
                        dataType: 'date',
                        entityProperty: 'StartDate',
                        onChange: dojo.hitch(this, '_startDateChanged')
                    }, {
                        boundWidget: this.sel_Duration,
                        entityProperty: 'Duration'
                    }, {
                        boundWidget: this.sel_Duration,
                        entityProperty: 'StartDate',
                        widgetProperty: 'startTime',
                        dataType: 'date',
                        twoWay: false
                    }, {
                        boundWidget: this.sel_AlarmDur,
                        entityProperty: 'StartDate',
                        widgetProperty: 'startTime',
                        dataType: 'date',
                        twoWay: false
                    }, {
                        boundWidget: this.cb_Timeless,
                        entityProperty: 'Timeless',
                        widgetProperty: 'checked',
                        onChange: dojo.hitch(this, '_timelessChange')
                    }, {
                        boundWidget: this.cb_AutoRollover,
                        entityProperty: 'Rollover',
                        widgetProperty: 'checked'
                    }, {
                        boundWidget: this.dtp_scheduledDate,
                        dataType: 'date',
                        entityProperty: 'StartDate'
                    }, {
                        boundWidget: this.sel_DurationComplete,
                        entityProperty: 'Duration'
                    }, {
                        boundWidget: this.sel_DurationComplete,
                        entityProperty: 'StartDate',
                        widgetProperty: 'startTime',
                        dataType: 'date',
                        twoWay: false
                    }, {
                        boundWidget: this.cb_TimelessComplete,
                        entityProperty: 'Timeless',
                        widgetProperty: 'checked',
                        onChange: dojo.hitch(this, '_timelessChange')
                    }
                ]
            });
        },
        _createUABindings: function () {
            //if it is new or the current user is not a member, bind the alarm and alarm duration fields to the activity record - otherwise, bind them
            // to the user-activity...
            this._uaBindingMgr = new BindingsManager({
                items: [
                    {
                        boundWidget: this.cb_Alarm,
                        entityProperty: 'Alarm',
                        widgetProperty: 'checked',
                        onChange: dojo.hitch(this, '_alarmCheckChanged')
                    }
                ]
            });
        },
        _createNotificationBindings: function () {
            this._notificationBindingMgr = new BindingsManager({
                items: [
                    {
                        boundWidget: this.ta_confirmationResponse,
                        entityProperty: 'Notes',
                        boundEntity: this._notificationData
                    }
                ]
            });
        },
        _bind: function () {
            if (this._activityData) {
                if (!this._bindingMgr) {
                    this._createBindings();
                } else {
                    if (!this._bindingMgr.boundEntity || (this._activityData['$key'] !== this._bindingMgr.boundEntity['$key'])) {
                        this._bindingMgr.setBoundEntity(this._activityData);
                    } else {
                        this._bindingMgr.bind();
                    }
                }
                if (this.mode === 'New' || this.mode === 'CompleteUnscheduled') {
                    this._noUserActivity();
                }
                this._manualBind();
                this._setUI();
            }
        },
        _bindUserNotification: function () {
            if (!this._notificationBindingMgr) {
                this._createNotificationBindings();
            } else {
                this._notificationBindingMgr.setBoundEntity(this._notificationData);
            }
        },
        _isNullOrWhitespace: function (str) {
            return (!str || str.trim() === '');
        },
        _manualBind: function () {
            //because there are not relationships to several related entities, we have to manually bind to keep the denormalized data in sync...
            if (this._activityData) {
                var act, mockContact, mockLead;
                this._isBinding = true; //this prevents the change event handlers from overwriting values that we are going to set here...
                //for example, the account change handler removes the contact, opp, and ticket values.
                // account...
                act = this._activityData;
                var mockAcctObj = this._isNullOrWhitespace(act.AccountId) ? null : {
                    '$key': act.AccountId,
                    '$descriptor': act.AccountName
                };
                this.lup_Account.set('selectedObject', mockAcctObj);
                // contact...
                mockContact = this._isNullOrWhitespace(act.ContactId) ? null : {
                    '$key': act.ContactId,
                    '$descriptor': act.ContactName
                };
                this.lup_Contact.set('selectedObject', mockContact);

                // opportunity...
                var mockOpp = this._isNullOrWhitespace(act.OpportunityId) ? null : {
                    '$key': act.OpportutunityId,
                    '$descriptor': act.OpportunityName
                };
                this.lup_Opportunity.set('selectedObject', mockOpp);

                // ticket...
                var mockTick = this._isNullOrWhitespace(act.TicketId) ? null : {
                    '$key': act.TicketId,
                    '$descriptor': act.TicketNumber
                };
                this.lup_Ticket.set('selectedObject', mockTick);

                // lead...
                mockLead = this._isNullOrWhitespace(act.LeadId) ? null : {
                    '$key': act.LeadId,
                    '$descriptor': act.LeadName
                };

                this.lup_Lead.set('selectedObject', mockLead);
                this.tb_LeadCompanyName.set('value', this._isNullOrWhitespace(act.LeadId) ? '' : act.AccountName);
                this._updateLookupSeedValues(act.AccountId);

                // Leader...
                this.lup_Leader.set('selectedObject', act.Leader);

                //recurring tab...
                if (this.mode !== 'Complete') { //Recurring editor can cause reoccunce to change even though editoer is hidden.
                    this._recurringEditor.set('activity', act);
                }
                var alarmTime = Sage.Utility.Convert.toDateFromString(this._activityData.AlarmTime);
                this.sel_AlarmDur.set('timeValue', alarmTime);
                this._completeModeManualBind();
                this._isBinding = false;

                //MAA update
                if (this.mode == 'New' || this.mode === 'CompleteUnscheduled') {
                    if (this._activityData) {
                        act = this._activityData;

                        // contact...
                        mockContact = this._isNullOrWhitespace(act.ContactId) ? null : {
                            '$key': act.ContactId,
                            '$descriptor': act.ContactName
                        };
                        this.attendeesTab._addContactAttendee(mockContact);

                        // lead...
                        mockLead = this._isNullOrWhitespace(act.LeadId) ? null : {
                            '$key': act.LeadId,
                            '$descriptor': act.LeadName
                        };
                        this.attendeesTab._addLeadAttendee(mockLead);
                    }
                }
            }
        },
        _completeModeManualBind: function () {
            if (this.mode === 'Complete' || this.mode === 'CompleteUnscheduled') {
                this.dtp_completedDate.set('value', new Date());
                this.pl_Result.set('value', this.completeText);
                if (this.mode === 'Complete') {
                    this.pl_Result.focus();
                }
            }
        },
        _bindUserActivity: function () {
            if (!this._uaBindingMgr) {
                this._createUABindings();
            }
            //before we bind, just make sure the start date is correct because it re-calculates the duration again only
            // when setting the time value...  Depending on how fast things load, sometimes the start date isn't right yet.
            //var disabled = this.sel_AlarmDur.get('disabled');
            this.sel_AlarmDur.set('disabled', false);
            var instanceStartDate = this._getActivityStartDate();
            this.sel_AlarmDur.set('startTime', instanceStartDate);

            var ent = (this._currentUserActivityData) ? this._currentUserActivityData : this._activityData;
            var alarmTime = utility.Convert.toDateFromString(ent.AlarmTime);
            if (this._currentUserActivityData && utility.getValue(this._activityData, 'RecurrenceState') === 'rstOccurrence') {
                //adjust the useractivity alarm time to match this occurrence...
                var baseStartDate = utility.Convert.toDateFromString(this._currentUserActivityData.Activity.StartDate);
                var baseAlarmDate = utility.Convert.toDateFromString(this._currentUserActivityData.AlarmTime);
                var dur = dojoDate.difference(baseStartDate, baseAlarmDate, 'minute');
                alarmTime = dojoDate.add(instanceStartDate, 'minute', dur);
            }
            this._uaBindingMgr.setBoundEntity(ent);

            this.sel_AlarmDur.set('timeValue', alarmTime);
            this.sel_AlarmDur.set('disabled', !ent.Alarm || this.mode === 'Confirm');
        },
        _getActivityStartDate: function () {
            if (this._activityData) {
                var sDate = Sage.Utility.Convert.toDateFromString(this._activityData.StartDate);
                if ((this._activityData.Timeless) && (activityUtility.isDateFiveSecondRuleTimeless(sDate))) {
                    return new Date(sDate.getUTCFullYear(), sDate.getUTCMonth(), sDate.getUTCDate(), 0, 0, 5);
                }
                return sDate;
            }
            return new Date();
        },
        _onShowAvailabilityTab: function () {
            if (!this._availabilityShowing) {
                this._resetAttendeesList();
                this._loadAttendeesData();
            } else {
                scheduler.setCurrentView(this._getActivityStartDate(), 'timeline');
            }
        },
        _accountChanged: function (newAcct) {
            if (this._isBinding) {
                return;
            }

            var newId = (newAcct) ? newAcct['$key'] : '';
            var newActName = (newAcct) ? newAcct['$descriptor'] : '';
            var act = this._activityData;
            var mustSetContact = this._isNullOrWhitespace(act.ContactId);

            act.AccountId = newId;
            act.AccountName = newActName;
            act.PhoneNumber = '';
            act.LeadId = null;
            act.LeadName = '';

            this._isBinding = true;
            this.lup_Lead.set('selectedObject', null);
            this.tb_LeadCompanyName.set('value', '');
            this._updateLookupSeedValues(newId);
            this.lup_Lead.set('selectedObject', null);
            this.tb_LeadCompanyName.set('value', '');
            if (mustSetContact) {
                act.ContactId = '';
                act.ContactName = '';
                this.lup_Contact.set('selectedObject', null);
                this._setContactToCurrentAccountPrimary();
            }
            this._isBinding = false;
        },
        _contactChanged: function (newContact) {
            if (!this._isBinding) {
                var act = this._activityData;
                if (!newContact) {
                    act.ContactId = null;
                    act.ContactName = '';
                    act.PhoneNumber = '';
                    return;
                }
                act.ContactId = newContact['$key'];
                act.ContactName = newContact['$descriptor'];
                act.PhoneNumber = Sage.Utility.getValue(newContact, 'WorkPhone');

                //remove lead
                act.LeadId = null;
                act.LeadName = '';

                var actAccountEmpty = this._isNullOrWhitespace(act.AccountName);

                //set associated account
                act.AccountId = newContact.Account['$key'];
                act.AccountName = newContact.Account.AccountName;
                //account changed, so update seed values...
                this._updateLookupSeedValues(newContact.Account['$key']);

                this._isBinding = true;
                if (actAccountEmpty) {
                    this.lup_Account.set('selectedObject', {
                        '$key': newContact.Account['$key'], '$descriptor': newContact.Account.AccountName
                    });
                }
                this.lup_Lead.set('selectedObject', null);
                this.tb_LeadCompanyName.set('value', '');
                this._isBinding = false;
            }

            //MAA Update
            if (newContact && newContact['$key'] && !newContact['attendeeTab']) {
                if (this.attendeesTab._grid.mode != "insert" && this._isBinding) {
                    //If the grid is not rendered, it may insert duplicate items, so just set the item and add it when the tab shows
                    if (!this.attendeesTab._gridStarted) {
                        this.attendeesTab.setInitialPrimaryContact(newContact);
                    } else if (!this.attendeesTab._attendeeExists(newContact['$key'])) {
                        //If the contact is not already added, add it to the grid
                        this.attendeesTab._addContactAttendee(newContact);
                    }
                } else {
                    this.attendeesTab._addContactAttendee(newContact);
                }
            }
        },
        _opportunityChanged: function (newOpp) {
            if (this._isBinding) {
                return;
            }
            /*
            The logic for when the opportunity changes is like this...
            - If there is already a contact and account selected, and the opportunity is associated to the same account - do nothing
            - If there is no contact or account selected for the activity - or the account is different do the following:
            - Set the account to the associated account and:
            - If ONE associated contact is marked IsPrimary = true set the contact to it.
            - if more than one associated contact is marked primary, or none are marked primary,
            -if one of these is primary for the account and use it
            -if not, just grab the first one.
            -if there are no contacts associate with the opportunity, use the account's primary contact.
            */

            var act = this._activityData;
            if (!newOpp) {
                act.OpportunityId = null;
                act.OpportunityName = '';
                return;
            }
            act.OpportunityId = newOpp['$key'];
            act.OpportunityName = newOpp['$descriptor'];

            if (this._isNullOrWhitespace(act.AccountId) || act.AccountId !== newOpp.Account['$key']) {
                //set the associated account...
                var actAccountEmpty = this._isNullOrWhitespace(act.AccountName);
                var actContactEmpty = this._isNullOrWhitespace(act.ContactName);
                act.AccountId = newOpp.Account['$key'];
                act.AccountName = newOpp.Account.AccountName;
                act.LeadId = null;
                act.LeadName = '';

                this._updateLookupSeedValues(newOpp.Account['$key']);
                this._isBinding = true;
                if (actAccountEmpty) {
                    this.lup_Account.set('selectedObject', {
                        '$key': newOpp.Account['$key'], '$descriptor': newOpp.Account.AccountName
                    });
                }
                this.lup_Lead.set('selectedObject', null);
                this.tb_LeadCompanyName.set('value', '');
                this._isBinding = false;
                if (actContactEmpty) {
                    //remove contact for now, then when we find the primary, we'll set it again.
                    this.lup_Contact.set('selectedObject', null);
                    this._setContactBasedOnOpportunity();
                }
            }
        },
        _ticketChanged: function (newTick) {
            if (this._isBinding) {
                return;
            }
            var act = this._activityData;
            if (!newTick) {
                act.TicketId = null;
                act.TicketNumber = '';
                return;
            }

            act.TicketId = newTick['$key'];
            act.TicketNumber = newTick['$descriptor'];
            //update account and contact, if there isn't an account - or if the account is different from the ticket's account
            if (this._isNullOrWhitespace(act.AccountId) || act.AccountId !== newTick.Account['$key']) {
                var actAccountEmpty = this._isNullOrWhitespace(act.AccountName);
                var actContactEmpty = this._isNullOrWhitespace(act.ContactName);
                act.AccountId = newTick.Account['$key'];
                act.AccountName = newTick.Account['AccountName'];
                act.LeadId = null;
                act.LeadName = '';
                this._updateLookupSeedValues();

                //Do we set it to the contact associated with the ticket - or the primary?
                // I'm going with the one on the ticket, but previous versions used the primary...
                act.ContactId = Sage.Utility.getValue(newTick, 'Contact.$key');
                act.ContactName = Sage.Utility.getValue(newTick, 'Contact.NameLF');
                act.PhoneNumber = Sage.Utility.getValue(newTick, 'Contact.WorkPhone');

                this._isBinding = true;
                if (actAccountEmpty) {
                    this.lup_Account.set('selectedObject', {
                        '$key': newTick.Account['$key'], '$descriptor': newTick.Account['AccountName']
                    });
                }
                if (actContactEmpty) {
                    this.lup_Contact.set('selectedObject', {
                        '$key': newTick.Contact['$key'], '$descriptor': newTick.Contact['NameLF']
                    });
                }
                this.lup_Lead.set('selectedObject', null);
                this.tb_LeadCompanyName.set('value', '');
                this._isBinding = false;
            }
        },
        _leadChanged: function (newLead) {
            if (this._isBinding) {
                return;
            }
            var act = this._activityData;
            if (!newLead) {
                act.LeadId = null;
                act.LeadName = '';
                act.PhoneNumber = '';
                this.tb_LeadCompanyName.set('value', '');
                return;
            }
            //clear out the TACO and make way for Lead.
            act.ContactId = null;
            act.ContactName = '';
            act.AccountId = null;
            act.TicketId = null;
            act.TicketNumber = '';
            act.OpportunityId = null;
            act.OpportunityName = '';
            this._updateLookupSeedValues();
            this._isBinding = true;
            this.lup_Contact.set('selectedObject', null);
            this.lup_Account.set('selectedObject', null);
            this.lup_Opportunity.set('selectedObject', null);
            this.lup_Ticket.set('selectedObject', null);
            this._isBinding = false;
            // now set the lead info...
            act.LeadId = newLead['$key'];
            act.LeadName = newLead['LeadFullName'];
            act.AccountName = newLead['Company'];
            act.PhoneNumber = newLead['WorkPhone'];
            this.tb_LeadCompanyName.set('value', newLead['Company']);

            //MAA update
            if (this._isBinding) {
                return;
            }
            if (newLead && newLead['$key'] && !newLead['attendeeTab']) {
                this.attendeesTab._addLeadAttendee(newLead);
            }
        },
        _leaderChanged: function (newLeader) {
            if (this._isBinding) {
                return;
            }
            var oldLeaderId = this._activityData.Leader['$key'] || this._activityData['UserId'];
            if (newLeader) {
                var key = newLeader['$key'].substr(0, 12);
                this._activityData.Leader = {
                    '$key': key,
                    '$descriptor': newLeader['$descriptor'] || newLeader['Name']
                };
                this._activityData.LeaderChanged = true;
            }
            this._updateUsersListWithNewLeader(oldLeaderId, this._activityData.Leader);
        },
        _setContactBasedOnOpportunity: function () {
            if (this._isNullOrWhitespace(this._activityData.OpportunityId)) {
                this._rebindToCurrentContact();
                return;
            }
            var req = new Sage.SData.Client.SDataResourceCollectionRequest(Sage.Data.SDataServiceRegistry.getSDataService('dynamic'));
            req.setResourceKind('opportunities');
            var pathIdx = req.uri.pathSegments.length - 1;
            var resourceSegment = req.uri.getPathSegment(pathIdx);
            resourceSegment['predicate'] = '"' + this._activityData.OpportunityId + '"';
            req.uri.setPathSegment(pathIdx + 1, 'Contacts');
            req.setQueryArg('select', 'IsPrimary,Contact/NameLF,Contact/IsPrimary,Contact/WorkPhone');
            req.setQueryArg('orderby', 'IsPrimary desc');
            req.read({
                success: function (data) {
                    var oppCons = data['$resources'];
                    if (oppCons.length < 1) {
                        this._setContactToCurrentAccountPrimary();
                        return;
                    }
                    var oppPri = false, accPri = false, firstCon = oppCons[0], newActCon;
                    for (var i = 0; i < oppCons.length; i++) {
                        if (oppCons[i]) {
                            if (oppCons.IsPrimary) {
                                if (!oppPri || oppCons[i].Contact.IsPrimary) {
                                    oppPri = oppCons[i];
                                }
                            }
                            if (!accPri && oppCons[i].Contact.IsPrimary) {
                                accPri = oppCons[i];
                            }
                        }
                    }
                    newActCon = oppPri || accPri || firstCon;
                    if (newActCon) {
                        this._activityData.ContactId = Sage.Utility.getValue(newActCon, 'Contact.$key');
                        this._activityData.ContactName = Sage.Utility.getValue(newActCon, 'Contact.NameLF');
                        this._activityData.PhoneNumber = Sage.Utility.getValue(newActCon, 'Contact.WorkPhone');
                        this._rebindToCurrentContact();
                    }
                },
                failure: function () {
                    this._rebindToCurrentContact();
                },
                scope: this
            });
        },
        _setContactToCurrentAccountPrimary: function () {
            if (this._isNullOrWhitespace(this._activityData.AccountId)) {
                this._rebindToCurrentContact();
                return;
            }
            //look up the primary contact...
            var req = new Sage.SData.Client.SDataResourceCollectionRequest(Sage.Data.SDataServiceRegistry.getSDataService('dynamic'));
            req.setResourceKind('accounts');
            var pathIdx = req.uri.pathSegments.length - 1;
            var resourceSegment = req.uri.getPathSegment(pathIdx);
            resourceSegment['predicate'] = '"' + this._activityData.AccountId + '"';
            req.uri.setPathSegment(pathIdx + 1, 'Contacts');
            req.setQueryArg('select', 'NameLF,IsPrimary,WorkPhone');
            req.setQueryArg('orderby', 'IsPrimary desc'); //rather than selecting "where IsPrimary", do it this way so we at least get something - if there is one that is primary, it will come back, otherwise, we'll just get one.
            req.setQueryArg('count', '1'); //only need one...
            req.read({
                success: function (data) {
                    var contacts = data['$resources'];
                    if (contacts.length < 1) {
                        //fall back to the one that was there...
                        this._rebindToCurrentContact();
                        return;
                    }
                    var primaryContact = contacts[0];
                    this._activityData.ContactId = Sage.Utility.getValue(primaryContact, '$key');
                    this._activityData.ContactName = Sage.Utility.getValue(primaryContact, 'NameLF');
                    this._activityData.PhoneNumber = Sage.Utility.getValue(primaryContact, 'WorkPhone');
                    this._isBinding = true;
                    this.lup_Contact.set('selectedObject', primaryContact);
                    this._isBinding = false;
                },
                failure: function () {
                    this._rebindToCurrentContact();
                },
                scope: this
            });
        },
        _rebindToCurrentContact: function () {
            this._isBinding = true;
            this.lup_Contact.set('selectedObject', {
                '$key': this._activityData.ContactId, '$descriptor': this._activityData.ContactName
            });
            this._isBinding = false;
        },
        _updateLookupSeedValues: function (newSeed) {
            var accId = newSeed || this._activityData.AccountId;
            this.contactLookupConfig.seedValue = accId;
            this.opportunityLookupConfig.seedValue = accId;
            this.ticketLookupConfig.seedValue = accId;
        },
        // ... endregion - data methods

        // ... region UI interactions   ...
        _setUI: function () {
            this._formatHeader();
            this._setDisabledByTimlessValue();
            this._setHasAlarmUI();
            if (this._isNullOrWhitespace(this._activityData.LeadId)) {
                this.rdo_Contact.set('checked', true);
            } else {
                this.rdo_Lead.set('checked', true);
            }
            this._setContactLeadVisibility();
            this._setScheduledByLabel();
        },
        _checkSecurityAccess: function (accessFor, accessTo, callback, scope) {
            this.accessData = false;
            if (!this._accessStore) {
                this._accessStore = new SingleEntrySDataStore({
                    include: ['$descriptors'],
                    resourceKind: 'activityresourceviews',
                    service: sDataServiceRegistry.getSDataService('dynamic')
                });
            }
            this._accessStore.fetch({
                predicate: "'" + accessTo + "-" + accessFor + "'",
                onComplete: function (accessData) {
                    callback.call(scope, accessData);
                },
                onError: function () {
                    callback.call(scope, null);
                },
                scope: this
            });
        },
        _setUIForActivityType: function (actType) {
            this.pk_Regarding.set('pickListName', activityUtility.getActivityPicklistName('Regarding', actType));
            this.pk_Category.set('pickListName', activityUtility.getActivityPicklistName('Category', actType));
            this.pl_Result.set('pickListName', activityUtility.getActivityPicklistName('Result', actType));

            //Applying AllowComplete Option.
            this.btn_Complete.set('disabled', !this._activityData.AllowComplete);

            //If the user doesn't have access to edit the Leader's calendar, we need to disable a bunch of stuff...
            //this.btn_OK.set('disabled', false);  //enable it in case it was disabled the last time around...
            if (this.mode !== 'Confirm') {
                var editAllowed = this._activityData.AllowEdit;
                var deleteAllowed = this._activityData.AllowDelete;

                //Users can edit only alarm time if its not the leader's instance
                if (this.activityMemberId && this.activityMemberId !== this._activityData.Leader.$key) {
                    editAllowed = false;
                    deleteAllowed = false;
                }
                this._bulkSetProperty(this, this.noEditDisableList, 'disabled', (!editAllowed));

                //Textarea Disabled doesn't allow scrolling in IE, so make it read only
                this.ta_Notes.set('readonly', !editAllowed);

                //To allow members to update their alarmtime even if they don't have edit access to leader's calendar
                if ((this.activityMemberId && this._memberSecurityData[this.activityMemberId] && this._memberSecurityData[this.activityMemberId].AllowEdit) || this.activityMemberId === this._currentUserId || this._activityData['UserId'] === this._currentUserId) {
                    this.btn_OK.set('disabled', false);
                } else {
                    this.btn_OK.set('disabled', !this._activityData.AllowEdit);
                }
                this.btn_Delete.set('disabled', !deleteAllowed);
            }

            if (this.mode === 'Complete') {
                this.btn_asScheduled.set('disabled', !this._activityData.AllowComplete);
                this.btn_Now.set('disabled', !this._activityData.AllowComplete);
            }

            // disable the category picklist for personal activities...
            this.pk_Category.set('disabled', (actType === 'atPersonal') || (this.mode === 'Confirm') || this.pk_Category.get('disabled'));
            // hide the add (lookup) resources/users button for to-do and personal activities
            if ((!this._canEdit()) || (actType === 'atPersonal' || actType === 'atToDo')) {
                domClass.add(this.lup_Resources.domNode, 'display-none');
            } else {
                domClass.remove(this.lup_Resources.domNode, 'display-none');
            }
        },
        _setDisabledByTimlessValue: function () {
            if (!this._activityData) {
                return;
            }
            var tless = this._activityData['Timeless'];
            this._handleAutoRolloverState();
            this.dtp_startDate.set('displayTime', !tless);
            var editAllowed = this._activityData.AllowEdit;
            if (this.activityMemberId && this.activityMemberId !== this._activityData.Leader.$key) {
                editAllowed = false;
            }
            this.sel_Duration.set('disabled', tless || (this.mode === 'Confirm') || !editAllowed);
            this.sel_DurationComplete.set('disabled', tless);
            this.dtp_scheduledDate.set('displayTime', !tless);
        },
        _handleAutoRolloverState: function () {
            var enabled = (this._activityData['Timeless'] && !this._activityData['Recurring']);
            if (enabled) {
                this.cb_AutoRollover.set('disabled', false);
            } else {
                this.cb_AutoRollover.set('disabled', true);
                this.cb_AutoRollover.set('checked', false);
            }
        },
        _bulkSetProperty: function (ui, propsList, prop, val) {
            for (var i = 0; i < propsList.length; i++) {
                var ctrl = ui[propsList[i]];
                if (ctrl) {
                    ctrl.set(prop, val);
                }
            }
        },
        _timelessChange: function () {
            this._setDisabledByTimlessValue();
            if (this.mode === 'Complete' || this.mode === 'CompleteUnscheduled') {
                if (this.cb_TimelessComplete.get('checked')) {
                    var schedDate = this.dtp_scheduledDate.get('value');
                    schedDate.setHours(0);
                    schedDate.setMinutes(0);
                    schedDate.setSeconds(5);
                    this.dtp_scheduledDate.set('value', schedDate);
                }
            } else {
                var leadTime;
                var alarmTime;
                var d = this.dtp_startDate.get('value');
                utility.setValue(this._activityData, 'TimelessChanged', true);
                if (this.cb_Timeless.get('checked')) {
                    d.setHours(0);
                    d.setMinutes(0);
                    d.setSeconds(5);
                    this.dtp_startDate.set('value', d);
                    leadTime = this._getAlarmLeadTime();
                    alarmTime = this._getAlarmTime(d, leadTime, true);
                    this.sel_AlarmDur.set('startTime', d);
                    this.sel_AlarmDur.set('timeValue', alarmTime);
                } else {
                    var nowDate = activityUtility.roundDateToNextQuarterHour(new Date());
                    var min = nowDate.getMinutes();
                    var hour = nowDate.getHours();
                    var newDate = new Date(d.getFullYear(), d.getMonth(), d.getDate(), hour, min);
                    this.dtp_startDate.set('value', newDate);
                    leadTime = this._getAlarmLeadTime();
                    alarmTime = this._getAlarmTime(newDate, leadTime, false);
                    this.sel_AlarmDur.set('startTime', newDate);
                    this.sel_AlarmDur.set('timeValue', alarmTime);
                }
            }
        },
        _alarmCheckChanged: function (entity, property, oldValue, newValue) {
            this._setHasAlarmUI(newValue);
        },
        _descriptionChanged: function () {
            this._formatHeader();
        },
        _notesChanged: function (entity, property, oldNotes, newNotes) {
            utility.setValue(this._activityData, 'Notes', (newNotes) ? newNotes.substr(0, 255) : newNotes);
        },
        _startDateChanged: function () {
            var newStartDate = this.dtp_startDate.get('value');
            this.sel_Duration.set('startTime', newStartDate);
            this.sel_AlarmDur.set('startTime', newStartDate);

            //Account for Timeless start Time
            var leadTime = this._getAlarmLeadTime();
            var alarmTime = this._getAlarmTime(newStartDate, leadTime, this.cb_Timeless.get('checked'));
            this.sel_AlarmDur.set('timeValue', alarmTime);

            //let the duration picker calculate the new alarm time, then set it back to the activity or user activity...
            var act = (this._currentUserActivityData) ? this._currentUserActivityData : this._activityData;
            Sage.Utility.setValue(act, 'AlarmTime', Sage.Utility.Convert.toIsoStringFromDate(this.sel_AlarmDur.get('timeValue')));

            if (this._availabilityShowing) {
                scheduler.setCurrentView(newStartDate, 'timeline');
                //make sure we have the availability data...
                this._requestAvailability();
            }

            //tell the recurring editor...
            this._recurringEditor.set('startDate', newStartDate);
        },
        _getAlarmTime: function (startDate, leadTime, timeless) {
            var alarmTime = dojoDate.add(startDate, 'minute', leadTime * -1);
            if (timeless === true) {
                alarmTime = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
                alarmTime = dojoDate.add(alarmTime, 'minute', leadTime * -1);
            }
            return alarmTime;
        },
        _getAlarmLeadTime: function () {
            var leadTime = '15';
            if (this._options[this.activityType]) {
                var optset = this._options[this.activityType];
                leadTime = optset['alarmLead'];
            }
            if (leadTime.toLowerCase() === 'none') {
                leadTime = 15;
            } else {
                leadTime = parseInt(leadTime, 10);
            }
            return leadTime;
        },
        _setHasAlarmUI: function (newValue) {
            if (typeof newValue === 'undefined') {
                newValue = Sage.Utility.getValue(this._currentUserActivityData || this._activityData, 'Alarm');
            }
            this.sel_AlarmDur.set('disabled', !newValue || this.mode === 'Confirm');
        },
        _setContactLeadVisibility: function () {
            var cVisible = this.rdo_Contact.get('checked');
            domClass.remove((cVisible) ? this.contactContainer.domNode : this.leadContainer.domNode, 'display-none');
            domClass.add((cVisible) ? this.leadContainer.domNode : this.contactContainer.domNode, 'display-none');
        },
        _formatHeader: function () {
            var action = '';
            var activityType = activityUtility.getActivityTypeName(this._activityData['Type'] || 'atAppointment');
            switch (this.mode) {
                case 'New':
                    if(this._activityData['Type'] === 'atAppointment')
							action = this.scheduleMeeting;
						else if(this._activityData['Type'] === 'atPhoneCall')
							action = this.schedulePhonecall;
						else 
							action = this.scheduleTodo;
						break;
                case 'Complete':
                case 'CompleteUnscheduled':
                    if(this._activityData['Type'] === 'atAppointment')
							action = this.completeMeeting;
						else if(this._activityData['Type'] === 'atPhoneCall')
							action = this.completePhonecall;
						else 
							action = this.completeTodo;
						break;
				case 'Update':
                    if(this._activityData['Type'] === 'atAppointment')
							action = this.updateMeeting;
						else if(this._activityData['Type'] === 'atPhoneCall')
							action = this.updatePhoneCall;
						else 
							action = this.updateToDo;
						break;
            }
            if (this.mode === 'Confirm') {
                if (!this._notificationData) {
                    return;
                }
                this._getUserInfoFor(this._notificationData.FromUser['$key'], function (user) {
                    if (this._notificationData) {
                        var confType = this._notificationData.Type;
                        switch (confType) {
                            case 'Change':
                                action = this.updatedText;
                                break;
                            case 'Confirm':
                                action = this.acceptedText;
                                break;
                            case 'Deleted':
                                action = this.deletedText;
                                break;
                            case 'Leader':
                                action = this.scheduledText;
                                break;
                            case 'Decline':
                                action = this.declinedText;
                                break;
                        }
                        var fmttext = (confType === 'New') ? this.newConfirmationHeaderFormatText : this.otherConfimationHeaderFormatText;
                        this._setHeader(dString.substitute(fmttext, {
                            activityType: '',
                            actionText: action,
                            user: user['UserName'] || user['$descriptor']
                        }));
                    }
                });
            } else {
                this._setHeader(dString.substitute(this.dialogHeaderFormatText, {
                    actionText: action,
                    activityType: '',
                    description: utility.htmlEncode(this._activityData['Description']) || ''
                }));
            }
        },
        _setHeader: function (headerText) {
            var html = dString.substitute('<div class="Global_Images icon16x16 ${0}" > </div>&nbsp;<span class="activity-dialog-title" style="max-width: 975px; text-overflow: ellipsis;">${1}</span>', [activityUtility.getActivityImageClass(this._activityData['Type'] || 'atAppointment', 'small'), headerText]);
            this._dialog.titleNode.innerHTML = html;
        },
        _setScheduledByLabel: function () {
            // adds the note:  Scheduled by <user> on <scheduled Date>
            var createDate = utility.Convert.toDateFromString(utility.getValue(this._activityData, 'CreateDate'));
            if (!createDate || createDate.getFullYear() < 1000) {
                createDate = new Date();
            }
            var startDate = this._getActivityStartDate();
            var createUser = utility.getValue(this._activityData, 'CreateUser').trim();
            var fmtStr = (this.mode === 'Complete' || this.mode === 'CompleteUnscheduled') ? this.completeScheduledByFormatText : this.scheduledByFormatText;
            var lbl;
            if (!createUser || this._currentUserId === createUser) {
                createUser = utility.getClientContextByKey('userPrettyName');
            } else if (createUser === 'PROCESS' || createUser === 'ADMIN') {
                createUser = 'Administrator';
            } else {
                this._getUserInfoFor(createUser, function (user) {
                    lbl = dString.substitute(fmtStr, {
                        user: user['$descriptor'],
                        date: locale.format(createDate, { selector: 'date', fullYear: true, locale: Sys.CultureInfo.CurrentCulture.name }),
                        startDate: locale.format(startDate, { selector: 'date', fullYear: true, locale: Sys.CultureInfo.CurrentCulture.name })
                    });
                    dojo.html.set(this.lbl_ScheduledBy, lbl);
                    dojo.html.set(this.lbl_ScheduledByComp, lbl);
                });
                return;
            }

            lbl = dString.substitute(fmtStr, {
                user: createUser,
                date: locale.format(createDate, {
                    selector: 'date', fullYear: true,
                    locale: Sys.CultureInfo.CurrentCulture.name
                }),
                startDate: locale.format(startDate, {
                    selector: 'date', fullYear: true,
                    locale: Sys.CultureInfo.CurrentCulture.name
                })
            });
            dojo.html.set(this.lbl_ScheduledBy, lbl);
            dojo.html.set(this.lbl_ScheduledByComp, lbl);
        },
        _getUserInfoFor: function (userId, callback) {
            if (userId) {
                var request = new Sage.SData.Client.SDataSingleResourceRequest(Sage.Data.SDataServiceRegistry.getSDataService('dynamic', false, true, true)); //go ahead and cache this...
                request.setResourceKind('userInfo');
                request.setResourceSelector("'" + userId + "'");
                //using precedence of 0 we only get $descriptor which is <lastname, firstname>,
                //...but do we want the UserName property which is <firstname lastname>???
                request.setQueryArg('precedence', '0');
                request.read({
                    success: callback,
                    scope: this,
                    failure: function () { }
                });
            }
        },
        _showRecurringTab: function () {
            this._recurringEditor.onTabShow();
            this._recurringEditor._setReadOnly(!this._canEdit());
        },
        _ensureAttachmentList: function () {
            on(this.cp_Attachments, 'show', dojo.hitch(this, function () {
                this._createAttachmentList();
            }));
        },
        // ... endregion UI interactions

        // ... region click/action handlers
        _completeClick: function () {
            this._completeAfterSaving = true;
            this._saveAndClose();
        },
        _deleteClick: function () {
            if (this._activityData && this._activityStore) {
                sageDialogs.raiseQueryDialogExt({
                    title: '',
                    query: this.areYouSureText,
                    callbackFn: function (result) {
                        if (result) {
                            this._activityStore.deleteEntity(this._activityData, this._successfulActivityDelete, this._failedActivityDelete, this);
                        }
                    },
                    yesText: this.okText,
                    noText: this.cancelText,
                    icon: 'questionIcon',
                    scope: this
                });
            }
        },
        _asScheduledClick: function () {
            this._updateAttendeesAndComplete(dojoDate.add(this.dtp_scheduledDate.get('value'), "minute", this._activityData.Duration));
        },
        _nowClick: function () {
            this._updateAttendeesAndComplete(this.dtp_completedDate.get('value'));
        },
        _updateAttendeesAndComplete: function (completedDate) {
            if (this.mode === 'CompleteUnscheduled') {
                var alarmTime = this.sel_AlarmDur.get('timeValue');
                //Alarm Time should never have a timeless date so fix it duration picker adds it.
                if (alarmTime.getSeconds() === 5) {
                    alarmTime = new Date(alarmTime.getFullYear(), alarmTime.getMonth(), alarmTime.getDate(), alarmTime.getHours(), alarmTime.getMinutes(), 0);
                }
                this._createActivityForNewOrCompleteUnscheduled(alarmTime, dojoLang.partial(this._preCompleteActivity, completedDate), this._failedActivitySave, this);
            }
            else if (this.mode === 'Complete') {
                this._preCompleteActivity(completedDate, null);
            }
            else {
                this._completeActivity(completedDate);
            }
        },
        _preCompleteActivity: function (completedDate, data) {
            var self = this;
            if (data) {
                this._activityData = data;
            }
            this._saveUserActivitiesAndResources(true);
            var deferred = this.attendeesTab._activitySaved(this._activityData);
            deferred.then(function (value) {
                self._completeActivity(completedDate);
            });
        },
        _completeActivity: function (completedDate) {
            if (this._isProcessing) {
                return;
            }
            this._isProcessing = true;
            /*
            to get the template:
            http://localhost:17966/SlxClient/slxdata.ashx/slx/system/-/activities/$service/complete/$template?format=json
            */
            var payload = {
                "$name": "Complete",
                "request": {
                    "entity": this._activityData,
                    "userId": this._currentUserId,
                    "result": this.pl_Result.get('value'),
                    "resultCode": this.pl_Result.get('code'),
                    "completeDate": utility.Convert.toIsoStringFromDate(completedDate)
                }
            };

            var request = new Sage.SData.Client.SDataServiceOperationRequest(sDataServiceRegistry.getSDataService('system'))
                .setResourceKind('activities')
                .setOperationName('Complete');
            request.execute(payload, {
                success: this._successfulComplete,
                failure: this._failedComplete,
                scope: this
            });
        },
        _okClick: function () {
            var activeElement = focusUtil.curNode;

            // IE8 has an issue where the value is saved before the blur realizes the value has changed, run the saveAndClose
            var aspectHandle = aspect.after(activeElement, "blur", dojoLang.hitch(this, function () {
                this._saveAndClose();
                aspectHandle.remove();
            }));
            if (activeElement) {
                activeElement.blur();
            }
        },
        _createActivityForNewOrCompleteUnscheduled: function (alarmTime, _success, _failur, context) {
            if (this.mode === 'New' || this.mode === 'CompleteUnscheduled') {
                if (this._attachmentList) {
                    var attachments = this._attachmentList.getNewAttachments();
                    if (attachments.length > 0) {
                        this._activityData.Attachment = true;
                    }
                }
                this._currentUserActivitySaved = true;
                utility.setValue(this._activityData, 'Alarm', this.cb_Alarm.get('checked'));
                utility.setValue(this._activityData, 'AlarmTime', utility.Convert.toIsoStringFromDate(alarmTime));
                if (this._activityData['AccountId'] === "")
                    this._activityData['AccountId'] = null;
                if (this._activityData['ContactId'] === "")
                    this._activityData['ContactId'] = null;
                this._activityStore.saveNewEntity(this._activityData, _success, _failur, context);
            }
        },
        _saveAndClose: function () {
            if (this._isProcessing) {
                return;
            }
            this._isProcessing = true;

            var alarmTime = this.sel_AlarmDur.get('timeValue');
            //Alarm Time should never have a timeless date so fix it duration picker adds it.
            if (alarmTime.getSeconds() === 5) {
                alarmTime = new Date(alarmTime.getFullYear(), alarmTime.getMonth(), alarmTime.getDate(), alarmTime.getHours(), alarmTime.getMinutes(), 0);
            }
            this._createActivityForNewOrCompleteUnscheduled(alarmTime, this._successfulActivitySave, this._failedActivitySave, this);
            if (this.mode !== 'New' && this.mode !== 'CompleteUnscheduled') {
                this._activityData.Attachment = this._activityData.AttachmentCount > 0 ? true : false;
                if (this._currentUserActivityData) {
                    //if it hasn't changed, don't bother posting...
                    if (utility.getValue(this._activityData, 'RecurrenceState') === 'rstOccurrence') {
                        //Set the current alarm and alarmtime values onto the activity 
                        // and don't save the user activity since we are creating an exception...
                        utility.setValue(this._activityData, 'Alarm', this.cb_Alarm.get('checked'));
                        utility.setValue(this._activityData, 'AlarmTime', utility.Convert.toIsoStringFromDate(alarmTime));
                        this._currentUserActivitySaved = true;
                        if (this._activityData.AllowEdit) {
                            this._saveActivity();
                        }
                    } else if ((this._tempUAData) && (this._tempUAData.Alarm === this._currentUserActivityData.Alarm
                        && this._tempUAData.AlarmTime.getTime() === alarmTime.getTime())) {
                        this._currentUserActivitySaved = true;
                        if (this._activityData.AllowEdit) {
                            this._saveActivity();
                        }
                    } else {
                        delete (this._currentUserActivityData.Activity);
                        this._currentUserActivityData.AlarmTime = utility.Convert.toIsoStringFromDate(alarmTime);
                        this._saveUserActivity();
                    }
                } else {
                    utility.setValue(this._activityData, 'AlarmTime', utility.Convert.toIsoStringFromDate(alarmTime));
                    this._currentUserActivitySaved = true;
                    if (this._activityData.AllowEdit) {
                        this._saveActivity();
                    }
                }
                this._ensureActivitySave();
            }
        },
        _saveUserActivity: function () {
            if (this._currentUserActivityStore) {
                this._currentUserActivityStore.save({
                    scope: this,
                    success: this._successfulCurrentUserActivitySave,
                    failure: this._failedUserActivitySave
                });
            }
        },
        _saveActivity: function () {
            if (this._activityStore) {
                this._activityStore.save({
                    scope: this,
                    success: this._successfulActivitySave,
                    failure: this._failedActivitySave
                });
            }
        },
        _ensureActivitySave: function () {
            if (!this._activityData.AllowEdit) {
                this._activitySaved = true;
                this._userActivitiesSaved = true;
                this._resourcesSaved = true;
                this._resourcesRemoved = true;
                this._attachmentsSaved = true;
                this._hideIfComplete();
            }
        },
        _successfulActivitySave: function (activity) {
            var deferred = this.attendeesTab._activitySaved(activity);
            deferred.then(dojo.hitch(this, function (value) {
                this._successfulActivityAttendeeSave(activity);
            }));
        },
        _successfulActivityAttendeeSave: function (activity) {
            if (this._activityData.LeaderChanged) {
                activity.LeaderChanged = true;
            }
            if (this._activityData.TimelessChanged) {
                activity.TimelessChanged = true;
            }
            this._activityData = activity;
            this._saveUserActivitiesAndResources();

            this._activitySaved = true;
            this._ensureActivitySave();
            this._hideIfComplete();
        },
        _saveUserActivitiesAndResources: function (suppressEvent) {
            var isNew = false;
            var publishEvent = !suppressEvent;
            var svc = Sage.Services.getService('ClientEntityContext');
            svc.clearTemporaryContext();
            if (!this.activityId) {
                isNew = true;
            }
            
            this.activityId = this._activityData['$key']; //Set this so that new UserActivities and ResourceSchedules can reference the parent...
            var hasMembers = false, hasResources = false;
            var ldr = this._activityData.Leader['$key'];
            for (var i = 0; i < this._newAttendeesData.length; i++) {
                hasMembers = (hasMembers || (this._newAttendeesData[i]['Type'] === 'User' && this._newAttendeesData[i]['$key'] !== ldr));
                hasResources = (hasResources || this._newAttendeesData[i]['Type'] === 'Resource');
            }
            if (hasMembers) {
                var uareq = new Sage.SData.Client.SDataTemplateResourceRequest(sDataServiceRegistry.getSDataService('system'));
                uareq.setResourceKind('userActivities');
                uareq.read({
                    async: false,
                    success: dojoLang.partial(this._onGetUserActivityTemplate),
                    failure: this._failedUserActivitySave,
                    scope: this
                });
            } else {
                this._userActivitiesSaved = true;
            }
            if (hasResources) {
                var resreq = new Sage.SData.Client.SDataTemplateResourceRequest(Sage.Data.SDataServiceRegistry.getSDataService('dynamic'));
                resreq.setResourceKind('resourceSchedules');
                resreq.read({
                    async: false,
                    success: this._onGetResourceScheduleTemplate,
                    failure: this._failedUserActivitySave,
                    scope: this
                });
            } else {
                this._resourcesSaved = true;
            }
            this._attachmentsSaved = true;
            if (this._attachmentList) {
                var attachments = this._attachmentList.getNewAttachments();
                if (attachments.length > 0 && this.mode === 'New') {
                    this._saveAttachments(attachments);
                    this._attachmentsSaved = false;
                }
            }
            if (this._attendeesForRemoval.length > 0) {
                this._removeResources();
            } else {
                this._resourcesRemoved = true;
            }

            if (isNew && publishEvent) {
                dojo.publish('/entity/activity/create', [this._activityData, this]);
            }

            if (!this._completeAfterSaving && !isNew) {
                //we're just switching to complete mode, no need for other things to update UI yet...
                dojo.publish('/entity/activity/change', [this._activityData, this]);
            }
        },
        _saveAttachments: function (attachments, histId) {
            this._attachmentRequests = attachments.length;
            for (var i = 0; i < attachments.length; i++) {
                var att = attachments[i];
                var req = new Sage.SData.Client.SDataSingleResourceRequest(sDataServiceRegistry.getSDataService('system'));
                req.setResourceKind('attachments');
                req.setResourceSelector('\'' + att.$key + '\'');
                if (histId) {
                    att.historyId = histId;
                } else {
                    att.activityId = this.activityId;
                }
                for (var p in this._activityData) {
                    if (p.substring(p.length - 2) === 'Id' && p !== 'UserId') {
                        var attProp = p.substring(0, 1).toLowerCase() + p.substring(1);
                        att[attProp] = this._activityData[p];
                    }
                }
                req.update(att, {
                    ignoreETag: true,
                    success: this._successfulAttachmentSave,
                    failure: this._failedAttachmentSave,
                    scope: this
                });
            }
        },
        _removeAttachments: function () {
            if (!this._attachmentList) {
                return;
            }
            var attachments = this._attachmentList.getNewAttachments();
            for (var i = 0; i < attachments.length; i++) {
                var att = attachments[i];
                var req = new Sage.SData.Client.SDataSingleResourceRequest(sDataServiceRegistry.getSDataService('system'));
                req.setResourceKind('attachments');
                req.setResourceSelector('\'' + att.$key + '\'');
                req['delete'](att, {
                    success: function () {
                    },
                    failure: function () {
                    },
                    scope: this
                });
            }
        },
        getRelationshipsForAttachments: function () {
            var obj = {
            };
            for (var p in this._activityData) {
                if (p.substring(p.length - 2) === 'Id' && p !== 'UserId') {
                    var attProp = p.substring(0, 1).toLowerCase() + p.substring(1);
                    obj[attProp] = this._activityData[p];
                }
            }
            if (this.mode === 'New' && !fileUtility.supportsHTML5File && !slx.desktop) {
                this._tempIdForAttachments = this._makeTempID();
                obj['activityId'] = this._tempIdForAttachments;
            }
            return obj;
        },
        doCarryOverAttachments: function (histId) {
            //this._ensureAttachmentList();
            attachmentUtility.getAttachmentTemplate(function (template) {
                this._getHistoryAttachments(histId, template);
            }, this);
        },
        _createAttachmentList: function () {
            var newAttachmentList = false;
            if (!this._attachmentList) {
                newAttachmentList = true;
                this._attachmentList = new AttachmentList({
                    workspace: '',
                    tabId: '',
                    placeHolder: this.id + '_attachmentsGridPlaceholder',
                    parentRelationshipName: 'activityId'
                });
                this._attachmentList.startup(dojo.hitch(this, function () {
                    this.cp_Attachments.resize();
                }));
            }
            this._attachmentList.setToReadOnly(!this._canEdit());
            if (newAttachmentList || this.mode != 'New') {
                window.setTimeout(this._attachmentList.resetEntityContext(), 100);
            }
        },
        _getHistoryAttachments: function (histId, template) {
            var histReq = new Sage.SData.Client.SDataResourceCollectionRequest(sDataServiceRegistry.getSDataService('system'));
            histReq.setResourceKind('attachments');
            histReq.setQueryArg('where', 'historyId eq \'' + histId + '\'');
            histReq.read({
                success: function (data) {
                    var items = data['$resources'];
                    var mixin = {
                        activityId: this._makeTempID(),
                        historyId: null
                    };
                    var req = new Sage.SData.Client.SDataSingleResourceRequest(sDataServiceRegistry.getSDataService('system'));
                    req.setResourceKind('attachments');
                    if (items && items.length) {
                        var l = items.length;
                        for (var i = 0; i < l; i++) {
                            var oldAttach = dojoLang.mixin(items[i], mixin);
                            var newAttach = dojoLang.mixin(template, oldAttach);
                            delete newAttach.createDate;
                            delete newAttach.modifyDate;
                            delete newAttach.createUser;
                            delete newAttach.modifyUser;
                            delete newAttach.$key;
                            delete newAttach.$etag;
                            //set the fileName property to the physicalFileName value so that it
                            // doesn't add this new record's ID to the beginning of the physicalFileName.
                            // It can't find it when that happens.
                            newAttach.fileName = newAttach.physicalFileName;
                            newAttach.attachDate = utility.Convert.toIsoStringFromDate(new Date());

                            req.create(newAttach, {
                                success: function (savedAttachment) {
                                    dojo.publish('/entity/attachment/create', [savedAttachment]);
                                },
                                failure: function () {
                                    console.log('failed to carry over attachment');
                                },
                                scope: this
                            });
                        }
                        this._createAttachmentList();
                    }
                },
                failure: function () {
                },
                scope: this
            });
        },
        //For followup activity
        //Get attendees from historyattendees and add it to Participants tab
        _getHistoryAttendees: function (historyId) {
            var histReq = new Sage.SData.Client.SDataResourceCollectionRequest(sDataServiceRegistry.getSDataService('dynamic'));
            histReq.setResourceKind('historyAttendees');
            histReq.setQueryArg('where', 'HistoryId eq \'' + historyId + '\'');
            histReq.read({
                success: function (data) {
                    var items = data['$resources'];
                    var attendees = [];
                    for (var i = 0; i < items.length; i++) {
                        if (items[i].EntityType != "User") {
                            var mixin = {
                                $key: items[i].EntityId,
                                $descriptor: items[i].Name,
                                general: false
                            };
                            var newItem = dojoLang.mixin(items[i], mixin);
                            attendees.push(newItem);
                        }
                    }
                    this.attendeesTab._addAttendeesToStore(attendees);
                },
                failure: function () {
                    console.log("Error getting historyAttendees for follow up activity");
                },
                scope: this
            });
        },
        _makeTempID: function () {
            if (!this._tempIdForAttachments) {
                var uid = this._currentUserId;
                var dstr = utility.Convert.toIsoStringFromDate(this.dtp_startDate.get('value'));
                dstr = dstr.replace(/[T:-]/g, '').substr(6, 6);
                this._tempIdForAttachments = 'NE' + uid.substr(uid.length - 4, 4) + dstr;
            }
            return this._tempIdForAttachments;
        },
        _attachmentRequests: 0,
        _successfulAttachmentSave: function (attachment) {
            this._attachmentRequests--;
            if (this._attachmentRequests < 1) {
                this._attachmentsSaved = true;
                this._hideIfComplete();
            }
        },
        _failedAttachmentSave: function () {
            this._attachmentRequests--;
            if (this._attachmentRequests < 1) {
                this._attachmentsSaved = true;
                this._hideIfComplete();
            }
        },
        _successfulCurrentUserActivitySave: function (userActivity) {
            this._currentUserActivitySaved = true;
            if (this._activityData.AllowEdit) {
                this._saveActivity();
            } else {
                dojo.publish('/entity/userActivity/change', [userActivity, this]);
            }
            this._hideIfComplete();
        },
        _successfulActivityDelete: function () {
            var svc = Sage.Services.getService('ClientEntityContext');
            svc.clearTemporaryContext();
            dojo.publish('/entity/activity/delete', [this._activityData['$key'], this]);
            if (this._activityData['Timeless']) {
                dojo.publish('/entity/activity/timeless/delete', [this._activityData['$key'], this]);
            }
            this.hide();
        },
        //When completing an unscheduled activity, create historyAttendee records directly
        _successfulComplete: function (history) {
            if (this.mode === 'CompleteUnscheduled') {
                var self = this;
                var _arguments = arguments;
                var deferred = this.attendeesTab._historySaved(history);
                deferred.then(function (value) {
                    self._successfulAttendeesComplete(history);
                });
            } else {
                this._successfulAttendeesComplete(history);
            }
        },
        _successfulAttendeesComplete: function (request) {
            var svc = Sage.Services.getService('ClientEntityContext');
            svc.clearTemporaryContext();
            var hist = request;
            if (this.mode === 'Complete' || this.mode === 'CompleteUnscheduled') {
                if (request.Response) {
                    hist = request.Response;
                }
                dojo.publish('/entity/activity/delete', [this._activityData['$key'], this]);
                if (this._activityData['Timeless']) {
                    dojo.publish('/entity/activity/timeless/delete', [this._activityData['$key'], this]);
                }
            }
            dojo.publish('/entity/history/create', [hist, this]);
            var histId = null;
            if (this.mode === 'Complete' || this.mode === 'CompleteUnscheduled') {
                if (request.Response) {
                    histId = request.Response.HistoryId;
                }
            } else {
                histId = hist.$key;
            }
            if (this._attachmentList) {
                var attachments = this._attachmentList.getNewAttachments();
                if (attachments.length > 0) {
                    this._activityData.Attachment = true;
                    this._saveAttachments(attachments, histId);
                }
            }
            var followUp = this.sel_Followup.get('value');
            switch (followUp) {
                case this.noneText:
                    this.hide();
                    return;
                case activityUtility.getActivityTypeName('atPhoneCall'):
                    //doing the circles because of localization...
                    followUp = 'atPhoneCall';
                    break;
                case activityUtility.getActivityTypeName('atAppointment'):
                    followUp = 'atAppointment';
                    break;
                case activityUtility.getActivityTypeName('atToDo'):
                    followUp = 'atToDo';
                    break;
            }
            if (typeof histId === 'undefined' || histId === null) {
                this.hide();
                sageDialogs.showError(this.scheduleFollowUpErrorText);
                return;
            }
            var actMixin = this._getFollowUpActivityData(histId);
            this.hide();
            window.setTimeout(function () {
                var actsvc = Sage.Services.getService('ActivityService');
                if (actsvc) {
                    actsvc.scheduleActivity({
                        'type': followUp, 'preConfigured': actMixin
                    });
                }
            }, 250);
        },
        _getFollowUpActivityData: function (historyId) {
            var a = this._activityData;
            var ret = {
                AccountId: a.AccountId,
                AccountName: a.AccountName,
                ContactId: a.ContactId,
                ContactName: a.ContactName,
                Description: a.Description,
                LeadId: a.LeadId,
                LeadName: a.LeadName,
                OpportunityId: a.OpportunityId,
                OpportunityName: a.OpportunityName,
                TicketId: a.TicketId,
                TicketNumber: a.TicketNumber

            };
            if (this.ck_coNotes.get('checked')) {
                ret['LongNotes'] = a.LongNotes;
                ret['Notes'] = a.Notes;
            }
            if (this.ck_coAttachments.get('checked')) {
                ret['carryOverAttachmentsFrom'] = historyId;
            }

            ret['carryOverParticipantsFrom'] = historyId;
            return ret;
        },
        _failedActivitySave: function (request) {
            var msg = activityUtility.findFailedRequestMessage(request, this.couldNotSaveErrorText);
            console.log('an error occurred saving activity %o', request);
            sageDialogs.showError(msg);
            this._completeAfterSaving = false;
        },
        _failedActivityDelete: function (request) {
            var msg = activityUtility.findFailedRequestMessage(request, this.couldNotDeleteErrorText);
            console.log('an error occurred deleting %o', request);
            sageDialogs.showError(msg);
            this._completeAfterSaving = false;
        },
        _failedUserActivitySave: function (request) {
            var msg = activityUtility.findFailedRequestMessage(request, this.couldNotSaveErrorText);
            console.log('an error occurred saving user activity %o', request);
            sageDialogs.showError(msg);
        },
        _failedResourceSave: function (request) {
            console.warn('an error occurred saving resources %o', request);
            var msg = activityUtility.findFailedRequestMessage(request, this.couldNotSaveErrorText);
            sageDialogs.showError(msg);
        },
        _failedComplete: function (request) {
            var msg = activityUtility.findFailedRequestMessage(request, this.couldNotCompleteErrorText);
            console.log('an error occurred completing activity %o', request);
            sageDialogs.showError(msg);
        },
        _onGetUserActivityTemplate: function (userActivity) {
            this._userActivitiesRequestCount = 0;
            var ldr = this.lup_Leader.get('selectedObject');
            ldr = ldr['$key'].substr(0, 12);
            var act = this._activityData;
            var alarmtime = utility.Convert.toDateFromString(act.AlarmTime);
            for (var i = 0; i < this._newAttendeesData.length; i++) {
                var nat = this._newAttendeesData[i];
                //don't post a useractivity for the leader...
                if (nat['Type'] === 'User' && nat['$key'] !== ldr) {
                    var newua = dojo.mixin({}, userActivity);
                    var setVals = {
                        User: {
                            '$key': nat['$key']
                        },
                        ActivityId: this.activityId,
                        Activity: {
                            '$key': this.activityId
                        },
                        Alarm: act.Alarm,
                        AlarmTime: utility.Convert.toIsoStringFromDate(alarmtime),
                        Status: 'asUnconfirmed'
                    };
                    newua = dojoLang.mixin(newua, setVals);
                    var req = new Sage.SData.Client.SDataSingleResourceRequest(Sage.Data.SDataServiceRegistry.getSDataService('system'));
                    req.setResourceKind('userActivities');
                    this._userActivitiesRequestCount++;
                    req.create(newua, {
                        async: false,
                        success: function (savedUserActivity) {
                            this._userActivitiesRequestCount--;
                            dojo.publish('/entity/userActivity/create', [savedUserActivity, this]);
                            if (this._userActivitiesRequestCount < 1) {
                                this._userActivitiesSaved = true;
                                this._hideIfComplete();
                            }
                        },
                        failure: this._failedUserActivitySave,
                        scope: this
                    });
                }
            }
            if (this._userActivitiesRequestCount < 1) {
                this._userActivitiesSaved = true;
                if (act.Timeless) {
                    dojo.publish('/entity/userActivities/timeless/saved', [act, this]);
                }
                this._hideIfComplete();
            }
        },
        _onGetResourceScheduleTemplate: function (resourceSched) {
            this._resourceRequestCount = 0;
            for (var i = 0; i < this._newAttendeesData.length; i++) {
                var nat = this._newAttendeesData[i];
                if (nat['Type'] === 'Resource') {
                    var newRe = dojoLang.mixin({}, resourceSched);
                    var act = this._activityData;
                    var sd = Sage.Utility.Convert.toDateFromString(act['StartDate']);
                    var ed = dojoDate.add(sd, 'minute', act['Duration']);
                    var setVals = {
                        ResourceId: nat['$key'],
                        ActivityId: this.activityId,
                        Description: nat['Name'],
                        StartDate: act['StartDate'],
                        EndDate: Sage.Utility.Convert.toIsoStringFromDate(ed),
                        UserId: act.Leader['$key']
                    };
                    newRe = dojoLang.mixin(newRe, setVals);
                    var req = new Sage.SData.Client.SDataSingleResourceRequest(Sage.Data.SDataServiceRegistry.getSDataService('dynamic'));
                    req.setResourceKind('resourceSchedules');
                    this._resourceRequestCount++;
                    req.create(newRe, {
                        success: function (resourceSchedule) {
                            this._resourceRequestCount--;
                            if (this._resourceRequestCount < 1) {
                                this._resourcesSaved = true;
                                this._hideIfComplete();
                            }
                        },
                        failure: this._failedResourceSave,
                        scope: this
                    });
                }
            }
        },
        _removeResources: function () {
            this._resourceDeleteRequestCount = 0;
            for (var i = 0; i < this._attendeesForRemoval.length; i++) {
                var rem = this._attendeesForRemoval[i];
                var request;
                var predicate;
                var publishEvt;
                if (rem['type'] === 'user') {
                    request = new Sage.SData.Client.SDataSingleResourceRequest(Sage.Data.SDataServiceRegistry.getSDataService('system'));
                    request.setResourceKind('userActivities');
                    predicate = dString.substitute("'ActivityId=${0};UserId=${1}'", [this.activityId, rem['id']]);
                    publishEvt = '/entity/userActivity/delete';
                } else {
                    request = new Sage.SData.Client.SDataSingleResourceRequest(Sage.Data.SDataServiceRegistry.getSDataService('dynamic'));
                    request.setResourceKind('resourceSchedules');
                    predicate = '\'' + rem['rsid'] + '\'';
                    publishEvt = '/entity/resourceSchedule/delete';
                }
                request.setResourceSelector(predicate);
                this._resourceDeleteRequestCount++;
                // create this scope object to maintain the correct event and ID to publish
                var scopeObj = {
                    notify: function () {
                        dojo.publish(this.evt, [this.predicate]);
                        this.editor._resourceDeleteRequestCount--;
                        if (this.editor._resourceDeleteRequestCount < 1) {
                            this.editor._resourcesRemoved = true;
                            this.editor._hideIfComplete();
                        }
                    },
                    evt: publishEvt,
                    predicate: predicate,
                    editor: this
                };

                var options = {
                    success: scopeObj.notify,
                    aborted: function () {
                    },
                    failure: this._failedResourceSave,
                    scope: scopeObj
                };
                request['delete']({ '$key': predicate }, options);
            }
        },
        _cancelClick: function () {
            if (this.mode === 'New') {
                this._removeAttachments();
            }
            this.hide();
        },
        _hideIfComplete: function () {
            if (this._activitySaved && this._userActivitiesSaved && this._currentUserActivitySaved
                && this._resourcesSaved && this._resourcesRemoved && this._attachmentsSaved) {
                var actId = this.activityId;
                if (this._completeAfterSaving) {
                    this._completeAfterSaving = false;
                    var svc = Sage.Services.getService('ActivityService');
                    if (svc) {
                        svc.completeActivity(actId);
                    }
                } else {
                    this.hide();
                }
            }
        },
        _acceptConfClick: function () {
            var activityService = Sage.Services.getService('ActivityService');
            activityService.acceptConfirmation({
                notification: this._notificationData,
                success: this._successfulAcceptConfirmation,
                failure: this._failedAcceptDecline,
                scope: this
            });

        },
        _declineClick: function () {
            var activityService = Sage.Services.getService('ActivityService');
            activityService.declineConfirmation({
                notification: this._notificationData,
                success: this._successfulDeclineConfirmation,
                failure: this._failedAcceptDecline,
                scope: this
            });
        },
        _deleteConfClick: function () {
            if (this._notificationData && this._notificationStore) {
                this._notificationStore.deleteEntity(this._notificationData, this._successfulNotificationDelete, this._failedActivityDelete, this);
            }
        },
        _getActivityDataFromNotificationData: function () {
            var activityId = null;
            var userId = null;
            if (this._notificationData) {
                if (this._notificationData.Activity) {
                    activityId = this._notificationData.Activity.$key;
                }
                if (this._notificationData.ToUser) {
                    userId = this._notificationData.ToUser.$key;
                }
            }
            var actObj = {
                'activityId': activityId, 'userId': userId
            };
            return actObj;
        },
        _successfulAcceptConfirmation: function () {
            dojo.publish('/entity/activity/confirm', [this._getActivityDataFromNotificationData(), null]);
            this._successfulNotificationDelete();
        },
        _successfulDeclineConfirmation: function () {
            dojo.publish('/entity/activity/decline', [this._getActivityDataFromNotificationData(), null]);
            this._successfulNotificationDelete();
        },
        _successfulNotificationDelete: function () {
            dojo.publish('/entity/userNotification/delete', [this._notificationData['$key'], this]);
            this.hide();
        },

        // ... endregion

        //region lookup configs
        _ensureLookupsCreated: function () {
            if (!this.lup_Account) {
                this.createAccountLookup();
                this.createContactLookup();
                this.createOpportunityLookup();
                this.createTicketLookup();
                this.createLeadLookup();
                this.createLeaderlookup();
                this.createResourcesLookup();
            }
            var self = this;
            if (dojo.byId("lu_lead_btnClearResult")) {
                dojo.connect(dojo.byId("lu_lead_btnClearResult"), 'onclick', null, function () {
                    self.attendeesTab.unCheckPrimary();
                }, true);
            }
            if (dojo.byId("lu_contact_btnClearResult")) {
                dojo.connect(dojo.byId("lu_contact_btnClearResult"), 'onclick', null, function () {
                    self.attendeesTab.unCheckPrimary();
                }, true);
            }
        },
        createAccountLookup: function () {
            this.createAccountLookupConfig();
            this.lup_Account = new Lookup({
                id: 'lu_account',
                allowClearingResult: true,
                showEntityInfoToolTip: true,
                readonly: true,
                config: this.accountLookupConfig
            });
            this.eventConnections.push(dojo.connect(this.lup_Account, 'onChange', this, '_accountChanged'));
            dojo.place(this.lup_Account.domNode, this.container_AccountLup.domNode, 'only');
        },
        createAccountLookupConfig: function () {
            this.accountLookupConfig = {
                id: '_activityAcc',
                structure: [
                    {
                        "label": this.accountText,
                        "field": "AccountName"
                    },
                            {
                                "label": this.cityText,
                                "field": "Address.City"
                            },
                            {
                                "label": this.stateText,
                                "field": "Address.State"
                            },
                            {
                                "label": this.mainPhoneText,
                                "field": "MainPhone"
                            },
                            {
                                "label": this.typeText,
                                "field": "Type"
                            },
                            {
                                "label": this.subTypeText,
                                "field": "SubType"
                            },
                            {
                                "label": this.statusText,
                                "field": "Status"
                            },
                            {
                                "label": this.acctMgrText,
                                "field": "AccountManager.UserInfo.UserName"
                            },
                            {
                                "label": this.ownerText,
                                "field": "Owner.OwnerDescription"
                            }
                ],
                gridOptions: {
                    contextualCondition: '',
                    contextualShow: '',
                    selectionMode: 'single',
                    columnResizing: true
                },
                storeOptions: {
                    resourceKind: 'accounts',
                    sort: [{
                        attribute: 'AccountName'
                    }]
                },
                isModal: true,
                seedProperty: '',
                seedValue: '',
                overrideSeedValueOnSearch: false,
                initializeLookup: false,
                preFilters: [],
                returnPrimaryKey: true,
                dialogTitle: this.lookupActText,
                dialogButtonText: this.okText
            };
            return this.accountLookupConfig;
        },
        createContactLookupConfig: function () {
            this.contactLookupConfig = {
                id: '_activityContact',
                structure: [
                    {
                        label: this.nameText,
                        field: 'NameLF'
                    }, {
                        label: this.accountText,
                        field: 'Account.AccountName'
                    }, {
                        label: this.cityText,
                        field: 'Address.City'
                    }, {
                        label: this.stateText,
                        field: 'Address.State'
                    }, {
                        label: this.workphoneText,
                        field: 'WorkPhone'
                    }, {
                        label: this.emailText,
                        field: 'Email'
                    }
                ],
                gridOptions: {
                    contextualCondition: '',
                    contextualShow: '',
                    selectionMode: 'single',
                    columnResizing: true
                },
                storeOptions: {
                    resourceKind: 'contacts',
                    select: ['Address/Timezone'],
                    sort: [{
                        attribute: 'NameLF'
                    }]
                },
                isModal: true,
                seedProperty: 'Account.Id',
                seedValue: '',
                overrideSeedValueOnSearch: true,
                initialLookup: true,
                preFilters: [],
                returnPrimaryKey: true,
                dialogTitle: this.lookupContactText,
                dialogButtonText: this.okText
            };
            return this.contactLookupConfig;
        },
        createContactLookup: function () {
            this.createContactLookupConfig();
            this.lup_Contact = new Lookup({
                id: 'lu_contact',
                allowClearingResult: true,
                config: this.contactLookupConfig,
                readonly: true,
                showEntityInfoToolTip: true
            });
            this.eventConnections.push(dojo.connect(this.lup_Contact, 'onChange', this, '_contactChanged'));
            dojo.place(this.lup_Contact.domNode, this.container_ContactLup.domNode, 'only');
        },
        createOpportunityLookupConfig: function () {
            this.opportunityLookupConfig = {
                id: '_activityOpp',
                structure: [
                    {
                        label: this.descriptionText,
                        field: 'Description'
                    }, {
                        label: this.acctMgrText,
                        field: 'AccountManager.UserInfo.UserName'
                    }, {
                        label: this.accountText,
                        field: 'Account.AccountName'
                    }, {
                        label: this.stageText,
                        field: 'Stage'
                    }, {
                        label: this.statusText,
                        field: 'Status'
                    }, {
                        label: this.ownerText,
                        field: 'Owner.OwnerDescription'
                    }
                ],
                gridOptions: {
                    contextualCondition: '',
                    contextualShow: '',
                    selectionMode: 'single',
                    columnResizing: true
                },
                storeOptions: {
                    resourceKind: 'opportunities',
                    sort: [{
                        attribute: 'Description'
                    }]
                },
                isModal: true,
                seedProperty: 'Account.Id',
                seedValue: '',
                overrideSeedValueOnSearch: true,
                initialLookup: true,
                preFilters: [],
                returnPrimaryKey: true,
                dialogTitle: this.lookupOpportunityText,
                dialogButtonText: this.okText
            };
            return this.opportunityLookupConfig;
        },
        createOpportunityLookup: function () {
            this.createOpportunityLookupConfig();
            this.lup_Opportunity = new Lookup({
                id: 'lu_opportunity',
                allowClearingResult: true,
                config: this.opportunityLookupConfig,
                readonly: true,
                showEntityInfoToolTip: true
            });
            this.eventConnections.push(dojo.connect(this.lup_Opportunity, 'onChange', this, '_opportunityChanged'));
            dojo.place(this.lup_Opportunity.domNode, this.container_OppLup.domNode, 'only');
        },
        createTicketLookupConfig: function () {
            this.ticketLookupConfig = {
                id: '_activityTicket',
                structure: [
                    {
                        label: this.ticketNumberText,
                        field: 'TicketNumber'
                    }, {
                        label: this.accountText,
                        field: 'Account.AccountName'
                    }, {
                        label: this.nameText,
                        field: 'Contact.NameLF'
                    }, {
                        label: this.phoneText,
                        field: 'Contact.WorkPhone'
                    }, {
                        label: this.statusText,
                        field: 'StatusCode',
                        pickListName: 'Ticket Status',
                        propertyType: 'SalesLogix.PickList',
                        type: 'Sage.UI.Columns.PickList'
                    }, {
                        label: this.urgencyText,
                        field: 'Urgency.Description'
                    }, {
                        label: this.areaText,
                        field: 'Area'
                    }
                ],
                gridOptions: {
                    contextualCondition: '',
                    contextualShow: '',
                    selectionMode: 'single',
                    columnResizing: true
                },
                storeOptions: {
                    resourceKind: 'tickets',
                    sort: [{
                        attribute: 'TicketNumber'
                    }]
                },
                isModal: true,
                seedProperty: 'Account.Id',
                seedValue: '',
                overrideSeedValueOnSearch: true,
                initialLookup: true,
                preFilters: [],
                returnPrimaryKey: true,
                dialogTitle: this.lookupTicketText,
                dialogButtonText: this.okText
            };
            return this.ticketLookupConfig;
        },
        createTicketLookup: function () {
            this.createTicketLookupConfig();
            this.lup_Ticket = new Lookup({
                id: 'lu_ticket',
                allowClearingResult: true,
                config: this.ticketLookupConfig,
                readonly: true,
                showEntityInfoToolTip: true
            });
            this.eventConnections.push(dojo.connect(this.lup_Ticket, 'onChange', this, '_ticketChanged'));
            dojo.place(this.lup_Ticket.domNode, this.container_TicketLup.domNode, 'only');
        },
        createLeadLookupConfig: function () {
            this.leadLookupConfig = {
                id: '_activityLead',
                structure: [
                    {
                        label: this.leadFullNameText,
                        field: 'LeadFullName'
                    }, {
                        label: this.companyText,
                        field: 'Company'
                    }, {
                        label: this.cityText,
                        field: 'Address.City'
                    }, {
                        label: this.stateText,
                        field: 'Address.State'
                    }, {
                        label: this.postalText,
                        field: 'Address.PostalCode'
                    }, {
                        label: this.statusText,
                        field: 'Status'
                    }, {
                        label: this.workphoneText,
                        field: 'WorkPhone'
                    }, {
                        label: this.ownerText,
                        field: 'Owner.OwnerDescription'
                    }
                ],
                gridOptions: {
                    contextualCondition: '',
                    contextualShow: '',
                    selectionMode: 'single',
                    columnResizing: true
                },
                storeOptions: {
                    resourceKind: 'leads',
                    select: ['Address/Timezone'],
                    sort: [{
                        attribute: 'LeadFullName'
                    }]
                },
                isModal: true,
                initialLookup: false,
                preFilters: [],
                returnPrimaryKey: true,
                dialogTitle: this.lookupLeadText,
                dialogButtonText: this.okText
            };
            return this.leadLookupConfig;
        },
        createLeadLookup: function () {
            this.createLeadLookupConfig();
            this.lup_Lead = new Lookup({
                id: 'lu_lead',
                allowClearingResult: true,
                config: this.leadLookupConfig,
                readonly: true,
                showEntityInfoToolTip: true
            });
            this.eventConnections.push(dojo.connect(this.lup_Lead, 'onChange', this, '_leadChanged'));
            dojo.place(this.lup_Lead.domNode, this.container_LeadLup.domNode, 'only');
        },
        createLeaderLookupConfig: function () {
            this.leaderLookupConfig = {
                id: '_activityLeader',
                structure: [
                    {
                        label: this.nameText,
                        field: 'Name',
                        sortable: true,
                        width: "400px",
                        editable: false,
                        propertyType: "System.String",
                        excludeFromFilters: false,
                        defaultValue: ""
                    }
                ],
                gridOptions: {
                    contextualCondition: function () {
                        return 'AllowAdd AND (AccessId eq \'' + utility.getClientContextByKey('userID') + '\' OR AccessId eq \'EVERYONE\') AND Type eq \'User\'';
                    },
                    contextualShow: '',
                    selectionMode: 'single',
                    columnResizing: true
                },
                storeOptions: {
                    resourceKind: 'activityresourceviews',
                    sort: [{
                        attribute: 'Name'
                    }]
                },
                isModal: true,
                preFilters: [],
                returnPrimaryKey: true,
                dialogTitle: this.lookupLeaderText,
                dialogButtonText: this.okText
            };
            return this.leaderLookupConfig;
        },
        createLeaderlookup: function () {
            this.createLeaderLookupConfig();
            this.lup_Leader = new Lookup({
                id: 'lu_leader',
                readonly: true,
                config: this.leaderLookupConfig
            });
            this.eventConnections.push(dojo.connect(this.lup_Leader, 'onChange', this, '_leaderChanged'));
            dojo.place(this.lup_Leader.domNode, this.container_LeaderLup.domNode, 'only');
        },
        createResourcesLookupConfig: function () {
            this.resourcesLookupConfig = {
                id: '_activityResources',
                btnToolTip: this.lookupResourcesText,
                structure: [
                    {
                        label: this.nameText,
                        field: 'Name'
                    }, {
                        label: this.typeText,
                        field: 'Type',
                        width: '100px'
                    }, {
                        label: this.locationText,
                        field: 'IsLocation',
                        propertyType: 'System.Boolean',
                        format: function (inRowIndex, inItem) {
                            var type = utility.getValue(inItem, 'Type');
                            if (!type) {
                                return this.defaultValue;
                            }
                            if (type === 'User') {
                                return '';
                            }
                            return (inItem['IsLocation'] === null || inItem['IsLocation'] === 'false') ? this.noText : this.yesText;
                        }
                    }, {
                        label: this.descriptionText,
                        field: 'Subtype',
                        width: '200px'
                    }
                ],
                gridOptions: {
                    columnResizing: true
                },
                displayMode: 5,
                storeOptions: {
                    resourceKind: 'activityresourceviews',
                    select: ['AccessId', 'ResourceId', 'AllowAdd', 'AllowEdit', 'AllowDelete'],
                    sort: [{
                        attribute: 'Type'
                    }, {
                        attribute: 'Name'
                    }]
                },
                isModal: true,
                initialLookup: false,
                preFilters: [],
                query: {
                    conditions: 'AllowAdd AND (AccessId eq \'' + this._currentUserId + '\' OR AccessId eq \'EVERYONE\')'
                },
                dialogTitle: this.lookupResourcesText,
                dialogButtonText: this.addResourceText,
                doSelected: function (items) {
                    var actEditor = dijit.byId('activityEditor');
                    if (actEditor) {
                        actEditor.addMembers(items);
                    }
                    this.lookupDialog.hide();
                }
            };
            return this.resourcesLookupConfig;
        },
        createResourcesLookup: function () {
            this.createResourcesLookupConfig();
            this.lup_Resources = new Sage.UI.SDataLookup(this.resourcesLookupConfig);
            //override cancel text to close, as there is a logic in SDataLookup.js to change this text: defect#: 13092318
            this.lup_Resources.cancelText = this.lup_Resources.closeText;
            dojo.place(this.lup_Resources.domNode, this.container_ResourcesLup.domNode, 'only');
        },
        //end region lookup configs

        //Availability Tab functionality...
        _schedulerInitialized: false,
        _resetAttendeesList: function () {

            if (!this._schedulerInitialized) {
                // to override scheduler's create activity functionality:
                scheduler.showLightbox = function () {
                    return false;
                };

                //for re-rendering the timeline when the left or right arrow clicked
                scheduler.config.timelineStep = 30; // get it from user option??
                scheduler.config.timelineStart = (this._options.calendar.dayStartTime * 2);
                scheduler.config.timelineSize = ((this._options.calendar.dayEndTime - this._options.calendar.dayStartTime) * 2);
                this._setTimePatternForDHTMLXLibrary();

                scheduler.createTimelineView({
                    name: "timeline",
                    x_unit: "minute",
                    x_date: this._DHTMLXLibraryTimePattern,
                    x_step: scheduler.config.timelineStep,
                    x_start: scheduler.config.timelineStart,
                    x_size: scheduler.config.timelineSize,
                    y_unit: [],
                    y_property: "section_id",
                    render: "bar",
                    section_autoheight: false,
                    dx: 100,
                    dy: 30 //min-height
                });
                scheduler.init('scheduler_here', new Date(), 'timeline');
                //don't allow dragging of activities...
                scheduler.attachEvent('onBeforeDrag', function () {
                    return false;
                });
                //don't allow double clicking to create activity
                scheduler.config.dblclick_create = false;

                scheduler.templates.day_date = function (dt) {
                    return activityUtility.formatLongDate(dt);
                };

                var self = this;

                //To support rerender timeline view with different times on click of buttons
                dojo.query(".dhx_cal_prev_timeline_button").connect("onclick", function () {
                    if (!scheduler.config.timelineStart == 0) {
                        self.reRenderTimeline('left');
                    }
                });
                dojo.query(".dhx_cal_next_timeline_button").connect("onclick", function () {
                    if (scheduler.config.timelineStart + scheduler.config.timelineSize < 48) {
                        self.reRenderTimeline('right');
                    }
                });
                this._schedulerInitialized = true;
            }
            scheduler.clearAll();
        },

        _loadAttendeesData: function () {
            this._availabilityShowing = true;
            if (this.mode === 'New' || this.mode === 'CompleteUnscheduled') {
                //create a mock attendee for the leader so it can be loaded into the list...
                var ldr = this.lup_Leader.get('selectedObject');
                var leaderName = ldr['$descriptor'],
                    leaderId = ldr['$key'].substr(0, 12);
                this.addMembers([
                    {
                        $descriptor: leaderName,
                        $key: leaderId,
                        IsLocation: false,
                        Name: leaderName,
                        Subtype: '',
                        Type: 'User'
                    }
                ]);
                return;
            }
            var actid = this.activityId;
            if (!actid && this._activityData) {
                actid = this._activityData.$key;
            }
            if (!actid) {
                console.warn('could not find activityid for query to get attendee data');
                return;
            }
            var realActivityId = actid.substr(0, 12);

            var req = new Sage.SData.Client.SDataNamedQueryRequest(Sage.Data.SDataServiceRegistry.getSDataService('mashups'))
                .setApplicationName('$app')
                .setResourceKind('mashups')
                .setQueryName('execute')
                .setQueryArg('_resultName', 'GetMembers')
                .setQueryArg('_activityId', realActivityId);
            req.uri.setCollectionPredicate("'ActivityFreeBusy'");
            req.read({
                success: dojo.hitch(this, this._onReceiveAttendees),
                failure: dojo.hitch(this, this._availabilityFailed)
            });
        },
        _attendeesTemplate: new Simplate([
            '<table class="attendee-item">',
            '<tr>',
            '<td class="attendee-name">{%= $.name %}</td>',
            '{% if (($.isNotLeader) && ($.allowDelete)) { %}',
            '<td class="remove-attendee" id="{%= $.id %}"><img src="images/icons/Delete_16x16.png" alt="{%= $.removeText %}" title="{%= $.removeText %}" onclick="{%= $.deleteCode %}" /></td>',
            '{% } %}',
            '<td class="attendee-status"><img src="{%= $.img %}" alt="{%= $.imgToolTipText %}" title="{%= $.imgToolTipText %}"/></td>',
            '</tr>',
            '</table>'
        ]),
        _onReceiveAttendees: function (data) {
            this._attendeesData = data['$resources'];
            //if the leader has changed since the dialog opened, the old leader will need to be removed from this list...
            if (this._originalLeaderId && this._originalLeaderId !== this._activityData.Leader['$key']) {
                var len = this._attendeesData.length;
                for (var i = 0; i < len; i++) {
                    if (this._attendeesData[i]['id'] === this._originalLeaderId) {
                        this._attendeesData.splice(i, 1);
                        break;
                    }
                }
            }
            this._rebuildTimeLine();
            this._requestAvailability();
        },
        _rebuildTimeLine: function (scrollDirection) {
            var i;
            for (i = 0; i < this._deleteAttendeeConnects.length; i++) {
                dojo.disconnect(this._deleteAttendeeConnects[i]);
            }
            this._deleteAttendeeConnects = [];
            var yUnits = [];
            var leaderYUnit = {
            };
            var memberUnits = [];
            var resourceUnits = [];
            var leaderId = this._activityData.Leader['$key'].trim();
            var deleteCode = "Sage.Utility.Activity.removeMember('${0}','${1}');";
            for (i = 0; i < this._attendeesData.length; i++) {
                var img = this._blankGif;
                var imgToolTipText = "";
                var status = this._attendeesData[i]['status'] || 0;
                if (status === 1 || status === 'asAccepted') {
                    img = 'images/icons/Accept.png';
                    imgToolTipText = this.acceptedText;
                } else if (status === 2 || status === 'asDeclned') {
                    img = 'images/icons/Decline.png';
                    imgToolTipText = this.declinedText;
                }
                var yUnit = {
                    key: this._attendeesData[i]['id'],
                    label: this._attendeesTemplate.apply({
                        name: this._attendeesData[i]['name'],
                        img: img,
                        imgToolTipText: imgToolTipText,
                        id: this._attendeesData[i]['id'],
                        isNotLeader: this._attendeesData[i]['id'].trim() !== leaderId,
                        allowDelete: this._canEdit(),
                        removeText: this.removeText,
                        deleteCode: dojo.string.substitute(deleteCode, [this.id, this._attendeesData[i]['id']])
                    })
                };
                if (this._attendeesData[i]['id'].trim() === leaderId) {
                    leaderYUnit = yUnit;
                } else if (this._attendeesData[i]['type'] === 'user') {
                    memberUnits.push(yUnit);
                } else {
                    resourceUnits.push(yUnit);
                }
            }
            yUnits = (leaderYUnit.key) ? [leaderYUnit].concat(memberUnits.concat(resourceUnits)) : memberUnits.concat(resourceUnits);
            for (i = 0; i < this._newAttendeesData.length; i++) {

                yUnits.push({
                    key: this._newAttendeesData[i]['$key'],
                    label: this._attendeesTemplate.apply({
                        name: this._newAttendeesData[i]['Name'],
                        img: this._blankGif,
                        id: this._newAttendeesData[i]['$key'],
                        isNotLeader: this._newAttendeesData[i]['$key'].trim() !== leaderId,
                        allowDelete: this._canEdit(),
                        removeText: this.removeText,
                        deleteCode: dojo.string.substitute(deleteCode, [this.id, this._newAttendeesData[i]['$key']])
                    })
                });
            }

            if (scrollDirection == "left") {
                if ((scheduler.config.timelineStart - scheduler.config.timelineSize) > 0) {
                    scheduler.config.timelineStart = scheduler.config.timelineStart - scheduler.config.timelineSize;
                } else {
                    scheduler.config.timelineStart = 0;
                }
            } else if (scrollDirection == "right") {
                var st = (scheduler.config.timelineSize + scheduler.config.timelineStart);
                if (st > (48 - scheduler.config.timelineSize)) {
                    scheduler.config.timelineStart = 48 - scheduler.config.timelineSize;
                } else {
                    scheduler.config.timelineStart = st;
                }
            }
            this._setTimePatternForDHTMLXLibrary();
            scheduler.createTimelineView({
                name: "timeline",
                x_unit: "minute",
                x_date: this._DHTMLXLibraryTimePattern,
                x_step: scheduler.config.timelineStep,
                x_start: scheduler.config.timelineStart,
                x_size: scheduler.config.timelineSize,
                //x_length:  96,  //show the whole day
                y_unit: yUnits,
                y_property: "section_id",
                render: "bar",
                section_autoheight: false,
                dx: 100,
                dy: 30 //min-height
            });

            scheduler.setCurrentView(this._getActivityStartDate(), 'timeline');
        },
        _updateLocation: function (newLocation, isAdd) {
            var location = this._activityData.Location;
            if (!location || location === '') {
                if (isAdd) {
                    location = newLocation;
                }
            } else {
                var parts = location.split('; ');
                var newParts = [];
                var exists = false;
                for (var i = 0; i < parts.length; i++) {
                    if (parts[i] === newLocation) {
                        if (isAdd) {
                            exists = true;
                        } else {
                            continue;
                        }
                    }
                    newParts.push(parts[i]);
                }
                if (!exists && isAdd) {
                    newParts.push(newLocation);
                }
                location = newParts.join('; ');
            }
            Sage.Utility.setValue(this._activityData, 'Location', location);
            this.tb_Location.set('value', location);
        },
        _removeMember: function (args) {
            var i;
            var id = args.memberId;
            var lst = [];
            for (i = 0; i < this._attendeesData.length; i++) {
                if (this._attendeesData[i]['id'] === id) {
                    if (this._attendeesData[i]['type'] === 'resource' && this._attendeesData[i]['IsLocation']) {
                        this._updateLocation(this._attendeesData[i]['name'], false); //sending false removes it from the location...
                    }
                    this._attendeesForRemoval.push(this._attendeesData[i]);
                } else {
                    lst.push(this._attendeesData[i]);
                }
            }
            this._attendeesData = lst;
            lst = [];
            for (i = 0; i < this._newAttendeesData.length; i++) {
                if (this._newAttendeesData[i]['$key'] === id) {
                    if (this._newAttendeesData[i]['Type'] === 'Resource' && this._newAttendeesData[i]['IsLocation'] === true) {
                        this._updateLocation(this._newAttendeesData[i]['Name'], false); //sending false removes it from the location...
                    }
                } else {
                    lst.push(this._newAttendeesData[i]);
                }
            }
            this._newAttendeesData = lst;
            this._rebuildTimeLine();

            //MAA update
            if (!args.attendeesTab) {
                this.attendeesTab._removeAssociatedContact(args.memberId);
            }
        },
        addMembers: function (items) {
            //this._requestAvailability();
            /* sample return obj...
            [{
                $descriptor: 'Lois Tomlin',  //and other sdata fields...
                $key: 'UDEMO...',
                IsLocation: false,
                Name: 'Lois Tomlin',
                Subtype: '....',
                Type: 'User'
                },{
                $descriptor: 'Room 10',
                $key: 'RDEMO...',
                IsLocation: true,
                Name: 'Room 10',
                Subtype: '....',
                Type: 'Resource'
            }]
            */
            var userIds = [];
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                if (item['$key'].length > 12) {
                    item['$key'] = item['$key'].substr(0, 12);
                }
                if (this._isMember(item)) {
                    continue;
                }
                if (item['ResourceId']) {
                    item['$key'] = item['ResourceId'];
                }
                if (item['Type'] === 'Resource' && item['IsLocation'] === true) {
                    this._updateLocation(item['Name'], true);
                }
                userIds.push(item['$key']);
                this._newAttendeesData.push(item);
            }
            if (this._availabilityShowing) {
                this._rebuildTimeLine();
                this._requestAvailability();
            }
            this.attendeesTab._addContactAttendees(userIds);
        },
        _isMember: function (newMember) {
            var i, len = this._attendeesData.length;
            for (i = 0; i < len; i++) {
                if (this._attendeesData[i]['id'] === newMember['$key']) {
                    return true;
                }
            }
            len = this._newAttendeesData.length;
            for (i = 0; i < len; i++) {
                if (this._newAttendeesData[i]['$key'] === newMember['$key']) {
                    return true;
                }
            }
            return false;
        },
        _updateUsersListWithNewLeader: function (oldLeaderId, newLeader) {
            //remove the old one...
            var i, len = this._attendeesData.length;
            for (i = 0; i < len; i++) {
                if (this._attendeesData[i]['id'] === oldLeaderId) {
                    this._attendeesData.splice(i, 1);
                    break;
                }
            }
            len = this._newAttendeesData.length;
            for (i = 0; i < len; i++) {
                if (this._newAttendeesData[i]['$key'] === oldLeaderId) {
                    this._newAttendeesData.splice(i, 1);
                    break;
                }
            }
            //add the new one...
            this.addMembers([
                {
                    $descriptor: newLeader['$descriptor'],
                    $key: newLeader['$key'],
                    IsLocation: false,
                    Name: newLeader['$descriptor'],
                    Subtype: '',
                    Type: 'User'
                }
            ]);
        },
        _requestAvailability: function () {
            if (this._attendeesData.length < 1 && this._newAttendeesData.length < 1) {
                return;
            }
            var quotedIds = [];
            for (var i = 0; i < this._attendeesData.length; i++) {
                quotedIds.push('\'' + this._attendeesData[i]['id'] + '\'');
            }
            for (i = 0; i < this._newAttendeesData.length; i++) {
                quotedIds.push('\'' + this._newAttendeesData[i]['$key'] + '\'');
            }
            if (this._availabilityDataDateRange.fromDate) {
                //do we already have the data for these users for this date range?
                var startDate = Sage.Utility.Convert.toDateFromString(this._activityData['StartDate']);
                if ((startDate > this._availabilityDataDateRange.fromDate)
                    && (startDate < this._availabilityDataDateRange.toDate)
                    && (quotedIds.join('') === this._availabilityDataDateRange.users.join(''))) {
                    return;
                }
            }
            this._requestAvailabilityFor(quotedIds);
        },
        _availabilityDataDateRange: {
            fromDate: false,
            toDate: false,
            users: []
        },
        _requestAvailabilityFor: function (quotedIds) {
            var startDate = Sage.Utility.Convert.toDateFromString(this._activityData['StartDate']);
            var fromDate = dojoDate.add(startDate, 'day', -7);
            var toDate = dojoDate.add(startDate, 'day', 7);

            this._availabilityDataDateRange.fromDate = fromDate;
            this._availabilityDataDateRange.toDate = toDate;
            this._availabilityDataDateRange.users = quotedIds;

            var actsvc = Sage.Services.getService('ActivityService');
            if (actsvc) {
                var options = {
                    quotedIds: quotedIds,
                    startDate: fromDate,
                    endDate: toDate,
                    expandRecurrences: true,
                    includeTimless: false,
                    timelessOnly: false
                };
                actsvc.getActivityFreeBusyFor(this, options, this._onReceiveAvailability, this._availabilityFailed);
            }

        },
        _onReceiveAvailability: function (data) {
            this._availabilityData = data['$resources'];
            this._applyAvailability();
        },
        _applyAvailability: function () {
            scheduler.clearAll();
            for (var i = 0; i < this._availabilityData.length; i++) {
                var item = this._availabilityData[i];
                if (item.type === 262162 && item.itemId !== this._currentUserId) {
                    item['description'] = activityUtility.getActivityTypeName('atPersonal');
                }
                var isCurrentEvent = (item["activityId"] == this.activityId) ? true : false;
                var stDate = Sage.Utility.Convert.toDateFromString(item['startDate']);
                var eDate = dojoDate.add(stDate, 'minute', item['duration']);
                scheduler.addEvent(stDate, eDate, item['description'], null, {
                    section_id: item['itemId'], activity_Id: item['activityId'], current_event: isCurrentEvent
                });
            }
        },
        reRenderTimeline: function (direction) {
            this._rebuildTimeLine(direction);
            this._applyAvailability();
        },

        _availabilityFailed: function (req, msg) {
            console.warn('Availability request failed.');
        },

        //end Availability tab...

        //Recurring tab functionality...

        _recurringStartDateChanged: function (newStart) {
            var stDate = this.dtp_startDate.get('value');
            if (newStart.getMonth() === stDate.getMonth() &&
                newStart.getDate() === stDate.getDate() &&
                newStart.getFullYear() === stDate.getFullYear()) {
                return;
            }
            if (this._activityData.StartDate) {
                var currentStartDateHrs = Sage.Utility.Convert.toDateFromString(this._activityData.StartDate).getHours();
                var currentStartDateMins = Sage.Utility.Convert.toDateFromString(this._activityData.StartDate).getMinutes();
                newStart.setHours(currentStartDateHrs);
                newStart.setMinutes(currentStartDateMins);
            }
            this._activityData.StartDate = (newStart.getFullYear) ? utility.Convert.toIsoStringFromDate(newStart) : newStart;
            this.dtp_startDate.set('value', newStart);
            this._startDateChanged();
        },
        _recurringPeriodChanged: function (newPeriod) {
            this._handleAutoRolloverState();
        },
        _isOccurence: function () {
            if (this.activityId.length > 12) {
                return true;
            }
            return false;
        },
        _canEdit: function () {
            if ((this.mode === 'Confirm') || (!this._activityData.AllowEdit) || this._isOccurence()) {
                return false;
            }
            return true;
        },
        _setTimePatternForDHTMLXLibrary: function(){
            /* https://docs.dhtmlx.com/scheduler/settings_format.html
            The time related formats, we interestd in are
            %g - the hour based on the 12-hour clock without a leading zero ( 1 to 12 );
            %G - the hour based on the 24-hour clock without a leading zero ( 0 to 23 ); 
            %A - displays AM (for times from midnight until noon) and PM (for times from noon till midnight).
            */
            var shortTimeFormat = Sys.CultureInfo.CurrentCulture.dateTimeFormat.ShortTimePattern;
            var is24HrFormat = shortTimeFormat.indexOf('H') !== -1;
            if (!is24HrFormat) {
                // Use am & pm.
                this._DHTMLXLibraryTimePattern = '%g:%i %a';
            } else {
                this._DHTMLXLibraryTimePattern = '%G:%i';
            }            
        },
        _emptyActivity: {
            "$key": "",
            "AccountId": null,
            "AccountName": "",
            "ActivityBasedOn": null,
            "Alarm": false,
            "AlarmTime": utility.Convert.toIsoStringFromDate(new Date()),
            "Attachment": false,
            "Category": null,
            "ContactId": null,
            "ContactName": "",
            "CreateDate": "",
            "CreateUser": "",
            "Description": "",
            "Duration": 15,
            "ForeignId1": null,
            "ForeignId2": null,
            "ForeignId3": null,
            "ForeignId4": null,
            "LeadId": null,
            "LeadName": "",
            "LongNotes": null,
            "Notes": null,
            "OpportunityId": null,
            "OpportunityName": null,
            "OriginalDate": "",
            "PhoneNumber": "",
            "Priority": null,
            "ProcessId": null,
            "ProcessNode": null,
            "ProjectId": null,
            "RecurIterations": 0,
            "RecurPeriod": 0,
            "RecurPeriodSpec": 0,
            "Recurring": false,
            "RecurSkip": "",
            "Rollover": false,
            "StartDate": utility.Convert.toIsoStringFromDate(new Date()),
            "TicketId": null,
            "TicketNumber": null,
            "Timeless": false,
            "Type": "atAppointment",
            "UserDef1": null,
            "UserDef2": null,
            "UserDef3": null,
            "AttachmentCount": null,
            "Location": null,
            "EndDate": "",
            "Resources": {},
            "Leader": { "$key": "" },
            "UserActivities": {},
            "UserNotifications": {}
        }
    });
    return activityEditor;
});
},
'Sage/_Templated':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
        'dojo/dom-construct',
        'dojo/_base/declare',
        'dojo/query',
        'dojo/parser',
        'dojo/_base/array',
        'dojo/_base/lang',
        'dijit/registry',
        'dijit/_base/wai'
],
function(domConstruct, declare, query, parser, array, lang, registry, wai) {
    // not inheriting from dijit._Templated, but using similar functionality.
    // this is required for contentTemplate to work property.
    var templated = declare('Sage._Templated', null, {
        constructor: function () {
            this._attachPoints = [];
            this._attachEvents = [];
        },
        buildRendering: function () {
            var root, domString;
            if (this.widgetTemplate && this.contentTemplate) {
                throw new Error('Both "widgetTemplate" and "contentTemplate" cannot be specified at the same time.');
            }
            
            if (this.contentTemplate) {
                this.inherited(arguments);
                domString = ['<div>', this.contentTemplate.apply(this), '</div>'].join('');
                root = domConstruct.toDom(domString);
                this._attachTemplateNodes(root);
            } else if (this.widgetTemplate) {
                domString = this.widgetTemplate.apply(this);
                root = domConstruct.toDom(domString);
                if (root.nodeType !== 1) {
                    throw new Error('Invalid template.');
                }

                this.domNode = root;
                this._attachTemplateNodes(root);
            } else {
                return;
            }

            if (this.widgetsInTemplate) {
                // Store widgets that we need to start at a later point in time
                var widgetsToAttach = parser.parse(root, {
                    noStart: !this._earlyTemplatedStartup,
                    template: true,          //1.6 addition
                    inherited: {dir: this.dir, lang: this.lang},
                    propsThis: this,         //1.6 addition - so data-dojo-props of widgets in the template can reference "this" to refer to me
                    scope: 'dojo'  //1.6 addition - even in multi-version mode templates use dojoType/data-dojo-type
                });

                this._startupWidgets = this._startupWidgets || [];
                this._startupWidgets = this._startupWidgets.concat(widgetsToAttach);

                this._supportingWidgets = this._supportingWidgets || [];
                this._supportingWidgets = this._supportingWidgets.concat(registry.findWidgets(root));

                this._attachTemplateNodes(widgetsToAttach, function(n, p) {
                    return n[p];
                });
            }

            if (this.contentTemplate) {
                query('> *', root).place(this.domNode);
            } else {
                this._fillContent(this.srcNodeRef);
            }
        },
        _fillContent: function(/*DomNode*/ source){
            // summary:
            //      Relocate source contents to templated container node.
            //      this.containerNode must be able to receive children, or exceptions will be thrown.
            // tags:
            //      protected
            var dest, frag, hasChildren;

            dest = this.containerNode;
            frag = document.createDocumentFragment();
            hasChildren = false;
            if(source && dest){
                while(source.hasChildNodes()){
                    frag.appendChild(source.firstChild);
                    hasChildren = true;
                }

                if (hasChildren) {
                    dest.appendChild(frag);
                }
            }
        },
        _attachTemplateNodes: function(rootNode, getAttrFunc){
            // summary:
            //		Iterate through the template and attach functions and nodes accordingly.
            // description:
            //		Map widget properties and functions to the handlers specified in
            //		the dom node and it's descendants. This function iterates over all
            //		nodes and looks for these properties:
            //			* dojoAttachPoint
            //			* dojoAttachEvent
            //			* waiRole
            //			* waiState
            // rootNode: DomNode|Array[Widgets]
            //		the node to search for properties. All children will be searched.
            // getAttrFunc: Function?
            //		a function which will be used to obtain property for a given
            //		DomNode/Widget
            // tags:
            //		private

            getAttrFunc = getAttrFunc || function (n,p){ return n.getAttribute(p); };

            var nodes = (rootNode instanceof Array) ? rootNode : (rootNode.all || rootNode.getElementsByTagName("*"));
            var x = (rootNode instanceof Array) ? 0 : -1;
            for (; x<nodes.length; x++) {
                var baseNode = (x == -1) ? rootNode : nodes[x];
                if(this.widgetsInTemplate && (getAttrFunc(baseNode, "dojoType") || getAttrFunc(baseNode, "data-dojo-type"))){
                    continue;
                }
                // Process dojoAttachPoint
                //var attachPoint = getAttrFunc(baseNode, "dojoAttachPoint");
                var attachPoint = getAttrFunc(baseNode, "dojoAttachPoint") || getAttrFunc(baseNode, "data-dojo-attach-point");
                if (attachPoint) {
                    var point, points = attachPoint.split(/\s*,\s*/);
                    while ((point = points.shift())){
                        if (this[point] instanceof Array) {
                            this[point].push(baseNode);
                        } else {
                            this[point]=baseNode;
                        }
                        
                        this._attachPoints.push(point);
                    }
                }

                // Process dojoAttachEvent
                //var attachEvent = getAttrFunc(baseNode, "dojoAttachEvent");
                var attachEvent = getAttrFunc(baseNode, "dojoAttachEvent") || getAttrFunc(baseNode, "data-dojo-attach-event");
                if (attachEvent) {
                    // NOTE: we want to support attributes that have the form
                    // "domEvent: nativeEvent; ..."
                    var event, events = attachEvent.split(/\s*,\s*/);
                    var trim = lang.trim;
                    while((event = events.shift())){
                        if(event){
                            var thisFunc = null;
                            if(event.indexOf(":") != -1){
                                // oh, if only JS had tuple assignment
                                var funcNameArr = event.split(":");
                                event = trim(funcNameArr[0]);
                                thisFunc = trim(funcNameArr[1]);
                            }else{
                                event = trim(event);
                            }
                            if(!thisFunc){
                                thisFunc = event;
                            }
                            //this.connect(baseNode, event, thisFunc);
                            this._attachEvents.push(this.connect(baseNode, event, thisFunc));
                        }
                    }
                }

                // waiRole, waiState
                // TODO: remove this in 2.0, templates are now using role=... and aria-XXX=... attributes directicly
                var role = getAttrFunc(baseNode, "waiRole");
                if (role) {
                    wai.setWaiRole(baseNode, role);
                }
                
                var values = getAttrFunc(baseNode, "waiState");
                if (values){
                    array.forEach(values.split(/\s*,\s*/), function(stateValue){
                        if(stateValue.indexOf('-') != -1){
                            var pair = stateValue.split('-');
                            wai.setWaiState(baseNode, pair[0], pair[1]);
                        }
                    });
                }
            }
        },
        startup: function(){
            array.forEach(this._startupWidgets, function(w){
                if(w && !w._started && w.startup){
                    w.startup();
                }
            });
            this.inherited(arguments);
        },
        destroyRendering: function(){
            // Delete all attach points to prevent IE6 memory leaks.
            array.forEach(this._attachPoints, function(point) {
                delete this[point];
            }, this);
            this._attachPoints = [];

			// And same for event handlers
			array.forEach(this._attachEvents, this.disconnect, this);
			this._attachEvents = [];

            this.inherited(arguments);
        }

    });

    return templated;
});

},
'Sage/Data/SingleEntrySDataStore':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
        'Sage/Data/BaseSDataStore',
        'Sage/Utility',
        'dojo/_base/declare'
],
function (BaseSDataStore, Utility, declare) {
    var singleEntrySDataStore = declare('Sage.Data.SingleEntrySDataStore', BaseSDataStore, {
        _entity: false,
        _request: false,
        _okToCache: true,
        postMixInProperties: function () {
        },
        getFeed: function (predicate) {
        },
        fetch: function (context) {
            if (context.queryOptions && context.queryOptions.currentEntity && this._entity) {
                this.returnCollectionProperty(context, context.queryOptions.property);
                return;
            }

            this.verifyService();
            var request = this._getRequest();
            if (context.predicate) {
                if (this._entity && (context.predicate === this._entity.$key) && this._okToCache) {
                    if (context.onComplete) {
                        context.onComplete.call(context.scope || this, this._entity, context);
                        return;
                    }
                }
                request.setResourceSelector(context.predicate);
            }

            if (this.select && this.select.length > 0)
                request.setQueryArg('select', this.select.join(','));
            if (this.include && this.include.length > 0)
                request.setQueryArg('include', this.include.join(','));
            if (this.predicate && this.predicate.length > 0) {
                request.setResourceSelector(this.predicate);
            }

            if (context.beforeRequest) {
                context.beforeRequest.call(context.scope || this, request);
            }
            request.read({
                success: dojo.hitch(this, this.onSuccess, context),
                failure: dojo.hitch(this, this.onFailure, context)
            });
        },
        save: function (options) {
            if (this._request && this._entity) {
                options.ignoreETag = Utility.isTrue(options.ignoreETag) ? options.ignoreETag : this.ignoreETag;
                this._okToCache = false;
                this._request.update(this._entity, options);
            }
        },
        setValue: function (item, attribute, value) {
            var entity = item || this._entity;
            if (entity) {
                var oldValue = this.getValue(entity, attribute, '');
                Utility.setValue(entity, attribute, value);
                this.onSet(entity, attribute, oldValue, value);
            }
        },
        getCurrentEntity: function () {
            return this._entity;
        },
        newItem: function (args /*, parentInfo */) {
            var request = new Sage.SData.Client.SDataTemplateResourceRequest(this.service);
            request.setResourceKind(this.resourceKind);
            request.read({
                success: function (entry) {
                    this._entity = entry;
                    if ((args.onComplete) && (typeof args.onComplete === 'function')) {
                        args.onComplete.call(args.scope || this, entry);
                    }
                },
                failure: function (err) {
                    if (args.onError) {
                        args.onError.call(args.scope || this, err);
                    }
                },
                scope: this
            });
        },
        saveNewEntity: function (entity, success, failure, scope, beforePost) {
            if (!entity) {
                entity = this._entity;
            }
            var request = new Sage.SData.Client.SDataSingleResourceRequest(this.service);
            request.setResourceKind(this.resourceKind);
            if (beforePost) {
                beforePost.call(scope || this, request, entity);
            }
            request.create(entity, {
                success: success || function (created) {
                    if (typeof console !== 'undefined') {
                        console.log('created item: ' + created.$key);
                    }
                },
                failure: failure || function (response, o) {
                    if (typeof console !== 'undefined') {
                        console.log('Item not created: ' + entity.$key);
                    }
                },
                scope: scope || this
            });
        },
        deleteEntity: function (entity, success, failure, scope) {
            entity = entity || this._entity;
            if (entity) {
                var request = new Sage.SData.Client.SDataSingleResourceRequest(this.service);
                request.setResourceKind(this.resourceKind);
                request.setResourceSelector("'" + entity['$key'] + "'");
                request['delete'](entity, {
                    success: success || function (result) {
                        if (typeof console !== 'undefined') {
                            console.log('item was successfully deleted. ' + result); }
                    },
                    failure: failure || function (response) {
                        if (typeof console !== 'undefined') {
                            console.log('Item not deleted: ' + entity.$key);
                        }
                    },
                    scope: scope || this
                });
            }
        },
        clearCache: function () {
            this._entity = false;
        },
        _getRequest: function () {
            if (!this._request) {
                var req = new Sage.SData.Client.SDataSingleResourceRequest(this.service);
                req.setResourceKind(this.resourceKind);
                this._request = req;
            }
            return this._request;
        },
        returnCollectionProperty: function (context, propertyName) {
            if (this._entity && this._entity.hasOwnProperty(propertyName)) {
                var list = this._entity[propertyName].$resources;
                if (typeof list !== 'unknown') {// jshint ignore:line
                    if (context.onBegin) {
                        context.onBegin.call(context.scope || this, list.length, context);
                    }
                    if (context.onComplete) {
                        context.onComplete.call(context.scope || this, list, context);
                    }
                }
            }
        },
        onSuccess: function (options, data) {
            if (data) {
                this._okToCache = true;
                this._entity = data;
                if (options.onComplete) {
                    options.onComplete.call(options.scope || this, data, options);
                }
            } else {
                if (options.onError) {
                    options.onError.call(options.scope || this, 'invalid feed', options);
                }
            }
        },
        onFailure: function (options, request, requestOptions) {
            this._entity = false;
            if (options.onError) {
                options.onError.call(options.scope || this, request.responseText, options);
            }
        },
        onSet: function (item, attribute, oldValue, value) { }
    });
    return singleEntrySDataStore;
});

},
'Sage/MainView/BindingsManager':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dijit/_Widget',
    'dojo/_base/declare',
    'Sage/Utility/Activity'
],
function (_Widget, declare, activityUtility) {
    var dataBinding = declare('Sage.MainView.DataBinding', _Widget, {
        boundEntity: false,
        boundWidget: false,
        widgetEvent: 'onChange',
        widgetProperty: 'value',
        entityProperty: false,
        defaultValue: '',
        // if twoWay is true, when the user changes the value in the control, 
        // it will update the bound entity.  If it is false, it will not listen
        // for changes in the control.
        twoWay: true,
        _connection: false,
        bind: function () {
            if (this.boundWidget && this.boundEntity && this.entityProperty) {
                this.boundWidget.set(this.widgetProperty, this._formatValueFromEntity(Sage.Utility.getValue(this.boundEntity, this.entityProperty, this.defaultValue)));
                if (this.twoWay && !this._connection) {
                    this._connection = dojo.connect(this.boundWidget, this.widgetEvent, dojo.hitch(this, 'applyWidgetChange', this.boundWidget));
                }
            }
        },
        _formatValueFromEntity: function (val) {
            //override this function to handle special formatting such as dates or other data type conversions.
            return val;
        },
        applyWidgetChange: function (widget, newValue) {
            if (!newValue) {
                newValue = widget.get(this.widgetProperty);
            }
            var oldValue = Sage.Utility.getValue(this.boundEntity, this.entityProperty);
            var formatted = this._formatValueFromControl(newValue);
            if (oldValue != formatted) {
                //console.log('setting new value to entity' + this.entityProperty + ': %o  %o', this.boundEntity, newValue);
                Sage.Utility.setValue(this.boundEntity, this.entityProperty, formatted);
                this.onChange(this.boundEntity, this.entityProperty, oldValue, newValue);
            }
        },
        _formatValueFromControl: function (val) {
            //override this function to handle special formatting such as dates or other data type conversions.
            return val;
        },
        _setBoundEntityAttr: function (entity) {
            this.boundEntity = entity;
            this.bind();
        },
        destroy: function () {
            dojo.disconnect(this._connection);
            this.inherited(arguments);
        },
        onChange: function (entity, propertyName, oldValue, newValue) {

        }
    });
    var dateDataBinding = declare('Sage.MainView.DateDataBinding', dataBinding, {
        //Use this type of databinding when the value needs to be converted to and from SData standard string formats
        // to date types for the controls.
        _formatValueFromEntity: function (val) {
            var dateval = Sage.Utility.Convert.toDateFromString(val);
            if (dateval && activityUtility.isDateFiveSecondRuleTimeless(dateval)) {
                dateval = new Date(dateval.getUTCFullYear(), dateval.getUTCMonth(), dateval.getUTCDate(), 0, 0, 5);
            }
            return dateval;
        },
        _formatValueFromControl: function (val) {
            if (!val || !val.getUTCFullYear) {
                val = this.boundWidget.get(this.widgetProperty);
                if (!val || !val.getUTCFullYear) {
                    return '';
                }
            }
            return Sage.Utility.Convert.toIsoStringFromDate(val);
        }
    });

    var bindingManager = declare('Sage.MainView.BindingsManager', null, {
        constructor: function (opts) {
            //_entity: false,
            this._bindings = [];
            this._connections = [];
            this.boundEntity = false;
            this._defaultBindingOptions = {
                boundEntity: false,
                boundWidget: false,
                widgetEvent: 'onChange',
                widgetProperty: 'value',
                entityProperty: false,
                defaultValue: '',
                twoWay: true,
                dataType: 'string'
            };

            var o = opts || {};
            var def = dojo.mixin(this._defaultBindingOptions, o.defaultBinding || {});
            var bdgs = o.items || [];
            for (var i = 0; i < bdgs.length; i++) {
                this._addNew(dojo.mixin({}, def, bdgs[i]));
            }
        },
        add: function (binding) {
            if (binding instanceof Sage.MainView.DataBinding) {
                this._connections.push(dojo.connect(binding, 'onChange', this, 'onChange'));
                this._bindings.push(binding);
            }
        },
        _addNew: function (bindingConfig) {
            if (bindingConfig.dataType === 'date') {
                this.add(new dateDataBinding(bindingConfig));
            } else {
                this.add(new dataBinding(bindingConfig));
            }
        },
        addBindings: function (configs) {
            if (dojo.isArray(configs)) {
                for (var i = 0; i < configs.length; i++) {
                    this._addNew(dojo.mixin(this._defaultBindingOptions, configs[i]));
                }
            } else {
                this._addNew(dojo.mixin(this._defaultBindingOptions, configs));
            }
        },
        bind: function () {
            for (var i = 0; i < this._bindings.length; i++) {
                if (this._bindings[i] instanceof Sage.MainView.DataBinding) {
                    this._bindings[i].bind();
                }
            }
        },
        setBoundEntity: function (entity) {
            this._entity = entity;
            for (var i = 0; i < this._bindings.length; i++) {
                if (this._bindings[i] instanceof Sage.MainView.DataBinding) {
                    this._bindings[i].set('boundEntity', entity);  //it binds itself in its setter...
                }
            }
        },
        destroy: function () {
            // disconnect change listeners...
            var i, l = this._connections.length;
            for (i = 0; i < l; i++) {
                dojo.disconnect(this._connections[i]);
            }
            this._connections = [];
            //destroy bindings...
            l = this._bindings.length;
            for (i = 0; i < l; i++) {
                var item = this._bindings.pop();
                item.destroy();
            }
            this._bindings = [];
            //this.inherited(arguments);
        },
        onChange: function (entity, propertyName, oldValue, newValue) {
        }
    });

    return bindingManager;
});
},
'Sage/Utility/Activity':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/date/locale',
    'dojox/grid/cells/_base',
    'Sage/Utility',
    'dojo/string',
    'dojo/i18n!./nls/Activity',
    'dojo/_base/declare',
    'Sage/Data/SDataServiceRegistry',
    'Sage/Data/SingleEntrySDataStore'
],
function (dateLocale, cell, utility, dstring, nlsStrings, declare, sDataServiceRegistry, SingleEntrySDataStore) {
    var isValidId = function (id) {
        var valid = false;
        if (id) {
            if (id.trim() !== '') {
                valid = true;
            }
        }
        return valid;
    };
    var typeCell = declare("Sage.Utility.Activity.TypeCell", dojox.grid.cells.Cell, {
        format: function (value, inItem) {
            //console.log('index: ' + inRowIndex + '   item: %o', inItem);
            if (!inItem) {
                return this.defaultValue;
            }
            var type = '';
            if (typeof value === 'number') {
                type = this.get(value, inItem);
            } else {
                type = value;
            }
            var activity = (inItem.hasOwnProperty('Activity') && typeof inItem['Activity'] === 'object') ? inItem.Activity : inItem;
            var key = utility.getValue(activity, "$key");
            var confStatus = (inItem.hasOwnProperty('Status')) ? inItem.Status : false;
            var fmtStr = '<span onclick="${0}" class="activity-type-link" ><div class="Global_Images icon16x16 ${1}" title="${2}"></div>&nbsp;${2}</span>';

            //Determine the recurrnece context, se we pass the correct recurring flag so that the reocrrnce dlg will be not be shown if there is no ending to the reocurrnce. 
            var reocState = Sage.Utility.getValue(activity, 'RecurrenceState');
            var recurring = Sage.Utility.Activity._getReccurenceFlag(activity);
            //typically, we will want to edit the activity
            var href = 'javascript:Sage.Link.editActivity(\'' + key + '\', ' + recurring + ')';
            if (confStatus) {
                var curUser = utility.getClientContextByKey('userID');
                //assume the current user is who the useractivity is for...
                var actUser = (inItem.hasOwnProperty['User']) ? inItem.User['$key'] : curUser;
                //if the current user has not confirmed the activity, then they need to confirm it before editing.
                if (confStatus === 'asUnconfirmed' && curUser === actUser) {
                    href = 'javascript:Sage.Link.confirmActivityFor(\'' + key + '\', \'' + curUser + '\')';
                }
            } else {
                //if we don't know if the user has confirmed or not, let the activity service check...
                href = 'javascript:Sage.Link.editActivityIfConfirmed(\'' + key + '\', ' + recurring + ')';
            }
            return dstring.substitute(fmtStr, [href, Sage.Utility.Activity.getActivityImageClass(type, 'small'), Sage.Utility.Activity.getActivityTypeName(type)]);
        }
    });
    var historyTypeCell = declare('Sage.Utility.Activity.HistoryTypeCell', dojox.grid.cells.Cell, {
        format: function (value, inItem) {
            if (!inItem) {
                return this.defaultValue;
            }
            var key = utility.getValue(inItem, '$key');
            var typeValue = utility.getValue(inItem, 'Type');
            var typeDisp = "";
            var type = "";
            if (typeValue.toString().substring(0, 2) === "at") {
                typeDisp = Sage.Utility.Activity.getActivityTypeName(typeValue);
                type = typeValue;
            } else {
                typeDisp = Sage.Utility.Activity.getActivityTypeNameFromEnumValue(typeValue);
                type = Sage.Utility.Activity.getActivityTypeCodeFromEnumValue(typeValue);
            }
            var fmt = '<span onclick="javascript:Sage.Link.editHistory(\'${0}\')" class="activity-type-link"><div class="Global_Images icon16x16 ${1} title="${2}"></div>&nbsp;${2}</span>';
            return dstring.substitute(fmt, [key, Sage.Utility.Activity.getActivityImageClass(type, 'small'), typeDisp]);
        }
    });
    var alarmCell = declare('Sage.Utility.Activity.AlarmCell', cell, {
        formatter: function (val, index) {
            return (val) ? "<img src='images/icons/Alarm_16x16.gif'/>" : "<div><div>";
        }
    });
    var recurCell = declare("Sage.Utility.Activity.RecurCell", dojox.grid.cells.Cell, {
        format: function (inRowIndex, inItem) {
            if (!inItem) {
                return this.defaultValue;
            }
            var html = "";
            var activity = (inItem.hasOwnProperty('Activity') && typeof inItem['Activity'] === 'object') ? inItem.Activity : inItem;
            var recur = utility.getValue(activity, 'Recurring');
            var recurState = utility.getValue(activity, 'RecurrenceState');
            if (recur || (recurState && recurState === 'rstOccurrence')) {
                html = '<div class="Global_Images icon16x16 icon_recurring"></div>';
            }
            return html;
        }
    });
    var attachCell = declare("Sage.Utility.Activity.AttachCell", dojox.grid.cells.Cell, {
        format: function (inRowIndex, inItem) {
            if (!inItem) {
                return this.defaultValue;
            }
            var html = "<div><div>";
            var activity = (inItem.hasOwnProperty('Activity') && typeof inItem['Activity'] === 'object') ? inItem.Activity : inItem;
            var attach = utility.getValue(activity, 'Attachment');
            if (attach) {
                html = '<div class="Global_Images icon16x16 icon_attach_to_16"></div>';
            }
            return html;
        }
    });
    var confrimStatusCell = declare("Sage.Utility.Activity.ConfrimStatusCell", dojox.grid.cells.Cell, {
        format: function (inRowIndex, inItem) {
            if (!inItem) {
                return this.defaultValue;
            }
            var html = "<div><div>";
            var status = utility.getValue(inItem, 'Status');
            if (status === 'asUnconfirmed') {
                html = '<div class="Global_Images icon16x16 icon_unconfirmedActivity16x16"></div>';
            }
            return html;
        }
    });
    var durationCell = declare("Sage.Utility.Activity.DurationCell", dojox.grid.cells.Cell, {
        format: function (inRowIndex, inItem) {
            if (!inItem) {
                return this.defaultValue;
            }
            var durationStr = "";
            var activity = (inItem.hasOwnProperty('Activity') && typeof inItem['Activity'] === 'object') ? inItem.Activity : inItem;
            var duration = utility.getValue(activity, 'Duration');
            if (duration) {
                var timeless = utility.getValue(activity, 'Timeless');
                durationStr = Sage.Utility.Activity.formatDuration(duration, timeless);
            }
            return durationStr;
        }
    });
    var nameCell = declare("Sage.Utility.Activity.NameCell", dojox.grid.cells.Cell, {
        format: function (inRowIndex, inItem) {
            if (!inItem) {
                return this.defaultValue;
            }
            var activity = (inItem.hasOwnProperty('Activity') && typeof inItem['Activity'] === 'object') ? inItem.Activity : inItem;
            var contact = utility.getValue(activity, 'ContactName');
            var contactId = utility.getValue(activity, 'ContactId');
            if (isValidId(contactId)) {
                return '<a href="Contact.aspx?entityid=' + contactId + '" >' + contact + '</a>';
            }
            var lead = utility.getValue(activity, 'LeadName');
            var leadId = utility.getValue(activity, 'LeadId');
            if (isValidId(leadId)) {
                return '<a href="Lead.aspx?entityid=' + leadId + '" >' + lead + '</a>';
            }
            return "<div></div> ";
        }
    });
    var nameTypeCell = declare("Sage.Utility.Activity.NameTypeCell", dojox.grid.cells.Cell, {
        format: function (inRowIndex, inItem) {
            if (!inItem) {
                return this.defaultValue;
            }
            var activity = (inItem.hasOwnProperty('Activity') && typeof inItem['Activity'] === 'object') ? inItem.Activity : inItem;
            var contactId = utility.getValue(activity, 'ContactId');
            if (isValidId(contactId)) {
                return nlsStrings.Contact;
            }
            var leadId = utility.getValue(activity, 'LeadId');
            if (isValidId(leadId)) {
                return nlsStrings.Lead;
            }
            return '';
        }
    });
    var accountCell = declare("Sage.Utility.Activity.AccountCell", dojox.grid.cells.Cell, {
        format: function (inRowIndex, inItem) {
            if (!inItem) {
                return this.defaultValue;
            }
            var activity = (inItem.hasOwnProperty('Activity') && typeof inItem['Activity'] === 'object') ? inItem.Activity : inItem;
            var account = utility.getValue(activity, 'AccountName');
            var accountId = utility.getValue(activity, 'AccountId');
            var html = '';
            if (isValidId(accountId)) {
                html = '<a href="Account.aspx?entityid=' + accountId + '" >' + account + '</a>';
            }
            var leadId = utility.getValue(activity, 'LeadId');
            if (isValidId(leadId)) {
                html = '<a href="Lead.aspx?entityid=' + leadId + '" >' + account + '</a>';
            }
            return html;
        }
    });
    var leaderCell = declare("Sage.Utility.Activity.LeaderCell", dojox.grid.cells.Cell, {
        format: function (inRowIndex, inItem) {
            if (!inItem) {
                return this.defaultValue;
            }
            var activity = (inItem.hasOwnProperty('Activity') && typeof inItem['Activity'] === 'object') ? inItem.Activity : null;
            var leader;

            if (activity) {
                leader = utility.getValue(activity, "Leader");
            } else {
                leader = (inItem.hasOwnProperty('Leader') && typeof inItem['Leader'] === 'object') ? inItem.Leader : inItem;
            }
            var leaderName = utility.getValue(leader, '$descriptor');
            return leaderName;
        }
    });
    var completeCell = declare("Sage.Utility.Activity.CompleteCell", dojox.grid.cells.Cell, {
        format: function (inRowIndex, inItem) {
            if (!inItem) {
                return this.defaultValue;
            }
            var key = utility.getValue(inItem, '$key');
            if (isValidId(key)) {
                var activity = (inItem.hasOwnProperty('Activity') && typeof inItem['Activity'] === 'object') ? inItem.Activity : inItem;
                return dstring.substitute('<span onclick="javascript:Sage.Link.completeActivity(\'${0}\', ${1})" class="activity-type-link">${2}</span>', [key, utility.getValue(activity, 'Recurring'), nlsStrings.Complete]);
            }
            return '';
        }
    });
    Sage.namespace('Utility.Activity');
    Sage.Utility.Activity = {
        timelessText: nlsStrings.timelessText,
        _imageMap: {
            small: {
                'atNote': 'images/icons/note_16x16.gif',
                'atPhoneCall': 'images/icons/Call_16x16.gif',
                'atToDo': 'images/icons/To_Do_16x16.gif',
                'atAppointment': 'images/icons/Meeting_16x16.gif',
                'atPersonal': 'images/icons/Personal_16x16.gif',
                'atLiterature': 'images/icons/Literature_16x16.png',
                'atDoc': 'images/icons/mailletter_16x16.png',
                'atFax': 'images/icons/fax_16x16.gif',
                'atEmail': 'images/icons/mailletter_16x16.png'
            },
            medium: {
                'atNote': 'images/icons/Note_24x24.gif',
                'atPhoneCall': 'images/icons/Call_24x24.gif',
                'atToDo': 'images/icons/To_Do_24x24.gif',
                'atAppointment': 'images/icons/Meeting_24x24.gif',
                'atPersonal': 'images/icons/Personal_24x24.gif',
                'atLiterature': 'images/icons/Literature_24x24.png',
                'atDoc': 'images/icons/mailletter_24x24.gif',
                'atFax': 'images/icons/fax_24x24.gif',
                'atEmail': 'images/icons/mailletter_24x24.gif'
            },
            large: {
                'atNote': 'images/icons/Note_24x24.gif',
                'atPhoneCall': 'images/icons/Call_32x32.gif',
                'atToDo': 'images/icons/To_Do_32x32.gif',
                'atAppointment': 'images/icons/Meeting_32x32.gif',
                'atPersonal': 'images/icons/Personal_32x32.gif',
                'atLiterature': 'images/icons/Literature_32x32.png',
                'atDoc': 'images/icons/mailletter_32x32.gif',
                'atFax': 'images/icons/fax_32x32.gif',
                'atEmail': 'images/icons/mailletter_32x32.gif'
            }
        },
        _iconClassMap: {
            small: {
                'atNote': 'icon_note_16x16',
                'atPhoneCall': 'icon_Call_16x16',
                'atToDo': 'icon_To_Do_16x16',
                'atAppointment': 'icon_Meeting_16x16',
                'atPersonal': 'icon_Personal_16x16',
                'atLiterature': 'icon_Literature_16x16',
                'atDoc': 'icon_mailletter_16x16',
                'atFax': 'icon_fax_16x16',
                'atEMail': 'icon_mailletter_16x16'
            },
            medium: {
                'atNote': 'icon_Note_24x24',
                'atPhoneCall': 'icon_Call_24x24',
                'atToDo': 'icon_To_Do_24x24',
                'atAppointment': 'icon_Meeting_24x24',
                'atPersonal': 'icon_Personal_24x24',
                'atLiterature': 'icon_Literature_24x24',
                'atDoc': 'icon_mailletter_24x24',
                'atFax': 'icon_fax_24x24',
                'atEmail': 'icon_mailletter_24x24'
            },
            large: {
                'atNote': 'icon_Note_24x24',
                'atPhoneCall': 'icon_Call_32x32',
                'atToDo': 'icon_To_Do_32x32',
                'atAppointment': 'icon_Meeting_32x32',
                'atPersonal': 'icon_Personal_32x32',
                'atLiterature': 'icon_Literature_32x32',
                'atDoc': 'icon_mailletter_32x32',
                'atFax': 'icon_fax_32x32',
                'atEmail': 'icon_mailletter_32x32'
            }
        },
        _picklistMap: {
            'Regarding': {
                'atNote': 'Note Regarding',
                'atPhoneCall': 'Phone Call Regarding',
                'atToDo': 'To Do Regarding',
                'atAppointment': 'Meeting Regarding',
                'atEmail': 'To Do Regarding',
                'atPersonal': 'Personal Activity Regarding',
                'atLiterature': 'To Do Regarding'
            },
            'Category': {
                'atNote': 'Note Category Codes',
                'atPhoneCall': 'Phone Call Category Codes',
                'atToDo': 'To Do Category Codes',
                'atAppointment': 'Meeting Category Codes',
                'atEmail': 'To Do Category Codes',
                'atPersonal': '',
                'atLiterature': 'To Do Category Codes'
            },
            'Result': {
                'atNote': 'Meeting Result Codes',
                'atPhoneCall': 'Phone Call Result Codes',
                'atToDo': 'To Do Result Codes',
                'atAppointment': 'Meeting Result Codes',
                'atEmail': 'To Do Result Codes',
                'atPersonal': 'Personal Activity Result Codes',
                'atLiterature': 'To Do Result Codes'
            }
        },
        _notMyPersonalActivityMixin: {
            "AccountId": '',
            "AccountName": '',
            "Category": nlsStrings.Personal,
            "ContactId": '',
            "ContactName": '',
            "Description": nlsStrings.Personal,
            "LeadId": '',
            "LeadName": "",
            "LongNotes": '',
            "Notes": '',
            "OpportunityId": '',
            "OpportunityName": '',
            "PhoneNumber": "",
            "Priority": '',
            "TicketId": '',
            "TicketNumber": '',
            "Location": ''
        },
        secureActivityData: function (activity) {
            if ((activity.Type == 262162) || (activity.Type == 'atPersonal')) {
                var currentUserId;
                var clientContextSvc = Sage.Services.getService('ClientContextService');
                if (clientContextSvc) {
                    if (clientContextSvc.containsKey("userID")) {
                        currentUserId = clientContextSvc.getValue("userID");
                    }
                }
                if (currentUserId === activity.UserId) {
                    return;
                }
                if (activity.Leader) {

                    if (currentUserId === activity.Leader.$key) {
                        return;
                    }
                }
                //the current user does should not see this data.
                dojo.mixin(activity, Sage.Utility.Activity._notMyPersonalActivityMixin);
            }
        },
        getActivityImage: function (type, size) {
            size = Sage.Utility.Activity._verifySize(size);
            type = type || 'atAppointment';
            return Sage.Utility.Activity._imageMap[size][type] || Sage.Utility.Activity._imageMap[size]['atAppointment'];
        },
        _verifySize: function (size) {
            size = size || 'small';
            size = size.toLowerCase();
            if (size !== 'small' && size !== 'medium' && size !== 'large') {
                size = 'small';
            }
            return size;
        },
        getActivityImageClass: function (type, size) {
            size = Sage.Utility.Activity._verifySize(size);
            type = type || 'atAppointment';
            return Sage.Utility.Activity._iconClassMap[size][type] || Sage.Utility.Activity._iconClassMap[size]['atAppointment'];
        },
        getActivityTypeName: function (type) {
            switch (type) {
                case 'atPhoneCall':
                    return nlsStrings.PhoneCall || 'Phone Call';
                case 'atToDo':
                    return nlsStrings.ToDo || 'To Do';
                case 'atAppointment':
                    return nlsStrings.Meeting || 'Meeting';
                case 'atPersonal':
                    return nlsStrings.Personal || 'Personal Activity';
                case 'atLiterature':
                    return nlsStrings.Literature || 'Literature';
                case 'atFax':
                    return nlsStrings.Fax || 'Fax';
                case 'atLetter':
                    return nlsStrings.Letter || 'Letter';
                case 'atNote':
                    return nlsStrings.Note || 'Note';
                case 'atEMail':
                    return nlsStrings.Email || 'E-mail';
                case 'atDoc':
                    return nlsStrings.Document || 'Document';
                case 'atDatabaseChange':
                    return nlsStrings.DatabaseChange || 'Database Change';
                case 'atInternal':
                    return nlsStrings.Event || 'Event';
                case 'atSchedule':
                    return nlsStrings.ScheduledEvent || 'Scheduled Event';
                default:
                    return type;
            }
        },
        getActivityTypeNameFromEnumValue: function (value) {
            switch (value) {
                case 262146:
                    return nlsStrings.PhoneCall || 'Phone Call';
                case 262147:
                    return nlsStrings.ToDo || 'To Do';
                case 262145:
                    return nlsStrings.Meeting || 'Meeting';
                case 262162:
                    return nlsStrings.Personal || 'Personal Activity';
                case 262163:
                    return nlsStrings.Literature || 'Literature';
                case 262155:
                    return nlsStrings.Fax || 'Fax';
                case 262148:
                    return nlsStrings.Note || 'Note';
                case 262154:
                    return nlsStrings.Email || 'E-mail';
                case 262153:
                    return nlsStrings.Document || 'Document';
                case 262156:
                    return nlsStrings.DatabaseChange || 'Database Change';
                case 0:
                    return nlsStrings.Event || 'Event';
                case 1:
                    return nlsStrings.ScheduledEvent || 'Scheduled Event';
                default:
                    return value;
            }
        },
        getActivityTypeCodeFromEnumValue: function (value) {
            switch (value) {
                case 262146:
                    return 'atPhoneCall';
                case 262147:
                    return 'atToDo';
                case 262145:
                    return 'atAppointment';
                case 262162:
                    return 'atPersonal';
                case 262163:
                    return 'atLiterature';
                case 262155:
                    return 'atFax';
                case 262148:
                    return 'atNote';
                case 262154:
                    return 'atEMail';
                case 262153:
                    return 'atDoc';
                case 262156:
                    return 'atDatabaseChange';
                case 0:
                    return 'atInternal';
                case 1:
                    return 'atSchedule';
                default:
                    return value;
            }
        },
        getActivityTypeEnumValue: function (name) {
            switch (name) {
                case 'atPhoneCall':
                    return '262146';
                case 'atToDo':
                    return '262147';
                case 'atAppointment':
                    return '262145';
                case 'atPersonal':
                    return '262162';
                case 'atLiterature':
                    return '262163';
                case 'atFax':
                    return '262155';
                case 'atNote':
                    return '262148';
                case 'atEMail':
                    return '262154';
                case 'atDoc':
                    return '262153';
                case 'atDatabaseChange':
                    return '262156';
                case 'atSchedule':
                    return '1';
                case 'atInternal':
                    return '0';
                default:
                    return name;
            }
        },
        getActivityTypeEnumCode: function (type) {
            switch (type) {
                case 262146:
                    return 'atPhoneCall';
                case 262147:
                    return 'atToDo';
                case 'atAppointment':
                case 262145:
                    return 'atAppointment';
                case 262162:
                    return 'atPersonal';
                case 'atLiterature':
                    return 'atLiterature';
                case 'atFax':
                    return 'atFax';
                case 'atLetter':
                    return 'atLetter';
                case 'atNote':
                    return 'atNote';
                case 'atEMail':
                    return 'atEMail';
                default:
                    return type;
            }
        },
        getConfirmationTypeEnumCode: function (type) {
            switch (type) {
                case 0:
                    return 'New';
                case 1:
                    return 'Change';
                case 2:
                    return 'Deleted';
                case 3:
                    return 'Confirm';
                case 4:
                    return 'Decline';
                case 5:
                    return 'Unknown';
                case 6:
                    return 'Leader';
                default:
                    return type;
            }
        },
        getConfirmationDisplayName: function (type) {
            switch (type) {
                case 'New':
                    return nlsStrings.New || 'New';
                case 'Change':
                    return nlsStrings.Change || 'Change';
                case 'Deleted':
                    return nlsStrings.Deleted || 'Deleted';
                case 'Confirm':
                    return nlsStrings.Confirm || 'Confirm';
                case 'Decline':
                    return nlsStrings.Decline || 'Decline';
                case 'Unknown':
                    return nlsStrings.Unknown || 'Unknown';
                case 'Leader':
                    return nlsStrings.Leader || 'Leader';
                default:
                    return type;
            }
        },
        getActivityPicklistName: function (picklist, actType) {
            picklist = picklist || 'Regarding';
            if (!Sage.Utility.Activity._picklistMap.hasOwnProperty(picklist)) {
                picklist = 'Regarding';
            }
            return Sage.Utility.Activity._picklistMap[picklist][actType] || Sage.Utility.Activity._picklistMap[picklist]['atToDo'];
        },
        formatActivityStartDate: function (startDate, timeless) {
            if (!startDate) {
                return '';
            }
            if (Sage.Utility.Convert.isDateString(startDate)) {
                startDate = Sage.Utility.Convert.toDateFromString(startDate);
            }
            if (typeof timeless === 'undefined') {
                timeless = Sage.Utility.Activity.isDateFiveSecondRuleTimeless(startDate);
            }
            if (!timeless) {
                return dateLocale.format(startDate, {
                    selector: 'datetime', fullYear: true,
                    locale: Sys.CultureInfo.CurrentCulture.name
                });
            } else {
                var timelessDate = new Date(startDate.getUTCFullYear(), startDate.getUTCMonth(), startDate.getUTCDate());
                return dateLocale.format(timelessDate, {
                    selector: 'date', fullYear: true,
                    locale: Sys.CultureInfo.CurrentCulture.name
                }) + ' ' + this.timelessText;
            }
        },
        getActivityEndDate: function (startDate, duration, timeless) {
            if (!startDate) {
                return false;
            }
            if (Sage.Utility.Convert.isDateString(startDate)) {
                startDate = Sage.Utility.Convert.toDateFromString(startDate);
            }
            if (typeof timeless === 'undefined') {
                timeless = Sage.Utility.Activity.isDateFiveSecondRuleTimeless(startDate);
            }
            if (!timeless) {
                return dojo.date.add(startDate, "minute", duration);
            } else {
                return new Date(startDate.getUTCFullYear(), startDate.getUTCMonth(), startDate.getUTCDate(), 0, 0, 5);
            }
        },
        formatActivityStartDateForCalendar: function (startDate, dateFormat, timeless) {
            if (!startDate) {
                return '';
            }
            if (Sage.Utility.Convert.isDateString(startDate)) {
                startDate = Sage.Utility.Convert.toDateFromString(startDate);
            }
            var sDate = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate(), startDate.getHours(), startDate.getMinutes());
            if (timeless) {
                sDate = new Date(startDate.getUTCFullYear(), startDate.getUTCMonth(), startDate.getUTCDate(), 0, 0, 5);
            }
            if (dateFormat)
                return dateLocale.format(sDate, {
                    selector: 'date', datePattern: dateFormat,
                    locale: Sys.CultureInfo.CurrentCulture.name
                });
            else
                return dateLocale.format(sDate, {
                    selector: 'date', datePattern: "MM/d/yy H:mm",
                    locale: Sys.CultureInfo.CurrentCulture.name
                });
        },
        formatActivityEndDateForCalendar: function (startDate, duration) {
            if (!startDate) {
                return '';
            }
            if (Sage.Utility.Convert.isDateString(startDate)) {
                startDate = Sage.Utility.Convert.toDateFromString(startDate);
            }
            var stDate = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate(), startDate.getHours(), startDate.getMinutes());
            var eDate = dojo.date.add(stDate, "minute", duration);
            //Some activities will end after midnight, so make it same date and just update the time to handle it in Activity scheduler
            if (dojo.date.compare(eDate, stDate, "date") > 0) {
                //eDate = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate(), eDate.getHours(), eDate.getMinutes());
                return dateLocale.format(stDate, {
                    selector: 'date', datePattern: "MM/d/yy 24:00",
                    locale: Sys.CultureInfo.CurrentCulture.name
                });
            }
            return dateLocale.format(eDate, {
                selector: 'date', datePattern: "MM/d/yy H:mm",
                locale: Sys.CultureInfo.CurrentCulture.name
            });
        },
        formatEventDateForCalendar: function (startDate, dateFormat) {
            if (!startDate) {
                return '';
            }
            if (Sage.Utility.Convert.isDateString(startDate)) {
                startDate = Sage.Utility.Convert.toDateFromString(startDate);
            }
            var sDate = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate(), startDate.getHours(), startDate.getMinutes());

            if (dateFormat)
                return dateLocale.format(sDate, {
                    selector: 'date', datePattern: dateFormat,
                    locale: Sys.CultureInfo.CurrentCulture.name
                });
            else
                return dateLocale.format(sDate, {
                    selector: 'date', datePattern: "MM/d/yy H:mm",
                    locale: Sys.CultureInfo.CurrentCulture.name
                });
        },
        formatEventDate: function (startDate) {
            if (!startDate) {
                return '';
            }
            if (Sage.Utility.Convert.isDateString(startDate)) {
                startDate = Sage.Utility.Convert.toDateFromString(startDate);
            }
            return dateLocale.format(startDate, {
                selector: 'date', fullYear: true,
                locale: Sys.CultureInfo.CurrentCulture.name
            });
        },
        formatDateAdd: function (dt, mode, duration) {
            if (!dt) {
                return '';
            }
            if (Sage.Utility.Convert.isDateString(dt)) {
                dt = Sage.Utility.Convert.toDateFromString(dt);
            }
            var dtAdd = new Date(dt.getFullYear(), dt.getMonth(), dt.getDate(), dt.getHours(), dt.getMinutes());
            dtAdd = dojo.date.add(dtAdd, mode, duration);
            return dateLocale.format(dtAdd, {
                selector: 'date', fullYear: true,
                locale: Sys.CultureInfo.CurrentCulture.name
            });
        },
        formatShortDate: function (dt) {
            if (!dt) {
                return '';
            }
            if (Sage.Utility.Convert.isDateString(dt)) {
                dt = Sage.Utility.Convert.toDateFromString(dt);
            }
            var dtAdd = new Date(dt.getFullYear(), dt.getMonth(), dt.getDate(), dt.getHours(), dt.getMinutes());
            return dateLocale.format(dtAdd, {
                selector: 'date', formatLength: 'short', fullYear: true,
                locale: Sys.CultureInfo.CurrentCulture.name
            });
        },
        formatLongDate: function (dt) {
            if (!dt) {
                return '';
            }
            if (Sage.Utility.Convert.isDateString(dt)) {
                dt = Sage.Utility.Convert.toDateFromString(dt);
            }
            var dtAdd = new Date(dt.getFullYear(), dt.getMonth(), dt.getDate(), dt.getHours(), dt.getMinutes());
            return dateLocale.format(dtAdd, {
                selector: 'date', formatLength: 'long', fullYear: true,
                locale: Sys.CultureInfo.CurrentCulture.name
            });
        },
        roundDateToNextQuarterHour: function (dt) {
            dt.setSeconds(0);
            var curMin = dt.getMinutes();
            if (curMin < 15) {
                dt.setMinutes(15);
            } else if (curMin < 30) {
                dt.setMinutes(30);
            } else if (curMin < 45) {
                dt.setMinutes(45);
            } else {
                dt.setMinutes(0);
                dt = dojo.date.add(dt, 'hour', 1);
            }
            return dt;
        },
        isDateFiveSecondRuleTimeless: function (d) {
            if (!d) {
                return false;
            }
            return ((d.getUTCHours() === 0) && (d.getUTCMinutes() === 0) && (d.getUTCSeconds() === 5));
        },
        formatDuration: function (duration, timeless) {
            if (timeless) {
                return '';
            }
            if (!duration) {
                return '0'+nlsStrings.m;
            }
            if (duration < 60) {
                return duration + nlsStrings.m;
            }
            if (duration > 60) {
                var hours = String(duration / 60).split(".");
                var min = duration % 60;
                return hours[0] + nlsStrings.h+" " + min + nlsStrings.m;
            }
            else {
                return "1"+nlsStrings.hr;
            }
        },
        formatTimelessStartDate: function (value) {
            if (!value) {
                return '';
            }
            var pad = function (n) {
                return n < 10 ? '0' + n : n;
            };
            return value.getUTCFullYear() + '-'
                + pad(value.getUTCMonth() + 1) + '-'
                + pad(value.getUTCDate()) + 'T00:00:00Z';
        },
        formatTimelessEndDate: function (dateValue, mode, increment) {
            if (!dateValue) {
                return '';
            }
            var newDate = new Date(dateValue.getFullYear(), dateValue.getMonth(), dateValue.getDate());
            if (mode && increment) {
                newDate = dojo.date.add(newDate, mode, increment);
            }
            var pad = function (n) {
                return n < 10 ? '0' + n : n;
            };
            var utcYear = newDate.getUTCFullYear();
            var utcMonth = newDate.getUTCMonth() + 1;
            var utcDate = newDate.getUTCDate();

            return utcYear + '-'
                + pad(utcMonth) + '-'
                + pad(utcDate) + 'T23:59:59Z';
        },
        formatRawTimelessStartDate: function (value) {
            if (!value) {
                return '';
            }
            var pad = function (n) { return n < 10 ? '0' + n : n; };
            return value.getFullYear() + '-'
                + pad(value.getMonth() + 1) + '-'
                + pad(value.getDate()) + 'T00:00:00Z';
        },
        formatRawTimelessEndDate: function (dateValue, mode, increment) {
            if (!dateValue) {
                return '';
            }
            var newDate = new Date(dateValue.getFullYear(), dateValue.getMonth(), dateValue.getDate());
            if (mode && increment) {
                newDate = dojo.date.add(newDate, mode, increment);
            }
            var pad = function (n) {
                return n < 10 ? '0' + n : n;
            };
            var utcYear = newDate.getFullYear();
            var utcMonth = newDate.getMonth() + 1;
            var utcDate = newDate.getDate();

            return utcYear + '-'
                + pad(utcMonth) + '-'
                + pad(utcDate) + 'T23:59:59Z';
        },
        getNthWeekOfMonth: function (d) {
            //returns a number 1 - 5 indicating the week in which the supplied date occurs.
            //The typical usage should consider a return value of 5 to mean the "Last" week.
            var tempDate = new Date(d.getFullYear(), d.getMonth(), d.getDate());
            var curMonth = tempDate.getMonth();
            for (var i = 1; i < 7; i++) {
                tempDate = dojo.date.add(tempDate, 'week', -1);
                if (curMonth !== tempDate.getMonth()) {
                    return i;
                }
            }
            return 1;
        },
        setDateToNthWeekDay: function (d, nthWeek, weekDay) {
            //returns the date in the month of the provided date that lands on the 
            // specified weekday.  e.g. First Friday.
            var i, tempDate = new Date(d.getFullYear(), d.getMonth(), d.getDate());
            if (nthWeek === 5) {
                //"last" - count backwards...
                tempDate.setDate(dojo.date.getDaysInMonth(tempDate));
                for (i = 0; i < 7; i++) {
                    if (tempDate.getDay() === weekDay) {
                        break;
                    }
                    tempDate = dojo.date.add(tempDate, 'day', -1);
                }
            } else {
                // count from the beginning...
                tempDate.setDate(1);
                //get to the first day that matches...
                for (i = 0; i < 7; i++) {
                    if (tempDate.getDay() === weekDay) {
                        break;
                    }
                    tempDate = dojo.date.add(tempDate, 'day', 1);
                }
                //then add correct number of weeks (first week - add 0 etc.)
                tempDate = dojo.date.add(tempDate, 'week', nthWeek - 1);
            }
            return tempDate;
        },
        isValidId: function (id) {
            var valid = false;
            if (id) {
                if (id.trim() !== '') {
                    valid = true;
                }
            }
            return valid;
        },
        getConfirmStatusName: function (type) {
            if (!type) {
                return nlsStrings.Unknown || 'Unknown';
            }
            switch (type.toUpperCase().trim()) {
                case "CHANGE":
                    return nlsStrings.confirmTypeChanged || 'Changed';
                case "CONFIRM":
                    return nlsStrings.confirmTypeConfirmed || 'Confirmed';
                case "DELETED":
                    return nlsStrings.confirmTypeDeleted || 'Deleted';
                case "LEADER":
                    return nlsStrings.Leader || 'Leader';
                case "NEW":
                    return nlsStrings.New || 'New';
                default:
                    return type;
            }
        },
        isReocurringId: function (id) {
            if (id.charAt(12) === ';') {
                return true;
            }
            return false;
        },
        findFailedRequestMessage: function (request, def) {
            if (request.responseText) {
                var rsp = eval(request.responseText);
                if (dojo.isArray(rsp)) {
                    if (rsp[0]) {
                        return rsp[0].message || def;
                    }
                }
            }
            return def;
        },
        removeMember: function (actvityEditorId, memberId) {
            var editor = dijit.byId(actvityEditorId);
            if (editor) {
                var args = {
                    memberId: memberId
                };
                editor._removeMember(args);
            }
        },
        getActivityEditLink: function (activity) {
            var key = activity.id;
            var fmtStr = '<span onclick="${0}" class="activity-type-link">${1}</span>';
            var recurring = Sage.Utility.Activity._getReccurenceFlag(activity);
            var desc = activity.Description || Sage.Utility.Activity.getActivityTypeName(Sage.Utility.Activity.getActivityTypeEnumCode(activity.Type));
            var href = 'javascript:Sage.Link.editActivity(\'' + key + '\', ' + recurring + ')';
            return dstring.substitute(fmtStr, [href, desc]);
        },
        getActivitySummaryHeader: function (activity) {
            var key = activity.id;
            var fmtStr = '<span onclick="${0}" class="activity-type-link">${1}</span>';
            var sHtml = '';
            if (activity.Alarm) {
                sHtml += '<div class="Global_Images icon24x24 icon_Alarm_24x24" > </div>&nbsp;';
            }
            if ((Sage.Utility.Activity.isReocurringId(activity.id)) || (activity.Recurring)) {
                sHtml += '<div class="Global_Images icon16x16 icon_recurring" > </div>&nbsp;';
            }
            sHtml += '<div class="Global_Images icon24x24 ' + Sage.Utility.Activity.getActivityImageClass(activity.Type, 'medium') + '"> </div>&nbsp;';
            var recurring = Sage.Utility.Activity._getReccurenceFlag(activity);
            var desc = activity.Description || Sage.Utility.Activity.getActivityTypeName(Sage.Utility.Activity.getActivityTypeEnumCode(activity.Type));
            var href = 'javascript:Sage.Link.editActivity(\'' + key + '\', ' + recurring + ')';
            sHtml += dstring.substitute(fmtStr, [href, desc]);
            return sHtml;
        },
        getUserActivitySummaryHeader: function (userActivity) {
            var activity = userActivity.Activity;
            var sHtml = '';
            if (userActivity.Status === "asUnconfirmed") {
                sHtml += '<div class="Global_Images icon16x16 icon_unconfirmedActivity16x16" > </div>';
            }

            if (activity.Alarm) {
                sHtml += '<div class="Global_Images icon24x24 icon_Alarm_24x24" > </div>&nbsp;';
            }
            if ((Sage.Utility.Activity.isReocurringId(activity.$key)) || (activity.Recurring)) {
                sHtml += '<div class="Global_Images icon16x16 icon_recurring" > </div>&nbsp;';
            }
            sHtml += '<div class="Global_Images icon24x24 ' + Sage.Utility.Activity.getActivityImageClass(activity.Type, 'medium') + '"> </div>&nbsp;';
            var recurring = Sage.Utility.Activity._getReccurenceFlag(activity);
            var fmtStr = '<span onclick="${0}" class="activity-type-link">${1}</span>';
            var desc = activity.Description || Sage.Utility.Activity.getActivityTypeName(Sage.Utility.Activity.getActivityTypeEnumCode(activity.Type));
            var href = 'javascript:Sage.Link.editActivity(\'' + activity.$key + '\', ' + recurring + ')';
            if (userActivity.Status === "asUnconfirmed") {
                href = 'javascript:Sage.Link.confirmActivityFor(\'' + activity.$key + '\', ' + userActivity.User.$key + ')';
            }
            sHtml += dstring.substitute(fmtStr, [href, desc]);
            return sHtml;
        },
        getActivityCompleteHref: function (activity) {
            var key = activity.$key;
            var recurring = Sage.Utility.Activity._getReccurenceFlag(activity);
            var href = 'javascript:Sage.Link.completeActivity(\'' + key + '\', ' + recurring + ')';
            return href;
        },
        _getReccurenceFlag: function (activity) {
            if (activity.RecurrenceState) {
                // comeing from system feed;
                // Case where no end of reoccuring range. so let treat this as not reoccuring. 
                if ((activity.Recurring === true) && (activity.RecurrenceState === 'rstMaster')) {
                    return false;
                }
                if ((activity.Recurring === true) && ((activity.RecurIterations) < 0)) {
                    return false;
                }
                if (activity.RecurrenceState === 'rstOccurrence') {
                    return true;
                }
            } else {
                if (activity.Recurring === true) {
                    if ((activity.RecurIterations) < 0) {
                        return false;
                    }
                    return true;
                }
                return false;
            }
            return false;
        },
        getCurrentActivityId: function () {
            var contextservice = Sage.Services.getService('ClientEntityContext');
            var eContext = contextservice.getContext();
            var entityId = null;
            if (eContext && eContext.EntityTableName == 'ACTIVITY') {
                entityId = eContext.EntityId;
            }
            return entityId;
        },
        //Get contact data by contactId
        _getContactData: function (contactId, callback, scope) {
            if (!this._contactStore) {
                this._contactStore = new SingleEntrySDataStore({
                    include: ['$descriptors', 'Address'],
                    resourceKind: 'contacts',
                    service: sDataServiceRegistry.getSDataService('dynamic')
                });
            }
            this._contactStore.fetch({
                predicate: "'" + contactId + "'",
                onComplete: function (contactData) {
                    callback.call(scope, contactData);
                },
                onError: function () {
                    callback.call(scope, null);
                },
                scope: this
            });
        },
        //Get Lead data by LeadId
        _getLeadData: function (leadId, callback, scope) {
            if (!this._leadStore) {
                this._leadStore = new SingleEntrySDataStore({
                    include: ['$descriptors', 'Address'],
                    resourceKind: 'leads',
                    service: sDataServiceRegistry.getSDataService('dynamic')
                });
            }
            this._leadStore.fetch({
                predicate: "'" + leadId + "'",
                onComplete: function (leadData) {
                    callback.call(scope, leadData);
                },
                onError: function () {
                    callback.call(scope, null);
                },
                scope: this
            });
        },
        activityTypeCell: typeCell,
        activityAlarmCell: alarmCell,
        activityRecurringCell: recurCell,
        activityAttachCell: attachCell,
        activityConfirmStatusCell: confrimStatusCell,
        activityDurationCell: durationCell,
        activityNameCell: nameCell,
        activityNameTypeCell: nameTypeCell,
        activityAccountCell: accountCell,
        activityCompleteCell: completeCell,
        historyTypeCell: historyTypeCell,
        activityLeaderCell: leaderCell
    };

    return Sage.Utility.Activity;
});

},
'Sage/UI/_DialogLoadingMixin':function(){
/*globals define, window  */
define([
    'dojo/_base/declare',
    'dojox/widget/Standby'
],
function (declare, Standby) {
    return declare('Sage.UI._DialogLoadingMixin', null, {
        _standby: false,
        showLoading: function () {
            if (!this._standby && this.domNode) {
                var hideNode = this.domNode;
                if (this.containerNode) {
                    hideNode = this.containerNode;
                }
                this._standby = new Standby({
                    target: hideNode,
                    color: 'white',
                    image: 'images/loader_lg.gif',
                    duration: 50
                });
                document.body.appendChild(this._standby.domNode);
                this._standby.startup();
            }
            var self = this;
            window.setTimeout(function () {
                self._standby.show();
            }, 0);
        },
        hideLoading: function () {
            var self = this;
            window.setTimeout(function () {
                if (self._standby) {
                    self._standby.hide();
                }
            }, 1);
        }

    });
});
},
'Sage/UI/AttachmentList':function(){
/*globals Sage, dojo, define, window  */
define([
    'dijit/_Widget',
    'Sage/UI/EditableGrid',
    'Sage/Data/SDataServiceRegistry',
    'dojo/string',
    'Sage/UI/Controls/GridParts/Columns/DateTime',
    'Sage/Utility',
    'Sage/Utility/File',
    'Sage/Utility/File/Attachment',
    'Sage/UI/Dialogs',
    'Sage/Utility/File/AttachmentPropertiesEditForm',
    'Sage/Utility/File/FallbackFilePicker',
    'Sage/Utility/File/AddURLAttachment',
    'Sage/Utility/File/GoogleDocPicker',
    'Sage/UI/SLXPreviewGrid/Filter/DateRange',
    'Sage/UI/SLXPreviewGrid/Filter/Text',
    'dojo/_base/declare',
    'dojo/dom-construct',
    'dojo/_base/lang',
    'dojo/_base/connect',
    'dojo/i18n!./nls/AttachmentList',
    'Sage/Utility',
    'Sage/Utility/Workspace',
    'Sage/UI/GridView',
    'dojo/string',
    'dojo/store/Memory',
    'Sage/Store/SData'
],
function (_Widget,
    EditableGrid,
    SDataServiceRegistry,
    dString,
    colDateTime,
    utility,
    fileUtility,
    attachmentUtility,
    Dialogs,
    attachmentForm,
    FallbackFilePicker,
    AddURLAttachment,
    GoogleDocPicker,
    dateRangeFilter,
    textFilter,
    declare,
    domConstruct,
    lang,
    connect,
    attachmentListStrings,
    Utility,
    workspaceUtil,
    GridView,
    string,
    Memory,
    SDataObjectStore
    ) {
    var attachmentList = declare('Sage.UI.AttachmentList', [_Widget], {
        placeHolder: '',
        conditionFmt: '',
        parentRelationshipName: '',
        workspace: '',
        tabId: '',
        fileInputBtn: false,
        _fileInputOnChange: null,
        _attachmentEditor: false,
        _newAttachmentsCache: [],
        subscriptions: [],
        _grid: null,
        _store: {},
        constructor: function () {
            lang.mixin(this, attachmentListStrings);
            this.subscriptions = [];
        },
        startup: function (callBack) {
            this._newAttachmentsCache = [];
            this._checkDbType(callBack);
        },
        _checkDbType: function (callBack) {
            var svc = Sage.Services.getService('SystemOptions');
            svc.get('DbType',
                function (val) {
                    this._buildGrid(val === "2" || val === "3");
                    if (typeof callBack == 'function') {
                        callBack(this);
                    }
                },
                function () {
                    this._buildGrid(false);
                    if (typeof callBack == 'function') {
                        callBack(this);
                    }
                },
                this
            );
        },
        _buildGrid: function (isRemote) {
            var columns = [
                {
                    // key field, added for automation
                    field: '$key',
                    editable: false,
                    hidden: true,
                    unhidable: true,
                    id: 'id',
                    formatter: function (value, rowIdx) {
                        return ['<div id=', value, ' >', value, '</ div>'].join('');
                    }
                },
                {
                    field: 'description',
                    label: attachmentListStrings.attachmentText,
                    formatter: function (rowIdx, rowItem) {
                        if (!rowItem) {
                            return this.defaultValue;
                        }

                        // Call the utility function to encode the object's strings (recursively)
                        Utility.encodeObjectStrings(rowItem);

                        //console.warn('ToDo: include role security to Attachment description column rendering (or whatever other security) that was applied before.   <---<<<   <---<<<');
                        if (rowItem['url']) {
                            var href = rowItem['url'] || '';
                            href = (href.indexOf('http') < 0) ? 'http://' + href : href;
                            return dString.substitute('<a href="${0}" target="_blank" title="${1}">${2}</a>', [href, rowItem['url'], rowItem['$descriptor']]);
                        } else {
                            if (rowItem['fileExists']) {
                                return dString.substitute('<a href="javascript: Sage.Utility.File.Attachment.getAttachment(\'${0}\');" title="${1}">${1}</a>',
                                    [rowItem['$key'], rowItem['$descriptor']]);
                            } else {
                                return rowItem['$descriptor'];
                            }
                        }
                    },
                    filterConfig: { widgetType: textFilter },
                    width: '300px'
                },
                {
                    field: 'user',
                    label: attachmentListStrings.userText,
                    formatter: function (rowIdx, rowItem) {
                        if (!rowItem) { return ''; }
                        var user = (rowItem.hasOwnProperty('user') && typeof rowItem['user'] === 'object') ? rowItem.user : null;
                        if (!user) {
                            return '';
                        }
                        return (user['$descriptor']) ? user['$descriptor'] : '';
                    },
                    width: '120px'
                },
                {
                    field: 'attachDate',
                    label: attachmentListStrings.modDateText,
                    type: colDateTime,
                    filterConfig: {
                        widgetType: dateRangeFilter,
                        label: attachmentListStrings.dateRangeText
                    },
                    width: '175px'
                }, {
                    field: 'fileSize',
                    label: attachmentListStrings.sizeText,
                    formatter: function (v) {
                        return fileUtility.formatFileSize(v);
                    },
                    width: '120px'
                }, {
                    field: 'fileName',
                    label: attachmentListStrings.extensionText,
                    formatter: function (rowIdx, rowItem) {
                        if (!rowIdx) {
                            return '.';
                        }
                        return rowIdx.substr(rowIdx.lastIndexOf('.'));
                    },
                    sortable: false
                }
            ];
            var tools = [
                    {
                        id: this.id + '_btnBrowse',
                        imageClass: 'icon_Add_File_16x16',
                        handler: this.browseForFiles,
                        title: attachmentListStrings.addFileText,
                        alternateText: attachmentListStrings.addFileText,
                        appliedSecurity: '',
                        scope: this
                    }, {
                        //       id: this.id + '_btnAddGoogle',
                        //      imageClass: 'icon_google_16x16',
                        //      handler: this.addGoogle,
                        //      title: attachmentListStrings.addGoogleText,
                        //      appliedSecurity: '',
                        //      scope: this
                        //  }, {
                        id: this.id + '_btnAddUrl',
                        imageClass: 'icon_Internet_Service_Add_16x16',
                        handler: this.addUrlAttachment,
                        title: attachmentListStrings.addUrlText,
                        appliedSecurity: '',
                        alternateText: attachmentListStrings.addUrlText,
                        scope: this
                    }, {
                        id: this.id + '_btnEditAttachProps',
                        imageClass: 'icon_Edit_Item_16x16',
                        handler: this.editSelectedAttachment,
                        title: attachmentListStrings.editText,
                        appliedSecurity: '',
                        alternateText: attachmentListStrings.editText,
                        scope: this
                    }, {
                        id: this.id + '_btnDeleteAttachment',
                        imageClass: 'icon_Delete_16x16',
                        title: attachmentListStrings.deleteText,
                        handler: this.deleteSelectedAttachment,
                        appliedSecurity: '',
                        alternateText: attachmentListStrings.deleteText,
                        scope: this
                    }, {
                        id: this.id + '_btnHelp',
                        imageClass: 'icon_Help_16x16',
                        handler: function () {
                            utility.openHelp('attachmentstab');
                        },
                        title: attachmentListStrings.helpText,
                        alternateText: attachmentListStrings.helpText,
                        appliedSecurity: ''
                    }
            ];

            if (isRemote) {
                var remoteColumn = {
                    field: 'remoteStatus',
                    name: '&nbsp;',
                    width: '300px',
                    format: function (rowIdx, rowItem) {
                        if (!rowItem) {
                            return this.defaultValue;
                        }

                        var status = (rowItem['remoteStatus']) ? rowItem['remoteStatus'] : (rowItem['fileExists']) ? 'Delivered' : 'Available';
                        if (!rowItem['dataType']) {
                            status = 'X'; // URL attachments - do not put a link to download these, they fail anyway.
                        }

                        // Available | Requested | Delivered
                        var link = dString.substitute('<a href="javascript:Sage.Utility.File.Attachment.remoteRequestAttachment(\'${0}\')">${1}</a>',
                            [rowItem['$key'], attachmentListStrings.request]);
                        switch (status) {
                            case 'Available':
                                return attachmentListStrings.available + ' - ' + link;
                            case 'Requested':
                                return attachmentListStrings.requested; // +' - ' + link;
                            case 'Delivered':
                                return attachmentListStrings.delivered + ' - ' + link;
                            default:
                                return ' ';
                        }
                    }
                };
                columns.splice(2, 0, remoteColumn);
            }

            //var store = this._configureGridStore();
            var contextservice = Sage.Services.getService('ClientEntityContext');
            var ctx = contextservice.getContext();
            this.contextEntityType = ctx.EntityType;

            var curId = utility.getCurrentEntityId();
            var store = this._createLiveStore();
            this.mode = (!curId) ? 'insert' : '';

            var options = {
                columns: columns,
                gridLabel: 'Attachments',
                tools: tools,
                store: new Memory({ data: [] }),
                sort: [{ attribute: 'attachDate', descending: true }],
                id: this.id + '_attachments',
                minRowsPerPage: 25,
                placeHolder: this.placeHolder,
                mode: this.mode,
                columnHiding: true,
                columnResizing: true,
                columnReordering: true,
                selectionMode: 'extended',
                rowSelection: true,
                slxContext: { 'workspace': this.workspace, tabId: this.tabId }
            };

            //fire this so that customizations can change these options without overriding the whole thing
            this.onBeforeCreateGrid(options);

            var grid = this._grid = new GridView(options);
            grid.createGridView();

            dojo.connect(grid, 'destroy', this, this.destroy);

            this.fileInputBtn = dojo.doc.createElement('INPUT');
            dojo.attr(this.fileInputBtn, {
                'type': 'file',
                'multiple': 'true',
                'accept': '*/*',
                'class': 'display-none'
            });
            dojo.place(this.fileInputBtn, this.domNode, 'last');
            this._fileInputOnChange = connect.connect(this.fileInputBtn, 'onchange', this, this.handleFiles);

            this.subscriptions.push(dojo.subscribe('/entity/attachment/create', this, this.onNewAttachmentEntity));
            this.subscriptions.push(dojo.subscribe('/entity/attachment/update', this, this.onAttachmentUpdated));
            if (isRemote) {
                this.subscriptions.push(dojo.subscribe('/entity/attachment/requested', this, this.onAttachmentUpdated));
            }
            this.resetEntityContext(); //end of _buildGrid
        },
        _createLiveStore: function () {
            var parentRelationshipName = this.parentRelationshipName;
            var entityId = utility.getCurrentEntityId();
            if (parentRelationshipName === 'activityId') {
                entityId = entityId.substr(0, 12); // for reoccurring activity Ids;
            }

            this._store = new SDataObjectStore({
                service: SDataServiceRegistry.getSDataService('system'),
                contractName: 'system',
                resourceKind: 'attachments',
                resourcePredicate: null,
                include: ['$descriptors'],
                select: ['description', 'user', 'attachDate', 'fileSize', 'fileName', 'url', 'fileExists', 'remoteStatus', 'dataType'],
                where: string.substitute((parentRelationshipName || '\'A\'') + ' eq "${0}"', [entityId]),
                scope: this
            });
        },
        resetEntityContext: function () {
            var parentRelationshipName = this.parentRelationshipName;
            var entityId = utility.getCurrentEntityId();
            if (parentRelationshipName === 'activityId') {
                entityId = entityId.substr(0, 12); // for reoccurring activity Ids;
            }
            var contextualCondition = (parentRelationshipName || '\'A\'') + ' eq \'' + entityId + '\'';

            if ((!entityId && this.mode !== 'insert') ||
                       (entityId && this.mode === 'insert')) {
                this.mode = (!entityId) ? 'insert' : '';
            }

            if (this._grid) {
                if (this.mode === 'insert') {
                    this._grid.grid.setStore(new Memory({ data: [] }));
                } else {
                    this._store.where = contextualCondition;
                    this._grid.grid.setStore(this._store);
                }
            }
        },
        destroy: function () {
            var len = this.subscriptions.length;
            for (var i = 0; i < len; i++) {
                dojo.unsubscribe(this.subscriptions.pop());
            }
        },
        handleFiles: function (e) {
            var files = this.fileInputBtn.files;
            this._createAttachments(files);
        },
        handleGearsDesktopFileSelect: function (files) {
            if (files.length > 0) {
                attachmentUtility.createAttachments(files);
            }
        },
        _createAttachments: function (files) {
            if (files.length > 0) {
                attachmentUtility.createAttachments(files);
            }
        },
        onNewAttachmentEntity: function (attachment) {
            var contextservice = Sage.Services.getService('ClientEntityContext');
            var ctx = contextservice.getContext();
            if (this.contextEntityType !== ctx.EntityType) {
                return;
            }
            if (!attachment) {
                this._getFallBackPickerAttachment();
                return;
            } else {
                this._newAttachmentsCache.push(attachment);

                if (this.mode === 'insert') {
                    this._grid.grid.addItem(attachment);
                    this._grid.refresh();
                } else {
                    this._grid.grid.store.put(attachment).then(lang.hitch(this, function (response) {
                        this._grid.refresh();
                    }));
                }
            }
        },
        _getFallBackPickerAttachment: function () {
            var editor = dijit.byId('activityEditor');
            var idField = 'activityId';
            if (!editor || !editor._tempIdForAttachments) {
                editor = dijit.byId('historyEditor') || {};
                idField = 'historyId';
            }
            var tempid = editor._tempIdForAttachments;
            if (tempid) {
                var req = new Sage.SData.Client.SDataResourceCollectionRequest(SDataServiceRegistry.getSDataService('system'))
                    .setResourceKind('attachments')
                    .setQueryArg('select', ['description', 'userId', 'attachDate', 'fileSize', 'fileName', 'url', 'fileExists'].join(','))
                    .setQueryArg('where', idField + ' eq \'' + tempid + '\'')
                    .setStartIndex(1)
                    .setCount(50);
                req.read({
                    success: this._receivedFallBackPickerAttachments,
                    failure: function () {
                    },
                    scope: this
                });
            }
        },
        _receivedFallBackPickerAttachments: function (data) {
            var attachments = data.$resources;
            this.clearNewAttachments();
            for (var i = 0; i < attachments.length; i++) {
                var attachment = attachments[i];
                this._newAttachmentsCache.push(attachment);
                this._grid.store.put(attachment).then(lang.hitch(this, function (response) {
                    this._grid.grid.addItem(attachment);
                }));
            }
            this._grid.refresh();
        },
        onAttachmentUpdated: function (attachment) {
            var contextservice = Sage.Services.getService('ClientEntityContext');
            var ctx = contextservice.getContext();
            if (this.contextEntityType !== ctx.EntityType) {
                return;
            }
            if (this.mode === 'insert') {
                var newAtts = this._newAttachmentsCache;
                for (var i = 0; i < newAtts.length; i++) {
                    if (newAtts[i].$key === attachment.$key) {
                        lang.mixin(newAtts[i], attachment);
                    }
                }
            }
            this._grid.refresh();
        },
        getNewAttachments: function () {
            return this._newAttachmentsCache;
        },
        clearNewAttachments: function () {
            this._newAttachmentsCache = [];
            if (this._grid) {
                this._grid.grid.setStore(new Memory({ data: [] }));
            }
        },
        _editAttachmentInfo: function (attachId) {
            // use query parameter of _includeFile=false to get only the attachment entity for editing

            if (!this._attachmentEditor) {
                this._attachmentEditor = new attachmentForm();
            }
            this._attachmentEditor.set('attachmentId', attachId);
            this._attachmentEditor.show();

        },
        browseForFiles: function (e) {
            if (fileUtility.supportsHTML5File) {
                // Re-create the file input, otherwise onchange will not fire if you select the same file to upload again.
                var node = this.fileInputBtn.cloneNode();
                domConstruct.destroy(this.fileInputBtn);
                domConstruct.place(node, this.domNode, 'last');
                this.fileInputBtn = node;
                connect.disconnect(this._fileInputOnChange);
                this._fileInputOnChange = connect.connect(this.fileInputBtn, 'onchange', this, this.handleFiles);
                this.fileInputBtn.click();
            } else {
                var fbfp = dijit.byId('fallbackFilePicker');
                if (!fbfp) {
                    fbfp = new FallbackFilePicker({ id: 'fallbackFilePicker' });
                }
                fbfp.show();
            }
        },
        addUrlAttachment: function (e) {
            var ed = dijit.byId('urlAttachmentEditor');
            if (!ed) {
                ed = new AddURLAttachment({ id: 'urlAttachmentEditor' });
            }
            ed.set('attachmentId', '');
            ed.show();
        },
        editSelectedAttachment: function () {
            var selectedItems = this._grid.getSelectedRowData();
            if (selectedItems.length < 1) {
                return;
            }
            var item = selectedItems[0];  // what do we do if more than one is selected - edit only the first?
            this._editAttachmentInfo(item['$key']);
        },
        deleteSelectedAttachment: function () {
            this._grid.deleteSelected();
            dojo.publish('/entity/attachment/delete');
        },
        addGoogle: function () {
            var gPicker = dijit.byId('googleDocumentPicker');
            if (!gPicker) {
                gPicker = new GoogleDocPicker({ id: 'googleDocumentPicker' });
                dojo.connect(gPicker, 'onDocumentSelected', this, '_handleGoogleDocPicked');
            }
            gPicker.pick();
        },
        _handleGoogleDocPicked: function (title, url) {
            var request = new Sage.SData.Client.SDataTemplateResourceRequest(SDataServiceRegistry.getSDataService('system'));
            request.setResourceKind('attachments');
            request.read({
                success: function (attachment) {
                    attachment.description = dojo.isArray(title) ? title[0] : title;
                    attachment.url = dojo.isArray(url) ? url[0] : url;
                    this._addRelationshipsToGoogleDocAttachment(attachment);
                },
                failure: function (err) {
                    console.warn('an exception occurred getting attachment template ' + err);
                },
                scope: this
            });
        },
        _addRelationshipsToGoogleDocAttachment: function (attachment) {
            attachmentUtility.getKnownRelationships(function (rels) {
                var newAttach = lang.mixin(attachment, rels);
                newAttach.user = { '$key': utility.getClientContextByKey('userID') || '' };
                newAttach.attachDate = utility.Convert.toIsoStringFromDate(new Date());
                var request = new Sage.SData.Client.SDataSingleResourceRequest(SDataServiceRegistry.getSDataService('system'))
                    .setResourceKind('attachments');
                request.create(newAttach, {
                    success: function (att) {
                        dojo.publish('/entity/attachment/create', att);
                    },
                    failure: function (err) {
                        console.warn('an exception occurred saving Google document attachment ' + err);
                    },
                    scope: this
                });
            }, this);
        },
        onBeforeCreateGrid: function (options) { },
        setToReadOnly: function (readOnly) {
            var disableList = [this.id + '_btnBrowse',
                             this.id + '_btnAddUrl',
                             this.id + '_btnEditAttachProps',
                             this.id + '_btnDeleteAttachment'
            ];
            this._bulkSetProperty(this, disableList, 'disabled', readOnly);

        },
        _bulkSetProperty: function (ui, propsList, prop, val) {
            for (var i = 0; i < propsList.length; i++) {
                var ctrl = dijit.byId(propsList[i]);
                if (ctrl) {
                    ctrl.set(prop, val);
                }
            }
        }
    });
    return attachmentList;
});

},
'Sage/UI/EditableGrid':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define, TabControl */

define(['dojox/grid/DataGrid',
    'dijit/Toolbar',
    'dijit/form/Button',
    'dijit/layout/ContentPane',
    'Sage/Data/WritableSDataStore',
    'Sage/Data/WritableStore',
    'Sage/UI/SDataLookup',
    'dojo/i18n',
    'dojo/_base/lang',
    'Sage/Utility',
    'Sage/UI/ImageButton',
    'Sage/UI/Dialogs',
    'Sage/Utility/_LocalStorageMixin',
    'dojo/i18n!./nls/EditableGrid',
    'Sage/UI/ToolBarLabel',
    'dojo/parser',
    'dojo/dom-construct',
    'dojo/_base/declare',
    'dojo/_base/array'
],
function (DataGrid,
    Toolbar,
    Button,
    ContentPane,
    WritableSDataStore,
    WritableStore,
    SDataLookup,
    i18n,
    dojolang,
    Utility,
    ImageButton,
    Dialogs,
    _LocalStorageMixin,
    nlsEditablGrid,
    ToolBarLabel,
    parser,
    domConstruct,
    declare,
    array
) {
    var editableGrid = declare('Sage.UI.EditableGrid', [DataGrid, _LocalStorageMixin], {
        recordCountLabel: null,
        STORE_KEY_COLUMN_SIZE: '_COLUMN_UNIT_WIDTH_',
        STORE_NS: 'SAGE_UI_EDITABLEGRID',
        STORE_KEY_SORT: '_SORT_INFO_',
        lookupControl: null,
        mode: '',
        region: 'center',
        _dataChangeConnections: [],
        _registeredWidgets: null,

        constructor: function (opts) {
            this.mode = Utility.getModeId();
            if (opts.storeOptions && opts.storeOptions.isInsertMode) {
                this.mode = 'insert';
            }

            this._dataChangeConnections = [];
            this._registeredWidgets = [];
        },

        _setModeAttr: function (mode) {
            if (this.mode !== mode) {
                this.mode = mode;
                if (!this.store) {
                    return;
                }
                if (((mode === 'insert') && (this.store.declaredClass !== 'Sage.Data.WritableStore')) ||
                   ((mode !== 'insert') && (this.store.declaredClass != 'Sage.Data.WritableSDataStore'))) {
                    this._replaceStore();
                }
            }
        },
        _getModeAttr: function () {
            return this.mode;
        },
        // Fixes IE. Issue was the grid itself has focus, so blur on cells doesn't work
        onBlur: function () {
            if (this.edit && this.edit.isEditing()) {
                this.edit.apply();
            }
        },

        //end i18n strings.
        postMixInProperties: function () {
            dojo.mixin(this, nlsEditablGrid);
            dojo.mixin(this, i18n.getLocalization("dijit", "common"));
            this.setEditable();

            if (!this.storeOptions) {
                this.storeOptions = {};
            }
            this.ensureValue(this.storeOptions, 'pagesize', this.rowsPerPage || 20);
            this.ensureValue(this, 'singleClickEdit', true);

            if (typeof this.contextualCondition === 'function') {
                this.query = { fn: this.contextualCondition, scope: this };
            } else if (typeof this.contextualCondition === 'object') {
                if (this.contextualCondition.fn) {
                    this.ensureValue(this.contextualCondition, 'scope', this);
                    this.query = this.contextualCondition;
                }
            }

            //set up structure:
            this.structure = [
                {
                    defaultCell: dojolang.mixin({ defaultValue: '' }, this.columnDefaults),
                    cells: this.columns
                }
            ];
            function addToListUnique(item, list) {
                for (var i = 0; i < list.length; i++) {
                    if (item === list[i]) {
                        return;
                    }
                }
                list.push(item);
            }

            //create and startup the toolbar...
            if ((this.tabId) && (this.tabId !== '')) {
                this.addToolsToWorkspaceToolbar();
                this.currentEntityId = Utility.getCurrentEntityId();
            } else {
                this.createOwnToolbar();
            }

            //set up the datastore if they didn't give us one...
            this._setUserPrefColumnWidths();
            var cols = this.columns,
                sel, i, p, inc, parts, combined, field;

            if (!this.store) {
                sel = this.storeOptions.select || [];
                for (i = 0; i < sel.length; i++) {
                    sel[i] = sel[i].replace(/\./g, '/');
                }
                inc = this.storeOptions.include || [];
                for (i = 0; i < cols.length; i++) {
                    if (cols[i].field) {
                        field = cols[i].field;
                        addToListUnique(field.replace(/\./g, '/'), sel);
                    }
                    if (cols[i].field.indexOf('.') > 0) {
                        parts = cols[i].field.split('.');
                        combined = '';
                        for (p = 0; p < parts.length - 1; p++) {
                            combined += parts[p];
                            addToListUnique(combined, inc);
                            combined += '/';
                        }
                    }
                }
                this.store = this.getStore();
                //Clean up any dirty data flags.  We can assume it is clean with a new store.
                this.markClean();
            } else {
                //this means a datastore was given to us - most likely a proxydatastore.
                sel = this.store.select = this.store.select || [];
                inc = this.store.include = this.store.include || [];
                for (i = 0; i < sel.length; i++) {
                    sel[i] = sel[i].replace(/\./g, '/');
                }
                for (i = 0; i < cols.length; i++) {
                    if (cols[i].field) {
                        field = cols[i].field;
                        addToListUnique(field.replace(/\./g, '/'), sel);
                    }
                    if (cols[i].field.indexOf('.') > 0) {
                        parts = cols[i].field.split('.');
                        combined = '';
                        for (p = 0; p < parts.length - 1; p++) {
                            combined += parts[p];
                            addToListUnique(combined, inc);
                            combined += '/';
                        }
                    }
                }
            }
            //apply saved sort information...
            this._setSortInfo();
            this.inherited(arguments);
        },
        postCreate: function () {
            //summary:
            //Add event connections
            //Enable the grid to commit its changes on Enter -- TODO: Review behavior.
            dojo.connect(this, 'onKeyDown', this.customKeyDown);
            // Store column resizings
            dojo.connect(this, 'onResizeColumn', this._onResizeColumn);
            dojo.subscribe('Sage/events/TabWorkspace/MIDDLE_AREA_DROP', this, this._setMiddleAreaHeight);
            // Enhanced Loading message when adding and deleting items from the editable 
            // grid to display immediately rather than waiting for datastore fetch.
            this.connect(this, '_onNew', this.showLoading);
            // Update the display count.
            this.connect(this.scroller, 'scroll', this._onScroll);
            dojo.connect(this, 'onResizeColumn', this._onScroll);
            this.setupHeader();
            this.inherited(arguments);
        },
        showLoading: function () {
            this.showMessage(this.loadingMessage);
            this._clearData();
            this.markClean();
        },
        headerTemplate: new Simplate([
            '<div>',
            '<div id="{%= $.id %}_HeaderBar"  data-dojo-type="dijit.layout.ContentPane" gutters="false"  region="top" ',
                'style="{%= $.headerStyle %}" class="editable-grid-hbar">',
                '<div class="editable-grid-hbar-left"></div>',
                '<div class="editable-grid-hbar-center"></div>',
                    '<div class="editable-grid-hbar-right"><div id="{%= $.gridNodeId %}_recordCountLabel"></div></div>',
            '</div>',
            '</div>'
        ]),
        setupHeader: function () {
            //Get the headerBar created and ready.
            this.recordCountLabel = new ToolBarLabel();
            this.recordCountLabel.set('label', dojo.string.substitute(this.recordCountFormatString, this._getRecordCount()));
            var headerBar = this.headerTemplate.apply(this);
            headerBar = dojo.toDom(headerBar);
            this.headerContentPane = parser.parse(headerBar);
            // Put the header bar in place.
            //dojo.place(this.headerBar, this.gridNodeId, 'before');
            var container = dijit.byId(this.gridNodeId);
            container.addChild(this.headerContentPane[0]);
            // Put the record label in place
            dojo.place(this.recordCountLabel.domNode, this.gridNodeId + '_recordCountLabel', 'replace');
        },
        resetContextualCondition: function (contextualCondition) {
            if (typeof contextualCondition === 'function') {
                this.query = { fn: contextualCondition, scope: this };
            } else if (typeof contextualCondition === 'object') {
                if (contextualCondition.fn) {
                    this.ensureValue(contextualCondition, 'scope', this);
                    this.query = contextualCondition;
                }
            }
            this.contextualCondition = contextualCondition;

        },
        _getRecordCount: function () {
            // summary: Returns an array with the counts for the displayed records in the grid.  [firstrow, lastrow, count]
            var scroller,
                firstrow,
                lastrow,
                count;
            scroller = this.scroller;
            count = scroller.rowCount;
            if (count <= 0) {
                firstrow = 0;
                lastrow = 0;
                count = 0;
            } else {
                firstrow = (scroller.firstVisibleRow === 0) ? 1 : scroller.firstVisibleRow + 1;
                lastrow = (scroller.lastVisibleRow >= scroller.rowCount) ? scroller.rowCount : scroller.lastVisibleRow;
            }
            return [firstrow, lastrow, count];
        },
        _onScroll: function (inTop) {
            // Set the record count.
            if (this.recordCountLabel) {
                this.recordCountLabel.set('label', dojo.string.substitute(this.recordCountFormatString, this._getRecordCount()));
            }
        },
        _setMiddleAreaHeight: function (data) {
            var selfQuery = ['#', data.tab.ElementId, ' #', this.id].join('');
            var self = dojo.query(selfQuery)[0];
            if (self) {
                var middleTabItemQuery = ['#', data.tab.ElementId, ' .tws-tab-view-body'].join('');
                var middleTabItemViewBody = dojo.query(middleTabItemQuery)[0];
                //Set a default height (> 0) so the grid will have a place to expand from.
                dojo.style(middleTabItemViewBody, 'height', '10px');
                TabControl.setViewBodyHeight();
            }
        },
        _setUserPrefColumnWidths: function () {
            var self = this;
            dojo.forEach(this.columns, function (col) {
                if (col && col.field) {
                    var key = self._getColumnSizeKey(col),
                        value = self.getFromLocalStorage(key, self.STORE_NS);
                    if (value) {
                        col.width = value;
                    }
                }
            });
        },
        _getColumnSizeKey: function (cell) {
            var fieldStripped = cell.field.replace(/[\.\$]/g, '_'),
                id = [this.id, '_', this.STORE_KEY_COLUMN_SIZE, fieldStripped].join('');
            return id;
        },
        _onResizeColumn: function (columnIndex) {
            // Handle size storage
            var cell = this.getCell(columnIndex),
                value = cell.unitWidth,
                key = this._getColumnSizeKey(cell);
            this.saveToLocalStorage(key, value, this.STORE_NS);
        },
        listenForPageSave: function () {
            var bindingMgr = Sage.Services.getService('ClientBindingManagerService');
            if (bindingMgr) {
                bindingMgr.addListener(bindingMgr.ON_SAVE, this.saveChanges, this);
            }
        },
        removePageSaveListener: function () {
            var bindingMgr = Sage.Services.getService('ClientBindingManagerService');
            if (bindingMgr) {
                bindingMgr.removeListener(bindingMgr.ON_SAVE, this.saveChanges);
            }
        },
        setEditable: function () {
            var editable = true, i;
            //Check Action security of the grid.
            if (this.appliedSecurity) {
                var svc = Sage.Services.getService("RoleSecurityService");
                if (svc) {
                    editable = svc.hasAccess(this.appliedSecurity);
                }
            }
            if (this.readOnly) {
                editable = false;
            }

            //If user does not have edit access to the grid, we need to override each column and set them to false.
            if (!editable) {
                for (i = 0; i < this.columns.length; i++) {
                    if (this.columns[i].editable) {
                        this.columns[i].editable = false;
                    }
                }
                this.editable = false;
            } else {
                //if any of the columns are editable, assume the grid is editable...
                for (i = 0; i < this.columns.length; i++) {
                    if (this.columns[i].editable) {
                        this.editable = true;
                        break;
                    }
                }
            }
        },
        onHeaderCellClick: function (e) {
            // summary:
            // OVERRIDE of event fired when a header cell is clicked.
            // e: Event
            // Decorated event object which contains reference to grid, cell, and rowIndex
            // description:
            // Override for grid sorting to allow for:
            // 1. Disabling of sorting on a column level.
            // 2. Disabling of sorting on Insert mode due to limitations in the WritableStore.
            // 3. Displaying PageExitWarningMessage when unsaved data exists.
            var r = true;
            if (this.store.dirtyDataCache.isDirty) {
                var s = Sage.Services.getService("ClientBindingManagerService");
                r = confirm(s._PageExitWarningMessage);
            }
            if (this.columns[e.cell.index].sortable === false || !r || this.mode === 'insert') {
                dojo.stopEvent(e);
            }
            else {
                this.inherited(arguments);
                var sortProps = this.getSortProps();
                if (sortProps && sortProps.length > 0) {
                    var sortInfo = sortProps[0];
                    sortInfo.cellIndex = e.cell.index;
                    this.saveToLocalStorage(this.STORE_KEY_SORT + this.id, sortInfo, this.STORE_NS);
                }
            }
        },
        _setSortInfo: function () {
            var key = this.STORE_KEY_SORT + this.id;
            var sortProps = this.getFromLocalStorage(key, this.STORE_NS);
            if (sortProps) {
                if (sortProps.descending) {
                    this.sortInfo = (sortProps.cellIndex + 1) * -1;
                } else {
                    this.sortInfo = sortProps.cellIndex + 1;
                }
            }
        },
        ensureValue: function (obj, key, defaultValue) {
            obj[key] = obj[key] || defaultValue;
        },
        amIInATab: function () {
            if (this.context && this.context.workspace) {
                return (this.context.workspace.indexOf('TabWorkspace') > -1);
            }
            return false;
        },
        isMyTabVisible: function () {
            if (this.amIInATab() && window.TabControl) {
                return window.TabControl.getState().isTabVisible(this.tabId);
            }
            return true;
        },
        startup: function () {
            if (this._started) {
                return;
            }

            console.warn('ToDo: EditableGrid needs to connect to tab change events to properly refresh themselves.   EditableGrid - startup()');

            //            if (!this.isMyTabVisible()) {
            //                if (this.hasTabListeners) {
            //                    return;
            //                }
            //                if (typeof TabControl !== 'undefined') {
            //                    this.moreTabListener = TabControl.addListener('moretabchange', this.startup, this);
            //                    this.mainTabListener = TabControl.addListener('maintabchange', this.startup, this);
            //                    this.hasTabListeners = true;
            //                    return;
            //                }
            //            } else {
            //                if (this.hasTabListeners && TabControl) {
            //                    TabControl.removeListener('moretabchange', this.startup, this);
            //                    TabControl.removeListener('maintabchange', this.startup, this);
            //                    this.hasTabListeners = false;
            //                }
            //            }

            this.inherited(arguments);
            if (this.mode !== 'insert') {
                this.listenForPageSave();
            }
            // There are certain scenarios where a default height is required.
            if (this.context && this.context.workspace) {
                if (this.context.workspace.indexOf('TabWorkspace') <= -1) {
                    //console.log('grid.id = ' + this.id);
                    dojo.style(dojo.byId(this.id + '_Container'), 'height', '300px');
                    var main = dijit.byId(this.gridNodeId);
                    main.resize();
                }
            }
            if (this.amIInATab() && this.isMyTabVisible()) {
                var formtableQuery = ['#', 'element_', this.tabId, ' .formtable'].join('');
                var formTableBody = dojo.query(formtableQuery)[0];
                // Control is in a visible tab that is using a table layout
                if (formTableBody) {
                    //Editable Grid with it's container in markup
                    var container = dojo.byId(this.id + '_Container');
                    if (!container) {
                        //Preview Grid Layout container
                        container = dijit.byId(this.id).getParent();
                        container = container.domNode;
                    }

                    dojo.style(container, 'height', '300px');
                }
            }
        },
        destroy: function () {
            if (this.lookupControl) {
                this.lookupControl.destroy(false);
            }

            if (this.toolbar) {
                this.toolbar.destroy(false);
            }

            if (this.grid) {
                this.grid.destroy(false);
            }

            if (this.store && this.store.destroy) {
                this.store.destroy(false);
            }

            if (this._registeredWidgets) {
                array.forEach(this._registeredWidgets, function (item) {
                    item.destroy(false);
                });

                this._registeredWidgets = null;
            }

            this.removePageSaveListener();
            this.inherited(arguments);
        },
        _replaceStore: function () {
            dojo.forEach(this._dataChangeConnections, function (connection) {
                dojo.disconnect(connection);
            });
            if (this.store && this.store.destroy) {
                this.store.destroy(false);
            }
            this.store = false;
            this.store = this.getStore();
        },
        getStore: function () {
            if (this.store) {
                return this.store;
            }

            this.storeOptions['isInsertMode'] = (this.mode === 'insert');

            var store = (this.mode !== 'insert')
                ? new WritableSDataStore(this.storeOptions)
                : new WritableStore(this.storeOptions);

            if (this.onDataChange) {
                this._dataChangeConnections.push(dojo.connect(store, 'onSet', this.onDataChange));
            }
            if (store.onDataChange) {
                this._dataChangeConnections.push(dojo.connect(store, 'setValue', store.onDataChange));
                this._dataChangeConnections.push(dojo.connect(store, 'saveNewEntity', store.onDataChange));
                this._dataChangeConnections.push(dojo.connect(store, 'deleteItem', store.onDataChange));
                this._dataChangeConnections.push(dojo.connect(store, 'createItem', store.onDataChange));
            }
            this._dataChangeConnections.push(dojo.connect(store, 'onSet', this, function (entity, attribute, oldValue, newValue) {
                if (this.mode !== 'insert' && newValue) {
                    //Varying column types have different levels of depth. We must check down the chain to
                    // get to our returnObject property.
                    if (this.edit.info.cell &&
                        this.edit.info.cell.widget &&
                        this.edit.info.cell.widget.returnObject === true) {
                        if (oldValue.$key !== newValue.$key) {
                            this.markDirty();
                        }
                    }
                    else {
                        if (oldValue !== newValue) {
                            this.markDirty();
                        }
                    }
                }
            }));

            return store;
        },
        customKeyDown: function (e) {
            this.applyEditOnEnter(e);
            this.navigateOnKeyDown(e);
        },
        navigateOnKeyDown: function (e) {
            /* This code is causing the cells data to copy into the next cell on down arrow.
            if (e.keyCode === 38 || e.keyCode === 40) {
            var newRow = this.selection.selectedIndex;
            newRow = (e.keyCode === 38) ? newRow - 1 : newRow + 1;  // Arrow button conditions
            newRow = (newRow < 0) ? 0 : newRow;
            newRow = (newRow > this.rowCount - 1) ? this.rowCount - 1 : newRow;
            this.focus.setFocusIndex(newRow, 0);
            this.selection.deselectAll();
            this.selection.select(newRow);
            this.focus.scrollIntoView();
            dojo.stopEvent(e);
            }
            */
        },
        applyEditOnEnter: function (e) {
            if (e.charOrCode == 13 || e.keyCode == 13) {
                this.doApplyEdit();
                this.edit.apply();
                dojo.stopEvent(e);
            }
        },
        createOwnToolbar: function () {
            var roleService = Sage.Services.getService("RoleSecurityService");
            var container = dijit.byId(this.gridNodeId);
            this.toolbar = new Toolbar({ 'class': 'right-tools', 'region': 'top' });
            container.addChild(this.toolbar);
            for (var i = 0; i < this.tools.length; i++) {
                var tool = this.tools[i];
                if (tool.appliedSecurity && tool.appliedSecurity !== '') {
                    if ((roleService) && (!roleService.hasAccess(tool.appliedSecurity))) {
                        continue;
                    }
                }
                var btn = false;
                if (typeof tool === 'string') {
                    switch (tool) {
                        case 'add':
                            btn = new ImageButton({
                                imageClass: 'icon_plus_16x16',
                                tooltip: this.addText,
                                id: this.id + '_addBtn',
                                onClick: dojolang.hitch(this, function () { this.addNew(); })
                            });
                            break;
                        case 'delete':
                            btn = new ImageButton({
                                imageClass: 'icon_Delete_16x16',
                                tooltip: this.deleteText,
                                id: this.id + '_delBtn',
                                onClick: dojolang.hitch(this, function () { this.deleteSelected(); })
                            });
                            break;
                        case 'save':
                            btn = new ImageButton({
                                imageClass: 'icon_Save_16x16',
                                tooltip: this.saveText,
                                id: this.id + '_saveBtn',
                                onClick: dojolang.hitch(this, function () { this.saveChanges(); })
                            });
                            break;
                        case 'cancel':
                            btn = new ImageButton({
                                imageClass: 'icon_Reset_16x16',
                                tooltip: this.cancelText,
                                id: this.id + '_cancelBtn',
                                onClick: dojolang.hitch(this, function () { this.cancelChanges(); })
                            });
                            break;
                    }
                } else {
                    if ((tool.type) && (tool.type === 'Sage.UI.SDataLookup')) {
                        var conf = tool.controlConfig || tool;
                        btn = new SDataLookup(conf);
                        this.lookupControl = btn;
                    } else {
                        btn = new ImageButton({
                            icon: tool.icon || '',
                            imageClass: tool.imageClass || '',
                            id: tool.id,
                            onClick: dojolang.hitch(tool.scope || this, tool.handler),
                            tooltip: tool.alternateText || tool.tooltip
                        });
                    }
                }
                if (btn) {
                    this.toolbar.addChild(btn);
                    btn = false;
                }
            }

            this.toolbar.startup();
        },
        addToolsToWorkspaceToolbar: function () {
            //summary:
            //Add items to the rightToolsContainer

            if (this.readOnly) {
                return;
            }
            //Add dirty data message.
            //TODO: Rename TabId to containerNodeId.  Requires template change.
            this.dirtyDataMsgID = this.tabId + '_dirtydatamsg';
            var msgBox = domConstruct.create('span', {
                'class': 'grid-unsaveddata-msg',
                'id': this.dirtyDataMsgID,
                'style': 'display:none;',
                //TODO: Localize
                'content': (this.editable) ? this.unsavedDataText : ''
            });
            var rightToolsContainer, containerId;
            //Place the tools and 'unsaved data' message into the correct workspace.
            switch (this.context.workspace) {
                case 'Sage.Platform.WebPortal.Workspaces.Tab.TabWorkspace':
                    //Don't add the dirty data message if we are in insert mode.  All data is dirty in insert mode.
                    if (this.mode !== 'insert') {
                        var elem = dojo.query('#' + 'element_' + this.tabId + ' td.tws-tab-view-title');
                        if (elem.length > 0) {
                            dojo.place(msgBox, elem[0]);
                        }
                    }
                    containerId = ['element_', this.tabId].join('');
                    rightToolsContainer = dojo.query(['#', containerId, ' td.tws-tab-view-tools-right'].join(''));
                    break;
                case 'Sage.Platform.WebPortal.Workspaces.MainContentWorkspace':
                    //Don't add the dirty data message if we are in insert mode.  All data is dirty in insert mode.
                    if (this.mode !== 'insert') { dojo.place(msgBox, dojo.query('#' + this.tabId + ' span.mainContentHeaderTitle')[0]); }
                    //This containerId assignment appears redundant but we need the specific Id for the later query when placing the tool.
                    containerId = this.tabId;
                    rightToolsContainer = dojo.query('#' + containerId + ' td.mainContentHeaderToolsRight');
                    break;
                case 'Sage.Platform.WebPortal.Workspaces.DialogWorkspace':
                    //This containerId assignment appears redundant but we need the specific Id for the later query when placing the tool.
                    rightToolsContainer = dojo.query('td.dialog-tools-right');
                    break;
                default:
            }

            var roleService = Sage.Services.getService("RoleSecurityService");
            //Some buttons may be hidden in different modes and/or security levels.  
            //We'll keep a position variable to make sure the group stays together.            
            var position = 0, positionString, refNode;
            for (var i = 0; i < this.tools.length; i++) {
                positionString = '';
                var tool = this.tools[i];
                if (typeof tool.mergeControlId !== 'undefined' && tool.mergeControlId.length !== 0) {
                    refNode = dojo.query('[id$=' + tool.mergeControlId + ']', dojo.byId('element_' + this.tabId))[0];
                    positionString = tool.mergePosition.toLowerCase();
                }
                if (!refNode) {
                    // No control to place next to.  Use the container and possition 0.
                    refNode = rightToolsContainer[0];
                    positionString = '';
                }
                if (this.mode === 'insert' && !tool.displayInInsert) {
                    continue;
                }
                //check user's access to this functionality...
                if (tool.appliedSecurity && tool.appliedSecurity !== '') {
                    if ((roleService) && (!roleService.hasAccess(tool.appliedSecurity))) {
                        continue;
                    }
                }
                if (typeof tool === 'string') {
                    switch (tool) {
                        case 'add':
                            var addid = this.id + '_addBtn';
                            var addBtn = new ImageButton({
                                id: addid,
                                imageClass: 'icon_plus_16x16',
                                onClick: dojolang.hitch(this, this.addNew),
                                tooltip: this.addText
                            });
                            this._registeredWidgets.push(addBtn);
                            dojo.place(addBtn.domNode, rightToolsContainer[0], position);
                            break;
                        case 'delete':
                            var delid = this.id + '_delBtn';
                            var delBtn = new ImageButton({
                                id: delid,
                                tooltip: this.deleteText,
                                imageClass: 'icon_Delete_16x16',
                                onClick: dojolang.hitch(this, this.deleteSelected)
                            });
                            this._registeredWidgets.push(delBtn);
                            dojo.place(delBtn.domNode, rightToolsContainer[0], position);
                            break;
                        case 'save':
                            var saveid = this.id + '_saveBtn';
                            var saveBtn = new ImageButton({
                                id: saveid,
                                tooltip: this.saveText,
                                imageClass: 'icon_Save_16x16',
                                onClick: dojolang.hitch(this, this.saveChanges)
                            });
                            this._registeredWidgets.push(saveBtn);
                            dojo.place(saveBtn.domNode, rightToolsContainer[0], position);
                            break;
                        case 'cancel':
                            var cclid = this.id + '_cancelBtn';
                            var cancelBtn = new ImageButton({
                                id: cclid,
                                tooltip: this.cancelText,
                                imageClass: 'icon_Reset_16x16',
                                onClick: dojolang.hitch(this, this.cancelChanges)
                            });
                            this._registeredWidgets.push(cancelBtn);
                            dojo.place(cancelBtn.domNode, rightToolsContainer[0], position);
                            break;
                    }
                } else {
                    if ((tool.type) && (tool.type === 'Sage.UI.SDataLookup')) {
                        var conf = tool.controlConfig || tool;
                        var lup = new SDataLookup(conf);
                        dojo.place(lup.domNode, refNode, position);
                        this.lookupControl = lup;
                    } else {
                        var custombtn = new ImageButton({
                            id: tool.id,
                            icon: tool.icon || '',
                            imageClass: tool.imageClass || '',
                            onClick: dojolang.hitch(tool.scope || this, tool.handler),
                            tooltip: tool.alternateText || tool.tooltip
                        });
                        this._registeredWidgets.push(custombtn);
                        dojo.place(custombtn.domNode, refNode, (positionString.length > 0) ? positionString : position);
                    }
                }
                //Increment the position for consistent grouping of these items.
                position++;
            }
        },
        addNew: function (args) {
            if (this.store) {
                this.store.newItem(args);
            }
        },
        addAssociatedItems: function (items, parentName, childName, lookup) {
            // summary:
            //  Helper function for lookup tools.  This can be called by the handler to add items selected in a lookup
            var grid = this;
            if (Utility.getModeId() !== 'insert' && this.store.dirtyDataCache.isDirty) {
                Dialogs.raiseQueryDialog(
                    'Infor CRM',
                    this.dirtyDataMessage,
                    function (result) {
                        if (result) {
                            grid.addSelectedItems(items, parentName, childName, lookup);
                        }
                    },
                    this.okText,
                    this.cancelText
                );
            }
            else {
                grid.addSelectedItems(items, parentName, childName, lookup);
            }
        },
        addSelectedItems: function (items, parentName, childName, lookup) {
            var entities = [];
            var grid = this;
            for (var i = 0; i < items.length; i++) {
                var hasRecord = false;
                // duplicate detection
                for (var k in grid.store.dataCache) {
                    var rec = grid.store.dataCache[k];
                    if (rec[childName] && rec[childName].$key == items[i].$key)
                        hasRecord = true;
                }
                if (hasRecord)
                    continue;

                //Insert mode check
                var newRecord = {};
                if (Utility.getModeId() !== 'insert') {
                    newRecord[parentName] = { $key: Utility.getCurrentEntityId() };
                }
                newRecord[childName] = {};
                Utility.extend(newRecord[childName], items[i]);
                delete newRecord.$key;
                delete newRecord.$name;
                delete newRecord.$url;
                entities.push(newRecord);
            }
            if (entities.length > 0)
                grid.createItems(entities, function () {
                    if (Utility.getModeId() !== 'insert') {
                        __doPostBack("MainContent", "");
                    }
                });
            if (lookup)
                lookup.lookupDialog.hide();
        },
        createItems: function (items, callback) {
            if (dojo.isArray(items)) {
                var store = this.store;
                var iCreateCount = items.length;
                if (typeof console !== 'undefined') {
                    console.log('createItems() items.length = %o', iCreateCount);
                }
                //TODO: Replace callback with webworker.
                var fnResponse = function (arg1) {
                    // "this.", within the scope of fnResponse(), refers to the scope object below.
                    this.currentCount = this.currentCount + 1;
                    if (typeof console !== 'undefined') {
                        if (arg1 && typeof arg1 !== 'undefined' && arg1.getResponseHeader) {
                            console.log('createItems() response: (status = %o; statusText = %o): currentCount = %o; totalCount = %o',
                            arg1.status || 0, arg1.statusText || "", this.currentCount, this.totalCount);
                            console.log('createItems() response ETag: %o', arg1.getResponseHeader('ETag'));
                        } else {
                            if (arg1 && typeof arg1 !== 'undefined' && typeof arg1.$httpStatus === 'string') {
                                console.log('createItems() response ($httpStatus: %o; $key: %o; $descriptor: %o $etag: %o): currentCount = %o; totalCount = %o',
                                arg1.$httpStatus, arg1.$key || "", arg1.$descriptor, arg1.$etag, this.currentCount, this.totalCount);
                            } else {
                                console.log('createItems() response: (unknown status): currentCount = %o; totalCount = %o',
                                this.currentCount, this.totalCount);
                            }
                        }
                    }
                    if (this.currentCount === this.totalCount) {
                        this.grid.refresh();
                        if (typeof this.onComplete === 'function') {
                            this.onComplete.call(this.grid);
                        }
                    }
                };
                var scope = { grid: this, totalCount: iCreateCount, currentCount: 0, onResponse: fnResponse, onComplete: callback || null };
                for (var i = 0; i < items.length; i++) {
                    store.createItem(items[i], scope);
                }
            }
            else {
                //TODO: Localize and use message service.
                Dialogs.showError(this.createItemsInvalidArrayText);
            }
        },
        deleteSelected: function (callback) {
            var selectedItems = this.selection.getSelected();
            if (selectedItems.length < 1) {
                Dialogs.showError(this.noSelectionsText);
                return;
            }
            if (this.mode !== 'insert') {
                if (!this.store._checkPageExitWarningMessage()) {
                    return;
                }
            }
            var self = this;
            var opts = {
                title: 'Infor CRM',
                query: dojo.string.substitute(this.confirmDeleteFmtTxt, [selectedItems.length]),
                callbackFn: function (result) { self.deleteCallback(result, callback, selectedItems); },
                yesText: this.buttonOk, //OK
                noText: this.buttonCancel //Cancel
            };
            Dialogs.raiseQueryDialogExt(opts);
        },
        deleteCallback: function (result, callback, selectedItems) {
            if (result) {
                var grid = this;
                var store = this.store;
                var iDeleteCount = 0;
                for (var i = 0; i < selectedItems.length; i++) {
                    if (this.store.isItem(selectedItems[i])) {
                        iDeleteCount++;
                    }
                }
                grid.selection.clear();
                this.showLoading();
                //TODO: Replace callback with webworker.
                var fnResponse = function (arg1, arg2) {
                    // "this.", within the scope of fnResponse(), refers to the scope object below.
                    this.currentCount = this.currentCount + 1;
                    if (typeof console !== 'undefined') {
                        if (arg1 && typeof arg1 !== 'undefined' && arg1.getResponseHeader) {
                            console.log('deleteSelected() response: (status = %o; statusText = %o): currentCount = %o; totalCount = %o',
                                arg1.status || 0, arg1.statusText || "", this.currentCount, this.totalCount);
                            console.log('deleteSelected() response ETag: %o', arg1.getResponseHeader('ETag'));
                        } else {
                            console.log('deleteSelected() response (OK): currentCount = %o; totalCount = %o', this.currentCount, this.totalCount);
                        }
                    }
                    if (this.currentCount === this.totalCount) {
                        grid.refresh();
                        if (typeof this.onComplete === 'function') {
                            this.onComplete.call(grid);
                        }
                    }
                };
                var scope = { grid: grid, totalCount: iDeleteCount, currentCount: 0, onResponse: fnResponse, onComplete: callback || null };
                for (i = 0; i < selectedItems.length; i++) {
                    if (store.isItem(selectedItems[i])) {
                        store.deleteItem(selectedItems[i], scope);
                    }
                }
                if (!this.storeOptions.hasOwnProperty('clearStoreCacheOnDelete') || this.storeOptions.clearStoreCacheOnDelete === true) {
                    store.clearCache();
                }
            }
        },
        cancelChanges: function () {
            if (this.store && this.store.revert) {
                this.store.revert();
                this.markClean();
                this.refresh();
            }
        },
        saveChanges: function (callback) {
            //grids onBlur event doesn't work as expected in IE9, have to actually click outside the grid to have the event fire, so in lieu of relying on that event we'll just apply here
            this.onBlur();

            //Can be called from a listener on the page level save.  If the store is a proxy sdata store, it will not have a save function.
            if (!this.store.save) return;

            var iSaveCount = 0;
            for (var key in this.store.dirtyDataCache) {
                if (key !== 'isDirty') {
                    var entity = this.store.dirtyDataCache[key];
                    if (this.store.isItem(entity)) {
                        iSaveCount++;
                    }
                }
            }
            //TODO: Replace callback with webworker.
            var fnResponse = function (arg1, arg2) {
                // "this.", within the scope of fnResponse(), refers to the scope object below.
                this.currentCount = this.currentCount + 1;
                if (typeof console !== 'undefined') {
                    if (arg1 && typeof arg1 !== 'undefined' && arg1.getResponseHeader) {
                        console.log('saveChanges() response: (status = %o; statusText = %o): currentCount = %o; totalCount = %o',
                        arg1.status || 0, arg1.statusText || "", this.currentCount, this.totalCount);
                        console.log('saveChanges() response ETag: %o', arg1.getResponseHeader('ETag'));
                    } else {
                        if (arg1 && typeof arg1 !== 'undefined' && typeof arg1.$httpStatus === 'string') {
                            console.log('saveChanges() response ($httpStatus: %o; $key: %o; $descriptor: %o $etag: %o; $updated: %o): currentCount = %o; totalCount = %o',
                            arg1.$httpStatus, arg1.$key || "", arg1.$descriptor, arg1.$etag, arg1.$updated, this.currentCount, this.totalCount);
                        } else {
                            console.log('saveChanges() response: (unknown status): currentCount = %o; totalCount = %o',
                            this.currentCount, this.totalCount);
                        }
                    }
                }
                if (this.currentCount === this.totalCount) {
                    this.grid.markClean();
                    this.grid.refresh();
                    if (typeof this.onComplete === 'function') {
                        this.onComplete.call(this.grid);
                    }
                }
            };
            var scope = { grid: this, totalCount: iSaveCount, currentCount: 0, onResponse: fnResponse, onComplete: callback || null };
            this.store.save(scope);
        },
        markClean: function () {
            if (this.dirtyDataMsgID) {
                var dirtyDataMsg = dojo.byId(this.dirtyDataMsgID);
                if (dirtyDataMsg) {
                    dojo.style(dojo.byId(this.dirtyDataMsgID), 'display', 'none');
                }
                var bindingMgr = Sage.Services.getService('ClientBindingManagerService');
                if (bindingMgr) {
                    bindingMgr.clearDirtyAjaxItem(this.id);
                }
            }
        },
        markDirty: function () {
            var node = dojo.byId(this.dirtyDataMsgID);
            if (node) {
                dojo.style(node, 'display', 'inline');
            }
            var bindingMgr = Sage.Services.getService('ClientBindingManagerService');
            if (bindingMgr) {
                bindingMgr.addDirtyAjaxItem(this.id);
            }
        },
        refresh: function () {
            if (!this.scroller) {
                return;
            }
            this._refresh();
            this.onRefresh();
        },
        onRefresh: function () { }
    });
    return editableGrid;
});

},
'Sage/Data/WritableStore':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
        'Sage/Data/BaseSDataStore',
        'Sage/Utility',
        'dojo/_base/declare',
        'dojo/_base/lang'
],
function (BaseSDataStore, Utility, declare, lang) {
    var writableStore = declare('Sage.Data.WritableStore', BaseSDataStore, {
        //  summary:
        //      A data store implementation that allows the EditableGrid to have its data participate in .net postback and binding
        //      Configuration information is recieved from EditableGrid.
        //  description:
        //      dojo.data.api.Identity Implemented on BaseSDataStore...
        //      dojo.data.api.Read Implemented on BaseSDataStore...        
        isInsertMode: false,
        constructor: function (o) {
            lang.mixin(this, o);
            this.features['dojo.data.api.Write'] = true;
            this.features['dojo.data.api.Notification'] = true;
            this.identityAttributes = ['$cacheID'];
            this.dirtyDataCache = { isDirty: false };
            this.singleResourceRequest = null;
            if (!o.hasOwnProperty('isInsertMode')) {
                this.isInsertMode = Utility.getModeId() === 'insert';
            }
        },
        entry: '',
        fetch: function (context) {
            //summary:
            //  Retrieve data from dataCarrier, dataCache and/or feed, and provide it to the grid.
            var items = {};
            items.$resources = [];

            //Read from DataCarrier/TextBox only onLoad.
            if (context.isRender && this.dataCarrierId) {
                var carrier = dojo.query(['.', this.dataCarrierId].join(''));
                if (carrier[0].value.length > 0) {
                    var carrierItems = dojo.fromJson(carrier[0].value);
                    this.addItemsToCache(context, carrierItems.$resources);
                }
            }

            // Restructure the dataCache into an array to supply to the grid.
            for (var item in this.dataCache) {
                if (this.dataCache.hasOwnProperty(item) && item !== 'query') {
                    items.$resources.push(this.dataCache[item]);
                }
            }

            this.setContext(context);
            this.verifyService();

            //Check to see if anything has been added to cache.  Either from a lookup or a .net DataCarrier.
            //if (items.$resources && items.$resources.length > 0) {
            if (this.isInsertMode) {
                var self = this;
                window.setTimeout(function () { self.onSuccess(context, items); }, 5);
                return;
            }

            var request = new Sage.SData.Client.SDataResourceCollectionRequest(this.service)
                .setResourceKind(this.resourceKind)
                .setStartIndex(context.start + 1)
                .setCount(context.count);

            // TODO: How much of this query work is needed for Insert mode??
            var qry = '';
            // Check to see if a query has been added directly to the store, for binding with native dojo components, ie. ComboBox
            // TODO: Determine patterns for mixin, replacement, seed value, etc. of query, 
            if (this.query) {
                if (!context.query) {
                    context.query = {};
                }
                lang.mixin(context.query, this.query);
            }
            if (context.query) {
                if (typeof context.query === 'function') {
                    qry = context.query();
                } else if (typeof context.query === 'string') {
                    qry = context.query;
                } else if (typeof context.query === 'object') {
                    if (context.query.hasOwnProperty('fn')) {
                        qry = context.query.fn.call(context.query.scope || this);
                    }
                    if (context.query.hasOwnProperty('conditions')) {
                        if (typeof context.query.conditions === 'string') {
                            qry += (qry.length > 0) ? ' and ' + context.query.conditions : context.query.conditions;
                        }
                    }
                }
            }

            context.evaluatedQuery = qry || '';
            if (qry && qry !== '') {
                request.setQueryArg('where', qry);
            }
            if (this.select && this.select.length > 0)
                request.setQueryArg('select', this.select.join(','));
            if (this.include && this.include.length > 0)
                request.setQueryArg('include', this.include.join(','));

            // Make the request to get the sdata schema information for the entity.  
            // In Insert mode, the entityId will be 'Insert' and no results will be returned.
            var key = request.read({
                success: lang.hitch(this, this.onSuccess, context),
                failure: lang.hitch(this, this.onFailure, context)
            });

            return {
                abort: lang.hitch(this, this.abortRequest, key)
            };
        },
        onSuccess: function (context, feed) {
            //summary:
            //  Provides the items to the grid for rendering.
            //description:       
            //  Checks if the data carrier has received the feed header.  If not, add it.            
            if (this.entry === '') {
                this.entry = feed;
            }
            if (context.onBegin) {
                context.onBegin.call(context.scope || this, feed.$resources.length, context);
            }
            if (context.onComplete) {
                context.onComplete.call(context.scope || this, feed.$resources, context);
            }
        },
        addToCache: function (context, item, count) {
            var key;
            count = (typeof count === 'undefined') ? (Math.random() * 11) : count;
            if (this.isInsertMode) {
                //console.log(new Date().getTime());
                item.$cacheID = new Date().getTime() + count;
            }
            key = this.getIdentity(item);
            this.dataCache[key] = item;
        },
        addItemsToCache: function (context, items) {
            for (var i = 0; i < items.length; i++) {
                this.addToCache(context, items[i], i);
            }
        },
        clearCache: function () {
            //  summary:
            //      Inherits from BaseSDataStore.clearCache which clears data cache.  Calls clearDirtyDataCache as well for edit mode data.
            this.inherited(arguments);
            this.clearDirtyDataCache();
        },
        clearDirtyDataCache: function () {
            //  summary:
            //    Clears dirty data cache created from edit mode changes.  Sets isDirty flag to 'false'
            for (var key in this.dirtyDataCache) {
                if (key !== 'isDirty') {
                    delete this.dirtyDataCache[key];
                }
            }
            this.dirtyDataCache.isDirty = false;
            //this.dirtyDataCache = { isDirty: false };
        },
        isItem: function (something) {
            //  summary:
            //      Performs hasOwnProperty check on dataCache to verify if the provided item already exists.
            //  returns:
            //      'true' if dataCache has property, else 'false'
            var id = this.getIdentity(/* anything */something);
            if (id && id !== '') {
                return this.dataCache.hasOwnProperty(id);
            }
            return false;
        },
        isItemLoaded: function (/* anything */something) {
            //  summary:
            //      Performs isItem check on 'this' to verify if the provided item already exists.
            //  returns:
            //      'true' if Item exists, else 'false'
            return this.isItem(something); //boolean
        },
        loadItem: function (/* object */keywordArgs) {
            //  summary:
            //      REDUNDANT??
            if (!this.isItem(keywordArgs.item)) throw new Error('Unable to load ' + keywordArgs.item);
        },
        getValues: function (item, attributename) {
            if (this.isItem(item) && (typeof attributename === "string")) {
                return (item[attributename] || []).slice(0);
            }
            return [];
        },
        hasAttribute: function (item, attributename) {
            if (this.isItem(item) && (typeof attributename === "string")) {
                return attributename in item;
            }
            return false;
        },
        close: function () {
            this.clearCache();
        },
        //dojo.data.api.Write implementations...
        deleteItem: function (item, scope) {
            //summary:
            //  Find the item in the cache and remove it.  Grid is responsible for refreshing itself.
            var id = this.getIdentity(item);
            if (id && id !== '') {
                delete this.dataCache[id];
            }
            var options = {};
            options.scope = scope || this;
            var fnSuccess = function () {
                if (typeof this.onResponse === 'function') {
                    this.onResponse.call(this);
                }
            };
            options.success = fnSuccess;
            options.success.call(options.scope);
        },
        isDirty: function (item) {
            //item could be null - if so, it means is any item dirty...
            if (item) {
                var id = this.getIdentity(item);
                if (id && id !== '') {
                    return this.dirtyDataCache.hasOwnPropery(id);
                }
            }
            return this.dirtyDataCache.isDirty;
        },
        newItem: function (args /*, parentInfo */) {
            var request = this.createTemplateRequest();
            if (request) {
                request.read({
                    success: function (entry) {
                        if ((args) && (args.onComplete) && (typeof args.onComplete === 'function')) {
                            args.onComplete.call(args.scope || this, entry);
                        }
                    },
                    failure: this.requestTemplateFailure,
                    scope: this
                });
            }
        },
        createTemplateRequest: function () {
            //The entity to create the relationship/New record for, from the selection.        
            var request = new Sage.SData.Client.SDataTemplateResourceRequest(this.service);
            if ((this.resourceKind) && (this.resourceKind !== '')) {
                request.setResourceKind(this.resourceKind);
            }
            return request;
        },
        requestTemplateFailure: function () {
        },
        saveNewEntity: function (entity, success, failure, scope) {
            //summary:
            //  Create a new entity and add it to the dataCache.
            this.addToCache(scope, entity);
            success();
        },
        createItem: function (item, scope) {
            var options = {};
            options.scope = scope || this;
            options.scope.store = this;
            var fnSuccess = function (created) {
                if (typeof this.onResponse === 'function') {
                    this.onResponse.call(this, created);
                }
            };
            options.success = fnSuccess;
            this.addToCache(scope, item);
            options.success.call(options.scope, item);
        },
        revert: function () {
            //  summary:
            //      Clear the dirty data cache and call the onDataReset function.  
            //      The grid calls fetch again and gets the data.
            this.clearDirtyDataCache();
            this.onDataReset();
        },
        setValue: function (item, attribute, value) {
            //if (typeof console !== 'undefined') { console.log('setValue - %o %o %o', item, attribute, value) };
            var oldValue = this.getValue(item, attribute, '');
            Utility.setValue(item, attribute, value);
            this.onSet(item, attribute, oldValue, value);
            return true;
        },
        setValues: function (item, attribute, values) {
            alert('not implemented - setValues');
            //use where values is an array
        },
        unsetAttribute: function (item, attribute) {
            alert('not implemented - unsetAttribute');
            //delete all values of an attribute on the item...
        },
        dataCacheToArray: function () {
            var resources = [];
            for (var item in this.dataCache) {
                if (this.dataCache.hasOwnProperty(item) && item !== 'query') {
                    resources.push(this.dataCache[item]);
                }
            }
            return resources;
        },
        onDataChange: function () {
            //There is no dirtyDataCache tracking for Insert views.  Clear dirty data here, just in case.
            this.clearDirtyDataCache();
            var carrier = dojo.query(['.', this.dataCarrierId].join(''));
            if (carrier[0]) {
                this.entry.$resources = this.dataCacheToArray();
                carrier[0].value = JSON.stringify(this.entry);
            }
        },
        //dojo.data.api.Notification
        onSet: function (/* item */item,
        /*attribute-name-string*/attribute,
        /*object | array*/oldValue,
        /*object | array*/newValue) {
            // summary: 
            // See dojo.data.api.Notification.onSet()
            // No need to do anything. This method is here just so that the
            // client code can connect observers to it.
        },
        onNew: function (newItem, parentInfo) {
            //nothing to do here - client code connects observers to this
        },
        onDelete: function (deletedItem) {
            //nothing to do here - client code connects observers to this
        },
        onDataReset: function () {
        },
        onDataSaved: function () {
        },
        onItemSaved: function (savedItem, parentInfo) {
        },
        onItemNotSaved: function (notSavedItem, error) {
        }
    });
    return writableStore;
});

},
'Sage/UI/SDataLookup':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
/**
    @class Sage.UI.SDataLookup
sample config object for renderMode 5 ...
 {
    id: 'ProdLookup',
    btnToolTip: 'Lookup Product',
    dialogButtonText: 'Add Product',
    displayMode: 5, //$ {qf control . LookupDisplayMode}  When adding other dijit templates, 
        need to convert control to use enum values
    dialogTitle: 'Product Lookup',
    structure: [
        {
            name: 'Family',
            field: 'Family',
            displayField: 'Family',
            sortable: true,
            width: 15
        },
        {
            name: 'Name',
            field: 'Name',
            displayField: 'Name',
            sortable: true,
            width: 15
        },
        {
            name: 'Price',
            field: 'Price',
            displayField: 'Price',
            sortable: true,
            width: 15
        },
        {
            name: 'Program',
            field: 'Program',
            displayField: 'Program',
            sortable: true,
            width: 15
        }
    ]
    ], storeOptions: {
        resourceKind: 'products'
    },
    gridOptions: {
        selectionMode: 'Single',
        rowsPerPage: 15
    },
    doSelected: function (items) {
        var grid = dijit.byId('OppProducts');
        if (grid && grid.store) {
            grid.store.newItem({ onComplete: function (oppProduct) {
                var i;
                for (i = 0; i < items.length; i += 1) {
                    var newEntity = {};
                    var item = items[i];

                    oppProduct.Opportunity = { $key: Sage.Utility.getCurrentEntityId() };
                    //Set item to the product before destroying the key                           
                    oppProduct.Product = {};
                    delete item.index;
                    Sage.Utility.extend(oppProduct.Product, item);
                    //Clean up the item
                    delete item.$key;
                    delete item.$name;
                    delete item.$url;

                    Sage.Utility.extend(true, newEntity, oppProduct, item);
                    grid.store.saveNewEntity(newEntity, function (entity) { this._refresh(); }, function () { }, grid);
                }
            }
            });
        }
    }
}
*/
define([
    'dojo/_base/html',
    'dijit/Dialog',
    'dijit/form/Button',
    'Sage/UI/ComboBox',
    'Sage/Data/SDataServiceRegistry',
    'Sage/UI/ConditionManager',
    'Sage/Utility',
    'Sage/_Templated',
    'Sage/UI/Controls/GridParts/Columns/DateTime',
    'Sage/UI/Controls/GridParts/Columns/Phone',
    'Sage/UI/Controls/GridParts/Columns/PickList',
    'dijit/_Widget',
    'Sage/UI/Controls/_DialogHelpIconMixin',
    'dojo/_base/lang',
    'dojo/i18n!./nls/SDataLookup',
    'dojo/_base/declare',
    'Sage/UI/Controls/Grid',
    'Sage/Store/SData'
],
function (html, Dialog, Button, ComboBox, sDataServiceRegistry, ConditionManager, Utility, _Templated, DateTime, Phone, PickList, _Widget, DialogHelpIconMixin, lang, nlsResource, declare, Grid, SDataObjectStore) {
    (function () {
        if (!Utility) {
            Sage.namespace("Utility");
        }
        //TODO: Move to Sage.Utility
        Utility.addToListUnique = function (item, list) {
            for (var i = 0; i < list.length; i++) {
                if (item === list[i]) {
                    return;
                }
            }
            list.push(item);
        };

        Utility.SDataLookupChildObjectFormatter = function (opts) {
            console.warn("Deprecated: Utility.SDataLookupChildObjectFormatter. Use: Sage.Utility.SDataLookup.ChildObjectFormatter");
            var feedItem = opts,
                res,
                i;

            if (!feedItem || !feedItem[opts.childentity] || feedItem[opts.childentity].$resources.length === 0) {
                return dojo.string.substitute('<div style="text-indent:16px">${0}</div>', [opts.value || '&nbsp;']);
            }

            opts.value = opts.value || '&nbsp;';
            res = [];
            if (opts.includeButton) {
                res.push(dojo.string.substitute([
                    '<input type=button id="SOPshow${1}" style="height:16px;width:14px;border:0;background:transparent;vertical-align:top" onclick="dojo.query(\'.SOProw${1}\').style({display:\'\'});dojo.query(\'#SOPshow${1}\').style({display:\'none\'});dojo.query(\'#SOPhide${1}\').style({display:\'\'})" value="+">',
                    '<input type=button id="SOPhide${1}" style="display:none;height:16px;width:14px;border:0;background:transparent;vertical-align:top" onclick="dojo.query(\'.SOProw${1}\').style({display:\'none\'});dojo.query(\'#SOPshow${1}\').style({display:\'\'});dojo.query(\'#SOPhide${1}\').style({display:\'none\'})" value="-"> '
                ].join(''), [opts.value, opts.rowIdx]));
            }

            res.push(dojo.string.substitute('${0}<div class=SOProw${1} style="display:none">', [opts.value, opts.rowIdx]));
            for (i = 0; i < feedItem[opts.childentity].$resources.length; i++) {
                res.push(dojo.string.substitute('<div style="text-indent:2em">${0}</div>', [feedItem[opts.childentity].$resources[i][opts.fieldName] || '&nbsp;']));
            }

            res.push("</div>");
            return res.join('');
        };
    }());
    var widget = declare("Sage.UI.SDataLookup", [_Widget, _Templated], {
        config: null,
        grid: null,
        sdataStore: null,
        conditionMgr: null,
        structure: null,
        displayMode: 5,
        lookupDialog: null,
        dialogTitle: '',
        dialogWidth: 675,
        dialogHeight: 500,
        seedOnRowEntity: false,
        seedOnRelatedEntity: '',
        seedProperty: '',
        seedValue: '',
        overrideSeedValueOnSearch: false,
        preFilters: null,
        initializeLookup: true,
        rowEntityId: '',
        relatedEntityId: '',
        returnObject: true,
        addEmptyListItem: false,
        fields: null, //this.fields,
        query: null,
        // Id of the calling object.  Usage: To return data in doSelected.
        callerId: null,
        widgetsInTemplate: true,
        storeOptions: null,
        gridOptions: null,
        sortColumn: '',
        //On the close of the lookup there are requirements that we know what items where added. We can't use the grids row selections as that may not be accurate to what was added. In
        //other words you can add items multiple times without closing the lookup, in this case only the last selected item(s) will be available. This will keep a running tally of all
        //items added for this session
        newlyAddedItems: null,
        //Reference enum for Display Mode 
        displayModes: {
            'DropDownList': 0,
            'Dialog': 1,
            'HyperText': 2,
            'Text': 3,
            'ButtonOnly': 4,
            'ButtonOnlyClient': 5
        },
        btnIcon: 'images/icons/plus_16x16.gif',
        isModal: false,
        _addCondHandle: null,
        _removeCondHandle: null,
        _originalQueryConditions: '',
        id: 'lookupControl',

        dialogContent: new Simplate(['<div >',
            '<div style="padding:5px;" id="{%= $.id %}-Condition-container"></div>',
            '<div id="{%= $.id %}-Grid-container" style="width:auto;height:{%= $.gridHeight %}px;"></div>',
            '<div class="lookupButtonWrapper">',
            '{% if($.dialogButtonText){ %}',
                '<button data-dojo-type="dijit.form.Button" type="button" id="{%= $.id %}-GridSelectButton" ',
                    'onClick="dijit.byId(\'{%= $.id %}\').getGridSelections(); ">',
                    '{%= $.dialogButtonText %} </button>',
            '{% } %}',
                '<button data-dojo-type="dijit.form.Button" type="button" id="{%= $.id %}-CloseButton" ',
                'onClick="dijit.byId(\'{%= $.id %}\').doOnClose();">{%= $.hideText %}</button>',
            '</div>',
            '</div> ']),
        constructor: function () {
            this.gridOptions = {};
            this.storeOptions = {
                rowsPerPage: 20,
                include: [],
                select: ['Id'], //what about composite keys?
                sort: []
            };
            this.preFilters = [];
            this.newlyAddedItems = [];
            this.query = {};
            this.config = {};
            this.fields = [];
            this.structure = [];
            this.grid = [];
            this.sdataStore = [];
        },
        postMixInProperties: function () {
            var storeOptions,
             gridOptions;

            this._initialized = false;
            lang.mixin(this, dojo.i18n.getLocalization("Sage.UI", "SDataLookup"));
            if (typeof this.displayMode === 'string') {
                this.displayMode = this.displayModes[this.displayMode];
            }

            //Mixin any default options that are needed but were not included in the setup
            storeOptions = {
                rowsPerPage: 20,
                include: [],
                sort: [],
                select: ['Id'] //what about composite keys?
            };
            //If we are in Mode 0, drop down list, extend the grid query options directly onto the store.
            if (this.displayMode === 0) {
                this.initSDataStore();
                this.buildSDataStoreQueryConditions();
            }
                //Else add them to the lookup level query.
                //Do we need this else block?????
            else {
                if (typeof this.gridOptions.contextualCondition === 'function') {
                    this.query = {
                        fn: this.gridOptions.contextualCondition,
                        scope: this
                    };
                    this.query.conditions = this.query.fn();
                } else if (typeof this.gridOptions.contextualCondition === 'object') {
                    if (this.gridOptions.contextualCondition.fn) {
                        this.ensureValue(this.gridOptions.contextualCondition, 'scope', this);
                        this.query = this.gridOptions.contextualCondition;
                        this.query.conditions = this.gridOptions.contextualCondition.fn();
                    }
                }
                this.buildSDataStoreQueryForSeeding();
            }

            gridOptions = {
                rowsPerPage: 20,
                loadingMessage: this.loadingText,
                noDataMessage: this.noDataText,
                where: this.query,
                selectionMode: this.selectionMode,
                columnHiding: true,
                columnResizing: true,
                columnReordering: false,
                rowSelection: true,
                setUserPreferences: false,
                showHiderIcon: false
            };
            this._originalQueryConditions = this.query.conditions;
            this.storeOptions = Utility.extend(true, storeOptions, this.storeOptions);
            this.gridOptions = Utility.extend(false, gridOptions, this.gridOptions);

            // Set the widgetTemplate here so we can select the appropriate template for the selected display mode.
            this.widgetTemplate = new Simplate(this.setTemplate(this.displayMode));
        },
        setTemplate: function (mode) {
            //TODO: Move templates to Sage.Templates

            //TODO: Code review. 
            //  store="dijit.byId(\'{%= $.id %}\').sdataStore"
            // VS.
            // store="sdataStore"
            var tplMode0 = [
                    '<div id="{%= $.id %}" style="width:inherit;" > ',
                    '<select style="width:inherit;"  id="{%= $.id %}_select" searchAttr="{%= $.field %}" labelAttr="{%= $.field %}" ',
                    ' dojoAttachPoint="focusNode" autoComplete="true" required="{%= $.required %}" data-dojo-type="Sage.UI.ComboBox" value="{%= $.setSelectedValue() %}" ',
                    ' store="dijit.byId(\'{%= $.id %}\').sdataStore" name="{%= $.field %}">',
                    '</select>',
                    '</div>'
            ],
                tplMode5 = ['<img style="cursor: pointer; margin: 4px;" ',
                    ' onclick="dijit.byId(\'{%= $.id %}\').showLookup();" ',
                    'src="{%= $.btnIcon %}" alt="{%= $.btnToolTip %}" title="{%= $.btnToolTip %}" >'];
            switch (mode) {
                case 0:
                    return tplMode0;
                case 5:
                    return tplMode5;
                default:
                    return tplMode5;
            }
        },
        initDialog: function () {
            this.initConditionManager();
            this.initSDataStore();
            this._setQueryForLoad();
            this.initGrid(this.initializeLookup);
            this.lookupDialog.onCancel = this.closeCrossBtnEvent; 
        },
        _setQueryForLoad: function () {
            var condQuery = this.conditionMgr.getConditionsAsUrlWhereString(),
                seededQuery = this._originalQueryConditions,
                newQuery = '',
                queryParts = [];

            queryParts.push(condQuery);
            queryParts.push(seededQuery);

            // filter out empty items
            queryParts = dojo.filter(queryParts, function (item, index, array) {
                return item && item !== '';
            });

            newQuery = queryParts.join(' and ');

            if (newQuery) {
                this.gridOptions.where.conditions = newQuery;
            }
        },
        _setQueryForSearch: function () {
            var condQuery = this.conditionMgr.getConditionsAsUrlWhereString(),
                existingQuery = this._originalQueryConditions, // seeded query or existing query passed in via query
                newQuery = '',
                queryParts = [];

            if (this.isSeeded() && this.overrideSeedValueOnSearch === false) {
                queryParts.push(condQuery);
                queryParts.push(existingQuery);
            } else {
                if (this.isSeeded()) {
                    // discard the seed, override is true
                    queryParts.push(condQuery);
                } else {
                    // We are not seeded, add condition query and existing query if any
                    queryParts.push(condQuery);
                    queryParts.push(existingQuery);
                }
            }

            // filter out empty items
            queryParts = dojo.filter(queryParts, function (item, index, array) {
                return item && item !== '';
            });

            newQuery = queryParts.join(' and ');

            this.gridOptions.where.conditions = newQuery;

            /*
            console.debug('_setQueryForSearch:condQuery: ' + condQuery);
            console.debug('_setQueryForSearch:existingQuery: ' + existingQuery);
            console.debug('_setQueryForSearch:newQuery: ' + newQuery);
            console.debug('_setQueryForSearch:queryParts: ' + queryParts);
            */

            return newQuery;
        },
        doLookup: function () {
            this.grid.destroy(false);
            this._setQueryForSearch();
            this.initGrid(true);
        },
        setSelectedValue: function () {
            var retVal = (this.value !== null) ? this.value : '',
                fieldPath,
                fieldValue,
                i;

            if (this.returnObject && this.value !== null) {
                // The field could be several positions in length.
                //Extract the field value from the object by walking the sdata relationship path.
                fieldPath = this.field.split('.');
                fieldValue = this.value;
                for (i = 0; i < fieldPath.length; i++) {
                    if (fieldValue) {
                        fieldValue = fieldValue[fieldPath[i]];
                    }
                }
                retVal = fieldValue;
            }
            return retVal;
        },
        getGridSelections: function () {
            var items = this.grid.getSelectedRowData();
            if (items.length === 0) {
                return;
            }
            if (items.length > 0) {
                for (var k = 0; k < items.length; k++) {
                    this.newlyAddedItems.push(items[k]);
                }
            }
            this.doSelected(items);
            this.grid.clearSelection();
        },
        closeCrossBtnEvent: function () {
                var lookUpId = this.id.split('-');
                dijit.byId(lookUpId[0]).doOnClose();
         },
        onClose: function (items) {
			//do nothing, this is here as a placeholder for consumers to add custom handling for this event.
        },
        doOnClose: function () {
            var items = this.newlyAddedItems;
            this.onClose(items);
            this.lookupDialog.hide();
        },
        initConditionManager: function () {
            var addToFieldsUnique,
                cols,
                    fields,
                    fieldName,
                    displayName,
                    propertyType,
                    pickListName,
                    i,
                    cell,
                    opts,
                    self,
                    index,
                    filter,
                    field,
                    op,
                    value,
                    visible,
                        pickListStorageMode;

            if (this.conditionMgr) {
                return;
            }

            addToFieldsUnique = function (fieldName, displayName, propertyType, pickListName, pickListStorageMode, list) {
                var i;
                for (i = 0; i < list.length; i++) {
                    if (fieldName === list[i].fieldname) {
                        return;
                    }
                }
                list.push({
                    fieldName: fieldName, displayName: displayName, propertyType: propertyType, pickListName: pickListName, pickListStorageMode: pickListStorageMode
                });
            };

            cols = this.structure;
            fields = this.fields;

            for (i = 0; i < cols.length; i++) {
                if (cols[i].excludeFromFilters !== true) {
                    if (cols[i].field) {
                        cell = cols[i];
                        fieldName = cell.field;
                        propertyType = cell.propertyType;
                        displayName = cell.displayField || cell.label;
                        pickListName = cell.pickListName;
                        pickListStorageMode = cell.pickListStorageMode;
                        addToFieldsUnique(fieldName, displayName, propertyType, pickListName, pickListStorageMode, fields);
                    }
                }
            }

            opts = {
                fields: fields,
                fieldNameProperty: 'fieldName',
                fieldDisplayNameProperty: 'displayName',
                fieldTypeProperty: 'propertyType',
                id: this.id + '-ConditionManager'
            };

            this.conditionMgr = new ConditionManager(opts);
            self = this;

            // Leave first condition empty
            if (this.preFilters.length > 0) {
                this.conditionMgr.setFirstConditionValue('', '=', '');
            }

            // Add conditions here for preFilter
            for (index = 0; index < this.preFilters.length; index++) {
                filter = this.preFilters[index];
                field = filter.propertyName.trim();
                op = filter.conditionOperator.trim();
                value = filter.filterValue.trim();
                visible = filter.visible;
                this.conditionMgr.addCondition(field, op, value, visible);
            }

            dojo.place(this.conditionMgr.domNode, dojo.byId(this.id + '-Condition-container'), 'only');
            this._doSearchConnection = dojo.connect(this.conditionMgr, 'onDoSearch', this, 'doLookup');
        },
        onDoubleClick: function (event) {
            this.getGridSelections(); // fires onSelected
        },
        _formatStructure: function () {
            // Fix column types coming in from JSON. The cell/structure type must be a constructor.
            var cells,
                    i;
            if (this.structure) {
                cells = this.structure;
                for (i = 0; i < cells.length; i++) {
                    if (cells[i] && cells[i].type && typeof(cells[i].type) === 'string') {
                        switch (cells[i].type) {
                            case 'Sage.UI.Columns.DateTime':
                                cells[i].type = DateTime;
                                break;
                            case 'Sage.UI.Columns.Phone':
                                cells[i].type = Phone;
                                break;
                            case 'Sage.UI.Columns.PickList':
                                cells[i].type = PickList;
                                break;
                            default:
                                delete cells[i].type;
                                break;
                        }
                    }
                    if (cells[i].hidden === true) {
                        cells[i].unhidable = true;
                    }
                }
                this.structure = cells;
            }
        },
        initGrid: function (autoStartup) {
            //Create
            this._formatStructure();
            var columns = lang.clone(this.structure);
            var lookupGrid = dijit.byId([this.id, '-Grid'].join(''));
            if (!lookupGrid) {
                if (this.sdataStore.sort && this.sdataStore.sort.length > 0) {
                    var sort = [];
                    sort.push(this.sdataStore.sort[0]);
                    this.gridOptions.sort = sort;
                }
                if (!autoStartup) {
                    this.sdataStore.where = "Id like '_hack_'";
                } else if (typeof this.gridOptions.where === 'string') {
                    this.sdataStore.where = this.gridOptions.where;
                } else if (typeof this.gridOptions.where === 'object') {
                    if (typeof this.gridOptions.where.conditions !== 'undefined') {
                        this.sdataStore.where = this.gridOptions.where.conditions;
                    } else if (typeof this.gridOptions.where.fn === 'function') {
                        this.sdataStore.where = this.gridOptions.where.fn();
                    }
                }
                this.gridOptions.store = new SDataObjectStore(this.sdataStore);
                this.gridOptions.columns = columns;

                this.gridOptions.id = [this.id, '-Grid'].join('');
                this.gridOptions.placeHolder = [this.id, '-Grid-container'].join('');

                this.grid = new Grid(this.gridOptions);
                this.grid.resize();

                this.grid.onRowDblClick = lang.hitch(this, function (row) {
                    this.onDoubleClick(row.id, row.data);
                });
            }
                //Reuse - but only if the query conditions are different
            else {
                if (this.query.conditions !== lookupGrid.store.where) {
                    lookupGrid.destroy();
                    this.initGrid(autoStartup);
                } else {
                    this.grid = lookupGrid;
                }
            }
        },
        resetGrid: function () {
            var lookupGrid = dijit.byId([this.id, '-Grid'].join(''));
            if (lookupGrid) {
                lookupGrid.destroy();
            }
        },
        initSDataStore: function () {
            var cols = this.structure,
            sel = this.storeOptions.select || [],
            inc = this.storeOptions.include || [],
            field,
            i,
            parts,
            combined,
            p;

            for (i = 0; i < cols.length; i++) {
                if (cols[i].field) {
                    field = cols[i].field;
                    if (cols[i].displayField) {
                        field = field + '.' + cols[i].displayField;
                    }

                    Utility.addToListUnique(field.replace(/\./g, '/'), sel);

                    if (cols[i].field.indexOf('.') > 0) {
                        parts = cols[i].field.split('.');
                        combined = '';
                        for (p = 0; p < parts.length - 1; p++) {
                            combined += parts[p];
                            Utility.addToListUnique(combined, inc);
                            combined += '/';
                        }
                    }
                }
            }
            //Update the include and selects with additional items.
            this.storeOptions.include = inc;
            this.storeOptions.select = sel;
            //create the data store
            this.storeOptions.service = sDataServiceRegistry.getSDataService('dynamic');

            this.sdataStore = this.storeOptions;
        },
        isSeeded: function () {
            var seeded = (typeof this.seedValue === 'string' && this.seedValue !== '' && this.seedProperty !== '');
            return seeded;
        },
        buildSDataStoreQueryForSeeding: function () {

            var newQuery,
        seedQuery,
existingQuery;
            if (this.isSeeded()) {
                seedQuery = dojo.string.substitute('${0} eq "${1}"', [this.seedProperty, this.seedValue]);
                existingQuery = this.query.conditions;

                if (existingQuery && existingQuery !== '') {
                    newQuery = existingQuery + ' and ' + seedQuery;
                } else {
                    newQuery = seedQuery;
                }
                this.sdataStore.where = newQuery;
                this.query.conditions = newQuery;
            }
        },
        buildSDataStoreQueryConditions: function () {
            var queryFunc;

            //Set seed values in query conditions
            if (this.seedOnRowEntity) {
                this.sdataStore.where = dojo.string.substitute('Id eq "${0}"', [this.rowEntityId]);
            }

            if (this.seedOnRelatedEntity !== '') {
                this.sdataStore.where = dojo.string.substitute(' ${0}.Id eq "${1}" ', [this.seedOnRelatedEntity, this.relatedEntityId]);
            }

            // Check if there is a conditional where/contextual condition attached to the grid options.
            // If display mode is 0, then there is no grid in this first iteration.
            // Future integrations will include a grid in line.
            if (typeof this.gridOptions.contextualCondition === 'function') {
                queryFunc = {
                    fn: this.gridOptions.contextualCondition,
                    scope: this
                };
                this.sdataStore.where = Utility.extend(true, this.sdataStore.directQuery, queryFunc);
            }
        },
        //Not used
        render: function () {
            dojo.place(this.domNode, this.renderTo);
        },
        canShowLookup: function () {
            if (typeof this.gridOptions.contextualShow === 'function') {
                return this.gridOptions.contextualShow();
            }
            return {
                result: true, reason: ''
            };
        },
        showLookup: function () {
            var sError = 'The lookup cannot be displayed because one or more conditions have not been met.',
                oCanShowLookup = this.canShowLookup(),
                self = this,
                dHeight,
                dWidth,
                hideText = '';

            if (typeof oCanShowLookup !== 'object') {
                Sage.UI.Dialogs.showError('The call to the function canShowLookup() returned an invalid result.');
                return;
            }
            if (typeof oCanShowLookup.result === 'boolean' && oCanShowLookup.result) {
                dHeight = (self.dialogHeight > 0) ? self.dialogHeight : 450;
                dWidth = (self.dialogWidth > 0) ? self.dialogWidth : 700;
                self.lookupDialog = dijit.byId([self.id, '-Dialog'].join(''));
                if (!self.lookupDialog) {
                    self.lookupDialog = new Dialog({
                        title: self.dialogTitle,
                        id: [self.id, '-Dialog'].join(''),
                        style: ['height:', dHeight, 'px;width:', dWidth, 'px;'].join(''),
                        refreshOnShow: false,
                        _onKey: this._onKey
                    });

                    self.dialogHeight = dHeight;
                    self.dialogWidth = dWidth;

                    // If dialog is modal, we want the hide button to display "Cancel", otherwise "Close"
                    if (self.isModal) {
                        hideText = self.cancelText;
                    } else {
                        hideText = self.closeText;
                    }

                    // Calculate the grid height by subtracting the height of the other dialog elements from the dialog height: dheight-125.
                    self.lookupDialog.set("content", self.dialogContent.apply({
                        hideText: hideText, dialogButtonText: self.dialogButtonText, id: self.id, gridHeight: dHeight - 150
                    }));

                    // Create help icon
                    lang.mixin(self.lookupDialog, new DialogHelpIconMixin());
                    self.lookupDialog.createHelpIconByTopic('findlookup');
                }
                else {
                    // self.dialogHeight is null on refresh, which causes the dialog to not grow when adding conditions
                    self.dialogHeight = dHeight;
                    dojo.style([self.id, '-Dialog'].join(''), 'height', dHeight + 'px');
                }

                self.lookupDialog.show();
                if (!this.isModal) {
                    dojo.destroy([self.id, '-Dialog_underlay'].join(''));
                }

                //Position the dialog just below the main header.
                dojo.style([self.id, '-Dialog'].join(''), 'top', '60px');
                dojo.style([self.id, '-Dialog'].join(''), 'left', '300px');

                self.initDialog();
            }
            else {
                if (typeof oCanShowLookup.reason === 'string' && oCanShowLookup.reason.length !== 0) {
                    sError = oCanShowLookup.reason;
                }
                Sage.UI.Dialogs.showError(sError);
            }
        },
        doSelected: function (items) {
            //do nothing, this is here as a placeholder for consumers to add custom handling for this event.
        },
        _onKey: function (/*Event*/evt) {
            //summary:
            // An override to the Dialog _onKey that allows the Lookup control to function as a modeless dialog.  
            // Future implementations will see this feature as a mixin class available to any dialog class.
            // modality: modal, modeless
            // (modality === 'modeless') ? dijit.byId('dijit_DialogUnderlay_0').hide(); 
            // OR
            //  dojo.destroy(self.id + '-Dialog_underlay');        
            var self = this,
                args = arguments;
            dojo.query('*', this.domNode).forEach(function (node, index, arr) {
                if (node === evt.target) {
                    //We are inside the dialog. Call the inherited.
                    self.inherited(args);
                }
            });
        },
        destroy: function () {
            var dialog = dijit.byId([this.id, '-Dialog'].join(''));

            if (this.btnIcon) {
                dojo.destroy(this.btnIcon);
            }

            dojo.disconnect(this._doSearchConnection);
            dojo.unsubscribe(this._addCondHandle);
            dojo.unsubscribe(this._removeCondHandle);

            if (this.conditionMgr) {
                this.conditionMgr.destroy(false);
            }

            if (dialog) {
                dialog.uninitialize();
            }

            this.inherited(arguments);
        }
    });

    return widget;
});

},
'Sage/UI/ComboBox':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
       'dijit/form/ComboBox',
       'dojo/currency',
       'dojo/_base/declare'
],
function (comboBox, currency, declare) {
    var widget = declare("Sage.UI.ComboBox", [comboBox], {
        _hClickBody: false,
        maxHeight: dojo.isIE ? 160 : 170,
        shouldPublishMarkDirty: true,
        //.Net control behavior
        autoPostBack: false,
        _onKeyPress: function (e) {
            //ToDo: Enable option to allow free text
            //ToDo: Fix tab out option to auto complete on elements that do not allow free text.
            // if (option to allow free text (i.e. picklist) === false) {
            //if (e.constructor.DOM_VK_DOWN !== e.charOrCode && e.constructor.DOM_VK_IP !== e.charOrCode) {
            dojo.stopEvent(e);
            //}
            // }
        },
        postCreate: function () {
            this.connect(this, 'onChange', this.onChanged);
            this.inherited(arguments);
        },
        onChanged: function (e) {
            if (this.shouldPublishMarkDirty) {
                dojo.publish("Sage/events/markDirty");
            }
            if (this.autoPostBack) {
                __doPostBack(this.id, '');
            }
        }
    });

    return widget;
});

},
'Sage/UI/ConditionManager':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'Sage/_Templated',
    'dijit/_Widget',
    'dijit/form/Select',
    'dijit/form/Button',
    'Sage/UI/ImageButton',
    'Sage/UI/SearchConditionWidget',
    'Sage/Utility',
    'dojo/i18n!./nls/ConditionManager',
    'dojo/_base/declare'
],
function (_Templated, _Widget, select, button, imageButton, SearchConditionWidget, util, nls, declare) {
    var widget = declare('Sage.UI.ConditionManager', [_Widget, _Templated], {
        widgetsInTemplate: true,
        srchBtnCaption: 'Search',
        addrowlabel: 'Lookup by:',
        hiderowlabel: 'And:',
        hideimgurl: 'images/icons/Find_Remove_16x16.gif',
        addimgurl: 'images/icons/Find_Add_16x16.gif',
        hideimgalttext: 'Remove Condition',
        addimgalttext: 'Add Condition',
        errorOperatorRequiresValue: 'The operator requires a value',
        operators: null,
        fields: null,
        fieldsHash: null,
        fieldNameProperty: 'fieldname',
        fieldDisplayNameProperty: 'displayname',
        fieldTypeProperty: 'propertyType',
        fieldPickListNameProperty: 'pickListName',
        conditionWidgets: null,
        widgetConnects: null,
        widgetTemplate: new Simplate([
            '<div id="{%= $.id %}" class="lookup-condition-manager">',
                '<table cellspacing="0" cellpadding="3">',
                    '<tr><td><div dojoAttachPoint="conditions"></div></td></tr>', 
                '</table>',
                '<div class="lookup-condition-actions">',
                '<button id="{%= $.id %}-Search" data-dojo-type="dijit.form.Button" type="button" dojoAttachPoint="searchButton" dojoAttachEvent="onClick:_doSearch">{%= $.srchBtnCaption %}</button>',
                '</div>',
            '</div>']),
        isSettingValues: false,
        id: '',
        defaultOperator: null,
        defaultField: null,
        defaultValue: null,
        constructor: function() {
            this.conditionWidgets = {};
            this.operators = {};
            this.fieldsHash = {};
            this.fields = [];
            this.widgetConnects = [];
        },
        destroy: function() {
            var wid,
                i;
            
            for (i = 0; i < this.widgetConnects.length; i++) {
                dojo.disconnect(this.widgetConnects[i]);
            }
            
            for (wid in this.conditionWidgets) {
                if(this.conditionWidgets.hasOwnProperty(wid)) {
                    if (this.conditionWidgets[wid].destroy) {
                        this.conditionWidgets[wid].destroy();
                    }
                }
            }
            this.inherited(arguments);
        },
        postMixInProperties: function () {
            dojo.mixin(this, nls);
            this.inherited(arguments);
        },
        getOperatorsByField: function(field) {
            var boolOptions,
                stringLikeOptions,
                basicOptions,
                picklistControlOptions,
                operators;
                
            //build this after localization has been applied:
            //these are in the format of: dijit.form.__SelectOption 
            boolOptions = [
                { value: 'eq', label: this.equalTo, selected: false, disabled: false },
                { value: 'ne', label: this.notEqualTo, selected: false, diabled: false }   
            ];

            stringLikeOptions = [
                { value: 'sw', label: this.startingWith, selected: false, disabled: false },
                { value: 'like', label: this.contains, selected: false, diabled: false },
                { value: 'eq', label: this.equalTo, selected: false, diabled: false },
                { value: 'ne', label: this.notEqualTo, selected: false, diabled: false },
                { value: 'le', label: this.equalOrLessThan, selected: false, diabled: false },
                { value: 'ge', label: this.equalOrGreaterThan, selected: false, diabled: false },
                { value: 'lt', label: this.lessThan, selected: false, diabled: false },
                { value: 'gt', label: this.greaterThan, selected: false, diabled: false }
            ];

            basicOptions = [
                { value: 'eq', label: this.equalTo, selected: false, diabled: false },
                { value: 'ne', label: this.notEqualTo, selected: false, diabled: false },
                { value: 'le', label: this.equalOrLessThan, selected: false, diabled: false },
                { value: 'ge', label: this.equalOrGreaterThan, selected: false, diabled: false },
                { value: 'lt', label: this.lessThan, selected: false, diabled: false },
                { value: 'gt', label: this.greaterThan, selected: false, diabled: false }
            ];

            picklistControlOptions = [
                 { value: 'eq', label: this.equalTo, selected: false, diabled: false },
                 { value: 'ne', label: this.notEqualTo, selected: false, diabled: false }
            ];
            
            operators = {
                "System.Boolean": {
                    options: boolOptions 
                },
                "Boolean": {
                    options: boolOptions 
                },
                "System.String": { 
                    options: stringLikeOptions
                },
                "SalesLogix.PickList": {
                    options: picklistControlOptions
                },
                "Sage.Entity.Interfaces.UserType": {
                    options: basicOptions
                },
                "Sage.Entity.Interfaces.OwnerType": {
                    options : basicOptions
                },
                "System.DateTime": {
                    options: basicOptions
                },
                "DateTime": {
                    options: basicOptions
                },
                "Phone": {
                    options: stringLikeOptions
                },
                "User": {
                    options: stringLikeOptions
                },
                "Owner": {
                    options: stringLikeOptions
                },
                "System.Double": {
                    options: basicOptions 
                },
                "System.Int32": {
                    options: basicOptions 
                },
                "System.Int16": {
                    options: basicOptions 
                },
                "System.Decimal": {
                    options: basicOptions 
                },
                "Fixed": {
                    options: basicOptions 
                },
                "Decimal": {
                    options: basicOptions 
                },
                "Integer": {
                    options: basicOptions 
                },
                "Positive Integer": {
                    options: basicOptions 
                },
                "Currency": {
                    options: basicOptions 
                },
                "Percent": {
                    options: basicOptions 
                },
                "defaultOperators": {
                    options: stringLikeOptions 
                },
                "None": {
                    options: stringLikeOptions
                }
            };

            if ((field.hasOwnProperty(this.fieldTypeProperty)) && (operators.hasOwnProperty(field[this.fieldTypeProperty]))) {
                return operators[field[this.fieldTypeProperty]].options;
            }
            return operators.defaultOperators && operators.defaultOperators.options;
        },
        getConditionsAsUrlWhereString : function () {
            //manipulate conditions to match SData requirements for where URL parameter...
            var conds = this.getConditions(),
                condString = [],
                condVal = null,
                i,
                tempCondition,
                lhd, rhd, lhs, rhs,
                dateFormat;
                
            for (i = 0; i < conds.length; i++) {
                condVal = conds[i].val;
                if (typeof condVal === 'string') {
                    condVal = condVal.replace(/%/g, '');
                }
                if (condVal.constructor === Date){
                    // Handle equal to and not equal to as a special case.
                    // - They need to be in a range from start to end of date
                    if (conds[i].operator === 'eq' || conds[i].operator === 'ne') {
                        lhd = condVal;
                        rhd = condVal;
                        
                        lhd.setHours(0);
                        lhd.setMinutes(0);
                        lhd.setSeconds(0);
                        lhs = util.Convert.toIsoStringFromDate(lhd);
                        
                        rhd.setHours(23);
                        rhd.setMinutes(59);
                        rhd.setSeconds(59);
                        rhs = util.Convert.toIsoStringFromDate(rhd);
                        
                        // eq:(somedate > lhs and somedate < rhs)
                        // ne: (somedate < lhs or somedate > rhs)
                        dateFormat = {
                            field: conds[i].fieldname,
                            leftOp: 'gt', 
                            leftVal: lhs,
                            rightOp: 'lt', 
                            rightVal: rhs,
                            join: 'and'
                        };
                        
                        // Switch operators for not equal
                        if (conds[i].operator === 'ne') {
                            dateFormat.leftOp = 'lt';
                            dateFormat.rightOp = 'gt';
                            dateFormat.join = 'or';
                        }
                        
                        condString.push(dojo.string.substitute("(${field} ${leftOp} '${leftVal}' ${join} ${field} ${rightOp} '${rightVal}')", dateFormat));
                        continue;
                    } else if (conds[i].operator === 'le' || conds[i].operator === 'gt') {
                        /* less than/equal, greater than */
                        condVal.setHours(23);
                        condVal.setMinutes(59);
                        condVal.setSeconds(59);
                        
                    } else if (conds[i].operator === 'ge' || conds[i].operator === 'lt') {
                        /* greater than/equal, less than */
                        condVal.setHours(0);
                        condVal.setMinutes(0);
                        condVal.setSeconds(0);
                    }
                    
                    condVal = util.Convert.toIsoStringFromDate(condVal);
                }

                tempCondition = {
                    field: conds[i].fieldname,
                    op: conds[i].operator,
                    val: condVal
                };

                var fld = this.getField(conds[i].fieldname);
                if (fld && fld.propertyType === "SalesLogix.PickList") {
                    if (typeof condVal === "object" && condVal[0]) {
                        tempCondition.val = condVal[0];
                    }
                }
                
                if (tempCondition.op === 'like') {
                    tempCondition.val = ['%', tempCondition.val, '%'].join('');
                } else if (tempCondition.op === 'sw') {
                    tempCondition.op = 'like';
                    tempCondition.val += '%';
                }

                if (typeof tempCondition.val === 'string') {
                    tempCondition.val = ['"', tempCondition.val.toUpperCase(), '"'].join('');// wrap string in quotes
                    tempCondition.field = ['upper(', tempCondition.field, ')'].join('');// make search case insensitive
                }
                condString.push([tempCondition.field, ' ', tempCondition.op, ' ', tempCondition.val].join(''));
            }
            return condString.join(' and ');
        },
        getField: function (fieldName) {
            if (this.fieldsHash && this.fieldsHash.hasOwnProperty(fieldName)) {
                return this.fieldsHash[fieldName];
            }
            return false;
        },
        getConditionsJSON : function () {
            var i,
                conditions = this.getConditions(),
                condVal,
                currentCondition,
                condCount = conditions.length;

            for (i = 0; i < condCount; i++) {
                currentCondition = conditions[i];
                condVal = conditions[i].val;
                if (condVal.constructor === Date) {
                    var currfield = this.getField(currentCondition.fieldname);
                    condVal = (currfield.dateTimeType === 'D') ? util.Convert.toIsoStringFromDateNonUTC(condVal) : util.Convert.toIsoStringFromDate(condVal);
                }
                conditions[i].val = condVal;
            }
            return Sys.Serialization.JavaScriptSerializer.serialize(conditions);
        },
        getConditions : function () {
            var conds = [],
                wid,
                c;
            
            for (wid in this.conditionWidgets) {
                if (this.conditionWidgets.hasOwnProperty(wid)) {
                    if (this.conditionWidgets[wid].getCondition) {
                        c = this.conditionWidgets[wid].getCondition();
                        if (c) {
                            if (c.fieldname === "$key") {
                                c.fieldname = "id";
                            }
                            conds.push(c);
                        }
                    }
                }
            }
            return conds;
        },
        resetConditions: function() {
            var wid,
                i;
                
            for (i = 0; i < this.widgetConnects.length; i++) {
                dojo.disconnect(this.widgetConnects[i]);
            }
            for (wid in this.conditionWidgets) {
                if (this.conditionWidgets.hasOwnProperty(wid)) {
                    if (this.conditionWidgets[wid].getCondition) {
                        this._removeCondition(this.conditionWidgets[wid]);
                    }
                }
            }

            this._setInitialCondition();
        },
        _doSearch: function() {
            this.onDoSearch(this.getConditions());
        },
        _setFieldsAttr: function(fields) {
            var i;
            this.fields = fields;
            this.fieldsHash = {};
            for (i = 0; i < fields.length; i++) {
                this.fieldsHash[fields[i][this.fieldNameProperty]] = fields[i];
            }
            this.resetConditions();
        },
        setFirstConditionValue: function(field, op, value) {
            var prop,
                wid;
            // Set the defaults on the class
            this.defaultOperator = op;
            this.defaultField = field;
            this.defaultValue = value;
            for(prop in this.conditionWidgets) {
                if(this.conditionWidgets.hasOwnProperty(prop)) {
                    wid = this.conditionWidgets[prop];
                    if(wid.isFirstCondition) {
                        wid.defaultOperator = op;
                        wid.defaultField = field;
                        wid.defaultValue = value;
                        wid.refreshDefaults();
                    }
                }
            }
        },
        addCondition: function(field, op, value, visible) {
            var count = this._conditionCount(),
                newWid = new SearchConditionWidget({
                    conditionManager: this,
                    label: this.hiderowlabel,
                    isFirstCondition: false,
                    defaultField: field,
                    defaultOperator: op,
                    defaultValue: value,
                    id: this.id + '-SearchCondition' + count,
                    visible: visible
                });

            this.widgetConnects.push(dojo.connect(newWid, 'onRemoveLookupCondition', this, '_removeCondition'));
            
            dojo.place(newWid.domNode, this.conditions);
            newWid.startup();
            this.conditionWidgets[newWid.id] = newWid;
        },
        _setInitialCondition: function() {
            var self = this,
                wid = new SearchConditionWidget({
                    conditionManager: self,
                    label: self.addrowlabel,
                    isFirstCondition: true,
                    id: self.id + '-SearchCondition0',
                    visible: true
                });
                
            this.widgetConnects.push(dojo.connect(wid, 'onAddLookupCondition', self, '_addCondition'));
            self.conditionWidgets[wid.id] = wid;
            dojo.place(wid.domNode, self.conditions);
            wid.startup();
        },
        _addCondition: function() {
            var count = this._conditionCount(),
                newWid = new SearchConditionWidget({
                    conditionManager: this,
                    label: this.hiderowlabel,
                    isFirstCondition: false,
                    id: this.id + '-SearchCondition' + count,
                    visible: true
                });

            // Default Values?
            if (this.defaultField)
              newWid.defaultField = this.defaultField;
            if (this.defaultOperator)
              newWid.defaultOperator = this.defaultOperator;
            if (this.defaultValue)
              newWid.defaultValue = this.defaultValue;

            // Make sure the defaults are updated
            newWid.refreshDefaults();

            this.widgetConnects.push(dojo.connect(newWid, 'onRemoveLookupCondition', this, '_removeCondition'));
            this.conditionWidgets[newWid.id] = newWid;
            dojo.place(newWid.domNode, this.conditions);
            newWid.startup();
        },
        _removeCondition: function(conditionWidget) {
            var id = conditionWidget.id;
            conditionWidget.destroyRecursive();
            delete(this.conditionWidgets[id]);
        },
        _conditionCount: function() {
            var count = 0,
                wid;
            for (wid in this.conditionWidgets) {
                if(this.conditionWidgets.hasOwnProperty(wid)) {
                    count += 1;
                }
            }

            return count;
        },
        onDoSearch: function(args) {
        }
    });

    return widget;
});
},
'Sage/UI/ImageButton':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define(['dijit/form/Button',
    'dijit/_Widget',
    'dojo/text',
    'dojo/dom-style',
    'dojo/_base/declare',
    'dojo/text!../templates/ImageButton.html'
],
function (button, _Widget, text, domStyle, declare, template) {
    var widget = declare('Sage.UI.ImageButton', button, {
        hoverText: '',
        templateString: template,
        // we don't need the iconClass property so override the mapping
        // this will work for our MenuBarItem as well...
        iconClass: '',
        _setIconClassAttr: { node: 'iconNode', type: 'class' },
        
        label: '',
        _setLabelAttr: { node: 'containerNode', type: 'innerHTML' },
        
        icon: '',
        _setIconAttr: { node: 'iconNode', type: 'attribute', attribute: 'src' },
        
        imageClass: '',
        
        iconStyle: '',
        _setIconStyleAttr: { node: 'iconNode', type: 'style' },
        
        tooltip: '',
        _setTooltipAttr: { node: 'titleNode', type: 'attribute', attribute: 'title' },
        
        alt: '',
        _setAltAttr: { node: 'valueNode', type: 'attribute', attribute: 'title'},
        
        postMixInProperties: function() {
            if (this.hasImageClass() && this.hasIcon()) {
                this.icon = this._blankGif;
            } else {
                this.icon = this.icon || this._blankGif;
            }
            this.inherited(arguments);
        },
        postCreate: function () {
            this.inherited(arguments);
            if (this.hasImageClass()) {
                this.set('icon', this._blankGif);
                domStyle.set(this.iconNode, 'display', 'none');
            } else {
                domStyle.set(this.iconNodeSprite, 'display', 'none');
            }
        },
        hasImageClass: function () {
            if (this.imageClass && this.imageClass !== 'noIcon') {
                return true;
            }
            
            return false;
        },
        hasIcon: function () {
            if (this.icon && this.icon !== this._blankGif) {
                return true;
            }
            
            return false;
        },
        _onButtonClick: function (e) {
        }
    });
    
    return widget;
});

},
'Sage/UI/SearchConditionWidget':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define("Sage/UI/SearchConditionWidget", [
       'dojo/parser',
       'dojo/i18n',
       'dojo/_base/lang',
       'dojo/has',
       'dojo/_base/array',
       'dijit/_Widget',
       'dijit/form/Button',
       'dijit/form/TextBox',
       'dijit/form/NumberTextBox',
       'dijit/form/Select',
       'dijit/form/DateTextBox',
       'Sage/_Templated',
       'Sage/UI/ImageButton',
       'Sage/UI/Controls/DropDownSelectPickList',
       'Sage/UI/Controls/DropDownSelectUser',
       'Sage/UI/Controls/Phone',
       'dojo/i18n!./nls/SearchConditionWidget',
       'dojo/_base/declare'
],
function (
    parser, 
    i18n,
    lang,
    has,
    array,
    _Widget, 
    Button, 
    TextBox, 
    NumberTextBox, 
    Select, 
    DateTextBox, 
    _Templated, 
    ImageButton, 
    DropDownSelectPickList, 
    DropDownSelectUser, 
    Phone,
    resource,
    declare) {
    var searchWidget = declare('Sage.UI.SearchConditionWidget', [_Widget, _Templated], {
        widgetsInTemplate: true,
        isFirstCondition: false,
        conditionManager: false,
        label: '',
        defaultOperator: null,
        defaultField: null,
        defaultValue: null,
        id: '',
        _valueBox: null,
        visible: true,
        
        _loaded: false,
        // localized strings
        trueText: 'true',
        falseText: 'false',
        networkText: 'Network',
        remoteText: 'Remote',
        webText: 'Web',
        webViewerText: 'Web Viewer',
        concurrentText: 'Concurrent',
        retiredText: 'Retired',
        templateText: 'Template',
        addonText: 'Addon',
        adminText: 'Admin',
        userText: 'User',
        teamText: 'Team',
        departmentText: 'Department',
        systemText: 'System',
        // end localized strings

        // Static
        propertyTypeHandler: {},
        widgetTemplate: new Simplate([
            '<div id="{%= $.id %}" class="lookup-condition-row" dojoAttachPoint="_conditionRow">',
                '<label class="slxlabel lookupLabel">',
                    '{%= $.label %}',
                '</label>',
                '<select id="{%= $.id %}_fieldName" name="{%= $.id %}_fieldName" dojoAttachPoint="_fieldNameSelect" data-dojo-type="dijit.form.Select" style="width:150px">',
                    '{% for (var i=0; i < $.conditionManager.fields.length;i++) { %}',
                        '<option id="{%= $.id %}_fieldOption{%= i %}" value="{%= $.conditionManager.fields[i][$.conditionManager.fieldNameProperty] %}">{%= $.conditionManager.fields[i][$.conditionManager.fieldDisplayNameProperty] %}</option>',
                    '{% } %}',
                '</select>',
                '<select id="{%= $.id %}_operators" name="{%= $.id %}_operators" dojoAttachPoint="_operatorSelect" data-dojo-type="dijit.form.Select" style="width:130px">',
                '</select>',
                '<div style="display: inline;" class="searchConditionInput" dojoAttachPoint="_inputWidgetPlaceHolder"></div>',
                '<div class="conditionButton">',
                '{% if ( $.isFirstCondition ) { %}',
                    '<div id="{%= $.id %}-AddImageButton" data-dojo-type="Sage.UI.ImageButton" icon="{%= $.conditionManager.addimgurl %}" tooltip="{%= $.conditionManager.addimgalttext %}" dojoAttachPoint="_addConditionButton" dojoAttachEvent="onClick:_addLookupCondition"></div>',
                '{% } else { %}',
                    '<div id="{%= $.id %}-RemoveImageButton" data-dojo-type="Sage.UI.ImageButton" icon="{%= $.conditionManager.hideimgurl %}" tooltip="{%= $.conditionManager.hideimgalttext %}" dojoAttachPoint="_removeConditionButton" dojoAttachEvent="onClick:_removeLookupCondition"></div>',
                '{% } %}',
                '</div>',
            '</div>']),
        constructor: function(options) {
            if(resource) {
                this.trueText = resource.trueText;
                this.falseText = resource.falseText;
                this.networkText = resource.networkText;
                this.remoteText = resource.remoteText;
                this.webText = resource.webText;
                this.webViewerText = resource.webViewerText;
                this.concurrentText = resource.concurrentText;
                this.retiredText = resource.retiredText;
                this.templateText = resource.templateText;
                this.addonText = resource.addonText;
                this.adminText = resource.adminText;
                this.userText = resource.userText;
                this.teamText = resource.teamText;
                this.departmentText = resource.departmentText;
                this.systemText = resource.systemText;
            }
            
            this.registerTypeHandlers();
        },
        registerTypeHandlers: function () {
            this.propertyTypeHandler['default'] = {
                getValue: function () {
                    var value = this._valueBox.get('value');
                    return value;
                },
                getTemplate: function () {
                    return ['<input id="{%= $.id %}-TextValue" data-dojo-type="dijit.form.TextBox" dojoAttachPoint="_valueBox" />'];
                }
            };
            
            this.propertyTypeHandler['System.Boolean'] = {
                getValue: function () {
                    var value;
                    if(this._valueBox.value === 'true') {
                        value = true;
                    } else {
                        value = false;
                    }
                    
                    return value;
                },
                getTemplate: function () {
                    return [
                        '<select id="{%= $.id %}-SelectValue" class="dijitDropDown" data-dojo-type="dijit.form.Select" dojoAttachPoint="_valueBox">',
                        '<option id="{%= $.id %}-BooleanOptionTrue" value="true">{%= $.trueText %}</option>',
                        '<option id="{%= $.id %}-BooleanOptionFalse" value="false">{%= $.falseText %}</option>',
                        '</select>'
                    ];
                }
            };
            
            this.propertyTypeHandler['Boolean'] = {
                getValue: function () {
                    var value;
                    if(this._valueBox.value === 'true') {
                        value = 'T';
                    } else {
                        value = 'F';
                    }
                    return value;
                },
                getTemplate: function () {
                    return lang.hitch(this, this.propertyTypeHandler['System.Boolean'].getTemplate)();
                }
            };
            
            this.propertyTypeHandler['SalesLogix.PickList'] = {
                getValue: function () {
					var value = this._valueBox.get('value');
                    return value;
                },
                getTemplate: function () {
                    return [
                        '<select id="{%= $.id %}-PickValue" class="dijitDropDown" ',
                        'data-dojo-type="Sage.UI.Controls.DropDownSelectPickList" ',
                        'dojoAttachPoint="_valueBox" ',
                        'pickListName="{%= $.pickListName %}" ',
                        'storeMode="{%= $.pickListStorageMode %}" ',
                        'style="display: inline-block"',
                        '/>'
                    ];
                }
            };
            
            this.propertyTypeHandler['System.DateTime'] = {
                getValue: function () {
                    var value = this._valueBox.value;// returns a Date object
                    return isNaN(Date.parse(value)) ? null : value;
                },
                getTemplate: function () {
                    return [
                        '<input data-dojo-type="dijit.form.DateTextBox" id="{%= $.id %}-Date" dojoAttachPoint="_valueBox" constraints="{locale:Sys.CultureInfo.CurrentCulture.name}"',
                        '/>'
                    ];
                }
            };
            this.propertyTypeHandler['DateTime'] = this.propertyTypeHandler['System.DateTime'];
            
            this.propertyTypeHandler['Fixed'] = {
                getValue: function () {
                    var value = this._valueBox.get('value');
                    return value;
                },
                getTemplate: function () {
                    return ['<input id="{%= $.id %}-NumericValue" data-dojo-type="dijit.form.NumberTextBox" data-dojo-attach-point="_valueBox" constraints="{ type: \'decimal\' }" value="0" name="{%= $.id %}-NumberValue" />'];
                }
            };
            
            this.propertyTypeHandler['Integer'] = this.propertyTypeHandler['Fixed'];
            this.propertyTypeHandler['Positive Integer'] = this.propertyTypeHandler['Fixed'];
            this.propertyTypeHandler['Percent'] = this.propertyTypeHandler['Fixed'];
            this.propertyTypeHandler['Currency'] = this.propertyTypeHandler['Fixed'];
            this.propertyTypeHandler['System.Int32'] = this.propertyTypeHandler['Fixed'];
            this.propertyTypeHandler['System.Double'] = this.propertyTypeHandler['Fixed'];
            this.propertyTypeHandler['System.Decimal'] = this.propertyTypeHandler['Fixed'];
            this.propertyTypeHandler['System.Int16'] = this.propertyTypeHandler['Fixed'];
            
            this.propertyTypeHandler['Phone'] = {
                getValue: function () {
                    var value = this._valueBox.get('unformattedValue');
                    return value;
                },
                getTemplate: function () {
                    return ['<input id="{%= $.id %}-PhoneValue" data-dojo-type="Sage.UI.Controls.Phone" shouldPublishMarkDirty="false" dojoAttachPoint="_valueBox" />'];
                }
            };
            
            this.propertyTypeHandler['User'] = {
                getValue: function () {
                    var value = this._valueBox.get('value');
                    return value;
                },
                getTemplate: function () {
                    return [
                        '<select id="{%= $.id %}-UserValue" ',
                        'data-dojo-type="Sage.UI.Controls.DropDownSelectUser" ',
                        'dojoAttachPoint="_valueBox" ',
                        'style="display: inline-block;" ',
                        '></select>'
                    ];
                }
            };
            
            this.propertyTypeHandler['Sage.Entity.Interfaces.UserType'] = {
                getValue: function () {
                    var value = parseInt(this._valueBox.get('value'), 10);
                    return value;
                },
                getTemplate: function () {
                    return [
                        '<select id="{%= $.id %}-UserTypeValue" class="dijitDropDown" data-dojo-type="dijit.form.Select" dojoAttachPoint="_valueBox">',
                        '<option id="{%= $.id %}-UserTypeOption0" value="0">{%= $.networkText %}</option>',
                        '<option id="{%= $.id %}-UserTypeOption1" value="1">{%= $.remoteText %}</option>',
                        '<option id="{%= $.id %}-UserTypeOption2" value="2">{%= $.webText %}</option>',
                        '<option id="{%= $.id %}-UserTypeOption3" value="3">{%= $.webViewerText %}</option>',
                        '<option id="{%= $.id %}-UserTypeOption4" value="4">{%= $.concurrentText %}</option>',
                        '<option id="{%= $.id %}-UserTypeOption5" value="5">{%= $.retiredText %}</option>',
                        '<option id="{%= $.id %}-UserTypeOption6" value="6">{%= $.templateText %}</option>',
                        '<option id="{%= $.id %}-UserTypeOption7" value="7">{%= $.addonText %}</option>',
                        '<option id="{%= $.id %}-UserTypeOption8" value="8">{%= $.adminText %}</option>',
                        '</select>'
                    ];
                }
            };
            
            this.propertyTypeHandler['Sage.Entity.Interfaces.OwnerType'] = {
                getValue: function () {
                    var value = parseInt(this._valueBox.get('value'), 10);
                    return value;
                },
                getTemplate: function () {
                    return [
                        '<select id="{%= $.id %}-OwnerTypeValue" class="dijitDropDown" data-dojo-type="dijit.form.Select" dojoAttachPoint="_valueBox">',
                        '<option id="{%= $.id %}-OwnerTypeOption0" value="1">{%= $.userText %}</option>',
                        '<option id="{%= $.id %}-OwnerTypeOption1" value="2">{%= $.teamText %}</option>',
                        '<option id="{%= $.id %}-OwnerTypeOption2" value="3">{%= $.departmentText %}</option>',
                        '<option id="{%= $.id %}-OwnerTypeOption3" value="0">{%= $.systemText %}</option>',
                        '</select>'
                    ];
                }
            };
            
            this.propertyTypeHandler['Owner'] = this.propertyTypeHandler['default'];
            this.propertyTypeHandler['None'] = this.propertyTypeHandler['default'];
            this.propertyTypeHandler['System.String'] = this.propertyTypeHandler['default'];
            this.propertyTypeHandler['defaultOperators'] = this.propertyTypeHandler['default'];
        },
        postCreate: function() {
            //set up the operators based on default field selection...
            this.refreshDefaults();
            if(!this.visible) {
                dojo.style(this._conditionRow, 'display', 'none');
            }

            this._fieldNameSelect.on('change', lang.hitch(this, this._fieldChanged));
            this.inherited(arguments);
        },
        getCondition: function() {
            var results = false;
            if (this.isValidCondition()) {
                results = {
                    fieldname: this._fieldNameSelect.get('value'),
                    operator: this._operatorSelect.get('value'),
                    val: this._getFieldValue()
                };
            }
            
            return results;
        },
        isValidCondition: function() {
            var val = this._getFieldValue(),
                results = false;
            if(typeof val === 'string') {
                results = (val.trim() !== '');
            } else {
                results = (val !== null && val !== undefined);
            }

            return results;
        },
        _getFieldValue: function() {
            var fieldName = this._fieldNameSelect.get('value'),
                operator = this._operatorSelect.get('value'),
                field = this._getField(fieldName),
                value,
                fieldPropertyType,
                mapper;

            if (field) {
                fieldPropertyType = this._getFieldPropertyTypeValue(field);
                mapper = this.propertyTypeHandler[fieldPropertyType];
                if (typeof mapper === 'undefined') {
                    console.warn('Property ' + fieldPropertyType + ' has no mapping.');
                    mapper = this.propertyTypeHandler['default'];
                }
                value = lang.hitch(this, mapper.getValue)();
            }

            return value;
        },
        _renderFieldTemplates: function() {
            var operators, templateArray, simplate, template,
                val = this._fieldNameSelect.get('value'),
                field = this._getField(val),
                fieldPropertyType,
                temp,
                mapper;
                
            if (field) {
                fieldPropertyType = this._getFieldPropertyTypeValue(field);
                mapper = this.propertyTypeHandler[fieldPropertyType];
                if (typeof mapper === 'undefined') {
                    console.warn('Property ' + fieldPropertyType + ' has no mapping.');
                    mapper = this.propertyTypeHandler['default'];
                }
                
                templateArray = lang.hitch(this, mapper.getTemplate)();

                // Create widget for user input based on type of field.
                simplate = new Simplate(templateArray);

                // Copy 'this' into a temp object for the simplate.apply call
                temp = {};
                dojo.mixin(temp, this);
                dojo.mixin(temp, { pickListName: field.pickListName });
                dojo.mixin(temp, { pickListStorageMode: field.pickListStorageMode });
                template = simplate.apply(temp);

                if (template) {
                    dojo.forEach(dijit.findWidgets(this._inputWidgetPlaceHolder), function(wid) {
                        wid.destroy();
                    }, this);

                    this._inputWidgetPlaceHolder.innerHTML = '';
                    dojo.place(template, this._inputWidgetPlaceHolder);
                    parser.parse(this._inputWidgetPlaceHolder);
                    dojo.forEach(dijit.findWidgets(this._inputWidgetPlaceHolder), function(wid) {
                        wid.startup();
                        this._valueBox = wid;
                        dojo.connect(this._valueBox, 'onKeyDown', this, '_onKeyDown');
                    }, this);
                }
            }
        },
        uninitialize: function() {
            if (this._inputWidgetPlaceHolder) {
                dojo.forEach(dijit.findWidgets(this._inputWidgetPlaceHolder), function(wid) {
                    wid.destroy();
                }, this);
            }
            this.inherited(arguments);
        },
        _fieldChanged: function(newValue) {
            var val = this._fieldNameSelect.get('value'),
                field = this._getField(val),
                operators,
                opSel,
                len,
                i;

            if (field) {
                this._renderFieldTemplates();

                operators = this.conditionManager.getOperatorsByField(field);
                // reset ops
                if (operators) {
                    opSel = this._operatorSelect;
                    len = opSel.options.length;
                    for (i = len - 1; i >= 0; i--) {
                        opSel.removeOption(i);
                    }
                    
                    // Ensure none are selected
                    for (i = 0; i < operators.length; i++) {
                        operators[i].selected = false;
                    }
                    
                    opSel.addOption(operators);
                }
                
                this._setToDefaultOperator();
                this._setToDefaultValue();
            }
        },
        _onKeyDown: function(event) {
            if (event.keyCode === 13) {

                //get the format of the searched for field
                var fieldName = this._fieldNameSelect.get('value');
                var valObj = this._getField(fieldName);

                //check there is a user input search field, and that it enforces the Phone format
                if (valObj && valObj.format && valObj.format === "Phone") {
                    this._valueBox.onChange(this._valueBox.displayedValue); // Force an update
                }

                this.conditionManager._doSearch();

            }
        },
        _getField: function(fieldName) {
            if (this.conditionManager.fieldsHash.hasOwnProperty(fieldName)) {
                return this.conditionManager.fieldsHash[fieldName];
            }
            
            return false;
        },
        _getFieldPropertyTypeValue: function(field) {
            if(field && field.hasOwnProperty(this.conditionManager.fieldTypeProperty)) {
                return field[this.conditionManager.fieldTypeProperty];
            }
            
            return null;
        },
        _addLookupCondition: function() {
            this.onAddLookupCondition();
            dojo.publish('onAddLookupCondition', this);
        },
        onAddLookupCondition: function() {
        },
        _removeLookupCondition: function() {
            this.onRemoveLookupCondition(this);
            dojo.publish('onRemoveLookupCondition', this);
        },
        onRemoveLookupCondition: function(widget) {

        },
        _setToDefaultValue: function() {
            if (!this._isOnDefaultField()) {
                return;
            }
            
            if(this.defaultValue) {
                // Set the condition value
                this._valueBox.set('value', this.defaultValue);
            }
        },
        _setToDefaultField: function() {
            var i, fieldOptions;
            
            if(this.defaultField) {
                // Set the condition field
                fieldOptions = this._fieldNameSelect.getOptions();
                for(i = 0; i < fieldOptions.length; i++) {
                    if(fieldOptions[i].value === this.defaultField) {
                        this._fieldNameSelect.set('value', fieldOptions[i].value);
                        break;
                    }
                }
            }
        },
        _setToDefaultOperator: function() {
            var operatorOptions,
                j;
                
            if (!this._isOnDefaultField()) {
                return;
            }
            
            if(this.defaultOperator && typeof this.defaultOperator === 'string') {
                // Set the condition operator
                operatorOptions = this._operatorSelect.getOptions();
                for(j = 0; j < operatorOptions.length; j++) {
                    if(operatorOptions[j].label === this.defaultOperator ||
                        operatorOptions[j].value === this.defaultOperator) {
                        this._operatorSelect.set('value', operatorOptions[j].value);
                        break;
                    }
                }
            }
        },
        _isOnDefaultField: function () {
            var results = false,
                fieldOptions;
                
            if (this.defaultField) {
                // Set the condition field
                fieldOptions = this._fieldNameSelect.get('value');
                results = (fieldOptions === this.defaultField);
            } else {
                results = true;
            }
            
            return results;
        },
        refreshDefaults: function() {
            // Order is important here.
            // 1.) _setToDefaultField will set the default field search condition
            // 2.) _fieldChanged depends on this to get the operator
            this._setToDefaultField();
            this._fieldChanged();
                    }
    });

    return searchWidget;
});

},
'Sage/UI/Controls/DropDownSelectPickList':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */

/**
 * @class Sage.UI.Controls.DropDownSelectPickList
 *  Class for dropdown select picklists. Used in search condition widgets.
 */
define([
    'dijit/_TemplatedMixin',
    'dijit/_WidgetsInTemplateMixin',
    'dijit/_Widget',
    'dijit/form/ComboBox',
    'dojo/data/ItemFileReadStore',
    'Sage/UI/Controls/PickList',
    'dojo/_base/array',
    'dojo/text!./templates/DropDownSelectPickList.html',
    'dojo/_base/declare'
],
function (_TemplatedMixin, _WidgetsInTemplateMixin, _Widget, comboBox, itemFileReadStore, pickList, array, template, declare) {
    var widget = declare('Sage.UI.Controls.DropDownSelectPickList', [pickList, _Widget, _TemplatedMixin, _WidgetsInTemplateMixin], {
        /**
         * Takes the following options object: 
         * {
         *  pickListName: 'PickListName', // Required
         *  storeOptions: {}, // Optional
         *  dataStore: {}, // Option
         *  canEditText: false,
         *  itemMustExist: true,
         *  maxLength: -1,
         *  storeMode: 'text', // text, id, code
         *  sort: true,
         *  displayMode: 'AsControl',
         *  clientId: 'ASP.NET Control ClientID Here',
         *  required: false
         * }
         */
        constructor: function(options) {
            if (options.clientId) {
                this.id = options.clientId + '-DropDownSelectPickList';
            }
            this.lastValidValue = options.value;
            this.inherited(arguments);
        },
        postCreate: function () {            
            this.inherited(arguments);
        },
        _onChange: function (newVal) {
            if (this.storeData) {
                var val = this.comboBox.get('value');
                if (val != this.initialValue) {
                    if (this.get('itemMustExist')) {
                        var valid = dojo.some(this.storeData.items, function (item) {
                            if (item.text == newVal || newVal == '') { // jshint ignore:line
                                return true;
                            } else {
                                return false;
                            }
                        }, this);
                        if (valid) {
                            this.lastValidValue = newVal;
                        }
                        if (!valid) {
                            if (this.lastValidValue !== 'undefined' && this.lastValidValue !== null) {
                                this.comboBox.set('value', this.lastValidValue);
                                return;
                            }
                        }
                    }
                    if (this.comboBox.isValid()) {
                        var code = '',
                            id = '';
                        dojo.forEach(this.storeData.items, function (item) {
                            if (item.text == val) {
                                code = item.code;
                                id = item.id;
                            }
                        }, this);
                        this.setASPNETInputs(val, code, id);
                    }
                }
            }
            this.onChange(this.lastValidValue);
        },
        _loadData: function() {
            if (this.nodataload) {
                return;
            }
            var def = new dojo.Deferred();
            this.getPickListData(def);

            def.then(dojo.hitch(this, this.setItems), function (e) {
                console.error(e);
            });
        },
        setItems: function(data) {
                if (typeof data === 'string') {
                    this.initialValue = data;
                    this.comboBox.set('value', data);
                }

                var items = [];
                for (var i = 0; i < data.items.$resources.length; i++) {
                    var item = data.items.$resources[i];
                    items.push({
                        id: item.$key,
                        code: item.code,
                        number: item.number,
                        text: item.text
                    });
                }

                this.storeData = {
                    identifier: 'id',
                    label: 'text',
                    items: items
                };

                var tempStore = new itemFileReadStore({ data: this.storeData });
                this.comboBox.set('store', tempStore);
                this.comboBox.set('searchAttr', 'text');
        },
        uninitialize: function() {
            this.inherited(arguments);
        },
        _getValueAttr: function() {
            var results = this.comboBox.get('value');
            if (this.storeMode === 'id') {
                array.forEach(this.storeData.items, function (item) {
                    // donotlint
                    if (results == item.text) {
                        results = item.id;
                    }
                }, this);
            }
            return results;
        },
        _setPickListNameAttr: function() {
            this.inherited(arguments);
            this._loadData();
        },
        value: '',
        // Display properties
        templateString: template,
        widgetsInTemplate: true,
        /**
         * @property {object} storeData Data fetched from SData stored here.
         */
        storeData: null,
        // TODO: Remove
        /**
         * @property {string} lastValidValue Last valid value entered into the control.
         */
        lastValidValue: '',
        onChange: function (newVal) { }
    });
    return widget;
});
},
'Sage/UI/Controls/PickList':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define, cookie */

/**
* @class Sage.UI.Controls.PickList
* Base class for PickList widgets.
*/
define([
    'dojo/topic',
    'dojo/_base/declare',
    'dijit/_Widget',
    'dijit/Tooltip',
    'Sage/Utility',
    'dijit/Tooltip',
    'dojo/i18n!./nls/PickList',
    'dojo/string',
    'dojo/_base/lang',    
	'Sage/Services/PickListService'
],
function (topic, declare, _Widget, toolTip, util, tooltip, nls, dString, lang, PickListService) {
    var widget = declare('Sage.UI.Controls.PickList', [_Widget], {
        /**
        * @property {object} dataStore The data store which implements fetch()
        */
        dataStore: null,
        /**
        * @property {object} storeOptions The data store options object. See default values in constructor.
        */
        storeOptions: null,
        /**
        * @property {string} pickListName The name of the picklist. This is passed into the storeOptions.query if it was not overridden.
        */
        pickListName: '',
        /**
        * @property {string} The filter of the picklist. This is passed into the storeOptions.query if it was not overridden.
        */
        filter: '',
        /**
        * @property {string} The defaultLanguage of the picklist. This is passed into the storeOptions.query if it was not overridden.
        */
        defaultLanguage: '',
        /**
        * @property {boolean} canEditText Determines if a user can edit text in the textbox.
        */
        canEditText: false,
        /**
        * @property {boolean} itemMustExist Restrict data entered to data available in the picklist.
        */
        itemMustExist: true,
        /**
        * @property {number} maxLength Max length for item entered.
        */
        maxLength: -1,
        /**
        * @property {string} storeMode Determines what dropdown value/text gets posted back to the server (ASP.NET). 
        */
        storeMode: 'text', // text, id, code
        /**
        * @property {string} boundLanguage Determines the language queried instead of the browser. 
        */
        boundLanguage: '',
        /**
        * @property {boolean} filterByLanguage If true, then language fallback is disabled, and queries filter by language values. 
        */
        filterByLanguage: false,
        /**
        * @property {boolean} sort Tell the data store to sort by the picklist items/text property
        */
        sort: true,
        /**
        * @property {string} displayMode Sets the display mode as control or a hyperlink.
        */
        displayMode: 'AsControl', // AsControl, AsHyperlink (do we really need this?)
        /**
        * @property {string} clientID ASP.NET control's ClientID property.
        */
        clientId: '',
        /**
        * @property {boolean} required Set to true if a value is required.
        */
        required: false,
        /**
        * @property {number} tabIndex Sets value for tab order, defaults to 0.
        */
        tabIndex: 0,
        /**
        * @property {string} placeInNodeId Place widget in this dom node.
        */
        placeInNodeId: '',
        /**
        * @property {boolean} autoPostBack Should the control auto postback when value changes (onBlur).
        */
        autoPostBack: false,
        /**
        * @property {string} Tooltip text that displays over control.
        */
        controlTooltip: '',
        /**
        * @property {string} Tooltip text that displays over control button.
        */
        buttonTooltip: '',
        /**
        * @property {boolean} - Indicates whether the implementation should publish that it has dirty data to the ClientBindingManagerService.
        * default = true
        */
        shouldPublishMarkDirty: true,
        /**
        * @property Render the control as a hyperlink
        */
        renderAsHyperlink: false,
        // Private props for ASP.NET
        // TODO: _textId and _codeId are now passed in via config options (textId and codeId)
        _textId: '', // Textbox user sees (or used to see)
        _codeId: '', // Value for textbox, has either text or code
        _picklistId: '',
        _defaultValueId: '', // Default value
        _defaultCodeId: '', // Default code
        _defaultPicklistId: '', // Default Id
        _storageNameSpace: 'PickListData',
        // localized strings
        okText: '',
        missingPickListText: '',
        // end localized strings
        pickListServiceOptions: {},
        _pickListService: null,
        asyncDataLoading: true,
        defaultUseCache: true,
        // TODO: We need a hook for onChange

        /**
        * Takes the following options object: 
        * {
        *  pickListName: 'PickListName', // Required
        *  storeOptions: {}, // Optional
        *  dataStore: {}, // Optional
        *  canEditText: false,
        *  itemMustExist: true,
        *  maxLength: -1,
        *  storeMode: 'text', // text, id, code
        *  sort: true,
        *  displayMode: 'AsControl',
        *  clientId: 'ASP.NET Control ClientID Here',
        *  required: false
        *  placeInNodeId: '',
        *  autoPostBack: false
        * }
        *
        * @constructor
        */
        constructor: function(options) {
            this.storeOptions = options.storeOptions;
            this.dataStore = options.dataStore;
            this.filterByLanguage = options.filterByLanguage || this.filterByLanguage;
            this.boundLanguage = options.boundLanguage || null;
            this.asyncDataLoading = this.async;// used by the formatter to force a sync call.
            this.clientId = options.clientId || '';
            var cid = this.clientId;
            this._textId = cid + '_Text';
            this._codeId = cid + '_Code';
            this._picklistId = cid + '_PicklistId';
            this._defaultValueId = cid + '_DefaultValue';
            this._defaultCodeId = cid + '_DefaultCode';
            this._defaultPicklistId = cid + '_DefaultPicklistId';
            this._pickListService = Sage.Services.getService('PickList');

            if (nls) {
                this.okText = nls.okText;
                this.missingPickListText = nls.missingPickListText;
            }
        },
        postCreate: function() {
            var node = dojo.byId(this.placeInNodeId);
            if (node) {
                this._setDefaultFields();
                dojo.place(this.domNode, node, 'first');
            }
            this.inherited(arguments);
        },
        uninitialize: function() {
            this.inherited(arguments);
        },
        /**
        * Sets store up using given picklist name.
        * @function
        */
        _setStore: function (pickListType, filter) {
            if (pickListType)
                this.pickListServiceOptions.storageMode = pickListType;
            if (filter)
                this.pickListServiceOptions.filter = filter;
        },
        /**
        * Sets hidden fields to correct values if required is true. Logic pulled from old picklist control.
        * @function
        */
        _setDefaultFields: function() {
            if (this.required) {
                var text = dojo.byId(this._textId);
                if (text && text.value === '') {
                    var code = dojo.byId(this._codeId),
                        idField = dojo.byId(this._picklistId);
                    var defaultValue = dojo.byId(this._defaultValueId);
                    var defaultCode = dojo.byId(this._defaultCodeId);
                    var defaultId = dojo.byId(this._defaultPicklistId);
                    text.value = defaultValue.value;
                    code.value = defaultCode.value;
                    idField.value = defaultId.value;
                }
            }
        },
        /**
        * Creates tooltips for button (buttonNode) and control (focusNode)
        * @function
        */
        _setupTooltips: function(buttonNode, focusNode) {
            if (this.controlTooltip && this.controlTooltip !== '' && focusNode) {
                var t = new tooltip({
                    connectId: [focusNode],
                    label: this.controlTooltip,
                    position: ['below']
                });
            }

            if (this.buttonTooltip && this.buttonTooltip !== '' && buttonNode) {
                var t2 = new tooltip({
                    connectId: [buttonNode],
                    label: this.buttonTooltip,
                    position: ['below']
                });
            }
        },
        /**
        * @returns {object} SData picklist object with child items resource included. dojo.Deferred required as an argument.
        * Example: {
        *  name: 'PickList Name',
        *  allowMultiples: false,
        *  valueMustExist: true,
        *  required: true,
        *  alphaSorted: true,
        *  noneEditable: true,
        *  defaultLanguage: 'en'
        *  items: [
        *      { text: 'Arizona', code: 'AZ', number: 0, languageCode: 'en' },
        *      { text: 'Michigan', code: 'MI', number: 1, languageCode: 'en' }
        *  ]
        * }
        */
        getPickListData: function (deferred) { 
            var config = lang.mixin(this, {
                language: this.boundLanguage,
                async: this.asyncDataLoading,
                context: [
                        this.boundLanguage || '_',
                        this.filter || '_',
                        this.filterByLanguageBoundLanguage || '_',
                        this.filterByLanguage || '_',
                        this.storeMode || '_'
                    ].join('-'),
                pickListServiceOptions: {
                    filterByLanguage: this.filterByLanguage,
                    storageMode: this.storeMode
                }
            });
            config.context = config.context.replace(/\s/g, '_');
            config.useCache = config.usecache !== null && typeof config.usecach !== 'undefined' ? config.usecache :
                (config.useCache !== null && typeof config.useCache !== 'undefined' ? config.useCache : config.defaultUseCache);
            config.useCache = typeof config.useCache === 'string' ? config.useCache === "true" : config.useCache;
            config.useCache = config.useCache !== null && typeof(config.useCache) === 'boolean' ? 
                                config.useCache : true;
            if (this.pickListName) {
                var options = this._pickListService.getFirstByName(this.pickListName, 
                    lang.hitch(this, this._getItemSuccess, deferred),  
                    lang.hitch(this, this._getItemsFail, deferred),
                    config
                );
                this._pickListService.read(options);
            } 
        },
        _getItemsFail: function (deferred, e) {
            deferred.errback(e);
        },
        _getItemSuccess: function (deferred, data) {
            var filter = this.filter;
            if (data && data.items && data.items.$resources && data.items.$resources.length > 0) {
                var temp = data.items.$resources;
                if (this.sort && data.alphaSorted) {
                    data.items.$resources = temp.sort(function (a, b) {
                        if (a.text < b.text) 
                            return -1;
                        if (a.text > b.text)
                            return 1;
                        return 0;
                    });
                }
                if (filter) {
                    data.items.$resources = this.filterPickListItemsByFilter(data.items.$resources);
                }
            }
            this.setPicklistAttributes(data);
            deferred.callback(data);
        },
        filterPickListItemsByFilter: function (picklistItems) {
            return this.filterPickListItems(picklistItems, "filter");
        },
        filterPickListItems: function (picklistItems, filterBy) {
            var ValueToMatch = this[filterBy];
            var filteringField = filterBy;
            if (typeof (filterBy) === 'object') {
                if (filterBy.field) {
                    filteringField = filterBy.field;
                }
                if (filterBy.value || typeof(filterBy.value)==='boolean') {
                    ValueToMatch = filterBy.value;
                }
            }

            var filteredResults = [];
            if (ValueToMatch) {
                for (var i = 0; i < picklistItems.length; i++) {
                    var itm = picklistItems[i];
                    if (!this._doesPropertyValueAlreadyExistInList(filteredResults,itm,"code") && itm[filteringField] === ValueToMatch) {
                        filteredResults.push(itm);
                    }
                }
            }
            return filteredResults;
        },
        _doesPropertyValueAlreadyExistInList: function (arr, item, property) {
            var idx, matched = false;
            for (idx = 0; idx < arr.length && !matched; idx++) {
                matched = arr[idx][property] === item[property];
            }
            return matched;
        },
        setPicklistAttributes: function(picklist) {
            if (picklist.valueMustExist) {
                this._setItemMustExistAttr(picklist.valueMustExist);
            }
        },
        /**
        * Sets hidden ASP.NET fields.
        * @function
        */
        setASPNETInputs: function(textValue, codeValue, idValue) {
            if (this._textId && this._codeId && this._picklistId) {
                var text = dojo.byId(this._textId);
                var code = dojo.byId(this._codeId);
                var id = dojo.byId(this._picklistId);
                if (text && code && id) {
                    text.value = textValue;
                    id.value = idValue;
                    code.value = codeValue;
                    this.invokeChangeEvent();
                }
            }
        },
        /**
        * If configured to do so, publishes the markDirty event, showing that there is un-saved data. Will auto postback here if set as well.
        * @function
        */
        invokeChangeEvent: function() {
            if (this.shouldPublishMarkDirty) {
                dojo.publish("Sage/events/markDirty");
            }
            if (this.autoPostBack) {
                __doPostBack(this.clientId, '');
            }
        },
        // Properties
        _getCanEditTextAttr: function() {
            return this.canEditText;
        },
        _setCanEditTextAttr: function(value) {
            this.canEditText = value;
        },
        _getItemMustExistAttr: function() {
            return this.itemMustExist;
        },
        _setItemMustExistAttr: function(value) {
            this.itemMustExist = value;
        },
        _getMaxLengthAttr: function() {
            return this.maxLength;
        },
        _setMaxLengthAttr: function(value) {
            this.maxLength = value;
        },
        _getStoreModeAttr: function() {
            return this.storeMode;
        },
        _setStoreModeAttr: function(value) {
            this.storeMode = value;
            this._setStore(value, this.filter);
        },
        _getPickListNameAttr: function() {
            return this.pickListName;
        },
        _setPickListNameAttr: function(value) {
            this.pickListName = value;
            this._setStore(this.storeMode, this.filter);
        },
        _setPickListFilterAttr: function(value) {
            this.filter = value;
            this._setStore(this.storeMode, value);
         },
        _getPickListFilterAttr: function () {
            return this.filter;
        },
        statics: {
        },
        clearCache: function (name, lang) {
            if (this._pickListService === null) {
                this._pickListService = Sage.Services.getService('PickList');
            }
            this._pickListService.clearCache(name, lang);
        }
    });
    return widget;
});
},
'Sage/UI/Controls/DropDownSelectUser':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
       'dijit/_TemplatedMixin',
       'dijit/_WidgetsInTemplateMixin',
       'dijit/_Widget',
       'dijit/form/ComboBox',
       'dojo/data/ItemFileReadStore',
       'Sage/Data/BaseSDataStore',
       'Sage/Data/SDataServiceRegistry',
       'Sage/UI/ComboBox',
       'dojo/text!./templates/DropDownSelectUser.html',
       'dojo/_base/declare'
],
function (_TemplatedMixin, _WidgetsInTemplateMixin, _Widget, comboBox, itemFileReadStore, baseSDataStore, _SDataServiceRegistry, sageComboBox, template, declare) {
    /**
     * @class Search Condition "user" widget.
     */
    var widget = declare('Sage.UI.Controls.DropDownSelectUser', [_Widget, _TemplatedMixin, _WidgetsInTemplateMixin], {
        /**
         * @property {object} dataStore The data store which implements fetch()
         */
        dataStore: null,

        /**
         * @property {object} storeOptions The data store options object. See default values in constructor.
         */
        storeOptions: null,

        storeData: null,

        // Display properties
        templateString: template,
        widgetsInTemplate: true,

        // Store Options
        _position: 0,
        _pageSize: 100,
        _queryResults: null,

        /**
         * Takes the following options object: 
         * {
         *  storeOptions: {}, // Optional
         * }
         *
         * @constructor
         */
        constructor: function (options) {
            this.storeOptions = options.storeOptions || {
                include: ['UserInfo'],
                select: [
                    'Id',
                    'UserName',
                    'UserInfo/FirstName',
                    'UserInfo/LastName',
                    'Type'
                ],
                sort: [
                    { attribute: 'UserInfo.LastName', descending: false }
                ],
                service: _SDataServiceRegistry.getSDataService('dynamic', false, true, true),
                resourceKind: 'users'
            };

            this.dataStore = new baseSDataStore(this.storeOptions);

            this.inherited(arguments);
        },
        postCreate: function () {
            var def = new dojo.Deferred();
            // Reset Store Variable
            this._position = 0;
            this._queryResults = null;
            this.getUserData(def);

            def.then(dojo.hitch(this, function (data) {
                if (!data) {
                    return;
                }

                var items = [];
                var count = data.length;
                var item = null;
                for (var i = 0; i < count; i++) {
                    item = data[i];
                    if (item.Type !== 'Template') {
                        items.push({
                            id: item.$key,
                            text: [item.UserInfo.FirstName, item.UserInfo.LastName].join(' ')
                        });
                    }
                }

                this.storeData = {
                    identifier: 'id',
                    label: 'text',
                    items: items
                };

                var tempStore = new itemFileReadStore({ data: this.storeData });
                this.comboBox.set('store', tempStore);
                this.comboBox.set('searchAttr', 'text');

            }), function (e) {
                // errback
                console.error(e);
            });

            this.inherited(arguments);
        },
        /**
         * @returns {object} SData users objects with child UserInfo resource included. dojo.Deferred required as an argument.
         */
        getUserData: function (deferred) {
            this.dataStore.fetch({
                count: this._pageSize,
                start: this._position,
                onComplete: function (data) {
                    // Do we need to get more data?
                    if (data.length === this._pageSize) {
                        // Adjust the position
                        this._position += this._pageSize;
                        // Add to the array
                        if (this._queryResults === null) {
                            this._queryResults = data;
                        } else {
                            // This avoids creating an extra array
                            this._queryResults.push.apply(this._queryResults, data);
                        }//end if
                        // Go again
                        this.getUserData(deferred);
                    } else {
                        // Add to the array
                        if (this._queryResults === null) {
                            this._queryResults = data;
                        } else {
                            // This avoids creating an extra array
                            this._queryResults.push.apply(this._queryResults, data);
                        }//end if
                        // Return to the caller
                        deferred.callback(this._queryResults);
                    }//end if
                },
                onError: function (e) {
                    deferred.errback(e);
                },
                scope: this
            });
        },
        _getValueAttr: function () {
            return this.comboBox.get('value');
        }
    });

    return widget;
});

},
'Sage/UI/Controls/Phone':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
       'dijit/_Widget',
       'Sage/_Templated',
       'Sage/UI/Controls/TextBox',
       'dojo/_base/declare'
],
function (_Widget, _Templated, textBox, declare) {
    var widget = declare('Sage.UI.Controls.Phone', textBox, {
        slxchangehook: 'true',
        _setslxchangehookAttr: { node: 'focusNode', type: 'attribute', attribute: 'slxchangehook' },
        shouldPublishMarkDirty: true,
        //.Net control behavior
        autoPostBack: false,
        postCreate: function () {
            this.inherited(arguments);
            this.unformattedValue = this.unformatNumber(this.get('value'));
        },
        unformattedValue: '',
        formatPhoneChange: function (number) {
            this.unformattedValue = this.unformatNumber(this.get('value'));
            // Pass the unformatted string to be formatted (this matches server functionality)
            var formattedVal = this.formatNumberForDisplay(number, this.unformattedValue);
            this.set('value', formattedVal);
        },
        /*
        {0}: original value
        {1}: cleaned value
        {2}: entire match (against clean value)
        {3..n}: match groups (against clean value)
        */
        formatters: [{
            test: /^\+.*/,
            format: '{0}'
        }, {
            test: /^(\d{3})(\d{3,4})$/,
            format: '{3}-{4}'
        }, {
            test: /^(\d{3})(\d{3})(\d{2,4})$/, // 555 555 5555
            format: '({3}) {4}-{5}'
        }, {
            test: /^(\d{3})(\d{3})(\d{2,4})([^0-9]{1,}.*)$/, // 555 555 5555x
            format: '({3}) {4}-{5}{6}'
        }, {
            test: /^(\d{11,})(.*)$/,
            format: '{1}'
        }],
        unformatNumber: function (number) {
            var n = number;
            // Temporarily ignore strings that are international until a better system is in place
            if (n && n.length && (n[0] === '+' || n[0] === '0')) {
                return n;
            }
            // Matching mobile's format stripper
            n = n.replace(/[^0-9x]/ig, '');
            return n;
        },
        formatNumberForDisplay: function (number, clean) {
            var n = number;
            // Do not format if the string begins with a '+'
            if (/^\+/.test(n)) {
                return n;
            }
            if (typeof clean === 'undefined') clean = n;
            for (var i = 0; i < this.formatters.length; i++) {
                var formatter = this.formatters[i],
                        match;
                if ((match = formatter.test.exec(clean))) {
                    return String.format.apply(String, [formatter.format, n, clean].concat(match));
                }
            }
            return n;
        },
        onChange: function (e) {
            if (this.shouldPublishMarkDirty) {
                dojo.publish("Sage/events/markDirty");
            }
            this.formatPhoneChange(e);
        }
    });

    return widget;
});

},
'Sage/UI/Controls/TextBox':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
       'dijit/form/ValidationTextBox',
       'dojo/dom-class',
       'dojo/query',
       'dojo/_base/declare'
],
function (validationTextBox, domClass, dojoQuery, declare) {
    var widget = declare("Sage.UI.Controls.TextBox", [validationTextBox], {
        maxLength: '',
        // textWithIcons allows for styling to be applied to a textbox where an icon accompanies the text inside the box.
        textWithIcons: false,
        shouldPublishMarkDirty: true,
        //.Net control behavior
        autoPostBack: false,
        
        // Attribute maps
        hotKey: '',
        _setHotKeyAttr: { node: 'textbox', type: 'attribute', attribute: 'accessKey' },
        
        slxchangehook: 'true',
        _setslxchangehookAttr: { node: 'focusNode', type: 'attribute', attribute: 'slxchangehook' },

        postCreate: function () {
            this.connect(this, 'onChange', this.onChanged);
            this.inherited(arguments);
        },
        startup: function (parameters) {
            if (this.textWithIcons) {
                var self = this;
                dojo.ready(function () {
                    if (dojoQuery('#' + self.id)[0]) {
                        var element = dojoQuery('#' + self.id)[0];
                        domClass.add(element.parentNode, 'textcontainer-with-icons');
                    }
                });
            }
            this.inherited(arguments);
        },
        onChanged: function (e) {
            if (this.shouldPublishMarkDirty) {
                dojo.publish("Sage/events/markDirty");
            }
            if (this.autoPostBack) {
                __doPostBack(this.id, '');
            }
        },
        setAttribute: function (attr, val) {
            /* Hide deprecated warnings, due to the parser and _WidgetBase assuming focusNode is a dom node and not a widget */
            this.set(attr, val);
        }
    });

    return widget;
});

},
'Sage/UI/Controls/GridParts/Columns/DateTime':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/date/locale',
    'Sage/Utility',
    'Sage/Utility/Activity',
    'dojo/_base/declare',
    'dojo/_base/lang'
],
function (locale, Utility, activityUtility, declare, lang) {
    var widget = declare('Sage.UI.Controls.GridParts.Columns.DateTime', null, {
        // summary:
        //  Read-only date/time display column.
        //  The following configuration properties may be included when setting up the column:
        //  * formatType (date, time, or date/time - defaults to date/time)
        timelessField: '',
        timelessText: '',
        dateOnly: false,
        utc: false,
        useFiveSecondRuleToDetermineTimeless: false,
        constructor: function (args) {
            lang.mixin(this, args);
        },
        format: function (inRowIndex, inItem) {
            var retVal = this.formattedDate(inRowIndex, inItem);
            if (this.abbreviationLength) {
                var abbreviationFormatter = Sage.Format.abbreviationFormatter(this.abbreviationLength);
                retVal = abbreviationFormatter(retVal);
            }
            return retVal;
        },
        formattedDate: function (inRowIndex, inItem) {
            // summary:
            //	if given a date, convert it to local time and provide corresponding HTML
            if (!inItem)
                return '';
            var d = inRowIndex ? inRowIndex : this.defaultValue;

            this.dateOnly = (typeof this.dateTimeType === 'undefined') ? this.dateOnly : (this.dateTimeType.toUpperCase() === 'D');

            if (!d)
                return '';
            d = convert.toDateFromString(d, true);
            if (!d || d.constructor !== Date) {
                return '';
            }
            var tless = false;
            if (this.timelessField && this.timelessField !== '') {
                tless = convert.toBoolean(Utility.getValue(inItem, this.timelessField, 'F'));
            }
            if (this.useFiveSecondRuleToDetermineTimeless) {
                tless = activityUtility.isDateFiveSecondRuleTimeless(d);
            }
            // TODO: edit mode?    
            if (!this.dateOnly && !this.datePattern) {
                if (!tless) {
                    return locale.format(d, { selector: this.formatType || 'date/time', fullYear: true, locale: Sys.CultureInfo.CurrentCulture.name });
                } else {
                    var timelessDate = new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), 0, 0, 5);
                    return dojo.date.locale.format(timelessDate, { selector: 'date', fullYear: true, locale: Sys.CultureInfo.CurrentCulture.name }) + this.timelessText;
                }
            } else if (this.datePattern) {
                // If this is a date-only value ("D" date time type), undo the local time conversion before formatting.
                if (this.dateOnly) {
                    d = new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
                }
                return d.format(this.datePattern, { locale: Sys.CultureInfo.CurrentCulture.name });
            } else {
                if (this.utc) {
                    var dateOnly = new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
                    return locale.format(dateOnly, { selector: 'date', fullYear: true, locale: Sys.CultureInfo.CurrentCulture.name });
                }
                else {
                    return dojo.date.locale.format(d, { selector: 'date', fullYear: true, locale: Sys.CultureInfo.CurrentCulture.name });
                }
            }
        }
    });

    // conversion helper is used locally, and also registered under Sage.UI.Columns.DateTime.
    // It's a bit of a kludge, ideally these functions should be shared at a utility level
    var convert = Utility.Convert;

    return widget;
});
},
'Sage/UI/Controls/GridParts/Columns/Phone':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'Sage/Format',
    'Sage/UI/Controls/Phone',
    'dojo/_base/declare',
    'dojo/_base/lang'
],
function (Format, Phone, declare, lang) {
    var widget = declare('Sage.UI.Controls.GridParts.Columns.Phone', null, {
        defaultValue: '',
        widgetClass: Phone,
        constructor: function (args) {
            lang.mixin(this, args);
        },
        format: function (val, data) {
            return '<a href="tel:' + val + '">' + Format.phone(val, data) + '</a>';
        }
    });

    return widget;
});
},
'Sage/Format':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define(['Sage/Utility', 'dojo/string'],
function (utility, dString) {

    Sage.Format = {
        // summary:
        // this class contains common Saleslogix based formatters for formatting data in grids and elsewhere.
        phone: function (val, index) {
            if (!val) return '';
            if (val.length !== 10) return utility.htmlEncode(val);

            return dString.substitute('(${0}) ${1}-${2}',
            [val.substring(0, 3), val.substring(3, 6),
            val.substring(6)]);
        },
        email: function (val, index) {
            if (!val) return '';
            var dispstr = val;
            if (this.icon && this.icon !== '') {
                dispstr = (this.icon === true || this.icon === 'true')
                    ? '<img src="images/icons/Send_Write_email_16x16.png" />'
                    : '<img src="' + this.icon + '" />';
            }
            return dojo.string.substitute('<a href="mailto:${0}">${1}</a>', [val, dispstr]);
        },
        stringFromArray: function (formatString, arr) {
            switch (arr.length) {
                case 1:
                    return String.format(formatString, arr[0]);
                case 2:
                    return String.format(formatString, arr[0], arr[1]);
                case 3:
                    return String.format(formatString, arr[0], arr[1], arr[2]);
                case 4:
                    return String.format(formatString, arr[0], arr[1], arr[2], arr[3]);
                case 5:
                    return String.format(formatString, arr[0], arr[1], arr[2], arr[3], arr[4]);
                case 6:
                    return String.format(formatString, arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]);
                case 7:
                    return String.format(formatString, arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], arr[6]);
                case 8:
                    return String.format(formatString, arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], arr[6], arr[7]);
                case 9:
                    return String.format(formatString, arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], arr[6], arr[7], arr[8]);
                case 10:
                    return String.format(formatString, arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], arr[6], arr[7], arr[8], arr[9]);
                default:
                    return formatString;

            }
        },

        abbreviationFormatter: function (maxLength) {
            // summary:
            //  Return formatter function to be used to restrict length of a display
            return function (value, data) {
                if (value === null) {
                    return '';
                }
                if (typeof (value) != "string" || value.length <= maxLength) {
                    return value;
                }
                value = value.substring(0, maxLength);
                var ispace = value.lastIndexOf(" ");
                if (ispace > 0 && ispace > value.length * 0.75) {
                    // pick the last space in the string, but only if it's at least 3/4 of it
                    value = value.substring(0, ispace);
                }
                return value + "...";
            };
        },
        Address: {
            formatAddress: function (address, format) {
				// summary: 
				// Takes and array of address fields and formats them based on format.
				// @param address: Array of addres fields.
				// @param format: The country format should be the formatted.   
				var lineBreak = '\r\n';
				var formatString = '';
				var addressLines = this.GetAddressLines(address);
				var city = this.GetCity(address);
				var state = this.GetState(address);
				var zipCode = this.GetZipCode(address);
				var county = this.GetCounty(address);	
				var country = this.GetCountry(address);				
				
				//Replace %A i.e address lines
				formatString = format.replace(/%A/g, addressLines);
				//Replace %D i.e County or District					
				formatString = formatString.replace(/%D/g, county); 
				//Replace %C i.e City
				formatString = formatString.replace(/%C/g, city); 
				//Replace %Z i.e Zip code
				formatString = formatString.replace(/%Z/g, zipCode); 
				//Replace %S i.e State
				formatString = formatString.replace(/%S/g, state);
				if(format.indexOf('%A') === -1)
				{
					if(format === '')
						formatString += addressLines === ''? '': addressLines;
					else
						formatString += addressLines === ''? '': lineBreak + addressLines;
				}
				if(format.indexOf('%C') === -1)
					formatString += city === ''? '': lineBreak + city;				
				if(format.indexOf('%S') === -1)
					formatString += state === ''? '': lineBreak + state; 
				if(format.indexOf('%Z') === -1)
					formatString += zipCode === ''? '': lineBreak + zipCode;				
				//Replace %n i.e line break
				formatString = this.RemoveUnnecessaryChars(formatString);
				// Now add country lastly to address string	
				formatString = formatString + country;
				//Now replace ^ with emptyto handle it for test type	
				formatString = formatString.replace(/\^/g, '');
				if (addressLines === '' && city === '' && county === '' &&
                    state === '' &&	zipCode === '' && country === '')
                {
                    formatString = '';
                }
				return formatString;
			},
			RemoveUnnecessaryChars: function(formatString){
				var format = '';
				var lineBreak = '\r\n';
				var addressArray = formatString.split('%n');
				for(var i = 0; i < addressArray.length; i++)
				{
					var addressFormat = addressArray[i]; 
					addressFormat = addressFormat.replace(/^\,|\,$/g, '');	
					addressFormat = addressFormat.replace(/^\ |\ $/g, '');	
					addressFormat = addressFormat.replace(/^\ - |\ - $/g, '');
					addressFormat = addressFormat.replace(/^\-|\-$/g, '');
					addressFormat = addressFormat.replace(/\/$/g, '');
					if(addressFormat !== '')
						format += addressFormat + lineBreak;
				}
				return format;
			},
			GetAddressLines: function(address){								
				var lineBreak = '\r\n';
				var addr1 = this.GetValueByObjectName(address,'addr1');
				var addr2 = this.GetValueByObjectName(address,'addr2');
				var addr3 = this.GetValueByObjectName(address,'addr3');
				var addr4 = this.GetValueByObjectName(address,'addr4');
				var addr5 = this.GetValueByObjectName(address,'addr5');
				var addr6 = this.GetValueByObjectName(address,'addr6');
				
				var addressLines = addr1 !== '' ? addr1 : '';
                addressLines += addr2 !== '' ? lineBreak + addr2 : '';
                addressLines += addr3 !== '' ? lineBreak + addr3 : '';
                addressLines += addr4 !== '' ? lineBreak + addr4 : '';
                addressLines += addr5 !== '' ? lineBreak + addr5 : '';
                addressLines += addr6 !== '' ? lineBreak + addr6 : '';
				return addressLines;
			},
			GetCounty: function(address){ 
				return this.GetValueByObjectName(address,'county');
			},
			GetCity: function(address){ 
				return this.GetValueByObjectName(address,'city');
			},
			GetZipCode: function(address){ 
				return this.GetValueByObjectName(address,'postalCode');
			},
			GetState: function(address){ 
				return this.GetValueByObjectName(address,'state');
			},
			GetCountry: function(address)
			{
				return this.GetValueByObjectName(address,'country');
			},
			GetValueByObjectName: function(address, name)
			{
				var value = '';
				var valueObj = address.filter(function( obj ) {
					return obj.name === name;
				});
				if(valueObj.length > 0){
					if(valueObj[0].value !== '')
						value = valueObj[0].value;
				}
				return value;
			}
        }
    };
    return Sage.Format;
});

},
'Sage/UI/Controls/GridParts/Columns/PickList':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'Sage/UI/Controls/PickList',
    'Sage/UI/Controls/DropDownSelectPickList',
    'Sage/Data/BaseSDataStore',
    'dojo/_base/declare',
    'dojo/_base/array',
    'dojo/_base/lang'
],
function (pickList, dropDownSelectPickList, baseSDataStore, declare, dArray, lang) {
    var widget = declare('Sage.UI.Controls.GridParts.Columns.PickList', null, {
        widgetClass: dropDownSelectPickList,
        /**
        * @property {object} storeData Data fetched from SData stored here.
        */
        storeData: null,
        pickList: null,
        storageMode: 'id', //Default for column picklist
        displayMode: 'AsText', //Default for column picklist formatting
        constructor: function (args) {
            lang.mixin(this, args);
            this.inherited(arguments);
            if (this.storageMode === 'id' || this.storageMode === 'code') {
                if (this.pickListName && this.storeData === null) {
                    this._loadPickList();
                }
            }
        },
        format: function (val, data) {
            if (this.storageMode === 'id') {
                val = this.getStoreTextById(val);
            }
            if (this.storageMode === 'code') {
                val = this.getStoreTextByCode(val);
            }
            return (typeof val !== 'undefined' ? val : '');
        },
        _loadPickList: function () {
            var deferred = new dojo.Deferred();
            var config = {
                pickListName: this.pickListName, // Required
                canEditText: false,
                itemMustExist: true,
                maxLength: -1,
                storeMode: this.storageMode, // text, id, code
                sort: false,
                displayMode: this.displayMode,
                async: false
            };
            this.pickList = new pickList(config);
            this.pickList.getPickListData(deferred);

            deferred.then(lang.hitch(this, this._loadData), function (e) {
                console.error(e); // errback
            });

        },
        getStoreTextById: function (val) {
            var result = val;
            if (this.storeData) {
                //If the value is not found as an id in the list, return the value back.
                dArray.some(this.storeData.items, function (item) {
                    if (item.id === val) {
                        result = item.text;
                    }
                }, this);
            }
            return result;
        },
        getStoreTextByCode: function (val) {
            var result = val;
            if (this.storeData) {
                //If the value is not found as a code in the list, return the value back.
                dArray.some(this.storeData.items, function (item) {
                    if (item.code === val) {
                        result = item.text;
                    }
                }, this);
            }
            return result;
        },
        _loadData: function (data) {
            var items = [];
            for (var i = 0; i < data.items.$resources.length; i++) {
                var item = data.items.$resources[i];
                items.push({
                    id: item.$key,
                    code: item.code,
                    number: item.number,
                    text: item.text
                });
            }
            this.storeData = {
                identifier: 'id',
                label: 'text',
                items: items
            };
        }
    });

    return widget;
});
},
'Sage/UI/ToolBarLabel':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dijit/_Widget',
    'dijit/_TemplatedMixin',
    'dojo/_base/declare'
],
function (_Widget, _TemplatedMixin, declare) {
    var toolBarLabel = declare('Sage.UI.ToolBarLabel', [_Widget, _TemplatedMixin], {
        label: 'label',
        //Default region
        region: 'leading',
        templateString: '<span class="dijitToolbarLabel"><span class="dijitReset dijitInline " dojoAttachPoint="containerNode"></span></span>',

        attributeMap: {
            label: { node: "containerNode", type: "innerHTML" }
        },
        _append: function (val) {
            this.containerNode.innerHTML += val;
        },
        _setLabelAttr: function (label) {
            this.containerNode.innerHTML = this.label = label;
        }
    });
    return toolBarLabel;
});
},
'Sage/Utility/File':function(){
/*globals Sage, define, FileReader, FormData, window, VBArray, Sys */
define([
    'Sage/UI/Dialogs',
    'dojo/number',
    'dojo/_base/lang',
    'dojo/i18n!./nls/File'
],
function (dialogs, dNumber, lang, nlsStrings) {
    Sage.namespace('Utility.File');
    Sage.Utility.File = {
        fileType: {
            ftAttachment: 0,
            ftLibraryDocs: 1
        },
        
        supportsHTML5File: (window.File && window.FileReader && window.FileList && window.Blob),

        fileUploadOptions: { maxFileSize: 4000000 },
        init: function (options) {
            if (options) {
                this.fileUploadOptions = options;
            }
        },
        isFileSizeAllowed: function (files) {
            var l = 0;
            var maxfileSize = Sage.Utility.File.fileUploadOptions.maxFileSize;
            var title = nlsStrings.largeFileWarningTitle;
            var msg = nlsStrings.largeFileWarningText;
            for (var i = 0; i < files.length; i++) {
                if (files[i].size === 0) {
                    // do nothing.
                } else {

                    l += files[i].size || files[i].blob.length;
                }
            }
            if (l > (maxfileSize)) {
                dialogs.showError(msg, title);
                return false;

            }
            return true;
        },
        uploadFile: function (file, url, progress, complete, error, scope, asPut) {
            if (!Sage.Utility.File.isFileSizeAllowed([file])) {
                return;
            }
            if (Sage.gears) {
                this._uploadFileGears(file, url, progress, complete, error, scope, asPut);
            } else if (this.supportsHTML5File) {
                if ((window.FileReader.prototype.readAsBinaryString) || (window.FileReader.prototype.readAsArrayBuffer)) {

                    this._uploadFileHTML5_asBinary(file, url, progress, complete, error, scope, asPut);

                 } else {

                    this._uploadFileHTML5(file, url, progress, complete, error, scope, asPut);
                }
            } else {
                this._showUnableToUploadError();
            }
        },
        uploadFileHTML5: function (file, url, progress, complete, error, scope, asPut) {
            if (!Sage.Utility.File.isFileSizeAllowed([file])) {
                return;
            }
            if (this.supportsHTML5File) {
                if ((window.FileReader.prototype.readAsBinaryString) || (window.FileReader.prototype.readAsArrayBuffer)) {
                    this._uploadFileHTML5_asBinary(file, url, progress, complete, error, scope, asPut);
                } else {
                    this._uploadFileHTML5(file, url, progress, complete, error, scope, asPut);
                }
            } else {
                this._showUnableToUploadError();
            }
        },
        _uploadFileGears: function (file, url, progress, complete, error, scope, asPut) {
            if (!window.Sage && !Sage.gears) {
                this._showUnableToUploadError();
                return;
            }

            if (progress) {
                progress.call(scope,null);
            }

            if (!url) {
                //assume Attachment SData url
                url = 'slxdata.ashx/slx/system/-/attachments/file?format=json';
            }
            var request = Sage.gears.factory.create('beta.httprequest');
            request.open((asPut) ? 'PUT' : 'POST', url);

            //var boundary = '------multipartformboundary' + (new Date()).getTime();
            var boundary = "---------------------------" + (new Date()).getTime();
            var dashdash = '--';
            var crlf = '\r\n';

            var builder = Sage.gears.factory.create('beta.blobbuilder');
            //for (var i = 0; i < files.length; i++) {
            /* Write boundary. */
            builder.append(dashdash);
            builder.append(boundary);
            builder.append(crlf);
            //var file = files[i];
            /* Generate headers. */
            //builder.append('Content-Disposition: form-data; name="file_"'); // + i + '"'); // will not work for raw binary
            builder.append('Content-Disposition: attachment; name="file_"'); // + i + '"');

            if (file.name) {
                builder.append('; filename*="' + encodeURIComponent(file.name) + '"');
            }
            builder.append(crlf);

            builder.append('Content-Type: application/octet-stream');
            builder.append(crlf);
            builder.append(crlf);

            /* Append binary data. */
            builder.append(file.blob);
            builder.append(crlf);
            //}
            /* Mark end of the request. */
            builder.append(dashdash);
            builder.append(boundary);
            builder.append(dashdash);
            builder.append(crlf);

            if (typeof (complete) === 'function') {
                request.onreadystatechange = function () {
                    if (request.readyState === 4) {
                        //console.log(JSON.parse(xhr.responseText.replace(/^\{\}&&/, '')));
                        if (Math.floor(request.status / 100) !== 2) {
                            if (typeof (error) === 'function') {
                                error.call(scope || this, request);
                            }
                        } else {
                            complete.call(scope || this, request);
                        }
                    }
                };
            }

            if (typeof (progress) === 'function') {
                request.upload.onprogress = function (prog) {
                    // { total : 500, loaded : 250, lengthComputable : true };  <-- example progress object
                    progress.call(scope || this, prog);
                };
            }
            request.setRequestHeader('Content-Type', 'multipart/attachment; boundary=' + boundary);
            // request.setRequestHeader('Content-Type', 'multipart/form-data; boundary=' + boundary); //will not work for raw binary
            var blob = builder.getAsBlob();
            request.send(blob);
        },
        _uploadFileHTML5: function (file, url, progress, complete, error, scope, asPut) {            
            if (!this.supportsHTML5File || !window.FormData) {
                this._showUnableToUploadError();
                return;
            }

            if (progress) {
                progress.call(scope, null);
            }


            if (!url) {
                //assume Attachment SData url
                url = 'slxdata.ashx/slx/system/-/attachments/file';
            }
            var fd = new FormData();
            //fd.append('filename*', encodeURI(file.name)); //Does not work
            // This 'file.name' doesn't need encoding, as it is handled when the form is posted for us
            // (if we do this, it assumes the encoded characters are actually a part of the name,
            //  and this breaks the logic for pulling the attachments again)
            fd.append('file_', file, file.name);
            //fd.name = encodeURI(file.name)
            var request = new XMLHttpRequest();

            request.open((asPut) ? 'PUT' : 'POST', url);
            request.setRequestHeader('X-Requested-With', 'XMLHttpRequest');

            if (complete) {
                request.onreadystatechange = function () {
                    if (request.readyState === 4) {
                        //console.log(JSON.parse(xhr.responseText.replace(/^\{\}&&/, '')));
                        if (Math.floor(request.status / 100) !== 2) {
                            if (error) {
                                error.call(scope || this, request);
                            }
                        } else {
                            complete.call(scope || this, request);
                        }
                    }
                };
            }
            if (progress) {
                request.upload.addEventListener('progress', function (e) {
                    progress.call(scope || this, e);
                });
            }
            request.send(fd);
        },
        _uploadFileHTML5_asBinary: function (file, url, progress, complete, error, scope, asPut) {
            if (!this.supportsHTML5File) {
                this._showUnableToUploadError();
                return;
            }

            if (progress) {
                progress.call(scope, null);
            }
            window.BlobBuilder = window.BlobBuilder ||
                         window.WebKitBlobBuilder ||
                         window.MozBlobBuilder ||
                         window.MSBlobBuilder;


            if (!url) {
                //assume Attachment SData url
                url = 'slxdata.ashx/slx/system/-/attachments/file';
            }
            var request = new XMLHttpRequest();
            request.open((asPut) ? 'PUT' : 'POST', url);
            request.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
            var reader = new FileReader();
            reader.onload = lang.hitch(this, function(evt) {
                var binary, boundary, dashdash, crlf, bb, usingBlobBuilder, blobReader, blobData;

                blobReader = new FileReader();

                try {
                    new Blob();// This will throw an exception if it is no supported 
                    bb = [];
                } catch (e) {
                    bb = new window.BlobBuilder();
                    usingBlobBuilder = true;
                }
                
                //remove paths if they were passed as a part of the file name
                //thsi can happen if we are passed message obejct from our BHO
                var filenameParts = file.name.split("\\");
                var filename = filenameParts[filenameParts.length - 1];

                binary = evt.target.result;
                boundary = "---------------------------" + (new Date()).getTime();
                dashdash = '--';
                crlf = '\r\n';
                this._append(bb, dashdash + boundary + crlf);
                this._append(bb, 'Content-Disposition: attachment; ');
                this._append(bb, 'name="file_"; ');
                this._append(bb, 'filename*="' + encodeURIComponent(filename) + '" ');
                this._append(bb, crlf);
                this._append(bb, 'Content-Type: ' + file.type);
                this._append(bb, crlf + crlf);
                this._append(bb, binary);
                this._append(bb, crlf);
                this._append(bb, dashdash + boundary + dashdash + crlf);

                if (complete) {
                    request.onreadystatechange = function () {
                        if (request.readyState === 4) {
                            console.log('responseText: ' + request.responseText);

                            if (Math.floor(request.status / 100) !== 2) {
                                if (error) {
                                    error.call(scope || this, request);
                                }
                            } else {
                                complete.call(scope || this, request);
                            }
                        }
                    };
                }
                if (progress) {
                    request.upload.addEventListener('progress', function(e) {
                        progress.call(scope || this, e);
                    });
                }
                request.setRequestHeader('Content-Type', 'multipart/attachment; boundary=' + boundary);
                if (usingBlobBuilder) {
                    blobData = bb.getBlob(file.type);
                } else {
                    blobData = new Blob(bb);
                }
                blobReader.onload = function(e) {
                        request.send(e.target.result);

                };
                try {
                    request.send(blobData); //Send asTyped Array
                } catch (e) {
                    console.log('Error uploading file as typed array: ' + e);
                    blobReader.readAsArrayBuffer(blobData); //Send as Array Buffer
                }
            });
            try {
                reader.readAsArrayBuffer(file); //Send asTyped Array
            } catch (e) {
                var data;
                if (typeof file.blob != "undefined") {
                    if (file.blob.constructor == Array) {
                        //is this an object from our browser hook?
                        data = new Blob([new Uint8Array(file.blob)], { type: 'application/binary' });
                        reader.readAsArrayBuffer(data);
                    }
                    else if (typeof VBArray != "undefined") {
                        //is this our XGears file object coming from an Outlook message?

                        var blob = file.blob;
                        var fileArray = new VBArray(blob.getAsArray()).toArray();
                        data = new Blob([new Uint8Array(fileArray)], { type: 'application/binary' });
                        reader.readAsArrayBuffer(data);
                    }
                }
            }
        },
        _append: function(arrayOrBlobBuilder, data) {
            if (arrayOrBlobBuilder && arrayOrBlobBuilder.constructor === Array) {
                arrayOrBlobBuilder.push(data);
            } else {
                arrayOrBlobBuilder.append(data);
            }
        },
        _showUnableToUploadError: function () {
            dialogs.showError(nlsStrings.unableToUploadText);
        },
        formatFileSize: function (size) {
            size = parseInt(size, 10);
            if (size === 0) {
                return '0 KB';
            }
            if (!size || size < 0) {
                return nlsStrings.unknownSizeText;
            }
            if (size < 1024) {
                return '1 KB';
            }
            return dNumber.format(Math.round(size / 1024), { locale: Sys.CultureInfo.CurrentCulture.name }) + ' KB';
        }
    };

    return Sage.Utility.File;
});
},
'Sage/Utility/File/Attachment':function(){
/*globals define, Sage, window, dojo */
define([
    'Sage/Data/SingleEntrySDataStore',
    'Sage/Data/SDataServiceRegistry',
    'Sage/Utility/File',
    'Sage/UI/Dialogs',
    'dojo/_base/lang',
    'dojo/string',
    'Sage/Utility',
        'Sage/Utility/File/DescriptionsForm',
    'dojo/i18n',
    'dojo/i18n!./nls/Attachment'
],
    function (SingleEntrySDataStore, SDataServiceRegistry, FileUtil, dialogs, dLang, dString, Utility, DescriptionsForm, i18n) {
        Sage.namespace('Utility.File.Attachment');
        Sage.Utility.File.Attachment = {
            uploadingAttachments: 'Uploading attachments',
            uploadCompleted: 'Completed',
            uploadingPleaseWait: 'Uploading, please wait...',
            uploadFailed: 'Upload failed.',
            _store: false,
            _totalProgress: 0,
            _attachmentTemplate: false,
            _mixinsByName: {},
            _files: [],
            _fileCount: 0,
            _filesUploadedCount: 0,
            _isUploading: false,
            _descriptionsForm: false,
            //_uploadUrlFmt: 'slxdata.ashx/slx/system/-/attachments(\'${0}\')/file',
            _uploadUrl: 'slxdata.ashx/slx/system/-/attachments/file',
            createAttachments: function (files) {
                var entityDesc = '';
                if (Sage.Services.hasService('ClientEntityContext')) {
                    var entitycontext = Sage.Services.getService('ClientEntityContext');
                    var context = entitycontext.getContext();
                    entityDesc = context.Description || '';
                }
                this._ensureDescriptionsForm();
                this._descriptionsForm.set('entityDesc', entityDesc);
                this._descriptionsForm.set('files', files);
                this._descriptionsForm.show();
            },
            createAttachmentSilent: function (file, mixin) {

                //remove paths if they were passed as a part of the file name
                //this can happen if we are passed message object from our BHO
                var filenameParts = file.name.split("\\");
                var filename = filenameParts[filenameParts.length - 1];
                if (!mixin.hasOwnProperty('description')) {
                    mixin['description'] = this.getDefaultDescription(filename);
                }
                //console.log("creating attachment silently - desc: " + mixin['description']);



                this._mixinsByName[filename] = dLang.mixin(mixin, {
                    attachDate: Utility.Convert.toIsoStringFromDate(new Date()),
                    dataType: 'R'
                });
                this._files.push(file);
                if (!this._attachmentTemplate) {
                    this.getAttachmentTemplate(this.uploadFiles, this);
                } else {
                    this.uploadFiles();
                }
            },
            handleDescriptions: function (files, descriptions) {
                var propname = '';
                var id = '';
                this.getKnownRelationships(function (rels) {
                    var rootmixin = dLang.mixin(rels, {
                        attachDate: Utility.Convert.toIsoStringFromDate(new Date()),
                        dataType: 'R',
                        user: { '$key': Utility.getClientContextByKey('userID') || '' }
                    });
                    for (var i = 0; i < descriptions.length; i++) {
                        descriptions[i][propname] = id;
                        this._mixinsByName[descriptions[i].fileName] = dLang.mixin(descriptions[i], rootmixin);
                    }
                    for (i = 0; i < files.length; i++) {
                        this._files.push(files[i]);
                    }
                    if (!this._attachmentTemplate) {
                        this.getAttachmentTemplate(this.uploadFiles, this);
                    } else {
                        this.uploadFiles();
                    }
                }, this);
            },
            uploadFiles: function (template) {
                this._isUploading = true;
                this._fileCount = this._files.length;
                if (template && !this._attachmentTemplate) {
                    this._attachmentTemplate = template;
                }
                while (this._files.length > 0) {
                    var file = this._files.pop();
                    Sage.Utility.File.uploadFile(file,
                    this._uploadUrl,
                    this._updateProgress,
                    this._successUpload,
                    this._failAdd,
                    this);
                }
            },
            _successUpload: function (request) {

                //the id of the new attachment is buried in the Location response header...
                var url = request.getResponseHeader('Location');
                var re = /\'\w+\'/g;
                var matches = url.match(re);
                if (matches) {
                    var id = matches[0].replace(/\'/g, '');

                    //now that we have the id, we can fetch it using the SingleEntrySDataStore
                    var tempStore = new SingleEntrySDataStore({
                        resourceKind: 'attachments',
                        service: SDataServiceRegistry.getSDataService('system')
                    });
                    tempStore.fetch({
                        predicate: '"' + id + '"',
                        onComplete: function (attachment) {
                            //now we have the attachment entity, we can set the values to the properties we need to
                            var mixin = this._mixinsByName[attachment.fileName];
                            if (mixin) {
                                attachment = dLang.mixin(attachment, mixin);
                                // then save it
                                tempStore.save({
                                    scope: this,
                                    success: this._successAddEntity,
                                    failure: this._failAdd
                                });
                            }
                            //clean up in case they upload the same file again to another entity or something
                            delete (this._mixinsByName[attachment.fileName]);
                        },
                        beforeRequest: function (req) {
                            req.setQueryArg('_includeFile', 'false');
                        },
                        onError: this._failAdd,
                        scope: this
                    });
                }
                this._filesUploadedCount = this._filesUploadedCount + 1;
                this._updateProgress((this._fileCount < 1) ? 100 : (this._filesUploadedCount / this._fileCount) * 100);
            },
            _successAddEntity: function (entity) {
                //console.log('new attachment record created... ' + entity['$key']);
                dojo.publish('/entity/attachment/create', entity);
            },
            getAttachment: function (id) {
                if (id && id.length === 12) {
                    window.open('slxdata.ashx/slx/system/-/attachments(\'' + id + '\')/file', 'file');
                }
            },
            getAttachmentTemplate: function (callback, scope) {
                FileUtil.Attachment._createStore();
                FileUtil.Attachment._store.newItem({
                    onComplete: callback,
                    scope: scope || this
                });
            },
            getDefaultDescription: function (filename) {
                this._ensureDescriptionsForm();
                return this._descriptionsForm.getDefaultDescription(filename);
            },
            _createStore: function () {
                if (!FileUtil.Attachment._store) {
                    FileUtil.Attachment._store = new SingleEntrySDataStore({
                        resourceKind: 'attachments',
                        service: SDataServiceRegistry.getSDataService('system')
                    });
                }
            },
            _updateProgress: function (curFileProgress) {
                //console.log('progress obj: %o', curFileProgress);
                var self;
                var pct = this._totalProgress;
                //console.log('pct: ' + pct);
                if (curFileProgress && curFileProgress.lengthComputable) {
                    var thisFilePercent = (curFileProgress.loaded / curFileProgress.total) * 100;
                    pct += Math.round(thisFilePercent / this._fileCount);
                } else if (curFileProgress) {
                    pct = curFileProgress;
                }
                this._totalProgress = pct;
                //console.log('now calculated pct: ' + pct);
                if (pct < 99) {
                    dialogs.showProgressBar({
                        pct: pct,
                        title: this.uploadingAttachments,
                        message: this.uploadingPleaseWait,
                        showmessage: true
                    });
                } else {
                    dialogs.showProgressBar({
                        pct: pct,
                        message: this.uploadCompleted,
                        showmessage:true
                    });
                    self = this;
                    window.setTimeout(function() {
                        dialogs.closeProgressBar();
                    }, 1000);
                    this._resetCounts();
                }
            },
            _resetCounts: function () {
                this._fileCount = 0;
                this._filesUploadedCount = 0;
                this._isUploading = false;
                this._totalProgress = 0;
            },
            _failAdd: function (resp) {
                console.warn('Attachment failed to save %o', resp);
                dialogs.showProgressBar({
                    title: this.uploadingAttachments,
                    message: this.uploadFailed,
                    showmessage: true
                });
            },
            _successUpdate: function (attachment) {
                dojo.publish('/entity/attachment/update', attachment);
            },
            _ensureDescriptionsForm: function () {
                if (!this._descriptionsForm) {
                    this._descriptionsForm = new DescriptionsForm({
                        entityDesc: '',
                        files: this._files || []
                    });
                    dojo.connect(this._descriptionsForm, 'onDescriptionsEntered', this, 'handleDescriptions');
                }
            },
            getKnownRelationships: function (callback, scope, includeInsertActivity) {
                var retobj = {};
                if (Sage.Services.hasService('ClientEntityContext')) {
                    var entitycontext = Sage.Services.getService('ClientEntityContext');
                    var context = entitycontext.getContext();
                    var parts = context.EntityType.split('.');
                    var entityType = parts[parts.length - 1];
                    if (context.EntityId !== "") {
                        var id = context.EntityId;
                        switch (entityType) {
                            case 'IContact':
                                this._getContactRelationships(id, callback, scope);
                                return;
                            case 'IOpportunity':
                                this._getOpportunityRelationships(id, callback, scope);
                                return;
                            case 'ITicket':
                                this._getTicketRelationships(id, callback, scope);
                                return;
                            case 'ISalesOrder':
                                this._getSalesOrderRelationships(id, callback, scope);
                                return;
                            case 'IActivity':
                                this._getActivityRelationships(id, callback, scope);
                                return;
                            case 'IHistory':
                                this._getHistoryRelationships(id, callback, scope);
                                return;
                            case 'IContract':
                                this._getContractRelationships(id, callback, scope);
                                return;
                            case 'IReturn':
                                this._getReturnRelationships(id, callback, scope);
                                return;
                        }
                        var propname = context.EntityTableName.toLowerCase() + 'Id';
                        retobj[propname] = id;
                        callback.call(scope || this, retobj);
                        return;
                    } else if (entityType === 'IActivity' && includeInsertActivity) {
                        //we are in insert activity or history mode - get the relationships from the Editor...
                        //*** note *** this should only be called by the fallback file picker
                        // when using HTML5 File support or Gears, this is not needed.  This is just
                        // a hack for IE without gears.
                        this._getInsertActivityRelationships(callback, scope);
                        return;
                    } else if (entityType === 'IHistory' && includeInsertActivity) {
                        this._getInsertHistoryRelationships(callback, scope);
                        return;
                    }
                }
                callback.call(scope || this, {});
            },
            _getRequest: function (resourceKind, id) {
                var req = new Sage.SData.Client.SDataSingleResourceRequest(SDataServiceRegistry.getSDataService('dynamic'));
                req.setResourceKind(resourceKind);
                req.setResourceSelector('"' + id + '"');
                req.setQueryArg('precedence', '0');
                return req;
            },
            _getContactRelationships: function (id, callback, scope) {
                var req = this._getRequest('contacts', id);
                req.setQueryArg('include', 'Account');
                req.read({
                    success: function (contact) {
                        var obj = {
                            accountId: Utility.getValue(contact, 'Account.$key'),
                            contactId: contact.$key
                        };
                        callback.call(scope || this, obj);
                    },
                    failure: function () {
                        callback.call(scope || this, { 'contactId': id });
                    },
                    scope: this
                });
            },
            _getOpportunityRelationships: function (id, callback, scope) {
                var req = this._getRequest('opportunities', id);
                req.setQueryArg('include', 'Account,Contacts');
                req.setQueryArg('select', 'Contacts/IsPrimary,Account/Id');
                req.read({
                    success: function (opp) {
                        var obj = {
                            accountId: Utility.getValue(opp, 'Account.$key'),
                            opportunityId: opp.$key
                        };
                        var contactId = '';
                        var contacts = opp.Contacts.$resources;
                        if (contacts.length > 0) {
                            contactId = contacts[0].$key;
                        }
                        for (var i = 0; i < contacts.length; i++) {
                            if (contacts[i].IsPrimary) {
                                contactId = contacts[i].$key;
                            }
                        }
                        obj['contactId'] = contactId;
                        callback.call(scope || this, obj);
                    },
                    failure: function () {
                        callback.call(scope || this, { 'opportunityId': id });
                    },
                    scope: this
                });
            },
            _getSalesOrderRelationships: function (id, callback, scope) {
                var req = this._getRequest('salesorders', id);
                req.setQueryArg('include', 'Account');
                req.read({
                    success: function (so) {
                        //console.dir(so);
                        var obj = {
                            accountId: Utility.getValue(so, 'Account.$key'),
                            salesOrderId: so.$key
                        };
                        callback.call(scope || this, obj);
                    },
                    failure: function () {
                        callback.call(scope || this, { 'salesOrderId': id });
                    },
                    scope: this
                });
            },
            _getTicketRelationships: function (id, callback, scope) {
                var req = this._getRequest('tickets', id);
                req.setQueryArg('include', 'Account,Contact');
                req.read({
                    success: function (ticket) {
                        var obj = {
                            accountId: Utility.getValue(ticket, 'Account.$key'),
                            ticketId: ticket.$key,
                            contactId: Utility.getValue(ticket, 'Contact.$key')
                        };
                        callback.call(scope || this, obj);
                    },
                    failure: function () {
                        callback.call(scope || this, { 'ticketId': id });
                    },
                    scope: this
                });
            },
            _getReturnRelationships: function (id, callback, scope) {
                var req = this._getRequest('returns', id);
                req.setQueryArg('include', 'Account,Contact,Ticket');
                req.read({
                    success: function (rma) {
                        var obj = {
                            returnId: rma.$key,
                            accountId: Utility.getValue(rma, 'Account.$key'),
                            ticketId: Utility.getValue(rma, 'Ticket.$key'),
                            contactId: Utility.getValue(rma, 'Contact.$key')
                        };
                        callback.call(scope || this, obj);
                    },
                    failure: function () {
                        callback.call(scope || this, { returnId: id });
                    },
                    scope: this
                });
            },
            _getActivityRelationships: function (id, callback, scope) {
                var req = this._getRequest('activities', id);
                req.setQueryArg('select', 'AccountId,ContactId,LeadId,OpportunityId,TicketId');
                req.read({
                    success: function (activity) {
                        //console.dir(activity);
                        var obj = {
                            accountId: Utility.getValue(activity, 'AccountId'),
                            activityId: activity.$key,
                            contactId: Utility.getValue(activity, 'ContactId'),
                            leadId: Utility.getValue(activity, 'LeadId'),
                            opportunityId: Utility.getValue(activity, 'OpportunityId'),
                            ticketId: Utility.getValue(activity, 'TicketId')
                        };
                        callback.call(scope || this, obj);
                    },
                    failure: function () {
                        callback.call(scope || this, { 'activityId': id });
                    },
                    scope: this
                });
            },
            _getInsertActivityRelationships: function (callback, scope) {
                var ed = dijit.byId('activityEditor');
                if (ed) {
                    var obj = ed.getRelationshipsForAttachments();
                    callback.call(scope || this, obj);
                    return;
                }
                callback.call(scope || this, { 'activityId': '' });
            },
            _getHistoryRelationships: function (id, callback, scope) {
                var req = this._getRequest('history', id);
                req.setQueryArg('select', 'AccountId,ContactId,LeadId,OpportunityId,TicketId');
                req.read({
                    success: function (history) {
                        //console.dir(history);
                        var obj = {
                            accountId: Utility.getValue(history, 'AccountId'),
                            historyId: history.$key,
                            contactId: Utility.getValue(history, 'ContactId'),
                            leadId: Utility.getValue(history, 'LeadId'),
                            opportunityId: Utility.getValue(history, 'OpportunityId'),
                            ticketId: Utility.getValue(history, 'TicketId')
                        };
                        callback.call(scope || this, obj);
                    },
                    failure: function () {
                        callback.call(scope || this, { 'historyId': id });
                    },
                    scope: this
                });
            },
            _getInsertHistoryRelationships: function (callback, scope) {
                var ed = dijit.byId('historyEditor');
                if (ed) {
                    var obj = ed.getRelationshipsForAttachments();
                    callback.call(scope || this, obj);
                    return;
                }
                callback.call(scope || this, { 'historyId': '' });
            },
            _getContractRelationships: function (id, callback, scope) {
                var req = this._getRequest('contracts', id);
                req.setQueryArg('include', 'Account,Contact');
                req.read({
                    success: function (contract) {
                        var obj = {
                            accountId: Utility.getValue(contract, 'Account.$key'),
                            contractId: contract.$key,
                            contactId: Utility.getValue(contract, 'Contact.$key')
                        };
                        callback.call(scope || this, obj);
                    },
                    failure: function () {
                        callback.call(scope || this, { 'ticketId': id });
                    },
                    scope: this
                });
            },

            /* remote database attachment sync functionailty   */

            remoteRequestAttachment: function (attachId) {
                //http://localhost:17966/SlxClient/slxdata.ashx/slx/system/-/attachments/$service/RequestAttachment/$template?format=json
                var payload = {
                    '$name': 'RequestAttachment',
                    'request': {
                        'entity': { '$key': attachId },
                        AttachmentId: attachId
                    }
                };
                var request = new Sage.SData.Client.SDataServiceOperationRequest(SDataServiceRegistry.getSDataService('system'))
                    .setResourceKind('attachments')
                    .setOperationName('RequestAttachment');
                request.execute(payload, {
                    success: function (response) { dojo.publish('/entity/attachment/requested', response); }
                });
            }

            /* end remote handling.  */
        };

        Sage.Utility.File.Attachment = dojo.mixin(Sage.Utility.File.Attachment, i18n.getLocalization("Sage.Utility.File", "Attachment"));
        return Sage.Utility.File.Attachment;
    });

},
'Sage/Utility/File/DescriptionsForm':function(){
/*globals define, Sage   */
define([
    'Sage/Utility/File',
    'dijit/_Widget',
    'Sage/_Templated',
    'dojo/_base/lang',
    'dojo/string',
    'dijit/Dialog',
    'dojo/i18n',
    'dojo/i18n!./nls/DescriptionsForm',
    'dojo/_base/declare'
],
function (File, _Widget, _Templated, dLang, dString, Dialog, i18n, descriptionsFormStrings, declare) {
    var descForm = declare('Sage.Utility.File.DescriptionsForm', [_Widget, _Templated], {
        fileType: File.fileType.ftAttachment,
        titleFmt: 'Add Attachment(s) for ${0}',
        titleLibraryDoc: 'Add Library Document(s)',
        fileNameText: 'File name and size: ',
        descText: 'Description:',
        okText: 'OK',
        cancelText: 'Cancel',
        entityDesc: '',
        _formParts: [],
        files: [],
        widgetsInTemplate: true,
        widgetTemplate: new Simplate([
            '<div>',
                '<div dojoType="dijit.Dialog" id="dlgFileDescriptions" title="" dojoAttachPoint="_dialog">',
                    '<div dojoType="dojox.layout.TableContainer" orientation="horiz" cols="2" labelWidth="3" style="width:580px">',
                        '<div dojoType="dijit.layout.ContentPane" label="" style="width:212px;"><label>{%= $.fileNameText %}</label></div>',
                        '<div dojoType="dijit.layout.ContentPane" label="" style="width:250px;"><label>{%= $.descText %}</label></div>',
                    '</div>', //labels
                    '<div dojoType="dojox.layout.TableContainer" orientation="horiz" cols="2" labelWidth="5" dojoAttachPoint="contentNode" style="min-height:150px;width:580px;max-height:250px;overflow:auto" >',

                    '</div>', //body
                    '<div class="general-dialog-actions">', //buttons
                        '<div dojoType="dijit.form.Button" id="{%= $.id %}_btnOK" name="_btnOK" dojoAttachPoint="_btnOK" dojoAttachEvent="onClick:_okClick">{%= $.okText %}</div>',
                        '<div dojoType="dijit.form.Button" id="{%= $.id %}_btnCancel" name="_btnCancel" dojoAttachPoint="_btnCancel" dojoAttachEvent="onClick:_cancelClick">{%= $.cancelText %}</div>',
                    '</div>', //buttons
                '</div>', //dialog
            '</div>' //root
        ]),
        postMixInProperties: function () {
            dojo.mixin(this, descriptionsFormStrings);
            this.inherited(arguments);
        },
        show: function () {
            if (this.fileType !== File.fileType.ftLibraryDocs) {
                this._dialog.set('title', dString.substitute(this.titleFmt, [this.entityDesc]));
            }
            else {
                this._dialog.set('title', this.titleLibraryDoc);
            }
            this._dialog.show();
            this._addFormParts();
        },
        //        destroy: function () {
        //            this.inherited(arguments);
        //        },
        _setEntityDescAttr: function (desc) {
            this.entityDesc = desc;
        },
        _getEntityDescAttr: function () {
            return this.entityDesc;
        },
        _setFilesAttr: function (files) {
            this.files = files;
        },
        _getFilesAttr: function () {
            return this.files;
        },
        _addFormParts: function () {
            for (var i = 0; i < this.files.length; i++) {
                var file = this.files[i];
                var filelength = 0;
                if (file.size === 0) {
                    filelength = 0;
                }
                else {
                    filelength = file.size || file.blob.length;
                }
                if (filelength === 0) {
                    filelength += "0 Bytes";
                }
                else {
                    if (filelength) {
                        if (filelength > 1024) {
                            if (filelength > 1048576) {
                                filelength = Math.round(filelength / 1048576) + " MB";
                            } else {
                                filelength = Math.round(filelength / 1024) + " KB";
                            }
                        } else {
                            filelength += " Bytes";
                        }
                    }
                }
                var fnFld = new dijit.form.TextBox({
                    id: 'filename_' + i,
                    value: file.name + "  (" + filelength + ")",
                    style: 'min-width:250px;margin:0 0 5px 15px;',
                    disabled: true
                });
                var descFld = new dijit.form.TextBox({
                    id: 'desc_' + i,
                    value: this.getDefaultDescription(file.name),
                    style: 'min-width:250px;margin:0 0 5px 20px;',
                    maxLength: 128,
                    relFileName: file.name
                });
                this._formParts.push(fnFld);
                this._formParts.push(descFld);
                this.contentNode.addChild(fnFld);
                this.contentNode.addChild(descFld);
            }
        },
        _clearForm: function () {
            var len = this._formParts.length;
            for (var i = len - 1; i > -1; i--) {
                var elem = this._formParts[i];
                this.contentNode.removeChild(elem);
                elem.destroyRecursive(false);
            }
            this._formParts = [];
        },
        _okClick: function () {
            var descriptions = [];
            for (var i = 0; i < this._formParts.length; i++) {
                var elem = this._formParts[i];
                if (elem.params['relFileName']) {
                    descriptions.push({
                        description: elem.get('value') || this.getDefaultDescription(elem.params['relFileName']),
                        fileName: elem.params['relFileName']
                    });
                }
            }
            this._clearForm();
            this.onDescriptionsEntered(this.files, descriptions);
            this._dialog.hide();
        },
        _cancelClick: function () {
            this._clearForm();
            this._dialog.hide();
        },
        getDefaultDescription: function (filename) {
            // Strip off the file extension
            var idx = filename.lastIndexOf('.');
            if (idx != -1) {
                return filename.substr(0, idx);
            } else {
                return filename;
            }
        },
        onDescriptionsEntered: function (files, descriptions) { }
    });
    return descForm;
});
},
'Sage/Utility/File/AttachmentPropertiesEditForm':function(){
/*globals dojo, define, Sage, Simplate  */
define([
    'dijit/_Widget',
    'Sage/_Templated',
    'dojo/string',
    'dijit/Dialog',
    'Sage/UI/_DialogLoadingMixin',
    'dojo/_base/lang',
    'Sage/Data/SingleEntrySDataStore',
    'Sage/Data/SDataServiceRegistry',
    'Sage/MainView/BindingsManager',
    'Sage/Utility/File',
    'Sage/Utility',
    'Sage/UI/Dialogs',
    'dojox/layout/TableContainer',
    'Sage/UI/Controls/DateTimePicker',
    'dijit/form/TextBox',
    'dijit/form/Button',
    'dojox/form/Uploader',
    'dojo/i18n',
    'dojo/i18n!./nls/AttachmentPropertiesEditForm',
    'dojo/_base/declare'
],
function (_Widget,
    _Templated,
    dString,
    Dialog,
    _DialogLoadingMixin,
    dojoLang,
    SingleEntrySDataStore,
    sDataServiceRegistry,
    BindingsManager,
    fileUtility,
    sageUtility,
    sageDialogs,
    TableContainer,
    DateTimePicker,
    TextBox,
    Button,
    uploader,
    i18n,
    nlsResource,
    declare) {
    var attachForm = declare('Sage.Utility.File.AttachmentPropertiesEditForm', [_Widget, _Templated], {
        attachmentId: '',
        widgetsInTemplate: true,
        attachment: false,
        _bindingMgr: false,
        _store: false,
        _tempFile: false,
        _iframe: null,
        _showing: false,
        _iframeId: 'attachmentRePostIFrame',
        _uploadUrlFmt: 'slxdata.ashx/slx/system/-/attachments(\'${0}\')/file',
        widgetTemplate: new Simplate([
            '<div>',
                '<div dojoType="dijit.Dialog" title="{%= $.editText %}" dojoAttachPoint="_dialog">',
                    '<iframe src="about:blank" style="width:0px;height:0px;border-width:0px;" name="{%= $._iframeId %}" id="{%= $._iframeId %}" dojoAttachPoint="_iframe" dojoAttachEvent="onload:_iframeLoad"></iframe>',
                    '<form method="post" enctype="multipart/form-data" action="{%= $._buildPostUrl() %}" target="{%= $._iframeId %}" dojoAttachPoint="_postForm", class="attachment-properties-form">',
                        '<div dojoType="dojox.layout.TableContainer" orientation="horiz" cols="1" labelWidth="160" dojoAttachPoint="_urlContainer">',
                            '<div dojoType="dijit.form.TextBox" label="{%= $.urlText %}" id="{%= $.id %}_tb_Url" dojoAttachPoint="tb_Url" ></div>',
                        '</div>',
                        '<div dojoType="dojox.layout.TableContainer" orientation="horiz" cols="1" labelWidth="160" dojoAttachPoint="_fileNameContainer" >',
                            '<div dojoType="dijit.form.TextBox" label="{%= $.fileText %}" id="{%= $.id %}_tb_File" dojoAttachPoint="tb_File" ></div>',
                        '</div>',
                        '<div dojoType="dojox.layout.TableContainer" orientation="horiz" cols="1" labelWidth="160" >',
                            '<div dojoType="dijit.form.TextBox" label="{%= $.descriptionText %}" name="description" id="{%= $.id %}_tb_Description" dojoAttachPoint="tb_Description" maxlength="128" ></div>',
                            '<div dojoType="dijit.form.TextBox" label="{%= $.sizeText %}" id="{%= $.id %}_tb_size" dojoAttachPoint="tb_size" disabled="true" shouldPublishMarkDirty="false"></div>',
                            '<div dojoType="Sage.UI.Controls.DateTimePicker" label="{%= $.attachDateText %}" id="{%= $.id %}_dtp_AttachDate" dojoAttachPoint="dtp_attachDate" displayDate="true" displayTime="true" disabled="true" shouldPublishMarkDirty="false"></div>',
                            '<div dojoType="dijit.form.TextBox" label="{%= $.attachedByText %}" id="{%= $.id %}_tb_attachedBy" dojoAttachPoint="tb_attachedBy" disabled="true" shouldPublishMarkDirty="false"></div>',
                        '</div>', //form

                        '<div class="general-dialog-actions">',
                            '<input dojoType="dojox.form.Uploader" multiple="false" label="{%= $.uploadFileText %}" type="file" name="file" dojoAttachEvent="onChange:_onNewFile" dojoAttachPoint="btn_FileSelect" class="uploadButton" ></input>',
                        '</div>',
                        '<div class="general-dialog-actions">', //buttons
                            '<div dojoType="dijit.form.Button" id="{%= $.id %}_btnOK" name="_btnOK" dojoAttachPoint="_btnOK" dojoAttachEvent="onClick:_okClick" >{%= $.okText %}</div>',
                            '<div dojoType="dijit.form.Button" id="{%= $.id %}_btnCancel" name="_btnCancel" dojoAttachPoint="_btnCancel" dojoAttachEvent="onClick:_cancelClick">{%= $.cancelText %}</div>',
                        '</div>', //buttons
                        '<input type="hidden" name="X-HTTP-Method-Override" value="PUT" />', //in case we don't have async support
                    '</form>',
                '</div>', //dialog
            '</div>' //root node
        ]),
        postMixInProperties: function () {
            dojo.mixin(this, i18n.getLocalization("Sage.Utility.File", "AttachmentPropertiesEditForm"));
            this.inherited(arguments);
        },
        show: function () {
            this._dialog.show();
            if (!this._dialog._standby) {
                dojoLang.mixin(this._dialog, new _DialogLoadingMixin());
            }
            this._showing = true;
            if (!this.attachment) {
                this._dialog.showLoading();
            }
        },
        hide: function () {
            this.attachmentId = '';
            this.attachment = false;
            this._tempFile = false;
            if (this._dialog._standby) {
                this._dialog.hideLoading();
            }
            this._dialog.hide();
            this._showing = false;
        },
        _buildPostUrl: function () {
            var urlparts = [];
            urlparts.push(/https/i.test(window.location.protocol) ? 'https' : 'http');
            urlparts.push('://');
            urlparts.push(window.location.hostname);
            if (window.location.port && window.location.port !== 80) {
                urlparts.push(':', window.location.port);
            }
            urlparts.push('/');
            urlparts.push(sageUtility.getVirtualDirectoryName());
            urlparts.push('/slxdata.ashx/slx/system/-/attachments');
            if (this.attachment) {
                urlparts.push('("' + this.attachment.$key + '")');
            }
            urlparts.push('/file');
            var url = urlparts.join('');
            return url;
        },
        _iframeLoad: function (e) {
            if (this._iframe.contentDocument && this._iframe.contentDocument.URL.indexOf('attachments') > 0) {
                dojo.publish('/entity/attachment/update', '');
                this.hide();
            }
        },
        _setAttachmentIdAttr: function (attachId) {
            this.attachmentId = attachId;
            if (this.attachmentId && this.attachmentId !== '') {
                this._loadData();
            }
        },
        _getAttachmentIdAttr: function () {
            return this.attachmentId;
        },
        _loadData: function () {
            if (this._dialog._standby) {
                this._dialog.showLoading();
            }
            if (!this._store) {
                this._store = new SingleEntrySDataStore({
                    include: ['$descriptors'],
                    resourceKind: 'attachments',
                    service: sDataServiceRegistry.getSDataService('system')
                });
            }
            if (this.attachmentId !== '') {
                this._store.clearCache();
                this._store.fetch({
                    predicate: '"' + this.attachmentId + '"',
                    onComplete: this._receiveAttachment,
                    beforeRequest: function (request) {
                        request.setQueryArg('_includeFile', 'false');
                    },
                    onError: this._requestFail,
                    scope: this
                });
            } else {
                sageDialogs.showError('No attachment to edit');
            }
        },
        _receiveAttachment: function (attachment) {
            if (this._dialog._standby) {
                this._dialog.hideLoading();
            }
            this.attachment = attachment;
            this._ensureBindings();
            this._bind();
            if (this.attachment.url) {
                dojo.removeClass(this._urlContainer.domNode, 'display-none');
                dojo.addClass(this.btn_FileSelect.domNode, 'display-none');
                dojo.addClass(this._fileNameContainer.domNode, 'display-none');
            } else {
                dojo.addClass(this._urlContainer.domNode, 'display-none');
                dojo.removeClass(this.btn_FileSelect.domNode, 'display-none');
                dojo.removeClass(this._fileNameContainer.domNode, 'display-none');
            }
        },
        _ensureBindings: function () {
            if (!this._bindingMgr) {
                this._bindingMgr = new BindingsManager({
                    defaultBinding: { boundEntity: this.attachment },
                    items: [
                        {
                            boundWidget: this.tb_File,
                            entityProperty: 'fileName'
                        }, {
                            boundWidget: this.tb_Description,
                            entityProperty: 'description'
                        }, {
                            boundWidget: this.tb_size,
                            entityProperty: 'fileSize',
                            _formatValueFromEntity: function (v) {
                                return Sage.Utility.File.formatFileSize(v);
                            },
                            twoWay: false
                        }, {
                            boundWidget: this.dtp_attachDate,
                            entityProperty: 'attachDate',
                            dataType: 'date',
                            twoWay: false
                        }, {
                            boundWidget: this.tb_Url,
                            entityProperty: 'url'
                        }, {
                            boundWidget: this.tb_attachedBy,
                            entityProperty: 'user.$descriptor',
                            twoWay: false
                        }
                    ]
                });
            }
        },
        _bind: function () {
            if (!this._bindingMgr.boundEntity || (this.attachment.$key !== this._bindingMgr.boundEntity.$key)) {
                this._bindingMgr.setBoundEntity(this.attachment);
            } else {
                this._bindingMgr.bind();
            }
        },
        _onNewFile: function () {
            var files = this.btn_FileSelect._files;
            if (files && files.length > 0) {
                this.tb_File.set('value', files[0].name);
                this._tempFile = files[0];
            } else {
                //this._tempFile = true;
            }
            this.tb_Description.focus();
        },
        _uploadNewFile: function (file) {
            if (file) {
                var url = dString.substitute(this._uploadUrlFmt, [this.attachment.$key]);
                //Only Support by HTML5
                fileUtility.uploadFileHTML5(file,
                    url,
                    false,
                    this._newFileUploaded,
                    this._requestFail,
                    this,
                    true);
            }
        },
        _newFileUploaded: function () {
            this._tempFile = false;
            dojo.publish('/entity/attachment/update', this.attachment);
            this.hide();
        },
        _okClick: function () {
            if (this._dialog._standby) {
                this._dialog.showLoading();
            }
            this._saveAndHide();
        },
        _saveAndHide: function () {
            if (this._dialog._standby) {
                this._dialog.showLoading();
            }
            var self = this;
            if ((!fileUtility.supportsHTML5File && !Sage.gears) && (this._tempFile)) {
                this._store._okToCache = false;
                this._postForm.action = this._buildPostUrl();
                this._postForm.submit();
                //hack alert!... IE8 does not fire the iframe onload event, so hacking...
                //which is especially stupid because IE is the reason we have to do this kind
                // of post in the first place.  ugh!
                window.setTimeout(function () {
                    if (self._showing) {
                        dojo.publish('/entity/attachment/update', '');
                        self.hide();
                    }
                }, 5000);
                return;
            }

            //pop this into another thread so change events of the currently focused control have a chance to fire
            window.setTimeout(function () {
                self._saveAttachment();
            }, 10);
        },
        _saveAttachment: function () {
            // save for if the description was changed
            // (must happen before uploading the file, otherwise errors happen in IE)
            this._store.save({
                scope: this,
                success: function (attachmentUpdated) {
                    // if a new attachment is included, let the new attachment publish the
                    // update event, otherwise the user will see the attachments grid refresh twice
                    if(!this._tempFile) {
                    dojo.publish('/entity/attachment/update', attachmentUpdated);
                    this._dialog.hide();
                    }
                },
                failure: this._requestFail
            });
            // Uploads the new attachment if it exists
            if (this._tempFile) {
                this._uploadNewFile(this._tempFile);
            }
        },
        _cancelClick: function () {
            this.hide();
        },
        _requestFail: function (req) {
            console.warn('attachment request failed: ' + req);
            sageDialogs.showError(this.requestFailedMsg);
            this.hide();
        }
    });
    return attachForm;
});

},
'Sage/Utility/File/FallbackFilePicker':function(){
/*globals Sage, dojo, define */
define([
    'dijit/_Widget',
    'Sage/_Templated',
    'dijit/Dialog',
    'require',
    'dojo/string',
    'Sage/UI/Dialogs',
    'Sage/Utility',
    'Sage/Utility/ErrorHandler',
    'Sage/Utility/File',
    'Sage/Utility/File/Attachment',
    'dojo/_base/lang',
    'Sage/UI/_DialogLoadingMixin',
    'dojo/i18n',
    'dojo/i18n!./nls/FallbackFilePicker',
    'dojo/text!./templates/FallbackFilePicker_Attachment.html',
    'dojo/text!./templates/FallbackFilePicker_LibraryDoc.html',
    'dojo/_base/array',
    'dojo/_base/declare',
    'dojo/has'
],
// ReSharper disable InconsistentNaming
function (
    _Widget,
    _Templated,
    Dialog,
    require,
    dString,
    Dialogs,
    sageUtility,
    ErrorHandler,
    File,
    attachmentUtility,
    dojoLang,
    _DialogLoadingMixin,
    i18n,
    nlsBundle,
    attachmentTemplate,
    libraryDocTemplate,
    array,
    declare,
    has
 ) {
    var filePicker = declare('Sage.Utility.File.FallbackFilePicker', [_Widget, _Templated], {
        addLibraryFileText: 'Add Library File',
        attachFileText: 'Attach File',
        descriptionText: 'Description',
        uploadFileText: 'Select File',
        okText: 'OK',
        cancelText: 'Cancel',
        _iframeId: 'attachmentPostIFrame',
        _hiddenFields: ['_attachDate', '_accountId', '_activityId', '_contactId', '_contractId', '_defectId', '_historyId', '_leadId', '_opportunityId', '_productId', '_returnId', '_salesOrderId', '_ticketId', '_userId'],
        _showing: false,
        fileType: File.fileType.ftAttachment,
        widgetsInTemplate: true,
        id: 'fallbackFilePicker',
        widgetTemplate: null,
        constructor: function (options) {
            this.inherited(arguments);
            if (options && typeof options === 'object') {
                dojo.mixin(this, options);
            }
        },
        destroy: function () {
            if (this._dialog) {
                this._dialog.destroyRecursive();
            }
            this.inherited(arguments);
        },
        postMixInProperties: function () {
            dojo.mixin(this, i18n.getLocalization('Sage.Utility.File', 'FallbackFilePicker'));
            this.inherited(arguments);
            if (this.fileType != File.fileType.ftLibraryDocs) {
                this.widgetTemplate = new Simplate(eval(attachmentTemplate));
            }
            else {
                this.widgetTemplate = new Simplate(eval(libraryDocTemplate));
            }
        },
        show: function () {
            if (this._postForm) {
                this._postForm.reset();
            }
            this._dialog.show();
            if (this.fileType != File.fileType.ftLibraryDocs) {
                attachmentUtility.getKnownRelationships(this._receiveRelationships, this, true);
            }
            if (has('ie') < 9) {
                // Dojo has a bug where it cannot connect to an IE8 IFrame's onload event, so attachEvent is used.
                this._iframe.attachEvent('onload', this._iframeLoad);
                window.FallbackFilePicker = this;
            }
            this._showing = true;
        },
        hide: function () {
            this._dialog.hide();
        },
        _onHide: function () {
            if (this._dialog._standby) {
                this._dialog.hideLoading();
            }
            if (this.fileType != File.fileType.ftLibraryDocs) {
                for (var i = 0; i < this._hiddenFields.length; i++) {
                    if (this._hiddenFields[i]) {
                        this[this._hiddenFields[i]].value = '';
                    }
                }
            }
            this.tb_Description.set('value', '');
            this.tb_realFileName.set('value', '');
            this._showing = false;
        },
        _receiveRelationships: function (rels) {
            if (this.fileType == File.fileType.ftLibraryDocs) {
                return;
            }
            for (var rel in rels) {
                //console.log('rel: ' + rel + ' value: ' + rels[rel]);
                if (this['_' + rel]) {
                    this['_' + rel].value = rels[rel];
                } else if (rel) {
                    this['_' + rel] = dojo.create('input', {
                        'type': 'hidden',
                        'name': rel,
                        'value': rels[rel]
                    }, this._postForm);
                    this._hiddenFields.push('_' + rel);
                }
            }
            this._userId.value = sageUtility.getClientContextByKey('userID') || '';
            this._attachDate.value = sageUtility.Convert.toIsoStringFromDate(new Date());
        },
        _buildPostUrl: function () {
            var urlparts = [];
            urlparts.push(/https/i.test(window.location.protocol) ? 'https' : 'http');
            urlparts.push('://');
            urlparts.push(window.location.hostname);
            if (window.location.port && window.location.port !== 80) {
                urlparts.push(':', window.location.port);
            }
            urlparts.push('/');
            urlparts.push(sageUtility.getVirtualDirectoryName());
            if (this.fileType != File.fileType.ftLibraryDocs) {
                urlparts.push('/slxdata.ashx/slx/system/-/attachments/file?iframe=true&format=xml');
            }
            else {
                if (!Sage.Library || !Sage.Library.Manager || !Sage.Library.FileHandler) {
                    Dialogs.showError(this.invalidContext);
                    return null;
                }
                var sDirId = Sage.Library.FileHandler.findDirectoryId();
                var sUrl = dString.substitute('/slxdata.ashx/slx/system/-/libraryDirectories(\'${0}\')/documents/file?iframe=true&format=xml', [sDirId]);
                urlparts.push(sUrl);
            }
            var url = urlparts.join('');
            return url;
        },
        _iframeLoad: function (e) {
            var self;
            if (has('ie') < 9) {
                // NOTE: "this" in IE8 is the window and not the dialog.
                self = window.FallbackFilePicker;
            } else {
                self = this;
            }
            var frame = self._iframe;
            if (frame.contentDocument.body &&
                frame.contentDocument.body.innerText) {
                // Was there an unhandled Exception in Application_Error on the server because the file was too large?
                if (frame.contentDocument.body.innerText == 'RuntimeErrorPostTooLarge' /* DNL */) {
                    self.hide();
                    Dialogs.showError(self.fileTooLargeError);
                    return;
                }
            }
            try {
                var fnProcessDiagnoses = function (diagnosis) {
                    // Attempt to parse the innerText as an xml SData diagnoses.
                    // This data would be from a 500 error passed through by Sage.Integration.Server.dll.
                    if (diagnosis && diagnosis.hasOwnProperty('message')) {
                        var message = diagnosis.message;
                        if (diagnosis.hasOwnProperty('applicationCode') && ErrorHandler.isSDataExceptionDiagnoses(diagnosis.applicationCode)) {
                            var fnParseApplicationCode = function () {
                                var obj = {};
                                var arrAppData = diagnosis.applicationCode.split("; ");
                                array.forEach(arrAppData, function (item) {
                                    if (item && dojo.isString(item) && item.indexOf("=") !== -1) {
                                        var arrItem = item.split("=");
                                        var name = arrItem[0].trim();
                                        var value = arrItem[1].trim();
                                        obj[name] = value;
                                    }
                                });
                                return obj;
                            };
                            var info = fnParseApplicationCode();
                            if (info && info.hasOwnProperty('slxErrorId')) {
                                message += '<br /><br />';
                                message += self.slxErrorIdInfo + info.slxErrorId;
                            }
                        }
                        Dialogs.showError(message);
                    }
                };
                // The FallbackFilePicker is only used for IE
                if (has('ie')) {
                    var obj = {};
                    // Perhaps we have xml from an SData diagnoses?
                    if (has('ie') < 9) {
                        var sXml = (frame.contentDocument.body) ? frame.contentDocument.body.innerText : null;
                        if (sXml && dojo.isString(sXml)) {
                            sXml = sXml.trim();
                            // NOTE: The xml will be the "formatted" xml that IE creates...not the xml that we want.
                            var arrXml = sXml.split('\n');
                            if (dojo.isArray(arrXml)) {
                                array.forEach(arrXml, function (line, idx) {
                                    var pos = line.indexOf('- ');
                                    if (pos === 0) {
                                        arrXml[idx] = line.replace('- ', '');
                                    } else {
                                        pos = line.indexOf('  ');
                                        if (pos === 0) {
                                            arrXml[idx] = line.replace('  ', '');
                                        }
                                    }
                                });
                                sXml = arrXml.join('');
                                obj = ErrorHandler.getSDataDiagnosis(sXml, true);
                                fnProcessDiagnoses(obj);
                            }
                        }
                    } else {
                        // IE9+
                        if (frame.contentDocument.documentElement && frame.contentDocument.documentElement.childNodes.length >= 2) {
                            if (frame.contentDocument.documentElement.childNodes[1].tagName === 'sdata:diagnosis') {
                                var diagnosisNode = frame.contentDocument.documentElement.childNodes[1];
                                for (var i = 0; i < diagnosisNode.childNodes.length; i++) {
                                    var node = diagnosisNode.childNodes[i];
                                    if (node.nodeName.indexOf('sdata:') === 0) {
                                        obj[node.nodeName.replace('sdata:', '')] = node.textContent;
                                    }
                                }
                                fnProcessDiagnoses(obj);
                            }
                        }
                    }
                }
            } catch (err) {
                if (typeof console !== 'undefined') {
                    console.warn(err);
                }
            }
            if (frame.contentDocument.URL && typeof frame.contentDocument.URL !== 'undefined') {
                if (self.fileType != File.fileType.ftLibraryDocs) {
                    if (frame.contentDocument.URL.indexOf('attachments') > 0) {
                        dojo.publish('/entity/attachment/create', '');
                        self.hide();
                    }
                } else {
                    if (frame.contentDocument.URL.indexOf('/documents/file') > 0) {
                        dojo.publish('/sage/library/manager/libraryDocuments/refresh', null);
                        self.hide();
                    }
                }
            }
        },
        _onNewFile/*onChange*/: function (fileArray) {
            if (fileArray.srcElement && fileArray.srcElement.value.length > 0) {
                if (fileArray.srcElement.value) {
                    var fileName = fileArray.srcElement.value.replace(/^.*[\\\/]/, '');
                    if (this.tb_Description.get('value') === '') {
                        var fileNamePieces = fileName.split('.'),
                            descriptionValue = '';
                        if (fileNamePieces.length <= 2) {
                            descriptionValue = fileNamePieces[0];
                        }
                        else {
                            for (var i = 0; i < fileNamePieces.length - 1; i++) {
                                if (i > 0) {
                                    descriptionValue += '.';
                                }
                                descriptionValue += fileNamePieces[i];
                            }
                        }
                        this.tb_Description.set('value', descriptionValue);
                    }
                    this.tb_realFileName.set('value', fileName);
                }
            }
        },
        _okClick: function () {
            if (this.tb_realFileName.get('value') === '') {
                Dialogs.showInfo(this.pleaseSelectFile);
                return;
            }
            if (this.fileType === File.fileType.ftLibraryDocs) {
                // The action may have to change when a library file is added; the widget will only call _buildPostUrl()
                // the first time the form is submitted since the call to this._postForm.reset() does [not] reset the form action.
                this._postForm.action = this._buildPostUrl();
            }
            this._postForm.submit();
            if (!this._dialog._standby) {
                dojoLang.mixin(this._dialog, new _DialogLoadingMixin());
            }
            this._dialog.showLoading();
        },
        _cancelClick: function () {
            this.hide();
        }
    });
    return filePicker;
});

},
'Sage/Utility/File/AddURLAttachment':function(){
/*globals dojo, define, Sage, Simplate  */
define([
    'dijit/_Widget',
    'Sage/_Templated',
    'dojo/string',
    'dijit/Dialog',
    'Sage/UI/_DialogLoadingMixin',
    'dojo/_base/lang',
    'Sage/Data/SingleEntrySDataStore',
    'Sage/Data/SDataServiceRegistry',
    'Sage/MainView/BindingsManager',
    'Sage/Utility/File',
    'Sage/Utility',
    'Sage/Utility/File/Attachment',
    'Sage/UI/Dialogs',
    'dojo/i18n',
    'dojo/i18n!./nls/AddURLAttachment',
    'dojo/_base/declare'
],
function (_Widget,
    _Templated,
    dString,
    Dialog,
    _DialogLoadingMixin,
    dojoLang,
    SingleEntrySDataStore,
    sDataServiceRegistry,
    BindingsManager,
    fileUtility,
    sageUtility,
    attachmentUtility,
    sageDialogs,
    i18n,
    nlsResource,
    declare) {
    var urlAttachForm = declare('Sage.Utility.File.AddURLAttachment', [_Widget, _Templated], {
        //i18n strings
        descriptionText: 'Description',
        urlText: 'URL',
        titleText: 'Add URL Attachment',
        okText: 'OK',
        cancelText: 'Cancel',
        requestFailedMsg: 'The requested operation could not be completed, please try again later.',
        urlBlankMsg:'The URL or description property cannot be blank.',
        //end i18n strings
        attachmentId: '',
        attachment: false,
        widgetsInTemplate: true,
        _bindingMgr: false,
        _store: false,
        id: '',
        widgetTemplate: new Simplate([
            '<div>',
                '<div dojoType="dijit.Dialog" id="addUrlAttachDialog" title="{%= $.titleText %}" dojoAttachPoint="_dialog">',
                    '<div  class="attachment-properties-form">',
                        '<div dojoType="dojox.layout.TableContainer" orientation="horiz" cols="1" labelWidth="160" >',
                            '<div dojoType="dijit.form.TextBox" label="{%= $.urlText %}" id="{%= $.id %}_tb_Url" dojoAttachPoint="tb_Url" ></div>',
                            '<div dojoType="dijit.form.TextBox" label="{%= $.descriptionText %}" name="description" id="{%= $.id %}_tb_Description" dojoAttachPoint="tb_Description" maxlength="128" ></div>',
                        '</div>', //tableContainer
                        '<div class="general-dialog-actions">', //buttons
                            '<div dojoType="dijit.form.Button" id="{%= $.id %}_btnOK" name="_btnOK" dojoAttachPoint="_btnOK" dojoAttachEvent="onClick:_okClick" >{%= $.okText %}</div>',
                            '<div dojoType="dijit.form.Button" id="{%= $.id %}_btnCancel" name="_btnCancel" dojoAttachPoint="_btnCancel" dojoAttachEvent="onClick:_cancelClick">{%= $.cancelText %}</div>',
                        '</div>', //buttons
                    '</div>', // container
                '</div>', //dialog
            '</div>'// root
        ]),
        postMixInProperties: function () {
            dojo.mixin(this, i18n.getLocalization("Sage.Utility.File", "AddURLAttachment"));
            this.inherited(arguments);
        },
        show: function () {
            this._dialog.show();
            if (!this._dialog._standby) {
                dojoLang.mixin(this._dialog, new _DialogLoadingMixin());
            }
            this._loadData();
        },
        hide: function () {
            this.attachmentId = '';
            this.attachment = false;
            if (this._dialog._standby) {
                this._dialog.hideLoading();
            }
            this._dialog.hide();
        },
        _loadData: function () {
            if (this._dialog._standby) {
                this._dialog.showLoading();
            }
            if (!this._store) {
                this._store = new SingleEntrySDataStore({
                    include: [],
                    resourceKind: 'attachments',
                    service: sDataServiceRegistry.getService('system')
                });
            }
            this._store.newItem({
                onComplete: this._receiveAttachment,
                onError: this._requestFail,
                scope: this
            });
        },
        _receiveAttachment: function (attachment) {
            if (this._dialog._standby) {
                this._dialog.hideLoading();
            }
            this.attachment = attachment;
            attachmentUtility.getKnownRelationships(this._receiveRelationships, this);
        },
        _ensureBindings: function () {
            if (!this._bindingMgr) {
                this._bindingMgr = new BindingsManager({
                    defaultBinding: { boundEntity: this.attachment },
                    items: [
                        {
                            boundWidget: this.tb_Description,
                            entityProperty: 'description'
                        }, {
                            boundWidget: this.tb_Url,
                            entityProperty: 'url',
                            onChange: dojo.hitch(this, this._urlChange)
                        }
                    ]
                });
            }
        },
        _bind: function () {
            if (!this._bindingMgr.boundEntity || (this.attachment.$key !== this._bindingMgr.boundEntity.$key)) {
                this._bindingMgr.setBoundEntity(this.attachment);
            } else {
                this._bindingMgr.bind();
            }
            //console.dir(this.attachment);
            if (this._dialog._standby) {
                this._dialog.hideLoading();
            }
        },
        _receiveRelationships: function (rels) {
            this.attachment = dojoLang.mixin(this.attachment, rels);
            this.attachment.user = { '$key': sageUtility.getClientContextByKey('userID') || '' };
            this.attachment.attachDate = sageUtility.Convert.toIsoStringFromDate(new Date());
            this._ensureBindings();
            this._bind();
        },
        _urlChange: function () {
            var desc = this.tb_Description.get('value');
            if (!desc) {
                var newUrl = this.tb_Url.get('value');
                if (newUrl) {
                    var r = new RegExp(/\.([\w]*)/);
                    var matches = r.exec(newUrl);
                    if (matches.length > 1) {
                        this.tb_Description.set('value', matches[1]);
                    }
                }
            }
        },
        _cancelClick: function () {
            this.hide();
        },
        _okClick: function () {
            if (this._dialog._standby) {
                this._dialog.showLoading();
            }
            if ((this.attachment.url === null) || (this.attachment.url.trim() === '')) {
                 sageDialogs.showError(this.urlBlankMsg);
                return;
            }
            if ((this.attachment.description === null) || (this.attachment.description.trim() === '')) {
                sageDialogs.showError(this.urlBlankMsg);
                return;
            }
            this._saveAndHide();
        },
        _saveAndHide: function () {
            if (this._dialog._standby) {
                this._dialog.showLoading();
            }
            //pop this into another thread so change events of the currently focused control have a chance to fire
            var self = this;
            window.setTimeout(function () {
                var attachment = self.attachment;


                self._store.saveNewEntity(attachment,
                    function (newattachment) {
                        dojo.publish('/entity/attachment/create', newattachment);
                        this.hide();
                    },
                    self._requestFail,
                    self
                );
            }, 10);
        },
        _requestFail: function (req) {
            console.warn('url attachment failed: ' + req);
            sageDialogs.showError(this.requestFailedMsg);
            this.hide();
        }
    });
    return urlAttachForm;
});

},
'Sage/Utility/File/GoogleDocPicker':function(){
/*globals dojo define google  */
define([
    'dijit/_Widget',
    'dijit/tree/TreeStoreModel',
    'dijit/Dialog',
    'dijit/Tree',
    'dojo/window',
    'dojo/data/ItemFileReadStore',
    'dojo/i18n!./nls/GoogleDocPicker',
    'dojo/_base/declare'
],
function (
    _Widget,
    TreeStoreModel,
    Dialog,
    Tree,
    dojoWindow,
    ItemFileReadStore,
    nlsResources,
    declare
) {

    var googleAuthModule = declare('Sage.Utility.File.GoogleAuthModule', null, {
        couldNotOpenWindowMsg: 'Could not open authentication window - please check your popup blocker settings.',

        scope: '',
        authUrl: '',
        constructor: function (opts) {
            this.scope = opts.authUrl;
            dojo.mixin(this, opts);
            dojo.mixin(this, nlsResources);
        },

        login: function () {
            // summary:
            //  Process login.
            //  When login completes (either because the user is already logged in, or because he successfully logs in)
            // the onLoggedIn function will be called.
            var r = this;
            this._loadGoogleLibrary(function () {
                google.load("gdata", "2.0", { "callback":
                    function () {
                        google.gdata.onLoad();
                        if (google.accounts.user.checkLogin(r.authUrl)) {
                            r.onLoggedIn();
                        } else {
                            window.googleAuthModule = r;
                            var win = window.open("GoogleAuth.aspx", "_blank");
                            setTimeout(function () {
                                var blocked = false;
                                if (typeof win == 'undefined')
                                // safari popup blocker
                                    blocked = true;
                                else if (win && win.closed)
                                // happens if user closes the window right away
                                    blocked = false;
                                else if (win && !win.outerHeight)
                                    blocked = true;
                                if (blocked) {
                                    alert(r.couldNotOpenWindowMsg);
                                }
                            }, 3000);
                        }
                    }
                });
            });
        },
        logout: function () {
            if (google.accounts.user.checkLogin(this.authUrl)) {
                google.accounts.user.logout();
            }
        },
        onLoggedIn: function () {

        },
        _loadGoogleLibrary: function (callback) {
            if (typeof google !== 'undefined') {
                callback();
            } else {
                var cbName = "googleCallback_" + String(Math.random()).replace(/^0\./, "");
                window[cbName] = callback;
                var script = document.createElement("script");
                script.src = "https://www.google.com/jsapi?callback=" + cbName;
                script.type = "text/javascript";
                document.getElementsByTagName("head")[0].appendChild(script);
            }
        }

    });

    var googleDocPicker = declare('Sage.Utility.File.GoogleDocPicker', _Widget, {
        id: '',
        googleDocumentsTitle: 'Google Documents',
        pick: function () {
            // summary:
            //	Show picker.  When selection is done, onDocumentSelected will be picked.
            var auth = new googleAuthModule({ authUrl: 'https://docs.google.com/feeds' });
            dojo.connect(auth, 'onLoggedIn', this, this._onLoggedInHandler);
            auth.login();
        },
        _onLoggedInHandler: function () {
            var svc = new google.gdata.client.GoogleService("writely", "mytest");
            svc.getFeed("https://docs.google.com/feeds/documents/private/full?showfolders=true",
                dojo.hitch(this, "_displayFeed"),
                function (e) {
                    //alert(localeStrings.errorRetrievingData + "\n" + e.toString());
                }, undefined, true);
        },
        _displayFeed: function (feed) {
            var root = this._parseFeed(feed);
            dojo.ready(dojo.hitch(this, function () {
                var store = new ItemFileReadStore({ data: { items: [{ children: root, title: 'Root', root: true}]} });
                var treeModel = new TreeStoreModel({ store: store, childrenAttrs: ["children"], labelAttr: "title", query: {} });
                var tree = new Tree({
                    model: treeModel, showRoot: false, openOnDblClick: true
                });
                dojo.connect(tree, "onDblClick", dojo.hitch(this, function (item, node, evt) {
                    this.onDocumentSelected(item.title, item.url);
                }));
                dojo.connect(tree, "onLoad", dojo.hitch(this, function () {
                    var dlg = new Dialog({ title: nlsResources.googleDocumentsTitle, content: tree });
                    dlg.startup();
                    dlg.containerNode.style.maxHeight = dojo.window.getBox().h / 3 + "px";
                    dlg.containerNode.style.minWidth = "200px"; // dojo.window.getBox().w / 6 + "px";
                    dlg.containerNode.style.overflow = "auto";
                    dlg.show();
                }));
            }));
        },

        _parseFeed: function (feed) {
            // summary:
            //	Parse the incoming gdata feed and return the array of root items
            var items = [];
            var entries = feed.feed.entry;
            if (entries) {
                for (var i = 0; i < entries.length; i++) {
                    var entry = entries[i];
                    var newItem = { id: entry.id.$t, title: entry.title.$t, feedentry: entry };
                    dojo.some(entry.category, function (x) {
                        if (x.scheme == "http://schemas.google.com/g/2005#kind") {
                            newItem.type = x.label;
                            return true;
                        }
                    });
                    items.push(newItem);
                }
            }
            items.sort(function (a, b) { return a.title > b.title ? 1 : (a.title < b.title ? -1 : 0); });

            // this prepares the tree for the feed
            var root = items.slice(0);
            var removed = 0;
            dojo.forEach(items, function (item, i) {
                var hasParent = false;
                dojo.forEach(item.feedentry.link, function (link) {
                    if (link.rel == "http://schemas.google.com/docs/2007#parent") {
                        dojo.some(items, function (parent) {
                            if (link.href == parent.id) {
                                hasParent = true;
                                if (!parent.children)
                                    parent.children = [];
                                parent.children.push(item);
                            }
                        });
                    }
                    if (link.rel == "alternate") {
                        // this seems to be the most reliable way to obtain the edit URL
                        item.url = link.href;
                    }
                });
                if (hasParent) {
                    root.splice(i - removed, 1);
                    removed++;
                }
            });
            return root;
        },
        onDocumentSelected: function (title, url) {
            // summary:
            //	Function called when the user has picked a document

        }
    });


    return googleDocPicker;

});

},
'Sage/UI/SLXPreviewGrid/Filter/DateRange':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
        "dijit/form/DateTextBox",
        "dijit/_Widget",
        "dijit/_Templated",
        'Sage/UI/SLXPreviewGrid/Filter/_previewGridFilterMixin',
        'dojo/_base/declare'
],
function (DateTextBox, _Widget, _Templated, _filterMixin, declare) {
    var DateRange = declare("Sage.UI.SLXPreviewGrid.Filter.DateRange", [_Widget, _Templated, _filterMixin], {
        // summary:
        //  Date range filter
        templateString: "<div>" +
        "<input data-dojo-type='dijit.form.DateTextBox' dojoAttachPoint='dteFrom'> - " +
        "<input data-dojo-type='dijit.form.DateTextBox' dojoAttachPoint='dteTo'>" +
        "</div>",
        widgetsInTemplate: true,

        /////////////////////////////////////
        // Public API
        getQuery: function () {
            var toIsoStringFromDate = function (value, isUpperBound) {
                // format to ISO
                // if isUpperBound is true it will add 1 day (used for upper bound in date range)
                if (!value) {
                    return '';
                }
                if (value.constructor !== Date) {
                    value = Date.parse(value);
                }
                if (isUpperBound) {
                    value.setUTCDate(value.getUTCDate() + 1);
                }
                var pad = function (n) { return n < 10 ? '0' + n : n; };
                // adapted from: https://developer.mozilla.org/en/JavaScript/Reference/global_objects/date
                return value.getUTCFullYear() + '-'
                        + pad(value.getUTCMonth() + 1) + '-'
                        + pad(value.getUTCDate()) + 'T'
                        + pad(value.getUTCHours()) + ':'
                        + pad(value.getUTCMinutes()) + ':'
                        + pad(value.getUTCSeconds()) + 'Z';
            };
            var dFrom = toIsoStringFromDate(this.dteFrom.get('value'));
            var dTo = toIsoStringFromDate(this.dteTo.get('value'), true);



            var qry = '';
            if (dFrom) {
                qry = this.field + " ge '" + dFrom + "'";
            }
            if (dTo) {
                if (qry) {
                    qry += " and ";
                }
                qry += this.field + " lt '" + dTo + "'";
            }

            if (this.params["getTimeless"]) {
                if (qry) {
                    var fDate = false;
                    qry = "((" + qry + " and not Timeless) or (";
                    var dFromTimeless = Sage.Utility.Activity.formatTimelessStartDate(this.dteFrom.get('value'));
                    var dToTimeless = Sage.Utility.Activity.formatTimelessEndDate(this.dteTo.get('value'));
                    if (dFromTimeless) {
                        qry += this.field + " gt '" + dFromTimeless + "'";
                        fDate = true;
                    }
                    if (dToTimeless) {
                        if (fDate) {
                            qry += " and ";
                        }
                        qry += this.field + " lt '" + dToTimeless + "'";
                    }
                    qry += " and Timeless))";

                }
            }
            return qry;
        },

        reset: function () {
            this.dteFrom.set('value', 0);
            this.dteTo.set('value', 0);
        },
        getState: function () {
            return {
                'dFrom': this.dteFrom.get('value'),
                'dTo': this.dteTo.get('value')
            };
        },
        applyState: function (state) {
            if (state) {
                if (state['dFrom']) {
                    this.dteFrom.set('value', state['dFrom']);
                }
                if (state['dTo']) {
                    this.dteTo.set('value', state['dTo']);
                }
            }
        }
    });

    return DateRange;
});


},
'Sage/UI/SLXPreviewGrid/Filter/_previewGridFilterMixin':function(){
/*globals define  */
define([
    'dojo/_base/declare'
],
function (declare) {
    return declare('Sage.UI.SLXPreviewGrid.Filter._previewGridFilterMixin', null,
    {
        /////////////////////////////////////
        // Public API
        getQuery: function () {
            var v = this.get('value');
            if (v) {
                return "upper(" + this.field + ") like '%" + v.replace("'", "''").toUpperCase() + "%'";
            }
            return "";
        },

        reset: function () {
            this.set('value', '');
        },

        getState: function () {
            //console.log('returning filter state ' + this.field + ':  {value :' + this.get('value') + ' }');
            return { 'value': this.get('value') };
        },

        applyState: function (state) {
            //console.log('applying filter state ' + this.field + ' ' + state);
            if (state) {
                this.set('value', state['value'] || '');
            }
        }
    });
});
},
'Sage/UI/SLXPreviewGrid/Filter/Text':function(){
/*globals define */
define([
        'dijit/form/TextBox',
        'Sage/UI/SLXPreviewGrid/Filter/_previewGridFilterMixin',
        'dojo/_base/declare'
],
function (textBox, filterMixin, declare) {
    var text = declare("Sage.UI.SLXPreviewGrid.Filter.Text", [textBox, filterMixin], {
        // summary:
        //  a simple free-form text filter.  by default a "contains" search is performed

        postMixInProperties: function () {
            // reset the type to "text" - this overrides any type that is inherited from the column config 
            // (typically the type of grid cell that would be used)
            this.type = 'text';
            this.style = "width: 200px";
            this.inherited(arguments);
        },
        reset: function () {
            this.set('displayedValue', '');
            this.set('value', '');
        }
    });
    return text;
});
},
'Sage/Utility/Workspace':function(){
define([
    'dojo/_base/declare',
    'dijit/registry'
],
    function (declare, registry) {
        var workspaceUtil = declare('Sage.Utility.Workspace', [], {
    });
        workspaceUtil.getDetailTabWorkspaceContainer = function() {
            var tabNode = registry.byId('tabContent');
            var localTc = (tabNode) ? tabNode : registry.byId("mainContentDetails");
            return localTc;
        };
        return workspaceUtil;
    });
},
'Sage/UI/GridView':function(){
require({
    cache: {
        'url:Sage/UI/templates/GridView.html': "[\r\n'<div data-dojo-type=\"dijit.layout.ContentPane\" class=\"HundredPercentHeight abstractGrid\" >',\r\n    '<div data-dojo-attach-point=\"headerNode\" class=\"list-panel-tbar\" role=\"toolbar\">',\r\n        '<span dojoattachpoint=\"labelSection\"></span>',\r\n        '<span dojoattachpoint=\"abstractGrid_toolBar\" class=\"right-tools\"></span>',\r\n    '</div>',\r\n    '<div dojoattachpoint=\"abstractGrid_filters\"></div>',\r\n    '<div dojoattachpoint=\"abstractGrid_grid\" class=\"gridcontainer\"></div>',\r\n'</div>'\r\n]"
    }
});
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dijit/_Widget',
    'dojo/_base/declare',
    'dojo/_base/lang',
    'dojo/_base/array',
    'dojo/dom-construct',
    'dojo/dom',
    'dojo/string',
    'dojo/on',
    'dojo/text!./templates/GridView.html',
    'Sage/UI/ImageButton',
    'dojo/i18n!./nls/GridView',
    'Sage/UI/Dialogs',
    'Sage/_Templated',
    'Sage/Utility',
    'Sage/UI/SDataLookup',
    'Sage/UI/ComboBox',
    'Sage/UI/Controls/Grid',
    'put-selector/put',
    'dojo/mouse',
    'dojo/dom-class',
    'dojo/query',
    'dojo/dom-style',
    'dojo/aspect',
    'Sage/UI/Controls/GridParts/Columns/CheckBox',
    'Sage/UI/SLXPreviewGrid/FilterPanel',
    'Sage/Store/SData',
    'dojo/store/Memory',
    'Sage/Store/WritableStore',
    'dojo/_base/connect',
    'dojo/_base/event',
    'dojo/dom-attr',
    'dijit/registry'
],
function (
_Widget, declare, lang, array, domConstruct, dom, dojoString, on, template, ImageButton, nlsResource, dialogs, _Templated, Utility, SDataLookup, ComboBox, Grid, put, mouse, domClass, query, domStyle, aspect, CheckBox, FilterPanel, SDataObjectStore, Memory, WritableStore, connect, event, domAttr, registry) {
    var widget = declare('Sage.UI.GridView', [_Widget, _Templated], {
        widgetsInTemplate: true,
        store: false,
        mode: '',
        grid: false,
        rowCount: 0,
        //toolbar controllers
        show_ToolBar: true,
        help_keyword: false,
        help_location: false,
        tools: [],              // list of the name of controls which appear to the right side of the toolbar
        gridLabel: '',          // grid name or label, appears to the left side of the toolbar
        query: '',          // the queryOptions for the grid
        showRecordCount: false, // controls the displaying of the grid's row count
        mixins: [],
        widgetTemplate: new Simplate(eval(template)),
        _filter: null,
        filterText: 'Filter',
        region: 'center',
        _applyFilters: false,
        _dataChangeConnections: [],
        constructor: function (options) {
            lang.mixin(this, nlsResource);
            this.mode = Utility.getModeId();
            if (options.storeOptions && options.storeOptions.isInsertMode) {
                this.mode = 'insert';
            }
            if (this.mode !== 'insert') {
                this.listenForPageSave();
            }
            this.populateUserOptions();
            connect.connect(this, 'onKeyDown', this.customKeyDown);
        },
        listenForPageSave: function () {
            var bindingMgr = Sage.Services.getService('ClientBindingManagerService');
            if (bindingMgr) {
                bindingMgr.addListener(bindingMgr.ON_SAVE, this.saveChanges, this);
            }
        },
        removePageSaveListener: function () {
            var bindingMgr = Sage.Services.getService('ClientBindingManagerService');
            if (bindingMgr) {
                bindingMgr.removeListener(bindingMgr.ON_SAVE, this.saveChanges);
            }
        },
        applyEditOnEnter: function (e) {
            if (e.charOrCode == 13 || e.keyCode == 13) {
                this.doApplyEdit();
                this.edit.apply();
                event.stop(e);
            }
        },
        customKeyDown: function (e) {
            this.applyEditOnEnter(e);
        },
        /**
        * Submits any change done on grid to its store.
        * @param {}
        */
        saveChanges: function (callback) {
            this.grid.save().then(lang.hitch(this, function (response) {
                console.log("saveChanges() successfully called.");
                this.markClean();
                this.refresh();
            })).then(function (response) {
                if (callback) {
                    callback(response);
                }
            });
        },
        /**
        * Cancels any datachanges done on grid by refreshing the grid.
        * @param {}
        */
        cancelChanges: function () {
            this.markClean();
            this.grid.revert();
        },
        /**
        * creates the grid structure. While the data is required, if the columns' array has been previously populated
        * then the columns argument is not needed. If the columns value is provided anyways, then it will overwrite the 
        * previously populated columns array.
        * @param {}
        */
        createGridView: function () {

            if (this.slxContext) {
                this.context = this.slxContext;
                this.tabId = this.slxContext.tabId;
            }
            // Public property to hide stop header from rendering
            if (this.hideHeaderView !== true) {
                this._createGridHeader();
            } else {
                domClass.add(this.headerNode, 'display-none');
            }
            if (this._filter) {
                var filterConditions = this._filter ? this._filter.getQuery() : null;
                this.query = filterConditions ? this.query + " " + filterConditions : '';
            }
            var options = {
                query: this.query,
                placeHolder: this.abstractGrid_grid
            };

            if (this.columns) {
                options.columns = this.columns;
            }

            this._setEditable();

            options.store = this.store = this.getStore();

            if (this.storeOptions) {
                options.storeOptions = this.storeOptions;
            }
            if (this.mode) {
                options.mode = this.mode;
            }
            if (this.data) {
                options.data = this.data;
            }
            if (this.rowsPerPage) {
                options.rowsPerPage = this.rowsPerPage;
            }
            if (this.selectionMode) {
                options.selectionMode = this.selectionMode;
            }
            if (this.columnHiding) {
                options.columnHiding = this.columnHiding;
            }
            if (this.columnReordering) {
                options.columnReordering = this.columnReordering;
            }
            if (this.columnResizing) {
                options.columnResizing = this.columnResizing;
            }
            if (this.rowSelection) {
                options.rowSelection = this.rowSelection;
            }
            if (this.dijitRegistry) {
                options.dijitRegistry = this.dijitRegistry; //TODO:check if this is required
            }
            if (this.pagination) {
                options.pagination = this.pagination;
            }
            if (this.sort) {
                options.sort = this.sort;
            }
            if (this.indirectSelection) {
                options.indirectSelection = this.indirectSelection;
            }
            if (this.previewField) {
                options.previewField = this.previewField;
            }
            if (this.fullNoteField) {
                options.fullNoteField = this.fullNoteField;
            }
            if (this.keyboardNavigation) {
                options.keyboardNavigation = this.keyboardNavigation;
            }
            if (this.minRowsPerPage) {
                options.minRowsPerPage = this.minRowsPerPage;
            }
            if (this.maxRowsPerPage) {
                options.maxRowsPerPage = this.maxRowsPerPage;
            }
            if (this.rowsPerPage) {
                options.rowsPerPage = this.rowsPerPage;
            }
            if (this.keepScrollPosition) {
                options.keepScrollPosition = this.keepScrollPosition;
            }
            if (this.farOffRemoval) {
                options.farOffRemoval = this.farOffRemoval;
            }
            if (this.pagingDelay) {
                options.pagingDelay = this.pagingDelay;
            }

            var contextservice = Sage.Services.getService('ClientEntityContext');
            var ctx = contextservice.getContext();
            var contextId = (ctx && ctx.DisplayName) ? ctx.DisplayName + '_' : '';
            options.id = contextId + (this.id ? this.id : '') + '_gridView';

            var grid = this.grid = new Grid(options);

            if (this.onDataChange) {
                this.grid.onDataChange = lang.hitch(this, function (evt) {
                    evt.cell.row.data[evt.cell.column.field] = evt.value;

                    var orig = lang.clone(evt.cell.row.data);
                    var entity = evt.cell.row.data,
                        attribute = evt.cell.column.field,
                        oldValue = evt.oldValue,
                        newValue = evt.value;

                    this.onDataChange(entity, attribute, oldValue, newValue, evt, this);

                    for (var property in orig) {
                        if (entity.hasOwnProperty(property)) {
                            if (this.mode === 'insert') {
                                evt.grid.updateDirty(evt.rowId, property, orig[property]);
                                this.store.setValue(entity, property, entity[property]);
                            } else {
                                // Restriction: only first level of properties in data object saved 
                                if (typeof entity[property] !== 'object' && orig[property] != entity[property]) {
                                    evt.grid.updateDirty(evt.rowId, property, entity[property]);
                                }
                            }
                        }
                    }

                    this.update(evt);
                });
            }

            aspect.after(this.grid, '_onDataChange', lang.hitch(this, function (obj, args) {
                var evt = args[0];
                if (this.mode !== 'insert' && this.shouldPublishMarkDirty !== false) {
                    // Varying column types have different levels of depth. We must check down the chain to
                    // get to our returnObject property.
                    if (evt.cell &&
                        evt.cell.widget &&
                        evt.cell.widget.returnObject === true) {
                        if (evt.oldValue.$key !== evt.value.$key) {
                            this.markDirty();
                        }
                    }
                    else {
                        if (evt.oldValue !== evt.value) {
                            this.markDirty();
                        }
                    }
                }
            }));
            aspect.after(this.grid, '_onLoadComplete', lang.hitch(this, function (obj, args) {
                this.labelSection.innerHTML = dojoString.substitute(this.totalRecordCountLabel, [this.grid.totalRecords]);
                this.rowCount = this.grid.totalRecords; // TODO: move every instance to this.totalRecords
            }));

            this.dirtyDataMsgID = this.tabId + '_dirtydatamsg';

            // HACK for replace: grids in entity manager page are instantiated each time on tab switch 
            domConstruct.empty(this.placeHolder);
            domConstruct.place(this.domNode, this.placeHolder);

            if (this.classNames) {
                domClass.add(this.abstractGrid_grid, this.classNames);
            }

            // TODO : Remove after 8.3. this should be handled by individual implementation
            grid.resize();

            connect.publish('/ui/gridView/created', this);
        },
        /*
        * On a datachange event, this method will update the row with new value of the record entity
        * evt = datachange event
        */
        update: function (evt) {
            var row = this.grid.reRenderRow(evt.cell.row.data);
            domConstruct.place(row.childNodes[0], evt.cell.row.element.childNodes[0], 'replace');
            var args = this.grid._grid._editorsPendingStartup;
            for (var i = args.length; i--;) {
                this.startupEditor.apply(null, args[i]);
            }
        },
        /**
         * Method copied as is from editor.js from dgrid to start up editor controls.
         * This would otherwise fire when data is bound to the grid. Recreating and replacing a row needed this to be fired.
         */
        startupEditor: function (cmp, column, cellElement, value) {
            // Handles editor widget startup logic and updates the editor's value.
            var grid = column.grid;
            if (cmp.domNode) {
                // For widgets, ensure startup is called before setting value,
                // to maximize compatibility with flaky widgets like dijit/form/Select.
                if (!cmp._started) {
                    cmp.startup();
                }

                // Set value, but ensure it isn't processed as a user-generated change.
                // (Clear flag on a timeout to wait for delayed onChange to fire first)
                cmp._dgridIgnoreChange = true;
                cmp.set("value", value);
                setTimeout(function () {
                    cmp._dgridIgnoreChange = false;
                }, 0);
            }

            // track previous value for short-circuiting or in case we need to revert
            cmp._dgridLastValue = value;
            // if this is an editor with editOn, also update activeValue
            // (activeOptions will have been updated previously)
            if (grid._activeCell) {
                grid._activeValue = value;
                // emit an event immediately prior to placing a shared editor
                on.emit(cellElement, "dgrid-editor-show", {
                    grid: grid,
                    cell: grid.cell(cellElement),
                    column: column,
                    editor: cmp,
                    bubbles: true,
                    cancelable: false
                });
            }
        },
        _getToolbarPlaceHolder: function () {
            var msgBox = domConstruct.create('span', {
                'class': 'grid-unsaveddata-msg',
                'id': this.dirtyDataMsgID,
                'style': 'display:none;',
                'content': (this.editable) ? this.unsavedDataText : ''
            });
            var toolBarPlaceHolder = this.abstractGrid_toolBar;
            var containerId;
            if (this.context && this.context.workspace) {
                //Place the tools and 'unsaved data' message into the correct workspace.
                switch (this.context.workspace) {
                    case 'Sage.Platform.WebPortal.Workspaces.Tab.TabWorkspace':
                        //Don't add the dirty data message if we are in insert mode.  All data is dirty in insert mode.
                        if (this.mode !== 'insert') {
                            var elem = query('#' + 'element_' + this.tabId + ' td.tws-tab-view-title');
                            if (elem.length > 0) {
                                domConstruct.place(msgBox, elem[0]);
                            }
                        }
                        containerId = ['element_', this.tabId].join('');
                        toolBarPlaceHolder = query(['#', containerId, ' td.tws-tab-view-tools-right'].join(''));
                        break;
                    case 'Sage.Platform.WebPortal.Workspaces.MainContentWorkspace':
                        //Don't add the dirty data message if we are in insert mode.  All data is dirty in insert mode.
                        if (this.mode !== 'insert') {
                            domConstruct.place(msgBox, query('#' + this.tabId + ' span.mainContentHeaderTitle')[0]);
                        }
                        //This containerId assignment appears redundant but we need the specific Id for the later query when placing the tool.
                        containerId = this.tabId;
                        toolBarPlaceHolder = query('#' + containerId + ' td.mainContentHeaderToolsRight');
                        break;
                    case 'Sage.Platform.WebPortal.Workspaces.DialogWorkspace':
                        //This containerId assignment appears redundant but we need the specific Id for the later query when placing the tool.
                        toolBarPlaceHolder = query('td.dialog-tools-right');
                        break;
                    default:
                }
            }
            if (toolBarPlaceHolder.length > 0) {
                return toolBarPlaceHolder[0];
            }
            else {
                return toolBarPlaceHolder;
            }
        },
        _createOwnToolbar: function (toolbarPlaceHolder) {
            var roleService = Sage.Services.getService("RoleSecurityService");
            var container = this.abstractGrid_toolBar;
            for (var i = 0; i < this.tools.length; i++) {
                var tool = this.tools[i];
                if (tool.appliedSecurity && tool.appliedSecurity !== '') {
                    if ((roleService) && (!roleService.hasAccess(tool.appliedSecurity))) {
                        continue;
                    }
                }
                var btn = false;
                if (typeof tool === 'string') {
                    btn = this._createDefaultBtns(tool, 1);
                } else {
                    if (tool.type){
                        var conf = null;         
                        if (tool.type === 'Sage.UI.SDataLookup') {
                            conf = tool.controlConfig || tool;
                            btn = new SDataLookup(conf);
                            this.lookupControl = btn;
                        }
                        if (tool.type === 'Sage.UI.ComboBox') {
                            conf = tool.controlConfig || tool;
                            btn = new ComboBox(conf);
                            this.lookupControl = btn;
                        }
                    } else {
                        btn = new ImageButton({
                            icon: tool.icon || '',
                            imageClass: tool.imageClass || '',
                            id: tool.id,
                            onClick: lang.hitch(tool.scope || this, tool.handler),
                            tooltip: tool.alternateText || tool.tooltip
                        });
                    }
                }
                if (btn) {
                    this._addToolBarItem(btn, i + 1, toolbarPlaceHolder);
                }
            }
        },
        /**
        * show tooltip if cell overflows
        * @param {}
        */
        _createGridHeader: function () {
            if (this.previewField) {
                this.tools.unshift({
                    id: 'TogglePrvRows_' + ((this.tabId) ? this.tabId : ''),
                    imageClass: 'fa fa-bars',
                    tooltip: nlsResource.toggleRows,
                    handler: this.togglePreviewRows,
                    scope: this
                });
            }
            if (this.mode !== 'insert') {
                // Build filters
                this._filter = this._buildFilter();
            }

            // Get toolbar location 
            var toolbarPlaceHolder = this._getToolbarPlaceHolder();
            // Create and startup the toolbar...
            if ((this.tabId) && (this.tabId !== '')) {
                this._addToolsToWorkspaceToolbar(toolbarPlaceHolder);
                this.currentEntityId = Utility.getCurrentEntityId();
            } else {
                this._createOwnToolbar(toolbarPlaceHolder);
            }
        },
        /**
        * Create toolbar from tools variable
        * @param {}
        */
        _addToolsToWorkspaceToolbar: function (toolbarPlaceHolder) {
            if (this.readOnly) {
                return;
            }
            var roleService = Sage.Services.getService("RoleSecurityService");
            //Some buttons may be hidden in different modes and/or security levels.  
            //We'll keep a position variable to make sure the group stays together.            
            var positionString, refNode;
            for (var position = 0; position < this.tools.length; position++) {
                positionString = '';
                var tool = this.tools[position];
                if (typeof tool.mergeControlId !== 'undefined' && tool.mergeControlId.length !== 0) {
                    refNode = dojo.query('[id$=' + tool.mergeControlId + ']', dojo.byId('element_' + this.tabId))[0];
                    positionString = tool.mergePosition.toLowerCase();
                }
                if (!refNode) {
                    // No control to place next to.  Use the container and position 0.
                    refNode = toolbarPlaceHolder;
                    positionString = '';
                }
                if (this.mode === 'insert' && !tool.displayInInsert) {
                    continue;
                }
                if (tool.appliedSecurity && tool.appliedSecurity !== '') {
                    if ((roleService) && (!roleService.hasAccess(tool.appliedSecurity))) {
                        continue;
                    }
                }
                var btn = false;
                if (typeof tool === 'string') {
                    btn = this._createDefaultBtns(tool);
                } else {
                    if ((tool.type) && (tool.type === 'Sage.UI.SDataLookup')) {
                        var conf = tool.controlConfig || tool;
                        btn = new SDataLookup(conf);
                        this.lookupControl = btn;
                    } else {
                        btn = new ImageButton({
                            icon: tool.icon || '',
                            imageClass: tool.imageClass || '',
                            id: tool.id,
                            onClick: lang.hitch(tool.scope || this, tool.handler),
                            tooltip: tool.alternateText || tool.tooltip
                        });
                    }
                }
                if (btn) {
                    this._addToolBarItem(btn, (positionString.length > 0) ? positionString : position + 1, refNode);
                }
            }
        },
        /**
        * Add toolbar items to placeholder
        * @param {item, place, toolBarPlaceHolder} 
        */
        _addToolBarItem: function (item, place, refNode) {
            if (item.domNode) {
                if (place) {
                    domConstruct.place(item.domNode, refNode, place);
                }
                else {
                    domConstruct.place(item.domNode, refNode);
                }
            }
            else {
                if (place) {
                    domConstruct.place(item, refNode, place);
                }
                else {
                    domConstruct.place(item, refNode);
                }
            }
        },
        /**
        * Returns selected row data
        * @param {} 
        */
        getSelectedRowData: function () {
            return this.grid.getSelectedRowData();
        },
        /**
        * Returns selected row id
        * @param {} 
        */
        getSelectedRowId: function () {
            return this.grid.getSelectedRowId();
        },
        /**
        * Displays the help page when the help icon is selected
        * @param {} 
        */
        showHelp: function (hk, hl) {
            Utility.openHelp(hk, hl);
        },
        /**
        * Refreshes the grid contained in view
        * @param {} 
        */
        refresh: function () {
            this.markClean();
            this.grid.refresh();
        },
        /**
        * Handles querying for the User Options
        * @param {} 
        */
        populateUserOptions: function () {
            if (this.indirectSelection) return;

            var optionsSvc = Sage.Services.getService('UserOptions');
            if (optionsSvc && optionsSvc.get) {
                optionsSvc.get('GroupCheckboxEnabled', 'GroupGridView', lang.hitch(this, function (data) {
                    var groupCheckboxEnabled = data && data.value;
                    if (groupCheckboxEnabled === 'True' || groupCheckboxEnabled === 'T') {
                        this.indirectSelection = true;
                    }
                    else {
                        this.indirectSelection = false;
                    }
                }), null, this, false);
            }
        },
        /**
        * Build and return filter widget.
        * If the grid has no filter configuration then it will return null.
        * @param {} 
        */
        _buildFilter: function () {
            var filterConfig = [];
            for (var i = 0; i < this.columns.length; i++) {
                var cc = this.columns[i];
                if (cc.filterConfig) {
                    // filterconfig is supplemented with the column config itself, this way we keep the same label etc.
                    var fc = lang.mixin(lang.clone(cc), cc.filterConfig);
                    if (!fc.label) {
                        fc.label = cc.name;
                    }
                    filterConfig.push(fc);
                }
            }
            if (filterConfig.length === 0) {
                this._filtersApplied = false;
                return null;
            }
            var filter = new FilterPanel({
                id: this.id + '_filterpanel',
                region: 'top',
                filterConfig: filterConfig,
                style: 'display: none'
            });
            this.tools.unshift({
                id: this.id + '_Filter',
                imageClass: 'icon_Filter_16x16',
                tooltip: this.filterText,
                handler: lang.hitch(this, function () {
                    this._filter.toggle();
                })
            });

            domConstruct.place(filter.domNode, this.abstractGrid_filters);

            filter.onFilterApply = lang.hitch(this, function (conditions) {
                this.grid.setFilter(conditions);
            });

            return filter;
        },
        /**
        * Creates default toolbar buttons
        * @param {
        *           From: added as a step to consolidate code with a similar logic and functionality, but whose functionality was dependently named functions.
        *                 1 means from _createOwnToolbar
        *                 0 means from  _addToolsToWorkspaceToolbar
        *       } 
        * 
        */
        _createDefaultBtns: function (tool, from) {
            var btn;
            switch (tool) {
                case 'add':
                    btn = new ImageButton({
                        icon: '~/ImageResource.axd?scope=global&type=Global_Images&key=plus_16x16',
                        tooltip: nlsResource.addText,
                        id: this.id + '_addBtn',
                        onClick: lang.hitch(this, function () {
                            if (this.addItem)
                                this.addItem();
                            else if (this.addNew)
                                this.addNew();
                        })
                    });
                    break;
                case 'delete':
                    btn = new ImageButton({
                        icon: '~/ImageResource.axd?scope=global&type=Global_Images&key=Delete_16x16',
                        tooltip: nlsResource.deleteText,
                        id: this.id + '_delBtn',
                        onClick: lang.hitch(this, function () {
                            if (this.removeItem)
                                this.removeItem();
                            else if (this.deleteSelected)
                                this.deleteSelected();
                        })
                    });
                    break;
                case 'save':
                    btn = new ImageButton({
                        imageClass: 'icon_Save_16x16',
                        tooltip: nlsResource.saveText,
                        id: this.id + '_saveBtn',
                        onClick: lang.hitch(this, function () {
                            this.saveChanges();
                        })
                    });
                    break;
                case 'cancel':
                    btn = new ImageButton({
                        imageClass: 'icon_Reset_16x16',
                        tooltip: nlsResource.cancelText,
                        id: this.id + '_cancelBtn',
                        onClick: lang.hitch(this, function () {
                            this.cancelChanges();
                        })
                    });
                    break;
                case 'edit':
                    btn = new ImageButton({
                        icon: '~/ImageResource.axd?scope=global&type=Global_Images&key=Edit_Item_16x16',
                        tooltip: nlsResource.editText,
                        id: this.id + '_editBtn',
                        onClick: lang.partial(this.editItem, this)
                    });
                    break;
                case 'help':
                    btn = new ImageButton({
                        icon: '~/ImageResource.axd?scope=global&type=Global_Images&key=Help_16x16',
                        tooltip: nlsResource.helpText,
                        id: this.id + '_helpBtn',
                        onClick: this.showHelp
                    });
                    break;
            }
            return btn;
        },
        /**
        * Marks grid changes clean
        * @param {} 
        */
        markClean: function () {
            this.isDirty = false;
            if (this.dirtyDataMsgID) {
                var node = dom.byId(this.dirtyDataMsgID);
                if (node) {
                    domStyle.set(dom.byId(this.dirtyDataMsgID), 'display', 'none');
                }
                var bindingMgr = Sage.Services.getService('ClientBindingManagerService');
                if (bindingMgr) {
                    bindingMgr.clearDirtyAjaxItem(this.id);
                }
            }
        },
        /**
        * In case any data modification done on grid - fire up dirty event to notify browser.
        * @param {} 
        */
        markDirty: function () {
            this.isDirty = true;
            var node = dom.byId(this.dirtyDataMsgID);
            if (node) {
                domStyle.set(node, 'display', 'inline');
            }
            var bindingMgr = Sage.Services.getService('ClientBindingManagerService');
            if (bindingMgr) {
                bindingMgr.addDirtyAjaxItem(this.id);
            }
        },
        /**
        * Returns store based on store options.
        * @param {} 
        */
        getStore: function () {
            if (this.store) {
                return this.store;
            }

            if (!this.storeOptions) {
                throw ("Grid configuration is missing store");
            }

            this.storeOptions['isInsertMode'] = (this.mode === 'insert');
            this._storePrepareQuery();

            var store = (this.mode !== 'insert')
                ? new SDataObjectStore(this.storeOptions)
                : new WritableStore(this.storeOptions);

            if (store.onDataChange) {
                this._dataChangeConnections.push(connect.connect(store, 'setValue', store.onDataChange));
                this._dataChangeConnections.push(connect.connect(store, 'saveNewEntity', store.onDataChange));
                this._dataChangeConnections.push(connect.connect(store, 'deleteItem', store.onDataChange));
                this._dataChangeConnections.push(connect.connect(store, 'createItem', store.onDataChange));
            }
            return store;
        },
        _addToListUnique: function (item, list) {
            for (var i = 0; i < list.length; i++) {
                if (item === list[i]) {
                    return;
                }
            }
            list.push(item);
        },
        /**
        * Dynamic construction of query in case select parameters are not defined. Query is then 
        * constructed based on the columns passed on to the grid.
        * @param {} 
        */
        _storePrepareQuery: function () {
            var cols = this.columns,
                sel, i, p, inc, parts, combined, field;
            if (!this.store) {
                sel = this.storeOptions.select || [];
                inc = this.storeOptions.include || [];
            } else {
                //this means a datastore was given to us - most likely a proxydatastore.
                sel = this.store.select = this.store.select || [];
                inc = this.store.include = this.store.include || [];
            }

            this.storeOptions.select.push('Id');
            if (this.previewField) {
                this.storeOptions.select.push(this.previewField);
            }
            for (i = 0; i < sel.length; i++) {
                sel[i] = sel[i].replace(/\./g, '/');
            }
            for (i = 0; i < cols.length; i++) {
                // add columns to select 
                if (cols[i].field) {
                    field = cols[i].field;
                    this._addToListUnique(field.replace(/\./g, '/'), sel);

                    // include in select query for lookup editors
                    if (cols[i].editorArgs && cols[i].editorArgs.lookupOptions && cols[i].editorArgs.lookupOptions.field) {
                        var prop = field === cols[i].editorArgs.lookupOptions.field ? cols[i].editorArgs.lookupOptions.field : dojoString.substitute("${0}/${1}", [field, cols[i].editorArgs.lookupOptions.field]);
                        this._addToListUnique(prop.replace(/\./g, '/'), sel);
                    }
                }

                // add columns to "include" in sdata call
                if (cols[i].field.indexOf('.') > 0) {
                    parts = cols[i].field.split('.');
                    combined = '';
                    for (p = 0; p < parts.length - 1; p++) {
                        combined += parts[p];
                        this._addToListUnique(combined, inc);
                        combined += '/';
                    }
                }
            }
        },
        addAssociatedItems: function (items, parentName, childName, lookup) {
            // summary:
            //  Helper function for lookup tools.  This can be called by the handler to add items selected in a lookup
            var grid = this;
            if (Utility.getModeId() !== 'insert' && this.isDirty) {
                dialogs.raiseQueryDialog(
                    'Infor CRM',
                    this.dirtyDataMessage,
                    function (result) {
                        if (result) {
                            grid.addSelectedItems(items, parentName, childName, lookup);
                        }
                    },
                    this.okText,
                    this.cancelText
                );
            }
            else {
                grid.addSelectedItems(items, parentName, childName, lookup);
            }
        },
        addSelectedItems: function (items, parentName, childName, lookup) {
            var entities = [];
            var grid = this;
            for (var i = 0; i < items.length; i++) {
                var hasRecord = false;
                // duplicate detection
                for (var k in grid.store.data) {
                    var rec = grid.store.data[k];
                    if (rec[childName] && rec[childName].$key == items[i].$key)
                        hasRecord = true;
                }
                if (hasRecord)
                    continue;

                //Insert mode check
                var newRecord = {
                };
                if (Utility.getModeId() !== 'insert') {
                    newRecord[parentName] = {
                        $key: Utility.getCurrentEntityId()
                    };
                }
                newRecord[childName] = {
                };
                Utility.extend(newRecord[childName], items[i]);
                delete newRecord.$key;
                delete newRecord.$name;
                delete newRecord.$url;
                entities.push(newRecord);
            }
            if (entities.length > 0)
                grid.createItems(entities, function () {
                    if (Utility.getModeId() !== 'insert') {
                        __doPostBack("MainContent", "");
                    }
                });
            if (lookup)
                lookup.lookupDialog.hide();
        },
        createItems: function (items, callback) {
            if (lang.isArray(items)) {
                var store = this.grid.store;
                var iCreateCount = items.length;
                if (typeof console !== 'undefined') {
                    console.log('createItems() items.length = %o', iCreateCount);
                }
                //TODO: Replace callback with webworker.
                var fnResponse = function (arg1) {
                    // "this.", within the scope of fnResponse(), refers to the scope object below.
                    this.currentCount = this.currentCount + 1;
                    if (typeof console !== 'undefined') {
                        if (arg1 && typeof arg1 !== 'undefined' && arg1.getResponseHeader) {
                            console.log('createItems() response: (status = %o; statusText = %o): currentCount = %o; totalCount = %o',
                            arg1.status || 0, arg1.statusText || "", this.currentCount, this.totalCount);
                            console.log('createItems() response ETag: %o', arg1.getResponseHeader('ETag'));
                        } else {
                            if (arg1 && typeof arg1 !== 'undefined' && typeof arg1.$httpStatus === 'number') {
                                console.log('createItems() response ($httpStatus: %o; $key: %o; $descriptor: %o $etag: %o): currentCount = %o; totalCount = %o',
                                arg1.$httpStatus, arg1.$key || "", arg1.$descriptor, arg1.$etag, this.currentCount, this.totalCount);
                            } else {
                                console.log('createItems() response: (unknown status): currentCount = %o; totalCount = %o',
                                this.currentCount, this.totalCount);
                            }
                        }
                    }
                    if (this.currentCount === this.totalCount) {
                        this.grid.refresh();
                        if (typeof this.onComplete === 'function') {
                            this.onComplete.call(this.grid);
                        }
                    }
                };
                var scope = {
                    grid: this, totalCount: iCreateCount, currentCount: 0, onResponse: fnResponse, onComplete: callback || null
                };
                for (var i = 0; i < items.length; i++) {
                    store.createItem(items[i], scope);
                }
            }
            else {
                dialogs.showError(this.createItemsInvalidArrayText);
            }
        },
        destroy: function () {
            array.forEach(this._dataChangeConnections, function (connection) {
                connect.disconnect(connection);
            });
            if (this.lookupControl) {
                this.lookupControl.destroy(false);
            }

            if (this.grid) {
                this.grid.destroy(false);
            }

            if (this.store && this.store.destroy) {
                this.store.destroy(false);
            }

            if (this._registeredWidgets) {
                array.forEach(this._registeredWidgets, function (item) {
                    item.destroy(false);
                });

                this._registeredWidgets = null;
            }
            this.removePageSaveListener();
            this.inherited(arguments);
        },
        deleteSelected: function (callback) {
            var selectedItems = this.grid.getSelectedRowData();
            if (selectedItems.length === 0) {
                dialogs.showInfo(nlsResource.noSelectionsText);
                return;
            }

            if (this.mode !== 'insert') {
                if (!this._checkPageExitWarningMessage()) {
                    return;
                }
            }

            var self = this;
            var opts = {
                title: 'Infor CRM',
                query: dojoString.substitute(this.confirmDeleteFmtTxt, [selectedItems.length]),
                callbackFn: function (result) {
                    self.deleteCallback(result, callback, selectedItems);
                },
                yesText: this.yesText, //OK
                noText: this.noText //Cancel
            };
            dialogs.raiseQueryDialogExt(opts);
        },
        deleteCallback: function (result, callback, selectedItems) {
            if (result) {
                var grid = this.grid;
                var store = grid.store;
                grid.clearSelection();

                var fnResponse = function (arg1, arg2) {
                    if (arg1 && arg1.length) {
                        dialogs.showError(arg1);
                    }
                    grid.refresh();
                    if (typeof this.onComplete === 'function') {
                        this.onComplete.call(grid);
                    }
                };

                var scope = {
                    grid: grid, onResponse: fnResponse, onResponseExceptionMsg: '', onComplete: callback || null
                };

                if (store.deleteItem) {
                    store.deleteItem(selectedItems, scope);
                } else if (store.data) {
                    for (var i = 0; i < selectedItems.length; i++) {
                        store.remove(selectedItems[i].id);
                    }
                    grid.refresh();
                }
            }
        },
        _setEditable: function () {
            var editable = true, i;
            //Check Action security of the grid.
            if (this.appliedSecurity) {
                var svc = Sage.Services.getService("RoleSecurityService");
                if (svc) {
                    editable = svc.hasAccess(this.appliedSecurity);
                }
            }
            if (this.readOnly) {
                editable = false;
            }

            //If user does not have edit access to the grid, we need to override each column and set them to false.
            if (!editable) {
                for (i = 0; i < this.columns.length; i++) {
                    if (this.columns[i].editable) {
                        this.columns[i].editable = false;
                    }
                }
                this.editable = false;
            } else {
                //if any of the columns are editable, assume the grid is editable...
                for (i = 0; i < this.columns.length; i++) {
                    if (this.columns[i].editable) {
                        this.editable = true;
                        break;
                    }
                }
            }
        },
        _checkPageExitWarningMessage: function () {
            var response = true;
            if (this.isDirty) {
                var service = Sage.Services.getService("ClientBindingManagerService");
                response = confirm(service._PageExitWarningMessage);
            }
            return response;
        },

        togglePreviewRows: function () {
            this.grid.togglePreviewRows();
        },
        resize: function () {
            this.grid.resize();
        },
        /***********************************/
        // TODO: Remove all methods listed below after 8.3.
        /***********************************/
        _refresh: function () {
            console.error('grid onRefresh function is not guaranteed to exist after 8.3');
            this.refresh();
        },
        onRefresh: function () {
        },
        addNew: function (item) {
            console.error('grid addNew function is not guaranteed to exist after 8.3');
            this.grid.addItem(item);
        },
        showLoading: function () {
            console.error('grid showLoading function is not guaranteed to exist after 8.3');
        },
        setupHeader: function () {
            console.error('grid setupHeader function is not guaranteed to exist after 8.3');
            this._createGridHeader();
        },
        _getRecordCount: function () {
            console.error('grid _getRecordCount function is not guaranteed to exist after 8.3');
            return this.rowCount;
        }
    });
    return widget;
});
},
'Sage/UI/Controls/GridParts/Columns/CheckBox':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/_base/declare',
    'dijit/form/CheckBox'
],
function (declare, CheckBox) {
    var widget = declare("Sage.UI.Controls.GridParts.Columns.CheckBox", CheckBox, {
        _getValueAttr: function () {
            // summary:
            //		Hook so get('value') works.
            // description:
            //		If the CheckBox is checked, returns the value attribute.
            //		Otherwise returns false.
            return this.checked;
        }
    });

    return widget;
});

},
'Sage/UI/SLXPreviewGrid/FilterPanel':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
        'dijit/form/Button',
        'dijit/_Widget',
        'Sage/Utility/_LocalStorageMixin',
        'dojo/i18n!../nls/SLXPreviewGrid',
        'dojo/_base/declare'
],
function (Button, _Widget, _LocalStorageMixin, previewGridStrings, declare) {
    var filterPanel = declare("Sage.UI.SLXPreviewGrid.FilterPanel", [_Widget, _LocalStorageMixin], {
        // summary:
        //  Master filter panel for the grid.
        //  At construction time the "filterConfig" option should be set to an array of filter configuration objects.
        //  They must contain a property "widgetType" - type of the widget to instantiate (must have a "getQuery" method)
        //  and should have a "field" property, which usually will be used by the filter widget to build the query,
        //  and a "label" property.
        //  The rest of the options are passed down to that widget's constructor.
        // array of filter widgets
        _filters: null,
        _state: {},
        STORE_NS: 'SAGE_UI_EDITABLEGRID', //this is the same as the grid
        STORE_KEY_FILTERINFO: '_FILTER_INFO_',

        //i18n strings:
        applyText: 'Apply',
        resetText: 'Reset',
        //end i18n strings.

        /////////////////////////////////////
        // Widget lifecycle

        constructor: function () {
            this._filters = [];
        },
        postMixInProperties: function () {
            dojo.mixin(this, previewGridStrings);
            this._loadState();
            this.inherited(arguments);
        },
        buildRendering: function () {
            // summary:
            //  build the child filter widgets
            this.inherited(arguments);
            this.domNode.className = "filterPanel";
            var left = document.createElement("div");
            left.style.styleFloat = left.style.cssFloat = "left";
            left.style.width = "39%";
            var right = document.createElement("div");
            right.style.styleFloat = right.style.cssFloat = "left";
            right.style.width = "39%";

            var filterStates = this._state['filterStates'] || {};
            var target = left;
            dojo.forEach(this.filterConfig, function (item, index, ar) {

                if (target === left && index + 1 > ar.length / 2) {
                    target = right;
                }
                var filterItem = document.createElement("div");
                filterItem.className = "filterItem";
                var filter = this._createFilter(item);
                if (filterStates[item.field] && filter.applyState) {
                    filter.applyState(filterStates[item.field]);
                }
                this._filters.push(filter);
                if (item.label) {
                    var lbl = document.createElement("label");
                    lbl.appendChild(document.createTextNode(item.label + ":"));
                    lbl.className = "filterPanelLabel";
                    lbl.htmlFor = filter.domNode.id;
                    filterItem.appendChild(lbl);
                }
                filterItem.appendChild(filter.domNode);
                target.appendChild(filterItem);
            }, this);

            // create apply / reset buttons and add to right columns
            var btnPanel = document.createElement("div");
            btnPanel.style.styleFloat = btnPanel.style.cssFloat = "left";
            btnPanel.style.width = "20%";
            btnPanel.className = "filterButtonPanel";
            var btnOk = new Button({ label: this.applyText });
            btnPanel.appendChild(btnOk.domNode);
            dojo.connect(btnOk, "onClick", this, "_applyFilter");
            var btnReset = new Button({ label: this.resetText });
            btnPanel.appendChild(btnReset.domNode);
            dojo.connect(btnReset, "onClick", this, "_resetFilter");
            dojo.connect(this.domNode, "keydown", this, function (e) {
                if (e.keyCode === 13) {
                    this._applyFilter();
                }
            });

            this.domNode.appendChild(left);
            this.domNode.appendChild(right);
            this.domNode.appendChild(btnPanel);
        },
        startup: function () {
            this.inherited(arguments);
            dojo.forEach(this._filters, function (item) { item.startup(); });
            if (this._state['visible'] && this._state['visible'] === true) {
                this.toggle();
            }
        },
        destroy: function () {
            dojo.forEach(this._filters, function (item) {
                item.destroy(false);
            });

            dojo.forEach(dijit.findWidgets(this.domNode), function (wid) {
                wid.destroy(false);
            });

            this.inherited(arguments);
        },
        /////////////////////////////////////
        // Public API

        getQuery: function () {
            // summary:
            //  build and return the sdata query string for the filter.  If no conditions are specified then it will return null.
            var c = [];
            dojo.forEach(this._filters, function (f) {
                var q = f.getQuery();
                if (q) {
                    c.push(q);
                }
            });
            return c.length > 0 ? c.join(" and ") : null;
        },

        toggle: function () {
            if (this.domNode.style.display === "none") {
                this.domNode.style.display = "block";
                this._state['visible'] = true;
            }
            else {
                this.domNode.style.display = "none";
                this._state['visible'] = false;
            }
            this._saveState();
        },

        /////////////////////////////////////
        // Events

        onFilterApply: function (conditions) {
            // summary:
            //  callback when the filter should be applied
            // conditions:
            //  conditions query string
        },

        /////////////////////////////////////
        // Private Helpers

        _createFilter: function (column) {
            // summary:
            //  instantiate and return a filter widget
            var c = column.widgetType;
            var field = {
                field: column.field,
                lookupGridOptions: column.lookupGridOptions,
                lookupStoreOptions: column.lookupStoreOptions,
                lookupStructure: column.lookupStructure,
                name: column.label
            };
            return new c(field);
        },

        _applyFilter: function () {
            var filterStates = {};
            for (var i = 0; i < this._filters.length; i++) {
                var f = this._filters[i];
                if (f.getState) {
                    filterStates[f.field] = f.getState();
                }
            }
            this._state['filterStates'] = filterStates;
            this._saveState();
            this.onFilterApply(this.getQuery());
        },

        _resetFilter: function () {
            dojo.forEach(this._filters, function (f) { f.reset(); });
            this._applyFilter();
        },

        _saveState: function () {
            var key = this.STORE_KEY_FILTERINFO + this.id;
            this.saveToLocalStorage(key, this._state, this.STORE_NS);
        },
        _loadState: function () {
            var key = this.STORE_KEY_FILTERINFO + this.id;
            this._state = this.getFromLocalStorage(key, this.STORE_NS) || {};
        }
    });

    return filterPanel;
});
},
'Sage/Store/WritableStore':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
        'Sage/Store/BaseSDataStore',
        'Sage/Utility',
        'dojo/_base/declare',
        'dojo/_base/lang'
],
function (BaseSDataStore, Utility, declare, lang) {
    var writableStore = declare('Sage.Store.WritableStore', BaseSDataStore, {
        //  summary:
        //      A data store implementation that allows the EditableGrid to have its data participate in .net postback and binding
        //      Configuration information is received from EditableGrid.
        //  description:
        //      dojo.data.api.Identity Implemented on BaseSDataStore...
        //      dojo.data.api.Read Implemented on BaseSDataStore...
        isInsertMode: false,
        _isPostback: false,
        constructor: function (o) {
            lang.mixin(this, o);
            this.features['dojo.data.api.Write'] = true;
            this.features['dojo.data.api.Notification'] = true;
            this.identityAttributes = ['$cacheID'];
            this.dirtyDataCache = { isDirty: false };
            this.singleResourceRequest = null;
            if (!o.hasOwnProperty('isInsertMode')) {
                this.isInsertMode = Utility.getModeId() === 'insert';
            }
        },
        entry: '',
        query: function (context, queryOptions) {
            //summary:
            //  Retrieve data from dataCarrier, dataCache and/or feed, and provide it to the grid.
            var items = {};
            items.$resources = [];
            var item = null;

            //Read from DataCarrier/TextBox only onLoad.
            if (!this._isPostback && this.dataCarrierId) {
                var carrier = dojo.query(['.', this.dataCarrierId].join(''));
                if (carrier[0].value.length > 0) {
                    var carrierItems = dojo.fromJson(carrier[0].value);
                    var sorted = carrierItems.$resources.sort(Utility.dynamicSort(queryOptions.sort[0].attribute, queryOptions.sort[0].descending));
                    this.addItemsToCache(context, sorted);
                }
            }

            // Restructure the dataCache into an array to supply to the grid.
            for (item in this.data) {
                if (this.data.hasOwnProperty(item) && item !== 'query') {
                    items.$resources.push(this.data[item]);
                }
            }

            this.setContext(context);
            this.verifyService();
            this._isPostback = true;
            //Check to see if anything has been added to cache.  Either from a lookup or a .net DataCarrier.
            //if (items.$resources && items.$resources.length > 0) {
            if (this.isInsertMode) {
                var self = this;
                window.setTimeout(function () { self.onSuccess(context, items); }, 5);
                return items.$resources;
            }
        },
        onSuccess: function (context, feed) {
            //summary:
            //  Provides the items to the grid for rendering.
            //description:
            //  Checks if the data carrier has received the feed header.  If not, add it.
            if (this.entry === '') {
                this.entry = feed;
            }
            if (context.onBegin) {
                context.onBegin.call(context.scope || this, feed.$resources.length, context);
            }
            if (context.onComplete) {
                context.onComplete.call(context.scope || this, feed.$resources, context);
            }
        },
        addToCache: function (context, item, count) {
            var key;
            count = (typeof count === 'undefined') ? (Math.random() * 11) : count;
            if (this.isInsertMode) {
                //console.log(new Date().getTime());
                item.$cacheID = new Date().getTime() + count;
            }
            key = this.getIdentity(item);
            this.data[key] = item;
        },
        addItemsToCache: function (context, items) {
            for (var i = 0; i < items.length; i++) {
                this.addToCache(context, items[i], i);
            }
        },
        clearCache: function () {
            //  summary:
            //      Inherits from BaseSDataStore.clearCache which clears data cache.  Calls clearDirtyDataCache as well for edit mode data.
            this.inherited(arguments);
            this.clearDirtyDataCache();
        },
        clearDirtyDataCache: function () {
            //  summary:
            //    Clears dirty data cache created from edit mode changes.  Sets isDirty flag to 'false'
            for (var key in this.dirtyDataCache) {
                if (key !== 'isDirty') {
                    delete this.dirtyDataCache[key];
                }
            }
            this.dirtyDataCache.isDirty = false;
            //this.dirtyDataCache = { isDirty: false };
        },
        isItem: function (something) {
            //  summary:
            //      Performs hasOwnProperty check on dataCache to verify if the provided item already exists.
            //  returns:
            //      'true' if dataCache has property, else 'false'
            var id = this.getIdentity(/* anything */something);
            if (id && id !== '') {
                return this.data.hasOwnProperty(id);
            }
            return false;
        },
        isItemLoaded: function (/* anything */something) {
            //  summary:
            //      Performs isItem check on 'this' to verify if the provided item already exists.
            //  returns:
            //      'true' if Item exists, else 'false'
            return this.isItem(something); //boolean
        },
        loadItem: function (/* object */keywordArgs) {
            //  summary:
            //      REDUNDANT??
            if (!this.isItem(keywordArgs.item)) throw new Error('Unable to load ' + keywordArgs.item);
        },
        getValues: function (item, attributename) {
            if (this.isItem(item) && (typeof attributename === "string")) {
                return (item[attributename] || []).slice(0);
            }
            return [];
        },
        hasAttribute: function (item, attributename) {
            if (this.isItem(item) && (typeof attributename === "string")) {
                return attributename in item;
            }
            return false;
        },
        close: function () {
            this.clearCache();
        },
        //dojo.data.api.Write implementations...
        deleteItem: function (item, scope) {
            //summary:
            //  Find the item in the cache and remove it.  Grid is responsible for refreshing itself.
            var id = this.getIdentity(item);
            if (id && id !== '') {
                delete this.data[id];
            }
            var options = {};
            options.scope = scope || this;
            var fnSuccess = function () {
                if (typeof this.onResponse === 'function') {
                    this.onResponse.call(this);
                }
            };
            options.success = fnSuccess;
            options.success.call(options.scope);
        },
        isDirty: function (item) {
            //item could be null - if so, it means is any item dirty...
            if (item) {
                var id = this.getIdentity(item);
                if (id && id !== '') {
                    return this.dirtyDataCache.hasOwnPropery(id);
                }
            }
            return this.dirtyDataCache.isDirty;
        },
        newItem: function (args /*, parentInfo */) {
            var request = this.createTemplateRequest();
            if (request) {
                request.read({
                    success: function (entry) {
                        if ((args) && (args.onComplete) && (typeof args.onComplete === 'function')) {
                            args.onComplete.call(args.scope || this, entry);
                        }
                    },
                    failure: this.requestTemplateFailure,
                    scope: this
                });
            }
        },
        createTemplateRequest: function () {
            //The entity to create the relationship/New record for, from the selection.
            var request = new Sage.SData.Client.SDataTemplateResourceRequest(this.service);
            if ((this.resourceKind) && (this.resourceKind !== '')) {
                request.setResourceKind(this.resourceKind);
            }
            return request;
        },
        requestTemplateFailure: function () {
        },
        saveNewEntity: function (entity, success, failure, scope) {
            //summary:
            //  Create a new entity and add it to the dataCache.
            this.addToCache(scope, entity);
            success();
        },
        createItem: function (item, scope) {
            var options = {};
            options.scope = scope || this;
            options.scope.store = this;
            var fnSuccess = function (created) {
                if (typeof this.onResponse === 'function') {
                    this.onResponse.call(this, created);
                }
            };
            options.success = fnSuccess;
            this.addToCache(scope, item);
            options.success.call(options.scope, item);
        },
        revert: function () {
            //  summary:
            //      Clear the dirty data cache and call the onDataReset function.
            //      The grid calls fetch again and gets the data.
            this.clearDirtyDataCache();
            this.onDataReset();
        },
        setValue: function (item, attribute, value) {
            //if (typeof console !== 'undefined') { console.log('setValue - %o %o %o', item, attribute, value) };
            var oldValue = this.getValue(item, attribute, '');
            Utility.setValue(item, attribute, value);
            this.onSet(item, attribute, oldValue, value);
            return true;
        },
        setValues: function (item, attribute, values) {
            alert('not implemented - setValues');
            //use where values is an array
        },
        unsetAttribute: function (item, attribute) {
            alert('not implemented - unsetAttribute');
            //delete all values of an attribute on the item...
        },
        dataCacheToArray: function () {
            var resources = [];
            for (var item in this.data) {
                if (this.data.hasOwnProperty(item) && item !== 'query') {
                    resources.push(this.data[item]);
                }
            }
            return resources;
        },
        onDataChange: function () {
            //There is no dirtyDataCache tracking for Insert views.  Clear dirty data here, just in case.
            this.clearDirtyDataCache();
            var carrier = dojo.query(['.', this.dataCarrierId].join(''));
            if (carrier[0]) {
                this.entry.$resources = this.dataCacheToArray();
                carrier[0].value = JSON.stringify(this.entry);
            }
        },
        //dojo.data.api.Notification
        onSet: function (/* item */item,
        /*attribute-name-string*/attribute,
        /*object | array*/oldValue,
        /*object | array*/newValue) {
            // summary:
            // See dojo.data.api.Notification.onSet()
            // No need to do anything. This method is here just so that the
            // client code can connect observers to it.
        },
        onNew: function (newItem, parentInfo) {
            //nothing to do here - client code connects observers to this
        },
        onDelete: function (deletedItem) {
            //nothing to do here - client code connects observers to this
        },
        onDataReset: function () {
        },
        onDataSaved: function () {
        },
        onItemSaved: function (savedItem, parentInfo) {
        },
        onItemNotSaved: function (notSavedItem, error) {
        }
    });
    return writableStore;
});

},
'Sage/Store/BaseSDataStore':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
        'Sage/Utility',
        'Sage/Data/SDataServiceRegistry',
        'dojo/_base/declare',
        'dojo/_base/lang'
],
function (Utility, SDataServiceRegistry, declare, lang) {
    var baseStore = declare('Sage.Store.BaseSDataStore', null, {
        queryName: null,
        constructor: function (o) {
            lang.mixin(this, o);
            this.features = {
                'dojo.data.api.Read': true
            };
            if (!this.identityAttributes) {
                this.identityAttributes = [this.identityAttribute || '$key'];
            }
            if (!this.labelAttributes) {
                this.labelAttributes = ['$descriptor'];
            }
            this.features['dojo.data.api.Identity'] = true;
            this.data = { query: '' };
        },
        fetch: function (context) {
            if (!this.isNewContext(context) && this.feed) {
                this.onSuccess(context, this.feed);
                return;
            }

            this.setContext(context);
            if (context.count === Infinity) {
                context.count = 500;  //500 is almost Infinity, right?
            }

            var pagesize = (context.count - 0) || this.pageSize || 15;
            var startIdx = (context.start - 0) || 1;
            if (startIdx > 1) {
                startIdx = startIdx + 1;
            }

            this.verifyService();
            var request = this.getCollectionRequestObj(context);
            if (!request) {
                if (context.onError) {
                    context.onError.call(context.scope || this, "Invalid data url", context);
                }
                return;
            }

            request.setQueryArg(Sage.SData.Client.SDataUri.QueryArgNames.StartIndex, (isNaN(startIdx)) ? 1 : startIdx);
            var qry = '';

            // New dojo 1.7 controls will clobber this.query.
            // Issue a warn if this.query was set to an object or string
            if (this.query && typeof this.query !== 'function') {
                console.warn('BaseSDataStore.query should not be set. Use directQuery instead.');

                // Set the new property so we don't break anything.
                if (!this.directQuery) {
                    this.directQuery = this.query;
                }
            }

            // Check to see if a query has been added directly to the store, for binding with native dojo components, ie. ComboBox
            // TODO: Determine patterns for mixin, replacement, seed value, etc. of query,
            if (this.directQuery) {
                if (!context.query) {
                    context.query = {};
                }
                lang.mixin(context.query, this.directQuery);
            }
            if (context.query) {
                if (typeof context.query === 'function') {
                    qry = context.query();
                } else if (typeof context.query === 'string') {
                    qry = context.query;
                } else if (typeof context.query === 'object') {
                    for (var queryItem in context.query) {
                        //Initial context based query
                        if (queryItem === 'fn') {
                            qry = context.query.fn.call(context.query.scope || this);
                        }
                        //Additional conditions.  Typically from the ConditionManager.
                        else if (queryItem === 'conditions') {
                            if (typeof context.query.conditions === 'string' && context.query.conditions !== '') {
                                qry += (qry && qry.length > 0) ? ' and ' + context.query.conditions : context.query.conditions;
                            }
                        }
                        //In the case of ComboBoxes and FilteringTextBoxes, we need to include the user input into the query.
                        else if (queryItem !== 'scope') {
                            if (context.query.hasOwnProperty(queryItem)) {
                                var userInput = [queryItem, ' like ', "'", context.query[queryItem].replace('*', '%'), "'"].join('');
                                qry += (qry.length > 0) ? ' and ' + userInput : userInput;
                            }
                        }
                    }
                }
            }

            context.evaluatedQuery = qry || '';
            if (qry && qry !== '') {
                request.setQueryArg('where', qry);
            }

            if (this.select && this.select.length > 0)
                request.setQueryArg('select', this.select.join(','));

            if (this.include && this.include.length > 0)
                request.setQueryArg('include', this.include.join(','));

            if (this.sort) {
                // add the "intrinsic" sort (specified in store options)
                // take care not to re-add an attribute that is already specified in the context sort 
                // (or sdata will give an error)
                context.sort = context.sort || [];

                dojo.forEach(this.sort, function (sortItem) {
                    if (dojo.filter(context.sort, function (existingSort) {
                        return sortItem.attribute == existingSort.attribute;
                    }).length === 0) {
                        context.sort.push(sortItem);
                    }
                });
            }

            if (typeof context.resourcePredicate !== 'undefined') {
                request.getUri().setCollectionPredicate(context.resourcePredicate);
            }

            this._setQueryArgsOnRequest(context.queryArgs, request);

            if (context.sort && context.sort.length > 0) {
                var order = [];
                dojo.forEach(context.sort, function (v) {
                    if (v.descending)
                        this.push(v.attribute + ' desc');
                    else
                        this.push(v.attribute);
                }, order);
                // ProxySDataStore hits this, and it should be camel-case to follow our SData spec
                //  Our system is case-insensitive, but other systems following the spec may not be (X3 for instance)
                request.setQueryArg('orderBy', order.join(','));
            }

            if (this.beforeRequest && typeof this.beforeRequest === 'function') {
                this.beforeRequest.call(context.scope || this, request);
            }
            var key = request.read({
                success: lang.hitch(this, this.onSuccess, context),
                failure: lang.hitch(this, this.onFailure, context)
            });

            return {
                abort: lang.hitch(this, this.abortRequest, key)
            };
        },
        getCollectionRequestObj: function (context) {
            var request = this.queryName
                ? new Sage.SData.Client.SDataNamedQueryRequest(this.service).setQueryName(this.queryName)
                : new Sage.SData.Client.SDataResourceCollectionRequest(this.service);

            request.setResourceKind(this.resourceKind);
            request.setStartIndex(context.start + 1);

            if (this.resourcePredicate
                && this.resourcePredicate !== "''") {
                request.getUri().setCollectionPredicate(this.resourcePredicate);
            }

            this._setQueryArgsOnRequest(this.queryArgs, request);

            if (!context.count && this.count) {
                context.count = this.count;
            }
            request.setCount(context.count);
            return request;
        },
        _setQueryArgsOnRequest: function (queryArgs, request) {
            if (queryArgs) {
                for (var prop in queryArgs) {
                    if (queryArgs.hasOwnProperty(prop)) {
                        request.setQueryArg(prop, queryArgs[prop]);
                    }
                }
            }
        },
        abortRequest: function (key) {
            this.service.abortRequest(key);
        },
        onSuccess: function (context, feed) {
            if (context.onBegin) {
                if (typeof feed.$totalResults === 'undefined') {
                    feed.$totalResults = feed.$itemsPerPage + feed.$startIndex;// the previous value of 500000 allowed users to scroll past the last page.
                }
                context.onBegin.call(context.scope || this, feed.$totalResults, context);
            }
            if (context.onComplete) context.onComplete.call(context.scope || this, feed.$resources, context);
            this.addToCache(context, feed);
        },
        onFailure: function (context, request, o) {
            var msg = 'An unknown exception occurred obtaining data.';
            if (request.responseText) {
                var responseJObj = Sys.Serialization.JavaScriptSerializer.deserialize(request.responseText);
                if (dojo.isArray(responseJObj)) {
                    msg = responseJObj[0].message;
                } else {
                    msg = request.responseText;
                }
            }
            if (context && context.onError) {
                context.onError.call(context.scope || this, msg, context);
            }
            else {
                if (typeof msg === 'string' && typeof console !== 'undefined') {
                    if (request && request.status) {
                        msg += ' (HTTP status = %o; statusText = %o)';
                        console.error(msg, request.status, request.statusText);
                    }
                    else
                        console.error(msg);
                }
            }
        },
        setContext: function (newContext) {
            this.context = {
                start: newContext.start,
                count: newContext.count,
                query: newContext.query,
                queryOptions: newContext.queryOptions,
                sort: newContext.sort
            };
        },
        addToCache: function (context, feed) {
            var i, item, key;
            if (context.evaluatedQuery !== this.data.query) {
                this.clearCache();
                this.data.query = context.evaluatedQuery;
            }
            if (feed.$resources) {
                for (i = 0; i < feed.$resources.length; i++) {
                    item = feed.$resources[i];
                    key = this.getIdentity(item);
                    this.data[key] = item;
                }
            }
        },
        clearCache: function () {
            for (var key in this.data) {
                if (key !== 'query') {
                    delete this.data[key];
                }
            }
            this.data.query = '';
        },
        isNewContext: function (newContext) {
            if (typeof this.context !== 'object') return true;
            if (this.context.start !== newContext.start) return true;
            if (this.context.count !== newContext.count) return true;
            return false;
        },
        verifyService: function (contract) {
            if (!this.service) {
                this.service = SDataServiceRegistry.getSDataService(contract || 'dynamic');
            }
        },
        getValue: function (item, attribute, defaultValue) {
            return Utility.getValue(item, attribute);
        },
        getFeatures: function () {
            return this.features;
        },
        //dojo.data.api.Read implementations....
        getLabel: function (item) {
            var lbl = [];
            for (var i = 0; i < this.labelAttributes.length; i++) {
                if (item.hasOwnProperty(this.labelAttributes[i])) {
                    lbl.push(item[this.labelAttributes[i]]);
                }
            }
            return lbl.join(' ');
        },
        getLabelAttributes: function (item) {
            return this.labelAttributes;
        },
        //dojo.data.api.Identity implementations...
        getIdentity: function (item) {
            //summary:
            //  Returns the value of the unique identifier for the item passed
            //item:
            //  The item from which to obtain its identifier.
			var i;
            if (item) {
                var identity = [];
                if (Object.prototype.toString.call(item) === '[object Array]') {
                    for (var x = 0; x < item.length; x++) {
                        for (i = 0; i < this.identityAttributes.length; i++) {
                            if (item[x].hasOwnProperty(this.identityAttributes[i])) {
                                identity.push(item[x][this.identityAttributes[i]]);
                            }
                        }
                    }
                } else {
                    for (i = 0; i < this.identityAttributes.length; i++) {
                        if (item.hasOwnProperty(this.identityAttributes[i])) {
                            identity.push(item[this.identityAttributes[i]]);
                        }
                    }
                }
                return identity.join('');
            }
        },
        getIdentityAttributes: function (item) {
            return this.identityAttributes;
        },
        fetchItemByIdentity: function (keywordArgs) {
            //summary:
            //  returns the item from the store that matches the identity passed in the keywordArgs object.
            //keywordArgs:
            //  object that defines the item to locate and callback methods to invoke when the item has been located and loaded.
            //  {
            //      identity: string|object,    //id
            //      onItem: function(item),     //called when item has been loaded
            //      onError: function(error),   //called when an error occurred or item could not be loaded.
            //      scope: object,              //the scope in which to call the onItem and onError functions
            //  }
            if (this.data.hasOwnProperty(keywordArgs.identity)) {
                keywordArgs.onItem.call(keywordArgs.scope || this, this.data[keywordArgs.identity]);
            } else {
                var msg = 'Item with that key does not exist in the data cache: ' + keywordArgs.identity;
                if (keywordArgs.onError) {
                    keywordArgs.onError.call(keywordArgs.scope || this, { 'error': msg });
                } else {
                    if (typeof console !== 'undefined') { console.info(msg); }
                }
            }
        },
        containsValue: function (item, attr, value) {
            var val = Utility.getValue(item, attr);
            return val !== '';
        }
    });

    return baseStore;
});

},
'Sage/UI/Controls/Lookup':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dijit/_TemplatedMixin',
    'dijit/_WidgetsInTemplateMixin',
    'dijit/_Widget',
    'Sage/UI/ConditionManager',
    'Sage/UI/SDataLookup',
    'dojo/dom-attr',
    'Sage/UI/Controls/EntityInfoToolTip',
    'dojo/i18n!./nls/Lookup',
    'dojo/text!./templates/Lookup.html',
    'dojo/_base/declare'
],
function (_TemplatedMixin, _WidgetsInTemplateMixin, _Widget, conditionManager, _SDataLookup, domAttr, EntityInfoToolTip, i18nStrings, template, declare) {
    var widget = declare('Sage.UI.Controls.Lookup', [_Widget, _TemplatedMixin, _WidgetsInTemplateMixin], {

        /**
        * @property {string} DOM id of control
        */
        id: 'lookup',

        /**
        * @property {object} SDataLookup configuration object 
        */
        config: null,

        /**
        * @property {object} SDataLookup results object 
        */
        selectedObject: null,

        /**
        * @property {bool} showEntityInfoTooltip 
        */
        showEntityInfoToolTip: false,

        disabled: false,
        required: false,

        allowClearingResult: false,

        //i18n strings...
        buttonToolTip: 'Find',
        closeButtonToolTip: 'Remove',

        //end i18n strings
        _tooltip: false,

        _setSelectedObjectAttr: function (value) {
            this.textbox.value = (value) ? value.$descriptor : '';
            this.selectedObject = value;
            this._onChange(value);
        },

        _getSelectedObjectAttr: function () {
            return this.selectedObject;
        },

        _setShowEntityInfoToolTipAttr: function (showTooltip) {
            this.showEntityInfoToolTip = showTooltip;
            if (!this.domNode) {
                return;
            }
            this._tooltip = (showTooltip) ? this._createToolTip() : false;
        },
        _getShowEntityInfoToolTipAttr: function () {
            return this.showEntityInfoToolTip;
        },
        _createToolTip: function () {
            return new EntityInfoToolTip({
                connectId: [this.domNode],
                position: ['below'],
                entityName: this.config.storeOptions.resourceKind,
                entityId: (this.selectedObject && this.selectedObject['$key']) ? this.selectedObject['$key'] : ''
            });
        },

        _setAllowClearingResultAttr: function (allow) {
            this.allowClearingResult = allow;
            if (allow) {
                dojo.removeClass(this.clearButton, 'display-none');
            } else {
                dojo.addClass(this.clearButton, 'display-none');
            }
        },

        _getAllowClearingResultAttr: function () {
            return this.allowClearingResult;
        },

        _setDisabledAttr: function (value) {
            this.disabled = value;
            domAttr.set(this.focusNode, 'disabled', value);
            this.focusNode.setAttribute("aria-disabled", value);
            if (value) {
                dojo.style(this.clearButton, 'visibility', 'hidden');
                dojo.style(this.clearButton, 'display', 'none');
                dojo.style(this.lookupButton, 'visibility', 'hidden');
                dojo.style(this.lookupButton, 'display', 'none');
            } else {
                dojo.style(this.clearButton, 'visibility', '');
                dojo.style(this.clearButton, 'display', '');
                dojo.style(this.lookupButton, 'visibility', '');
                dojo.style(this.lookupButton, 'display', '');
            }
        },
        _getDisabledAttr: function () {
            return this.disabled;
        },
        _onChange: function (value) {
            if (this._tooltip) {
                this._tooltip.set('entityId', (value && value['$key']) ? value['$key'] : '');
            }
            this.onChange(value);
        },

        /**
        * Fires when lookup results are set or selectedObject is set.
        * @event
        */
        onChange: function (value) {
        },

        // Display properties
        templateString: template,
        widgetsInTemplate: false,

        /**
        *
        * @constructor
        */
        constructor: function (options) {
            this.inherited(arguments);
            dojo.mixin(this, i18nStrings);
        },

        //To force closetooltip
        hideTooltip: function () {
            if (this._tooltip) {
                this._tooltip.close();
            }
        },
        postCreate: function () {
            var self = this;

            dojo.connect(this.lookupButton, 'onclick', this.lookupButton, function () {
                if (!self.get('disabled')) {
                    var lookup = new _SDataLookup(self.config);
                    lookup.doSelected = function (items) {
                        self.set('selectedObject', items[0]);
                        lookup.lookupDialog.hide();
                        //lookup.destroy();
                    };

                    lookup.showLookup();
                    var handle = dojo.connect(lookup.lookupDialog, 'onHide', lookup, function () { dojo.disconnect(handle); this.destroy(); });
                }
            }, true);

            dojo.connect(this.clearButton, 'onclick', null, function () {
                if (!self.get('disabled')) {
                    self.textbox.value = '';
                    self.set('selectedObject', null);
                }
            }, true);
        }
    });

    return widget;
});

},
'Sage/UI/Controls/EntityInfoToolTip':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
       'dijit/Tooltip',
       'Sage/Data/SingleEntrySDataStore',
       'Sage/Utility',
       'dojo/string',
       'dojo/html',
       'dojo/i18n!./nls/EntityInfoToolTip',
       'dojo/_base/lang',
       'dojo/_base/declare'
],
function (tooltip, SingleEntrySDataStore, util, dString, dhtml, nlsStrings, lang, declare) {
    var widget = declare('Sage.UI.Controls.EntityInfoToolTip', tooltip, {

        /*
        Example:
        var t = new Sage.UI.Controls.EntityInfoToolTip({
        connectId: '<some Dom element id',
        position: ['below'],
        entityName: 'accounts',
        entityId: 'AA2EK0013106',
        dataProps: [
        { label: 'Co:', property: 'AccountName' },
        { label: 'Ph:', property: 'MainPhone' },
        { label: 'URL:', property: 'WebAddress' }
        ]
        });
        */


        /**
        * @property {string} Entity name. Required.
        */
        entityName: '',

        /**
        * @property {string} Entity ID to fetch. Required.
        */
        entityId: '',

        /**
        * @property {array} configuration of objects specifying label and property for requesting and displaying data
        */
        dataProps: [],
        /**
        * @property {aray} specifies relationship includes when needed for items defined in dataProps
        */
        include: [],

        /* Resource strings from nls/{language}/EntityInfoToolTip.js
        errorText: 'Information not found.',
        loadingText: 'Loading...',
        noInfoText: 'No information to show.',
        mainText: 'Main:',
        faxText: 'Fax:',
        tollFreeText: 'Toll Free:',
        urlText: 'Web URL:',
        workText: 'Work:',
        mobileText: 'Mobile:',
        emailText: 'Email:',
        contactNameText: 'Name:',
        phoneText: 'Phone:',
        accountText: 'Account:',
        */

        _store: null,
        _storeOptions: null,

        constructor: function (options) {
            lang.mixin(this, nlsStrings);
            this.inherited(arguments);
        },
        postCreate: function () {
            this.inherited(arguments);
            this.label = 'Loading...';
        },
        onShow: function (target) { 
            if (!this.entityId || this.entityId.trim() === '') {
                this.set('label', this.noInfoText);
            } else if (!this._store) {
                if (this.dataProps.length < 1) {
                    this.dataProps = this._findPredefined(this.entityName);
                }
                if (this.dataProps.length < 1) {
                    this.set('label', this.errorText);
                    return;
                }
                this._setupStore();
                this._fetchData(target);
            }
            this.inherited(arguments);
        },
        _setDataPropsAttr: function (dataProps) {
            this._store = false;
            this.set('label', this.loadingText);
            this.dataProps = dataProps;
        },
        _getDataPropsAttr: function () {
            return this.dataProps;
        },
        _setEntityIdAttr: function (entityId) {
            this._store = false;
            this.set('label', (entityId === '') ? this.noInfoText : this.loadingText);
            this.entityId = entityId;
        },
        _getEntityIdAttr: function () {
            return this.entityId;
        },
        _setupStore: function () {
            var select = [], sel = '', include = [], included = {};
            for (var i = 0; i < this.dataProps.length; i++) {
                sel = this.dataProps[i].property;
                if (sel.indexOf('.') > 0) {
                    var parts = sel.split('.'), inc = '';
                    for (var p = 0; p < parts.length - 1; p++) {
                        inc += parts[p];
                        if (!included[inc]) {
                            include.push(inc);
                            included[inc] = true;
                        }
                        inc += '/';
                    }
                    sel = sel.replace(/\./g, '/');
                }

                select.push(sel);
            }
            var self = this;
            var storeOptions = {
                include: dojo.isArray(this.include) ? this.include : [],
                select: select,
                resourceKind: self.entityName
            };
            if (include.length > 0) {
                storeOptions['include'] = include;
            }
            var dataStore = new SingleEntrySDataStore(storeOptions);

            self._storeOptions = storeOptions;
            self._store = dataStore;
        },
        _fetchData: function (target) {
            var t = target;
            this._store.fetch({
                predicate: '"' + this.entityId + '"',
                onComplete: function (data) { this.displayResults(data, t); },
                // when we implement "auto" mode, we can use this...
                //                beforeRequest: function (request) { 
                //                    request.setQueryArg('precedence', '1');
                //                },
                onError: function (e) {
                    this.set('label', this.errorText);
                },
                scope: this
            });
        },
        displayResults: function (data, target) {
            //console.log(data);
            var html = '<table class="propertyTip">';
            for (var i = 0; i < this.dataProps.length; i++) {
                var dp = this.dataProps[i];
                var val = util.getValue(data, dp.property);
                if (val) {
                    html += dString.substitute('<tr><td class="caption">${0}</td><td class="value">${1}</td></tr>', [dp.label, val]);
                }
            }
            html += '</table>';
            this.set('label', html);
            this.close();
            this.open(target);
        },
        _findPredefined: function (entity) {
            switch (entity) {
                case 'accounts':
                    return [
                        { label: this.mainText || 'Main Phone:', property: 'MainPhone' },
                        { label: this.faxText || 'Fax:', property: 'Fax' },
                        { label: this.tollFreeText || 'Toll Free', property: 'TollFree' },
                        { label: this.urlText || 'Web URL', property: 'WebAddress' }
                    ];
                case 'contacts':
                    return [
                        { label: this.workText || 'Work:', property: 'WorkPhone' },
                        { label: this.mobileText || 'Mobile:', property: 'Mobile' },
                        { label: this.faxText || 'Fax:', property: 'Fax' },
                        { label: this.emailText || 'Email:', property: 'Email' }
                    ];
                case 'leads':
                    return [
                        { label: this.workText || 'Work:', property: 'WorkPhone' },
                        { label: this.mobileText || 'Mobile:', property: 'Mobile' },
                        { label: this.faxText || 'Fax:', property: 'Fax' },
                        { label: this.emailText || 'Email:', property: 'Email' }
                    ];
                case 'tickets':
                    return [
                        { label: this.contactNameText || 'Contact:', property: 'Contact.Name' },
                        { label: this.phoneText || 'Phone:', property: 'Contact.WorkPhone' },
                        { label: this.emailText || 'Email:', property: 'Contact.Email' }
                    ];
                case 'opportunities':
                    return [
                        { label: this.accountText || 'Account:', property: 'Account.AccountName' },
                        { label: this.mainText || 'Main Phone:', property: 'Account.MainPhone' }
                    ];
            }
            return [];
        }
    });

    return widget;
});


},
'Sage/Utility/UserOptions':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
        'Sage/Utility'
    ],
    function (sageUtility) {
        Sage.namespace('Utility.UserOptions');
        Sage.Utility.UserOptions = {
            getConvertedOptionValue: function (optionName, value) {
                value = value.toLowerCase();
                var retValue = value;
                
                switch (optionName.toUpperCase()) {
                    case "DEFAULTCALENDARVIEW":
                        var monthRE = /^(month|2)$/i;
                        var weekRE = /^(week|1)$/i;
                        var workweekRE = /^(workweek|3)$/i;
                        var dayRE = /^(day|0)$/i;

                        if (monthRE.test(value)) retValue = "month";
                        else if (weekRE.test(value)) retValue = "week";
                        else if (workweekRE.test(value)) retValue = "workweek";
                        else if (dayRE.test(value)) retValue = "day";
                        else retValue = "day";
                        break;
                    case "WORKWEEKSUN":
                    case "WORKWEEKMON":
                    case "WORKWEEKTUE":
                    case "WORKWEEKWED":
                    case "WORKWEEKTHU":
                    case "WORKWEEKFRI":
                    case "WORKWEEKSAT":
                    case "REMEMBERUSERS":
                    case "SHOWONOPPORTUNITIES":
                    case "SHOWONREGARDING":
                    case "SHOWONPHONENUMBER":
                    case "SHOWONTIME":
                        var trueRE = /^(true|yes|T|1)$/i;
                        retValue = trueRE.test(value); // = sageUtility.Convert.toBoolean(value);
                        break;
                    case "LOADHISTORYONSTART":
                        var trueRE1 = /^(true|yes|T|Y|0)$/i;
                        retValue = trueRE1.test(value); // = sageUtility.Convert.toBoolean(value);
                        break;
                    case 'DAYSTARTTIME':
                        retValue = this.getHourPart(value);
                        if (retValue > 24) retValue = 9;
                        break;
                    case 'DAYENDTIME':
                        retValue = this.getHourPart(value);
                        if (retValue > 24) retValue = 17;
                        break;
                    case "NUMEVENTS":
                    case "DEFAULTINTERVAL":
                        retValue = parseInt(value, 10);
                        break;
                    default:
                        retValue = value;
                }
                return retValue;
            },
            getHourPart: function (value) {
                var dt = value.split(" ");
                var t, h;
                if (dt.length > 1 && value.indexOf("-") > 0) {
                    t = dt[1];
                    if (t) {
                        h = t.split(":")[0];
                    }
                } else {
                    h = value.split(":")[0];
                }
                if (value.indexOf('pm') > 0 || value.indexOf('PM') > 0) {
                    h = parseInt(h, 10) + 12;
                }
                return parseInt(h, 10);
            },
            getDay: function (value) {
                var retValue = value;
                if (value.length > 1) {
                    var daysArr = [];
                    daysArr["SUNDAY"] = 0;
                    daysArr["MONDAY"] = 1;
                    daysArr["TUESDAY"] = 2;
                    daysArr["WEDNESDAY"] = 3;
                    daysArr["THURSDAY"] = 4;
                    daysArr["FRIDAY"] = 5;
                    daysArr["SATURDAY"] = 6;
                    retValue = daysArr[value.toUpperCase()];
                }
                if (!retValue) retValue = 1;
                return retValue;

            },
            arraySort: function (a, b) {
                return a - b;
            }

        };

        return Sage.Utility.UserOptions;
    });

},
'Sage/MainView/ActivityMgr/ActivityEditorAttendeesTab':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define('Sage/MainView/ActivityMgr/ActivityEditorAttendeesTab', [
        'dojo',
        'dijit/_Widget',
        'Sage/_Templated',
        'dojo/_base/declare',
        'Sage/Data/SDataServiceRegistry',
        'Sage/Data/SingleEntrySDataStore',
        'Sage/Data/WritableSDataStore',
        'Sage/Utility',
        'Sage/Utility/Activity',
        'Sage/UI/SLXPreviewGrid',
        'Sage/UI/EditableGrid',
          'dijit/layout/ContentPane',
        'dojo/_base/lang',
        'dojo/DeferredList',
        'dojo/on',
        'dojo/_base/array',
        'dojo/topic',
        'dojo/string',
        'dojo/_base/Deferred',
        'Sage/MainView/ActivityMgr/AttendeeLookup/SpeedSearchLookup',
        'Sage/UI/Controls/SingleSelectPickList',
        'dojo/i18n!./nls/ActivityEditorAttendeesTab',
        'dojox/grid/cells/_base',
        'Sage/Extensions/UI/Columns/Radio',
        'Sage/Extensions/UI/Columns/CheckBox',
        'Sage/Extensions/UI/Columns/PickListSelect',
        'Sage/MainView/ActivityMgr/AttendeeLookup/LookupService'
],
    function (dojo, _Widget, _Templated, declare, sDataServiceRegistry, SingleEntrySDataStore, WritableSDataStore, utility, activityUtility, SlxPreviewGrid, EditableGrid,
        ContentPane, lang, DeferredList, on, array, topic, dstring, Deferred, SpeedSearchLookup, SingleSelectPickList, nlsStrings, AlwaysEdit, radio, checkBox,
        PickListSelect, lkupServie) {
        //The ActivityEditorAttendeesTab is a customization displaying how to add a tab to the activity dialog
        //  with a datagrid for adding and editing a collection of related entities.
        //The code to add it is below the declaration.
        var assocaitionsTab = declare('Sage.MainView.ActivityMgr.ActivityEditorAttendeesTab', [_Widget, _Templated], {
            actEditor: null,
            lup_Contact: null,
            lup_Lead: null,
            self: null,
            widgetsInTemplate: true,
            currentPrimaryEntityId: null,
            userContactAttendees: [],
            editorMode: null,
            resourceKind: 'activityAttendees',
            serviceName: 'dynamic',
            _activityId: null,
            _addedAttendees: null,
            _uncheckItem: null,
            _initialPrimaryContact: false,
            _gridStarted: false,
            _timeZones: [],
            _clearPrimary: false,
            constructor: function (options) {
                lang.mixin(this, options);
                lang.mixin(this, nlsStrings);
                var self = this;
                if (this._timeZones.length === 0) {
                    Sage.Utility.getTimeZones(function (result) {
                        self._timeZones = result;
                    });
                }
            },
            //the template for the tab content is simply a placeholder for the grid created in code
            widgetTemplate: new Simplate([
                '<div>',
                    '<div id="{%= $.id %}_attendeesGridPlaceholder" dojoAttachPoint="_attendeesGridPlaceholder" style="width:100%;height:100%;min-height:225px"></div>',
                '</div>'
            ]),
            userContactList: [],
            //keep an internal list of new _attendee items as they are added
            _newItems: [],
            //this is called once by the code that adds the tab to the activity editor.
            //build the grid and connect event listeners for important events.
            startup: function (readOnly) {
                //console.log("_attendeesTab startup");
                this._newItems = [];
                this._addedAttendees = [];
                //if we cannot find the editor, we really cannot do much, don't create the grid
                if (!this.actEditor) {
                    return;
                }
                this._activityId = utility.getCurrentEntityId();
                this._buildGrid(readOnly);

                //listen for when activities are saved so we can ensure the correct relationships and save the agenda
                dojo.subscribe('/entity/activity/create', this, this._activitySaved);
                dojo.subscribe('/entity/activity/change', this, this._activitySaved);

                //dojo.subscribe('/entity/activityAttendee/primaryClicked', this, this.primaryClicked);

                this.createLookups();
                this.self = this;
                var self = this;
            },
            primaryClicked: function (entity) {
                // console.log("primaryClicked -> Name :" + entity.Name + ",oldValue :" + entity.IsPrimary + ",NewValue:" + entity.checked);

                entity['attendeeTab'] = true;
                entity['PrimaryChecked'] = entity.checked;

                if (entity.checked) {
                    this._uncheckItem = entity;
                }

                if (!entity["AccountId"] && entity["EntityType"] == "Contact") {
                    activityUtility._getContactData(entity["EntityId"], function (contactData) {
                        if (contactData["Account"] && contactData["Account"]["$key"]) {
                            entity["AccountId"] = contactData["Account"]["$key"];
                        }
                        dojo.publish('/entity/activityAttendee/primaryChanged', [entity, this]);
                    }, this);
                } else if (!entity["AccountId"] && entity["EntityType"] == "Lead") {
                    activityUtility._getLeadData(entity["EntityId"], function (leadData) {
                        if (leadData["Account"] && leadData["Account"]["$key"]) {
                            entity["AccountId"] = leadData["Account"]["$key"];
                        }
                        dojo.publish('/entity/activityAttendee/primaryChanged', [entity, this]);
                    }, this);
                } else {
                    dojo.publish('/entity/activityAttendee/primaryChanged', [entity, this]);
                }
            },
            _primaryUnChecked: function (entity) {
                if (this.currentPrimaryEntityId !== entityId) {
                    console.log("new primary");
                } else {
                    console.log("");
                }
            },
            _getTimeZoneDisplayName: function (keyName) {
                var displayName = keyName;
                if (this._timeZones && this._timeZones.length > 0) {
                    var obj = this._timeZones.filter(function (val) {
                        return val.Keyname === keyName;
                    });
                    if (obj && obj[0]) {
                        displayName = obj[0].Displayname;
                    }
                }
                return displayName;
            },
            createToolsConfig: function () {
                //define the tools: an "add" button that calls our custom addItem and use the default "delete" functionality.
                var tools = [];
                tools = [
                    {
                        id: 'attendeeSpeedSearch',
                        imageClass: 'icon_plus_16x16',
                        handler: this.speedSearch,
                        tooltip: this.tooltip_speedSearch,
                        scope: this
                    },
                    {
                        id: 'attendeeAddContact',
                        imageClass: 'icon_Contact_Lookup_16x23',
                        //icon: './images/icons/Contact_Lookup_16x23.png',
                        handler: this.lookupContacts,
                        tooltip: this.tooltip_AddContact,
                        scope: this
                    },
                    {
                        id: 'attendeeeAddLead',
                        imageClass: 'icon_Lead_Lookup_16x23',
                        //icon: './images/icons/Lead_Lookup_16x23.png',
                        handler: this.lookupLeads,
                        tooltip: this.tooltip_AddLead,
                        scope: this
                    },
                    {
                        id: 'attendeeDelete',
                        imageClass: 'icon_Delete_16x16',
                        handler: this.deleteAttendees,
                        tooltip: this.tooltip_Delete,
                        scope: this
                    }
                ];
                return tools;
            },
            createColumnConfig: function (readOnly) {
                var primaryColumn, roleColumn, isAttendeeColumn;

                if (readOnly) {
                    primaryColumn = {
                        field: 'IsPrimary',
                        name: this.header_Primary,
                        width: '40px',
                        type: Sage.Extensions.Activity.primaryContactCheckBox1
                    };
                    roleColumn = {
                        field: 'RoleName',
                        name: this.header_RoleName
                    };
                    isAttendeeColumn = {
                        field: 'IsAttendee',
                        name: this.header_Attendee,
                        width: '70px',
                        type: Sage.Extensions.Activity.isAttendeeCheckBox1
                    };
                } else {
                    primaryColumn = {
                        field: 'IsPrimary',
                        name: this.header_Primary,
                        width: '40px',
                        editable: true,
                        radioType: 'group',
                        type: Sage.Extensions.UI.Columns.CheckBox,
                        checkBoxClicked: this.primaryClicked
                    };
                    roleColumn = {
                        field: 'RoleName',
                        name: this.header_RoleName,
                        pickListName: 'Attendee Role',
                        width: '130px',
                        type: Sage.Extensions.UI.Columns.PickListSelect,
                        options: ["Decision Maker", "Gate Keeper", "Other"],
                        editable: true
                    };
                    isAttendeeColumn = {
                        field: 'IsAttendee',
                        name: this.header_Attendee,
                        width: '70px',
                        editable: true,
                        radioType: 'group',
                        type: dojox.grid.cells.Bool
                    };
                }

                //define the columns:
                var columns = [
                    {
                        field: 'Name',
                        name: this.header_Name,
                        width: '150px',
                        editable: false
                    }, {
                        field: 'AccountName',
                        name: this.header_AccountName,
                        width: '150px',
                        editable: false
                    }, {
                        field: 'EntityType',
                        name: this.header_Type,
                        width: '60px',
                        editable: false
                    },
                    primaryColumn,
                    roleColumn,
                    isAttendeeColumn,
                    {
                        field: 'PhoneNumber',
                        name: this.header_Phone,
                        width: '100px',
                        editable: false
                    }, {
                        field: 'Email',
                        name: this.header_Email,
                        width: '150px',
                        editable: false
                    }, {
                        field: 'TimeZone',
                        name: this.header_TimeZone,
                        width: '150px',
                        editable: false
                    }
                ];
                return columns;
            },
            getSelect: function () {
                var select = [
                  'EntityType',
                  'EntityId',
                  'IsPrimary',
                  'Name',
                  'Description',
                  'Notes',
                  'AccountId',
                  'AccountName'
                ];
                return select;
            },
            getSort: function () {
                var sort = [{ attribute: 'Name' }];
                return sort;
            },
            contextualCondition: function () {
                // console.log('contextualCondition' + 'Activity.id eq \'' + self._activityId + '\'');
                var actId = this._activityId;
                if (actId && actId.length > 12) {
                    actId = actId.substr(0, 12);
                }
                return 'Activity.id eq \'' + actId + '\'';
            },
            getStoreOptions: function (readOnly) {
                var self1 = this;
                var options = {
                    readOnly: readOnly,
                    columns: this.createColumnConfig(readOnly),
                    tools: this.createToolsConfig(readOnly),
                    storeOptions: {
                        service: sDataServiceRegistry.getSDataService(this.serviceName),
                        resourceKind: this.resourceKind,
                        select: this.getSelect(),
                        sort: this.getSort(),
                        //newItemParentReferenceProperty: 'Activity',
                        onDataChange: lang.hitch(this, this.onGridDataChange),
                        onComplete: lang.hitch(this, this.onGridComplete),
                        clearStoreCacheOnDelete: false
                    },
                    slxContext: { 'workspace': '', tabId: '' },
                    contextualCondition: lang.hitch(this, this.contextualCondition),
                    id: this.id + '_attendees',
                    rowsPerPage: 40,
                    singleClickEdit: false,
                    enableCheckBoxSelection: false,
                    selectionMode: 'single'
                };
                //setting it to insert mode will have it use the writableStore.  This prevents the new
                // items from being posted to the server without the relationship to Activity.  When the
                // activity is saved, we will add the relationship and save the items at that point.
                if (this.editorMode.indexOf('New') === 0 || this.editorMode === "CompleteUnscheduled") {
                    options.storeOptions['isInsertMode'] = true;
                }
                return options;
            },
            onGridComplete: function (data, context) {
                var self1 = this;
                array.forEach(data, function (item, i) {
                    if (item["IsPrimary"]) {
                        this.currentPrimaryEntityId = item["EntityId"];
                    }
                    if (item["TimeZone"]) {
                        item["TimeZone"] = self1._getTimeZoneDisplayName(item["TimeZone"]);
                    }
                    //Rebind the edited but unsaved roles (to preserve the changed values between tab clicks)
                    if (self1._grid && self1._grid.mode !== "insert" && self1._grid.store && self1._grid.store.dirtyDataCache.isDirty) {
                        if (self1._grid.store.dirtyDataCache[item["$key"]]) {
                            item["RoleName"] = self1._grid.store.dirtyDataCache[item["$key"]]["RoleName"];
                            item["IsPrimary"] = self1._grid.store.dirtyDataCache[item["$key"]]["IsPrimary"];
                            item["IsAttendee"] = self1._grid.store.dirtyDataCache[item["$key"]]["IsAttendee"];
                        }
                    }
                });
            },
            onGridDataChange: function (entity, field, newValue) {
                return;
            },
            onGridBlur: function () {

            },
            //The "unsaved Data" message is not cleared as the "dirtyDataMsgID" is empty, overriding the method from EditableGrid.js
            onGridMarkClean: function () {
                if (this.dirtyDataMsgID) {
                    var dirtyDataMsg = dojo.byId(this.dirtyDataMsgID);
                    if (dirtyDataMsg) {
                        dojo.style(dojo.byId(this.dirtyDataMsgID), 'display', 'none');
                    }
                }
                var bindingMgr = Sage.Services.getService('ClientBindingManagerService');
                if (bindingMgr) {
                    bindingMgr.clearDirtyAjaxItem(this.id);
                }
            },
            onGridMarkDirty: function () {
                //Do not show the *unsaved message on top of the page
            },
            onGridFetchComplete: function () {
                if (this._grid.mode != "insert" && this._uncheckItem) {
                    //var chkBoxId = 'chk_IsPrimary_' + self._uncheckItem.EntityId;
                    //console.log("checkbox click" + self._uncheckItem.Name);
                    //dojo.byId(chkBoxId).click();
                }
                //Add the primary contact to grid
                if (this._initialPrimaryContact && this._gridStarted) {
                    //console.log("self._addPrimaryContact");
                    this._addPrimaryContact();
                    if (this._clearPrimary) {
                        this.clearPrimary(this._grid, 'IsPrimary');
                        this._clearPrimary = false;
                    }
                }
            },
            decalreCustomGridCell: function () {
                declare("Sage.Extensions.Activity.primaryContactCheckBox1", dojox.grid.cells.Bool, {
                    format: function (index, inItem) {
                        var value = Sage.Utility.getValue(inItem, "IsPrimary");
                        var checkbox = '<input type="checkbox" disabled="disabled" />';
                        if (value) {
                            checkbox = '<input type="checkbox" checked="checked" disabled="disabled" />';
                        }
                        return checkbox;
                    }
                });

                declare("Sage.Extensions.Activity.isAttendeeCheckBox1", dojox.grid.cells.Bool, {
                    format: function (index, inItem) {
                        var value = Sage.Utility.getValue(inItem, "IsAttendee");
                        var checkbox = '<input type="checkbox" disabled="disabled" />';
                        if (value) {
                            checkbox = '<input type="checkbox" checked="checked" disabled="disabled" />';
                        }
                        return checkbox;
                    }
                });

            },
            _buildGrid: function (readOnly) {
                //define the tools: an "add" button that calls our custom addItem and use the default "delete" functionality.
                this.decalreCustomGridCell();
                var actid = activityUtility.getCurrentActivityId();
                this._activityId = this._activityId || actid;

                //set up the rest of the grid options:
                var options = this.getStoreOptions(readOnly);

                //create the grid
                var grid = new SlxPreviewGrid.Grid(options, this._attendeesGridPlaceholder);

                grid.setSortColumn('Name');
                this._grid = grid._grid;

                dojo.connect(this._grid, 'onBlur', this, this.onGridBlur);

                //...and start it up
                grid.startup();

                //The "unsaved Data" message is not cleared as the "dirtyDataMsgID" is empty, overriding the method from EditableGrid.js
                this._grid.markClean = this.onGridMarkClean;
                this._grid.markDirty = this.onGridMarkDirty;

                dojo.connect(this._grid, "_onFetchComplete", this, this.onGridFetchComplete);
            },

            //Add Contact User to availability tab
            _addMemberToAvailabilityTab: function (memberData) {
                var members = [];
                members.push(memberData);
                this.actEditor.addMembers(members);
            },

            disableGrid: function () {
                this._grid.readOnly = true;
                this._grid.refresh();
            },

            //our handler for the "add" button
            saveGridChanges: function (callback) {
                //If we are not in insert mode, we should save existing changes before creating new items.
                //This prevents loss of data.  After the data is saved, we can create the new item.
                if (this._grid.mode !== 'insert') {
                    this._grid.saveChanges(lang.hitch(this, callback));
                } else {
                    callback();
                }
            },

            //Contact and Lead look up
            speedSearch: function () {
                var self = this;
                this._speedSearchLookup = new SpeedSearchLookup();
                this._speedSearchLookup.showLookup();

                this._speedSearchLookup.doSelected = function (items) {
                    self._processLookupResults(items);
                };
            },
            lookupContacts: function () {
                this.lup_Contact.seedProperty = 'Account.Id',
                this.lup_Contact.seedValue = this.actEditor._activityData.AccountId;
                this.lup_Contact.query.conditions = '';
                this.lup_Contact.buildSDataStoreQueryForSeeding();
                this.lup_Contact._originalQueryConditions = this.lup_Contact.query.conditions;
                this.lup_Contact.cancelText = this.lup_Contact.closeText;
                this.lup_Contact.overrideSeedValueOnSearch = true;
                this.lup_Contact.showLookup();
                var handle = dojo.connect(this.lup_Contact.lookupDialog, 'onHide', this.lup_Contact, function () {
                    dojo.disconnect(handle);
                    if (this.seedValue) {
                        this.resetGrid();
                    }
                });
            },
            lookupLeads: function () {
                this.lup_Lead.query.conditions = '';
                this.lup_Lead.buildSDataStoreQueryForSeeding();
                this.lup_Lead._originalQueryConditions = this.lup_Lead.query.conditions;
                this.lup_Lead.cancelText = this.lup_Lead.closeText;
                this.lup_Lead.showLookup();
            },
            //Callback method for Grid toolbar delete button
            deleteAttendees: function () {
                var selectedItems = this._grid.selection.getSelected();
                var self = this;
                this._grid.deleteSelected(function () {
                    if (selectedItems) {
                        for (var i = 0; i < selectedItems.length; i++) {
                            var selectedItem = selectedItems[i];

                            //Remove the Contact/Lead from General Tab if the deleted attendee is Primary
                            if (selectedItem.IsPrimary) {
                                selectedItem['attendeeTab'] = true;
                                selectedItem['PrimaryChecked'] = false;
                                dojo.publish('/entity/activityAttendee/primaryChanged', [selectedItem, this]);
                            }

                            //Remove the associated user from Availability tab
                            if (selectedItems[i].EntityType == 'Contact') {
                                var userId = self._checkUserContactAssociation(selectedItems[i].EntityId);
                                if (userId) {
                                    var args = { "memberId": userId, "attendeesTab": true };
                                    self.actEditor._removeMember(args);
                                }
                            }

                            if (i == selectedItems.length - 1) {
                                dojo.publish('/entity/activityAttendee/delete', [null, this]);
                            }
                        }
                    }
                });
            },
            _attendeeExists: function (entityId) {
                var count = this._grid.rowCount;
                // TODO: This check should be removed by avoiding duplicate addition to this._grid.store
                if (count === 0 && typeof (this._grid.store.dataCacheToArray) !== 'undefined' && count !== this._grid.store.dataCacheToArray().length) {
                    this._grid.store.deleteItem(this._grid.store.dataCacheToArray()[0]);
                }
                for (var i = 0; i < count; i++) {
                    var item = this._grid.getItem(i);
                    if (item.EntityId === entityId) {
                        return true;
                    }
                }
                return false;
            },
            resetPrimary: function (entityId) {
                var count = this._grid.rowCount;
                for (var i = 0; i < count; i++) {
                    var item = this._grid.getItem(i);
                    if (item.EntityId !== entityId) {
                        item.IsPrimary = false;
                    }
                }
            },
            unCheckPrimary: function () {
                if (this._grid.mode == "insert") {
                    this.resetPrimary();
                } else {
                    if (!this._gridStarted) {
                        this._clearPrimary = true;
                        return;
                    }
                    var count = this._grid.rowCount;
                    for (var i = 0; i < count; i++) {
                        var item = this._grid.getItem(i);
                        if (item.IsPrimary) {
                            //If edit mode, store the item to be unchecked and do the uncheck after the grid refreshes
                            this._uncheckItem = item;
                            dojo.publish('/entity/activityAttendee/primaryChanged', [item, this]);
                        }
                    }
                    this.clearPrimary(this._grid, 'IsPrimary');
                }
            },
            clearPrimary: function (grid, inAttrName) {
                var count = grid.rowCount;
                for (var i = 0; i < count; i++) {
                    var item = grid.getItem(i);
                    var chkBoxId = 'chk_' + inAttrName + '_' + item.EntityId;
                    dojo.byId(chkBoxId).checked = false;
                    grid.store.setValue(item, inAttrName, false);
                }
            },
            resetRows: function (grid, rowIndex, inAttrName, currentItem) {
                var count = grid.rowCount;
                var chkBoxId = '';
                for (var i = 0; i < count; i++) {
                    var item = grid.getItem(i);
                    if (item && item.EntityId !== currentItem.EntityId) {
                        chkBoxId = 'chk_' + this.field + '_' + item.EntityId;
                        dojo.byId(chkBoxId).checked = false;
                        grid.store.setValue(item, inAttrName, false);
                    } else if (item && item.EntityId === currentItem.EntityId) {
                        chkBoxId = 'chk_' + this.field + '_' + item.EntityId;
                        //dojo.byId(chkBoxId).checked = false;
                        grid.store.setValue(item, inAttrName, true);
                    }
                }
            },
            resetEntityContext: function () {
                var parentRelationshipName = this.parentRelationshipName;
                var entityId = utility.getCurrentEntityId();
                if (parentRelationshipName === 'activityId') {
                    entityId = entityId.substr(0, 12); // for reoccurring activity Ids;
                }
                var contextualCondition = function () {
                    return (parentRelationshipName || '\'A\'') + ' eq \'' + entityId + '\'';
                };
                this._previewGrid.resetContextualCondition(contextualCondition);
                this.refresh();
            },
            //Process result data retrieved from Speed Search look up and update the Grid
            _processLookupResults: function (results) {
                var attendees = [];
                var leadAttendees = [];
                for (var i = 0; i < results.length; i++) {
                    if (!this._attendeeExists(results[i].$key)) {
                        attendees.push(this._setAttendeeEntity(results[i]));
                        if (results[i].type == "Contact") {
                            this._getSlxAssociation("Contact", results[i].$key, null, function (data) {
                                if (data && data.length > 0 && data[0].UserId) {
                                    this._updateUserContactList(data[0].UserId, data[0].ContactId);
                                    this._getResourceData(utility.getClientContextByKey('userID'), data[0].UserId, this._addMemberToAvailabilityTab, this);
                                }
                            }, this);
                        }
                    }
                }
                if (attendees.length > 0) {
                    this._addAttendeesToStore(attendees);
                }
            },
            //Process result data retrieved from Contact Look up and update the Grid
            _processContactLookupResults: function (results) {
                var contactAttendees = [];
                for (var i = 0; i < results.length; i++) {
                    if (!this._attendeeExists(results[i].$key)) {
                        results[i].EntityType = 'Contact';
                        var _attendee = this._setAttendeeEntityFromContactLead("Contact", results[i]);
                        _attendee["IsAttendee"] = true;
                        contactAttendees.push(_attendee);
                        results[i].New = true;
                    }
                }
                if (contactAttendees.length > 0) {
                    this._addAttendeesToStore(contactAttendees);
                }

                for (var i = 0; i < results.length; i++) {
                    //Check if Contact is associated with User, if so, add the associated user to Availability tab
                    if (results[i].New && results[i].ContactUser && results[i].ContactUser.$resources && results[i].ContactUser.$resources.length > 0) {
                        this._updateUserContactList(results[i].ContactUser.$resources[0].UserId, results[i].$key);
                        this._getResourceData(utility.getClientContextByKey('userID'), results[i].ContactUser.$resources[0].UserId, this._addMemberToAvailabilityTab, this);
                    }
                }
            },
            //Process result data retrieved from Lead Look up and update the Grid
            _processLeadLookupResults: function (results) {
                var leadAttendees = [];
                for (var i = 0; i < results.length; i++) {
                    if (!this._attendeeExists(results[i].$key)) {
                        results[i].EntityType = 'Lead';
                        var _attendee = this._setAttendeeEntityFromContactLead("Lead", results[i]);
                        _attendee["IsAttendee"] = true;
                        leadAttendees.push(_attendee);
                    }
                }
                if (leadAttendees.length > 0) {
                    this._addAttendeesToStore(leadAttendees);
                }
            },
            getFieldValue: function (fields, name) {
                for (var i = 0; i < fields.length; i++) {
                    var field = fields[i];
                    if (field.fieldName == name) {
                        return field.fieldValue;
                    }
                }
                return '';
            },
            _setAttendeeEntity: function (results) {
                var attendeeEntity = {};
                attendeeEntity.EntityType = results.type;
                attendeeEntity.EntityId = results.$key;
                attendeeEntity.IsPrimary = false;
                attendeeEntity.Name = results.$descriptor;
                attendeeEntity.AccountName = this.getFieldValue(results.fields, 'account');
                attendeeEntity.Email = this.getFieldValue(results.fields, 'email');
                attendeeEntity.Description = "";
                attendeeEntity.Notes = "";
                attendeeEntity.TimeZone = "";
                attendeeEntity.PhoneNumber = this.getFieldValue(results.fields, 'phone');
                attendeeEntity.RoleName = "";
                attendeeEntity.general = false;
                attendeeEntity.IsAttendee = true;
                return attendeeEntity;
            },
            _setAttendeeEntityFromContactLead: function (type, results) {
                var attendeeEntity = false;
                if (results && results.$key) {
                    attendeeEntity = {};
                    attendeeEntity.EntityType = type;
                    attendeeEntity.EntityId = results.$key;
                    attendeeEntity.$key = results.$key;
                    attendeeEntity.IsPrimary = false;
                    attendeeEntity.Name = results.$descriptor;
                    attendeeEntity.$descriptor = results.$descriptor;
                    attendeeEntity.Account = results.Account;
                    attendeeEntity.AccountName = results.AccountName || results.Company;
                    if (type == "Lead") {
                        attendeeEntity.Company = results.Company;
                        attendeeEntity.LeadFullName = results.$descriptor;
                    }
                    attendeeEntity.Company = results.Company;
                    attendeeEntity.Email = results.Email;
                    attendeeEntity.Description = "";
                    attendeeEntity.Notes = "";
                    if (results.Address) {
                        attendeeEntity.TimeZone = results.Address.TimeZone;
                        if (attendeeEntity.TimeZone) {
                            attendeeEntity.TimeZone = this._getTimeZoneDisplayName(attendeeEntity.TimeZone);
                        }
                    }
                    attendeeEntity.PhoneNumber = results.WorkPhone;
                    attendeeEntity.RoleName = "";
                    attendeeEntity.general = false;

                }
                return attendeeEntity;
            },
            //Get Current user's security access to the given User Id
            _getResourceData: function (currentUserId, accessTo, callback, scope) {
                this.accessData = false;
                if (!this._accessStore) {
                    this._accessStore = new SingleEntrySDataStore({
                        include: ['$descriptors'],
                        resourceKind: 'activityresourceviews',
                        service: sDataServiceRegistry.getSDataService('dynamic')
                    });
                }
                this._accessStore.fetch({
                    predicate: "'" + accessTo + "-" + currentUserId + "'",
                    onComplete: function (accessData) {
                        callback.call(scope, accessData);
                    },
                    onError: function () {
                        callback.call(scope, null);
                    },
                    scope: this
                });
            },
            //Check if the Contact/User is associated
            _getSlxAssociation: function (type, entityId, scopeObj, callback, scope) {
                this.accessData = false;
                if (!this._associationStore) {
                    this._associationStore = new WritableSDataStore({
                        include: ['$descriptors'],
                        resourceKind: 'contactusers',
                        select: ['UserId', 'ContactId', 'Contact/Name', 'Contact/Email', 'Contact/WorkPhone', 'Contact/AccountName', 'User/Name'],
                        service: sDataServiceRegistry.getSDataService('dynamic')
                    });
                }
                var _query = "";
                if (type == "Contact") {
                    _query = dstring.substitute('ContactId eq \'${0}\' ', [entityId]);
                } else if (type == 'User') {
                    _query = dstring.substitute('UserId eq \'${0}\' ', [entityId]);
                }
                this._associationStore.fetch({

                    query: _query,

                    //predicate: "'" + accessTo + "-" + currentUserId + "'",
                    onComplete: function (accessData) {
                        callback.call(scope, accessData, scopeObj);
                    },
                    onError: function () {
                        callback.call(scope, null);
                    },
                    scope: this
                });
            },
            //Maintain a local list of Contact User association
            _updateUserContactList: function (userId, contactId) {
                if (!this.userContactList[userId]) {
                    this.userContactList[userId] = { "UserId": userId, "ContactId": contactId };
                }
            },
            //Verify if the provided ContactIs has associated UserId
            _checkUserContactAssociation: function (contactId) {
                var userId = false;
                if (this.userContactList) {
                    for (var i in this.userContactList) {
                        if (this.userContactList[i]["ContactId"] == contactId) {
                            userId = this.userContactList[i]["UserId"];
                            break;
                        }
                    }
                }
                return userId;
            },
            /**
            * Gets called when members are added to Availability Tab.
            * If the member has associated Contact, add it to Attendees Tab.
            * @param {String} userIds String array of Userids
            */
            _addContactAttendees: function (userIds) {

                var deferredArray = [];
                var len = userIds.length;
                var self = this;

                for (var i = 0; i < len; i++) {
                    deferredArray.push(this._getAssociationData(userIds[i]));
                }

                var deferredList = new DeferredList(deferredArray);

                //After checking all the userIds, add it to the store
                deferredList.then(function (result) {
                    for (var j = 0; j < result.length; j++) {
                        if (result[j][1]) {
                            self.userContactAttendees.push(result[j][1]);
                        }
                    }
                    self._addAttendeesToStore(self.userContactAttendees);
                    self.userContactAttendees = [];
                });
            },
            /**
            * Deferred method to get the association data if exists.
            * If the member has associated Contact, add it to Attendees Tab.
            * @param {String} userId
            */
            _getAssociationData: function (userId) {
                var d = new Deferred();
                var scopeObj = { "last": false };
                //var self = this;
                this._getSlxAssociation("User", userId, scopeObj, function (data, scope) {
                    if (data && data.length > 0) {
                        var attendeeEntity = null;
                        if (data[0].Contact) {
                            this._updateUserContactList(data[0].UserId, data[0].ContactId);
                            attendeeEntity = this._setAttendeeEntityFromContactLead('Contact', data[0].Contact);
                        }
                        d.resolve(attendeeEntity);
                    }
                }, this);

                return d;
            },
            _addPrimaryContact: function (contact) {
                if (this._initialPrimaryContact) {
                    if (!this._attendeeExists(this._initialPrimaryContact["$key"])) {
                        this._addContactAttendee(this._initialPrimaryContact);
                    }
                }
                this._initialPrimaryContact = false;
            },
            /**
            * Event listener for General Tab Contact update.
            * @param {object} contact
            */
            _addContactAttendee: function (contact) {
                var attendees = [];
                var attendee = null;
                if (contact) {
                    this.resetPrimary(contact['$key']);

                    if (this._grid.mode !== "insert") {
                        //    this._grid.saveChanges();
                    }
                    if (contact.Account) {
                        contact.AccountName = contact.Account.AccountName;
                        attendee = this._setAttendeeEntityFromContactLead('Contact', contact);
                        attendee.IsPrimary = true;
                        attendee.general = true;
                        attendees.push(attendee);
                        // this.saveGridChanges(this._addAttendeesToStore(attendees, true));
                        this._addAttendeesToStore(attendees, true);
                    } else {
                        // this._removeContactAttendee();
                        activityUtility._getContactData(contact.$key, function (data) {
                            if (data) {
                                attendee = this._setAttendeeEntityFromContactLead('Contact', data);
                                attendee.IsPrimary = true;
                                attendee.general = true;
                                attendees.push(attendee);
                                //this.saveGridChanges(this._addAttendeesToStore(attendees, true));
                                this._addAttendeesToStore(attendees, true);
                            }
                        }, this);
                    }
                }
            },
            _addLeadAttendee: function (lead) {
                var attendees = [];
                var attendee = null;
                if (lead) {
                    this.resetPrimary(lead['$key']);
                    if (!lead.Email && !lead.WorkPhone) {
                        this._removeLeadAttendee();
                        activityUtility._getLeadData(lead.$key, function (data) {
                            if (data) {
                                attendee = this._setAttendeeEntityFromContactLead('Lead', data);
                                attendee.general = true;
                                attendee.IsPrimary = true;
                                attendees.push(attendee);
                                this._addAttendeesToStore(attendees, true);
                            }
                        }, this);
                    } else {
                        attendee = this._setAttendeeEntityFromContactLead('Lead', lead);
                        attendee.general = true;
                        attendee.IsPrimary = true;
                        attendees.push(attendee);
                        this._addAttendeesToStore(attendees, true);
                    }
                }
            },
            _removeAssociatedContact: function (userId) {
                if (this.userContactList[userId]) {
                    var self = this;
                    var contactId = this.userContactList[userId]["ContactId"];
                    var count = this._grid.rowCount;
                    for (var i = 0; i < count; i++) {
                        var item = this._grid.getItem(i);
                        if (item.EntityId === contactId) {

                            self._grid.store.deleteItem(item);

                            if (item.IsPrimary) {
                                item['attendeeTab'] = true;
                                item['PrimaryChecked'] = false;
                                dojo.publish('/entity/activityAttendee/primaryChanged', [item, this]);
                            }
                            break;
                        }
                    }
                }
            },
            checkStoreItem: function (entityId) {
                var self = this;
                var deferred = new Deferred();

                this._grid.store.fetch({
                    onComplete: function (items) {
                        var storeItem = false;
                        dojo.forEach(items, function (item, index) {
                            if (item && item.EntityId == entityId) {
                                storeItem = true;
                            }
                        });
                        deferred.resolve(storeItem);
                    }
                });
                return deferred;
            },
            _removeContactAttendee: function () {
                var self = this;
                this._grid.store.fetch({
                    onComplete: function (items) {
                        dojo.forEach(items, function (item, index) {
                            if (item && item.general && item.EntityType == "Contact") {
                                self._grid.store.deleteItem(item);
                            }
                        })
                    }
                });
            },
            _removeLeadAttendee: function () {
                var self = this;
                this._grid.store.fetch({
                    onComplete: function (items) {
                        dojo.forEach(items, function (item, index) {
                            if (item && item.general && item.EntityType == "Lead") {
                                self._grid.store.deleteItem(item);
                            }
                        })
                    }
                });
            },
            _addLeadAttendees: function (leadIds) {
                var grid = this._grid;
                var service = Sage.Data.SDataServiceRegistry.getSDataService('dynamic');
                var fnAdd = function () {
                    var request = new Sage.SData.Client.SDataServiceOperationRequest(service)
                       .setResourceKind('activities')
                       .setOperationName('AddLeadAttendees');
                    var actId = utility.getCurrentEntityId();;
                    var entry = {
                        "$name": "AddLeadAttendees",
                        "request": {
                            "ActivityId": actId,
                            "leadIds": leadIds.join()
                        }
                    };
                    request.execute(entry, {
                        success: function (result) {
                            grid.refresh();
                        },
                        failure: function (result) {
                            Sage.UI.Dialogs.showError(dojo.string.substitute("Error adding lead attendees", [result]));
                            grid.refresh();
                        }
                    });
                };
                if (leadIds.length > 0) {
                    grid.showLoading();
                    fnAdd();
                }
            },
            _getNewContactAttendees: function () {
                return this._newItems;
            },
            setInitialPrimaryContact: function (contact) {
                this._initialPrimaryContact = contact;
            },
            refreshGrid: function () {
                this._grid.saveChanges();
                this._grid.refresh();
            },
            _addAttendeesToStore: function (attendees, fromGeneralTab) {
                var actid = utility.getCurrentEntityId();
                var updated = false;
                var self = this;

                if (this._grid.mode === 'insert' || !actid) {
                    var newAttendees = [];
                    for (var i = 0; i < attendees.length; i++) {
                        var attendee = attendees[i];
                        if (!this._attendeeExists(attendee.EntityId)) {
                            var index = -1;
                            for (var j = 0, len = this._newItems.length; j < len; j++) {
                                if (this._newItems[j]["$key"] === attendee.EntityId) {
                                    index = j;
                                    break;
                                }
                            }
                            if (index === -1) {
                                this._newItems.push(attendee);
                            }
                            newAttendees.push(attendee);
                        }
                    }
                    //if we are inserting the activity, just let the WritableStore cache it, we'll POST it later
                    this._grid.store.addItemsToCache(this, newAttendees);

                } else {
                    //if we are not in insert mode, the grid will have a WritableSDataStore, let it save the
                    //new item now so the refresh below will get the item.
                    var deferredArray = [];
                    //console.log("_addAttendeesToStore call deferred :");
                    for (var i = 0; i < attendees.length; i++) {
                        var attendee = attendees[i];
                        attendee["Account"] = null;
                        if (!this._attendeeExists(attendee.EntityId)) {
                            this._newItems.push(attendee);
                            attendee.Activity = { '$key': actid };
                            deferredArray.push(this._saveGridActivityAttendee(attendee));
                        }
                    }
                    var d1 = new DeferredList(deferredArray);
                    d1.then(function (results) {
                        //console.log("_addAttendeesToStore resolved :");
                        dojo.publish('/entity/activityAttendee/add', [results.length, this]);

                        if (fromGeneralTab && attendees && attendees.length > 0) {
                            //  self.resetPrimary(attendees[0]['EntityId']);
                        }
                    });
                }
                this._grid.refresh();
            },
            _saveGridActivityAttendee: function (attendee) {
                var d = new Deferred();
                this._grid.store.saveNewEntity(attendee, function () {
                    //console.log("_saveGridActivityAttendee success :" + attendee.$key);
                    d.resolve("success");
                }, function () {
                    //console.log("_saveGridActivityAttendee failure :" + attendee.$key);
                    d.resolve("success");
                },
                this);
                return d;
            },
            _addAdhocAttendee: function () {
                this._grid.store.newItem({
                    onComplete: function (attendee) {
                        //After the datastore has created the item for us, we can set the relationship property
                        var actid = utility.getCurrentEntityId();
                        if (!actid) {
                            actid = this.actEditor._makeTempID();
                        }
                        attendee.Activity = { '$key': actid };
                        //Set a default item order for this agenda item
                        //association.ItemOrder = this._grid.rowCount + 1;
                        //Add it to our list of new agenda items
                        this._newItems.push(association);
                        if (this._grid.mode === 'insert') {
                            //if we are inserting the activity, just let the WritableStore cache it, we'll POST it later
                            this._grid.store.addToCache(this, attendee, 1);
                        } else {
                            //if we are not in insert mode, the grid will have a WritableSDataStore, let it save the
                            //new item now so the refresh below will get the item.
                            this._grid.store.saveNewEntity(attendee);
                        }
                        //refresh the list so we see the new item.
                        this._grid.refresh();
                    },
                    scope: this
                });
            },
            //Handler for when activities are saved (new or changed)
            _activitySaved: function (activity) {
                var deferred = new Deferred();
                //console.log("_activitySaved1");

                if (this._grid.mode === 'insert') {
                    //If the grid is in insert mode, the activity was a new one so we need to set the
                    // relationship to the new Activity Id and then POST them
                    var actid = activity['$key'];
                    var count = 0;
                    var deferredArray = [];
                    var selectedItems = [];
                    var primaryAttendee = null;
                    for (var i = 0; i < this._newItems.length; i++) {
                        count = i;
                        var itm = this._newItems[i];
                        itm["Account"] = null;
                        itm['Activity'] = { '$key': actid };

                        if (!itm["IsPrimary"]) {
                            //POST ActivityAttendee only if it is non primary
                            //Add it to deferred array to execute
                            selectedItems.push(itm);
                        } else {
                            //UPDATE activity attendee if its primary
                            primaryAttendee = itm;
                        }
                    }
                    if (selectedItems.length > 0) {
                        deferredArray.push(this._saveActivityAttendees(selectedItems));
                    }
                    this._newItems = [];
                    if (primaryAttendee) {
                        //The primary Contact/Lead will get inserted as part of Activity Insert by business rules
                        //We need to update the columns isAttendee and Role name
                        var def = this._updatePrimaryAttendee(primaryAttendee, activity)
                        deferredArray.push(def);
                    }
                    // create a DeferredList to aggregate the state
                    // Wait until all the activity attendees getting saved and primary is updated
                    // to get the correct count on the activity list view
                    var d1 = new DeferredList(deferredArray, false);
                    d1.then(function (results) {
                        deferred.resolve({ success: true });
                    });

                } else {
                    //Because the grid was not in insert mode, the items had the correct relationship
                    // we just need to PUT and data changes that happened.
                    this._grid.saveChanges();
                    deferred.resolve({ success: true });
                    this._newItems = [];
                    this._uncheckItem = null;
                }

                return deferred;
            },
            _updatePrimaryAttendee: function (attendee, activity) {
                var deferred = new Deferred();
                var service = Sage.Data.SDataServiceRegistry.getSDataService('dynamic');
                var request = new Sage.SData.Client.SDataServiceOperationRequest(service)
                    .setResourceKind('activities')
                    .setOperationName('UpdatePrimaryActivityAttendee');
                var entry = {
                    "$name": "UpdatePrimaryActivityAttendee",
                    "request": {
                        "entity": activity,
                        "entityId": attendee.EntityId,
                        "isAttendee": attendee.IsAttendee,
                        "roleName": attendee.RoleName
                    }
                };
                request.execute(entry, {
                    success: function (result) {
                        deferred.resolve({ success: true });
                    },
                    failure: function (ex) {
                        console.log("failed to Update Attendee");
                    },
                    scope: this
                });
                return deferred;
            },
            //Handler for history created
            _historySaved: function (history) {
                var deferred = new Deferred();
                //console.log("_activitySaved1");

                if (this._grid.mode === 'insert') {
                    //If the grid is in insert mode, the activity was a new one so we need to set the
                    // relationship to the new Activity Id and then POST them
                    var histid = history['$key'];
                    var count = 0;
                    var deferredArray = [];
                    var entityId = "";
                    for (var i = 0; i < this._newItems.length; i++) {
                        count = i;
                        var itm = this._newItems[i];
                        itm["Account"] = null;
                        itm['History'] = { '$key': histid };

                        if (entityId !== itm["EntityId"]) {
                            //Add it to deferred array to execute
                            deferredArray.push(this._saveHistoryAttendee(itm));
                            entityId = itm["EntityId"];
                        }
                    }

                    this._newItems = [];
                    // create a DeferredList to aggregate the state
                    //Wait until all the activity attendees getting saved, to get the correct count on the activity list view
                    var d1 = new DeferredList(deferredArray);
                    d1.then(function (results) {
                        deferred.resolve({ success: true });
                    });
                }

                return deferred;
            },
            _saveActivityAttendee: function (itm) {
                var deferred = new Deferred();
                var self = this;
                var req = new Sage.SData.Client.SDataSingleResourceRequest(sDataServiceRegistry.getSDataService('dynamic'))
                           .setResourceKind('activityAttendees')
                           .create(itm, {
                               success: function () {
                                   deferred.resolve("success");
                               },
                               failure: function () {
                                   console.log('item did not save');
                               },
                               scope: this
                           });
                return deferred;
            },
            _saveActivityAttendees: function (selectedItems) {
                var deferred = new Deferred();
                var batchRequest = new Sage.SData.Client.SDataBatchRequest(sDataServiceRegistry.getSDataService('dynamic'));
                batchRequest.setResourceKind('activityAttendees');
                batchRequest.using(lang.hitch(this, function () {
                    for (var i = 0; i < selectedItems.length; i++) {
                        var request = new Sage.SData.Client.SDataSingleResourceRequest(sDataServiceRegistry.getSDataService('dynamic'));
                        request.setResourceKind('activityAttendees');
                        request['create'](selectedItems[i], { scope: this, ignoreETag: true });
                    }
                }));

                batchRequest.commit({
                    scope: this,
                    ignoreETag: true,
                    success: function (entry) {
                        deferred.resolve("success");
                    },
                    failure: function (err) {
                        console.error(err);
                    }
                });
                return deferred;
            },
            _saveHistoryAttendee: function (itm) {
                var deferred = new Deferred();
                var self = this;
                var req = new Sage.SData.Client.SDataSingleResourceRequest(sDataServiceRegistry.getSDataService('dynamic'))
                           .setResourceKind('historyAttendees')
                           .create(itm, {
                               success: function () {
                                   deferred.resolve("success");
                               },
                               failure: function () {
                                   console.log('item did not save');
                               },
                               scope: this
                           });
                return deferred;
            },

            //Handler for when the activity dialog closes
            _dialogHide: function () {
                //just a little house cleaning.
                this._newItems = [];
                this._grid.store.clearCache();
                this._grid._clearData();
                this._grid.markClean();
                this._uncheckItem = null;
                this._gridStarted = false;
            },
            destroy: function () {
                this.lup_Contact.destroy();
                this.lup_Lead.destroy();
                this._gridStarted = false;
                this.inherited(arguments);
            },
            //Handler for when the tab is opened.
            _tabShow: function () {
                if (this._grid) {

                    //check to see if the activity is a new one or not so we can set the grid
                    // to be in the correct "mode".
                    var gridmode = this._grid.get('mode');
                    if (this.editorMode.indexOf('New') == 0 || !this._activityId) {
                        this._grid.set('mode', 'insert');
                    } else {
                        this._grid.set('mode', '');
                    }

                    this._grid.refresh();
                    if (this.lup_Contact) {
                        this.lup_Contact.resetGrid();
                        this.lup_Contact.destroy();
                    }

                    if (this.lup_Lead) {
                        this.lup_Lead.resetGrid();
                        this.lup_Lead.destroy();
                    }

                    this.createLookups();
                    this._gridStarted = true;
                }
            },
            createLookups: function () {
                var srvc = Sage.Services.getService('LookupService');
                if (srvc) {
                    var self = this;
                    var contactLookup = srvc.getLookupInstance("Contact", "activityContactAttendee");
                    if (contactLookup) {

                        this.lup_Contact = contactLookup;
                        this.lup_Contact.doSelected = function (items) {
                            self._processContactLookupResults(items);
                            //this.lookupDialog.hide();
                        }
                    }
                    var leadLookup = srvc.getLookupInstance("Lead", "activityLeadAttendee");
                    if (leadLookup) {
                        this.lup_Lead = leadLookup;
                        leadLookup.doSelected = function (items) {
                            self._processLeadLookupResults(items);
                            //this.lookupDialog.hide();
                        }
                    }
                }
            },
            setToReadOnly: function (readOnly) {
                var disableList = ['attendeeSpeedSearch',
                                 'attendeeAddContact',
                                 'attendeeeAddLead',
                                 'attendeeDelete'
                ];
                this._bulkSetProperty(this, disableList, 'disabled', readOnly);
            },
            _bulkSetProperty: function (ui, propsList, prop, val) {
                for (var i = 0; i < propsList.length; i++) {
                    var ctrl = dijit.byId(propsList[i]);
                    if (ctrl) {
                        ctrl.set(prop, val);
                    }
                }
            }
        });

        return assocaitionsTab;
    });

},
'Sage/UI/SLXPreviewGrid':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
        './SLXPreviewGrid/Grid',
        './SLXPreviewGrid/FilterPanel',
        './SLXPreviewGrid/Filter/DateRange',
        './SLXPreviewGrid/Filter/Text'
],
function (Grid, FilterPanel, DateRange, Text) {
    // Dirty hack because SLXPreviewGrid was not done properly.
    return {
        Grid: Grid,
        FilterPanel: FilterPanel,
        Filter: {
            DateRange: DateRange,
            Text: Text
        }
    };
});

},
'Sage/UI/SLXPreviewGrid/Grid':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define, TabControl */
define([
    'Sage/UI/EditableGrid',
    'dijit/layout/BorderContainer',
    'dijit/form/SimpleTextarea',
    'dijit/_Widget',
    'dijit/_Templated',
    'dojo/i18n!../nls/SLXPreviewGrid',
    'dojo/_base/declare'
],
function (EditableGrid, BorderContainer, SimpleTextarea, _Widget, _Templated, i18nStrings, declare) {
    //dojo.requireLocalization("Sage.UI", "SLXPreviewGrid");
    var Grid = declare("Sage.UI.SLXPreviewGrid.Grid", [_Widget, BorderContainer], {
        // summary: 
        //  Editable grid with support for filter + preview area    

        // i18n strings:
        filterText: 'Filter',
        // end i18n strings

        // Fields    
        // name of sdata resource
        ////    resourceKind: "",
        // name of field to be displayed in preview pane (XXX: do we need a template?)
        previewField: "",
        // array of column configuration objects, with following properties:
        //   - field (SData field)
        //   - name (column header)
        //   - filterConfig: optional filter configuration, the "widgetType" property is 
        //      the type of filter widget to use, the rest is passed to the widget
        //   - width: the width can be specified as a pixel width ('30px')
        columns: null,
        // optional array of tools to be added to the toolbar (see EditableGrid)
        tools: null,
        // SLX context parameter: workspace, tabId
        slxContext: null,
        // optional function to be invoked when the user double clicks a row.  
        // Will be invoked with an "id" parameter (sdata $key for the selected row), 
        //    and the record object itself (use Sage.Utility.getValue to extract data from it)
        dblClickAction: null,
        contextualConditionFunction: null,
        liveSplitters: true,
        gutters: false,
        gridNodeId: '',
        _filter: null, // filter panel
        _grid: null, // EditableGrid instance
        _preview: null, // preview widget
        constructor: function () {
            this.connections = [];
        },
        amIInATab: function () {
            if (this.slxContext && this.slxContext.workspace) {
                return (this.slxContext.workspace.indexOf('TabWorkspace') > -1);
            }
            return false;
        },
        isMyTabVisible: function () {
            if (this.amIInATab() && TabControl) {
                return TabControl.getState().isTabVisible(this.slxContext.tabId);
            }

            return true;
        },

        // Widget lifecycle

        postMixInProperties: function () {
            dojo.mixin(this, i18nStrings);
            this.inherited(arguments);
        },

        buildRendering: function () {
            this.inherited(arguments);

            if (this.previewField) {
                this._preview = this._buildPreview();
            }

            this._filter = this._buildFilter();
            this._grid = this._buildGrid();
        },

        startup: function () {
            if (this._started) {
                return;
            }

            console.warn('ToDo: SLXPreviewGrid needs to connect to tab change events to properly refresh themselves.   SLXPreviewGrid - startup()');
            this.inherited(arguments);

            this.domNode.style.visibility = "visible";
            if (this._preview) {
                var splitter = this.getSplitter('right');
                this.connections.push(dojo.connect(splitter, "_stopDrag", this, function () {
                    this._setPref('previewSize', this._preview.domNode.style.width);
                    this.layout();
                }));
            }
        },

        // Public API

        getSelectedRecords: function (fields) {
            // summary:
            //  Retrieve an array of records selected in the grid.
            // fields:
            //  array of fields to extract data for.  For example, ["LongNotes", "ContactName"].  The returned objects
            //  will be plain JS objects with LongNotes and ContactName properties.
            var selIndices = this._grid.selection.getSelected();
            return dojo.map(selIndices, function (rec) {
                var result = {};
                dojo.forEach(fields, function (fieldName) {
                    result[fieldName] = this._grid.store.getValue(rec, fieldName);
                }, this);
                return result;
            }, this);
        },
        refresh: function () {
            // summary:
            //  Refreshes the grid's data (this does not affect the filter)
            this._grid.refresh();
        },

        setSortIndex: function (index, isAsend) {
            // summary:
            //  Set the Default sort column.
            this._grid.setSortIndex(index, isAsend);
        },
        setSortColumn: function (columnName, isAsend) {
            // summary:
            //  Set the Default sort column.
            var index = 0;
            for (var i = 0; i < this.columns.length; i++) {
                if (columnName === this.columns[i].field) {
                    index = i;
                }
            }
            this._grid.setSortIndex(index, isAsend);
        },

        addAssociatedItems: function () {
            // summary:
            //  Redirects to the grid's methods - this is a convenience for when the grid is used on a QF
            this._grid.addAssociatedItems.apply(this._grid, arguments);
        },

        // Events

        onSelected: function () {
            // summary:
            //  Fires when a record is selected in the grid       
        },

        // Private Helpers
        _buildPreview: function () {
            // summary:
            //  build and return preview widget
            var preview = new SimpleTextarea({
                style: 'height:100%; overflow: auto; width: ' + this._getPref('previewSize', '150px'),
                region: 'right',
                splitter: true,
                readOnly: true
            });
            this.addChild(preview);
            dojo.addClass(preview.domNode, 'preview-grid-text');
            return preview;
        },
        _buildGrid: function () {
            // summary:
            //  build and return grid widget        
            var tools = [];
            if (this._filter) {
                tools.push({
                    id: this.id + '_Filter',
                    imageClass: 'icon_Filter_16x16',
                    tooltip: this.filterText,
                    handler: dojo.hitch(this, function () {
                        this._filter.toggle();
                        this.layout();
                    })
                });
            }
            if (this.tools) {
                dojo.forEach(this.tools, function (item) { tools.push(item); });
            }

            var contextualCondition = { fn: this.contextualConditionFunction ||
                this.contextualCondition, conditions: this._filter ? this._filter.getQuery() : null
            };

            if (!this.storeOptions) {
                throw ("SLXPreviewGrid configuration is missing storeOptions");
            }

            this.storeOptions.select = this.storeOptions.select || [];
            this.storeOptions.select.push('Id');
            this.storeOptions.select.push(this.previewField);
            var grid = new EditableGrid({
                id: this.domNode.id + "_grid",
                gridNodeId: this.id,
                tabId: this.slxContext.tabId,
                context: this.slxContext,
                region: 'center',
                columnDefaults: { editable: false },
                //readOnly: true,
                columns: this.columns,
                tools: tools,
                contextualCondition: contextualCondition,
                storeOptions: this.storeOptions,
                keepSelection: true
            });

            this.connections.push(dojo.connect(grid, 'onSelected', this, this._updatePreviewText));
            this.connections.push(dojo.connect(grid.store, 'onSuccess', this, this._updatePreviewText));

            if (this.dblClickAction) {
                dojo.connect(grid, 'onRowDblClick', this, function (e) {
                    // Edit the selected item.
                    var rec = grid.getItem(e.rowIndex);
                    var id = grid.store.getValue(rec, "$key");
                    this.dblClickAction(id, rec);
                });
            }
            if (this._filter) {
                dojo.connect(this._filter, 'onFilterApply', this, function (conditions) {
                    contextualCondition.conditions = this._filter.getQuery();
                    grid.refresh();
                });
            }

            this.addChild(grid);
            return grid;
        },
        destroy: function () {
            var len = this.connections.length;
            for (var i = 0; i < len; i++) {
                dojo.disconnect(this.connections.pop());
            }
            this.inherited(arguments);
        },
        resetContextualCondition: function (contextualConditionFunction) {

            this.contextualConditionFunction = contextualConditionFunction;
            var contextualCondition = { fn: this.contextualConditionFunction ||
                this.contextualCondition, conditions: this._filter ? this._filter.getQuery() : null
            };
            this._grid.resetContextualCondition(contextualCondition);

        },
        _updatePreviewText: function () {
            if (this.previewField) {
                // Update the preview textbox.
                var sel = this._grid.selection.getSelected();
                var note = '';
                if (sel.length > 0 && sel[0]) {
                    note = sel[0][this.previewField] || this._grid.store.getValue(sel[0], this.previewField);
                }
                this._preview.set('value', note);
            }
        },
        _buildFilter: function () {
            // summary:
            //  build and return filter widget.
            //  If the grid has no filter configuration then it will return null.

            var filterConfig = [];
            dojo.forEach(this.columns, function (cc) {
                if (cc.filterConfig) {
                    // the filterconfig is supplemented with the column config itself, this way we keep the same label etc.
                    var fc = dojo.mixin(dojo.clone(cc), cc.filterConfig);
                    if (!fc.label) {
                        fc.label = cc.name;
                    }
                    filterConfig.push(fc);
                }
            });
            if (filterConfig.length === 0) {
                return null;
            }
            var filter = new Sage.UI.SLXPreviewGrid.FilterPanel({
                id: this.id + '_filterpanel',
                region: 'top',
                filterConfig: filterConfig,
                style: 'display: none'
            });
            this.addChild(filter);

            return filter;
        },
        _getPref: function (prefName, defaultValue) {
            var storage = window['localStorage'];
            var key = this.id + prefName;
            if (storage && storage[key]) {
                return storage[key];
            }
            return defaultValue;
        },
        _setPref: function (prefName, value) {
            var storage = window['localStorage'];
            if (storage) {
                storage[this.id + prefName] = value;
            }
        }

    });
    return Grid;
});
},
'Sage/MainView/ActivityMgr/AttendeeLookup/SpeedSearchLookup':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */

define('Sage/MainView/ActivityMgr/AttendeeLookup/SpeedSearchLookup',
[
    'dojo/_base/html',
    'Sage/Data/SDataServiceRegistry',
    'dijit/Dialog',
    'dijit/_Widget',
    'Sage/_Templated',
    'dojo/_base/lang',
    'dojo/string',
    'dojo/_base/array',
    'dijit/registry',
    'dojo/text!./templates/SpeedSearchLookup.html',
    'dojo/_base/declare',
    'Sage/UI/Controls/Grid',
    'dojo/i18n!./nls/SpeedSearchLookup',
    'Sage/Store/SData'
],
function (html, sDataServiceRegistry, Dialog, _Widget, _Templated, lang, string, array, registry, template, declare, Grid, nlsStrings, SDataObjectStore) {
    var widget = declare('Sage.MainView.ActivityMgr.AttendeeLookup.SpeedSearchLookup', [_Widget, _Templated], {
        //widgetTemplate: new Simplate(eval(template)),
        id: 'speedSearchLookup',
        btnIcon: 'images/icons/plus_16x16.gif',
        btnToolTip: 'Lookup',
        dialogTitle: 'Contact/Lead Look up',

        closeText: 'Close',
        loadingText: 'Loading...',
        // noDataText: 'No records returned',
        _initialized: false,
        _started: false,
        dialogButtonText: 'Search',
        widgetsInTemplate: true,
        widgetTemplate: new Simplate(eval(template)),
        srchBtnCaption: 'Search',
        _store: null,
        _grid: null,
        //end i18n strings.
        currentPage: 0,
        pageSize: 100,
        _storeOptions: null,
        _entry: null,
        indexes: [
           { indexName: 'Contact', indexType: 1, isSecure: true },
           { indexName: 'Lead', indexType: 1, isSecure: true }

        ],
        types: ['Contact', 'Lead'],
        iconPathsByType: {
            'Account': 'content/images/icons/Company_24.png',
            'Activity': 'content/images/icons/To_Do_24x24.png',
            'Contact': 'content/images/icons/Contacts_24x24.png',
            'History': 'content/images/icons/journal_24.png',
            'Lead': 'content/images/icons/Leads_24x24.png',
            'Opportunity': 'content/images/icons/opportunity_24.png',
            'Ticket': 'content/images/icons/Ticket_24x24.png'
        },
        constructor: function () {
            //   this._initializeList();
            lang.mixin(this, nlsStrings);

        },
        postMixInProperties: function () {
            // Set the widgetTemplate here so we can select the appropriate template for the selected display mode.
        },

        startup: function () {
            this._buildGrid();
            var self = this;
        },
        extractTypeFromItem: function (item) {
            for (var i = 0; i < this.types.length; i++) {
                if (item.source.indexOf(this.types[i]) !== -1) {
                    return this.types[i];
                }
            }

            return null;
        },
        extractDescriptorFromItem: function (item, type) {
            var descriptor = '';

            switch (type) {
                case 'Contact':
                    descriptor = string.substitute('${lastname}, ${firstname}', this.getFieldValues(item.fields, ['firstname', 'lastname']));
                    break;
                case 'Lead':
                    descriptor = string.substitute('${lastname}, ${firstname}', this.getFieldValues(item.fields, ['firstname', 'lastname']));
                    break;
                    /*  case 'Opportunity':
                          descriptor = this.getFieldValue(item.fields, 'subject');
                          break;
                      case 'History':
                          descriptor = string.substitute('${subject} (${date_created})', this.getFieldValues(item.fields, ['subject', 'date_created']));
                          break;
                      case 'Ticket':
                          descriptor = item.uiDisplayName;
                          break;*/
            }
            return descriptor;
        },

        extractKeyFromItem: function (item) {
            // Extract the entityId from the display name, which is the last 12 characters
            var displayName, len;
            displayName = item.displayName;
            if (!displayName) {
                return '';
            }

            len = displayName.length;
            return displayName.substring(len - 12);
        },
        getFieldValue: function (fields, name) {
            for (var i = 0; i < fields.length; i++) {
                var field = fields[i];
                if (field.fieldName == name) {
                    return field.fieldValue;
                }
            }

            return '';
        },
        getFieldValues: function (fields, names) {
            var results = {};

            // Assign each field in the results to an empty string,
            // so that dojo's string substitute won't blow up on undefined.
            array.forEach(names, function (name) {
                results[name] = '';
            });

            array.forEach(fields, function (field) {
                array.forEach(names, function (name, i) {
                    if (field.fieldName === name) {
                        results[name] = field.fieldValue;
                    }
                });
            });

            return results;
        },
        showLookup: function (mixinProperties) {
            this._dialog.set('title', this.dialogTitle);
            this.eventDefaultValues = mixinProperties || {};
            this._dialog.show();

            if (!this._initialized) {
                this._initializeList();
            }
            this._dialog.set('refocus', false);
            this.connect(this._dialog, 'onHide', this.destroy);

        },
        _initializeList: function () {
            this._started = false;
            //define the columns:
            var columns = [
                {
                    field: '$descriptor',
                    label: this.colName,
                    width: '20%',
                    sortable: false
                }, {
                    field: 'type',
                    label: this.colType,
                    width: '10%',
                    sortable: false
                }, {
                    field: 'accountName',
                    label: this.colAccount,
                    width: '30%',
                    sortable: false
                }, {
                    field: 'title',
                    label: this.colTitle,
                    width: '10%',
                    sortable: false
                }, {
                    field: 'email',
                    label: this.colEmail,
                    width: '30%',
                    sortable: false
                }, {
                    field: 'phone',
                    label: this.colWorkPhone,
                    width: '30%',
                    sortable: false
                }
            ];

            this._entry = {
                request: {
                    docTextItem: -1,
                    searchText: '',
                    searchType: 1,
                    noiseFile: 'PMINoise.dat',
                    includeStemming: false,
                    includeThesaurus: false,
                    includePhonic: false,
                    useFrequentFilter: false,
                    indexes: this.indexes,
                    whichPage: this.currentPage,
                    itemsPerPage: this.pageSize,
                    filters: null
                },
                response: null
            };

            var self = this;
            var onComplete = function (feed, totalCount) {
                this._initialized = true;
                array.forEach(feed, function (entry, i) {
                    entry.type = self.extractTypeFromItem(entry);
                    entry.$descriptor = entry.$descriptor || self.extractDescriptorFromItem(entry, entry.type);
                    entry.$key = self.extractKeyFromItem(entry);
                    entry.accountName = self.getFieldValue(entry.fields, 'account');
                    entry.title = self.getFieldValue(entry.fields, 'title');
                    entry.email = self.getFieldValue(entry.fields, 'email');
                    entry.phone = self.getFieldValue(entry.fields, 'phone');
                });

                // TODO: scroll for data on demand does not work with POST data
                //if (typeof totalCount !== 'undefined') {
                //    var remaining = this.feed.totalCount - ((this.currentPage + 1) * this.pageSize);
                //    this.set('remainingContent', string.substitute(this.remainingText, [remaining]));
                //}

                //domClass.toggle(this.domNode, 'list-has-more', this.hasMoreData());
            };

            this._storeOptions = {
                service: sDataServiceRegistry.getSDataService('system'),
                contractName: 'system',
                operationName: 'executeSearch',
                entry: this._entry,
                queryArgs: {
                    count: 100
                },
                onComplete: onComplete,
                operationSDataStore: 'Sage.SData.Client.SDataServiceOperationRequest', // TODO: check another way
                itemsProperty: 'response.items',
                totalCountProperty: 'response.totalCount'
            };

            var store = this._store = new SDataObjectStore(this._storeOptions);

            if (!this._grid) {
                var grid = this._grid = new Grid({
                    id: 'speedSearchGrid',
                    store: store,
                    columns: columns,
                    minRowsPerPage: 100,
                    placeHolder: dojo.byId(this._speedSearchGrid),
                    selectionMode: 'extended',
                    columnHiding: true,
                    columnResizing: true,
                    columnReordering: true,
                    rowSelection: true
                });

                grid.onRowDblClick = lang.hitch(this, function (row) {
                    this.onDoubleClick();
                });
                grid.resize();
            }
        },
        onDoubleClick: function () {
            this.getGridSelections();
        },
        uninitialize: function () {
            if (!this.contentNode) {
                return;
            }
            array.forEach(this.mainHandles, function (handle) {
                handle.remove();
            });

            this._destroyContent();

            this.inherited(arguments);
        },

        _destroyContent: function () {
            if (!this.contentNode) {
                return;
            }

            array.forEach(registry.findWidgets(this.contentNode), function (widget) {
                widget.destroy(false);
            });
            array.forEach(this.handles, function (handle) {
                handle.remove();
            });
            this.handles = [];
            this.contentNode.innerHTML = '';
        },
        initDialog: function () {

        },
        _onKey: function (/*Event*/evt) {
            //summary:
            // An override to the Dialog _onKey that allows the Lookup control to function as a modeless dialog.  
            // Future implementations will see this feature as a mixin class available to any dialog class.
            // modality: modal, modeless
            // (modality === 'modeless') ? dijit.byId('dijit_DialogUnderlay_0').hide(); 
            // OR
            //  dojo.destroy(self.id + '-Dialog_underlay');        
            var self = this,
                args = arguments;
            dojo.query('*', this.domNode).forEach(function (node, index, arr) {
                if (node === evt.target) {
                    //We are inside the dialog. Call the inherited.
                    self.inherited(args);
                }
            });
        },
        getGridSelections: function () {
            var items = this._grid.getSelectedRowData();
            this._grid.clearSelection();
            this.doSelected(items);
        },
        doSelected: function (items) {
            //do nothing, this is here as a placeholder for consumers to add custom handling for this event.
        },
        _cancelClick: function () {
            this.hide();
        },
        hide: function () {
            this._dialog.hide();
            this._started = false;
        },
        _doSearch: function () {
            if (this._valueBox.value) {
                this._entry.request.searchText = this._valueBox.value;
                this._store.entry = this._entry;
                this._grid.refresh();
            }
        },
        _onKeyPress: function (evt) {
            if (evt.keyCode == 13 || evt.keyCode == 10) {
                // event.stop(evt);
                this._valueBox.blur();
                this._doSearch();
            }
        },
        destroy: function () {
            var dialog = dijit.byId([this.id, '-Dialog'].join(''));

            if (this.btnIcon) {
                dojo.destroy(this.btnIcon);
            }

            dojo.disconnect(this._doSearchConnection);
            dojo.unsubscribe(this._addCondHandle);
            dojo.unsubscribe(this._removeCondHandle);

            if (this.conditionMgr) {
                this.conditionMgr.destroy(false);
            }

            if (dialog) {
                dialog.uninitialize();
            }
            dialog.destroyRecursive();
            this.inherited(arguments);
        }
    });
    return widget;

});

},
'Sage/UI/Controls/SingleSelectPickList':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */

/**
* @class Sage.UI.Controls.SingleSelectPickList
* Class for single select picklists.
*/
define([
'dijit/_Widget',
'dijit/_TemplatedMixin',
'dijit/_WidgetsInTemplateMixin',
'dijit/form/ComboBox',
'dojo/data/ItemFileReadStore',
'dojo/data/ObjectStore',
'dojo/store/Memory',
'Sage/UI/ComboBox',
'Sage/UI/Controls/PickList',
'dojo/text!./templates/SingleSelectPickList.html',
'dojo/string',
'dojo/_base/declare',
'dojo/keys'
],
function (_Widget, _TemplatedMixin, _WidgetsInTemplateMixin, _comboBox, itemFileReadStore, objectStore, memory, sageComboBox, pickList, template, string, declare, keys) {
var widget = declare('Sage.UI.Controls.SingleSelectPickList', [pickList, _Widget, _TemplatedMixin, _WidgetsInTemplateMixin], {

/**
* Takes the following options object:
* {
*  pickListName: 'PickListName', // Required
*  storeOptions: {}, // Optional
*  dataStore: {}, // Option
*  canEditText: false,
*  itemMustExist: true,
*  maxLength: -1,
*  storeMode: 'text', // text, id, code
*  sort: true,
*  displayMode: 'AsControl',
*  clientId: 'ASP.NET Control ClientID Here',
*  required: false,
*  tabIndex: 0
* }
*
* @constructor
*/
    store: null,
    cssClass: "",
constructor: function (options) {
    if (options.clientId) {
        this.id = options.clientId + '-SingleSelectPickList';
    }
    if (options.cssClass) {
        this.cssClass = options.cssClass;
    }

    this.inherited(arguments);
},
postCreate: function () {
    this._setupTooltips(this.comboBox._buttonNode, this.comboBox.textbox);
    this._setupRenderAsHyperlink();
    this._setupTooltips();
    this.inherited(arguments);
    var existingText = dojo.byId(this._textId);
    if (existingText && existingText.value && (this.comboBox.value !== existingText.value)) {
        this.comboBox.set('value', existingText.value);
    }

    if (this.cssClass && this.cssClass.length > 0) {
        this.comboBox.domNode.className = this.cssClass + ' ' + this.comboBox.domNode.className;
    }
},
_setupTooltips: function () {
    if (this.controlTooltip && this.controlTooltip !== '') {
        this.comboBox.set('title', this.controlTooltip);
    }

    if (this.buttonTooltip && this.buttonTooltip !== '') {
        if (this.comboBox._buttonNode) {
            this.comboBox._buttonNode.title = this.buttonTooltip;
        }
    }
},
_setupRenderAsHyperlink: function () {
    if (!this.renderAsHyperlink) {
        return;
    }

    dojo.addClass(this.comboBox.domNode, 'comboAsHyperlink');
    dojo.connect(this.comboBox.domNode, 'onclick', this, function () {
        this.comboBox.loadDropDown();
    });
},
_loadData: function () {
    var def = new dojo.Deferred();
    this.getPickListData(def);

    def.then(dojo.hitch(this, function (data) {
        if (typeof data === 'string') {
            this.comboBox.set('value', data);
        }

        var items = [];
        var storeItem;
        for (var i = 0; i < data.items.$resources.length; i++) {
            if (this.filter === data.items.$resources[i].filter || this.filter === "") {
                var item = data.items.$resources[i];
                items.push({
                    id: item.$key,
                    code: item.code,
                    number: item.number,
                    text: item.text,
                    filter: item.filter
                });
            }
        }

        this.storeData = {
            identifier: 'id',
            label: 'text',
            items: items
        };

        //this.store = new itemFileReadStore();
        this.store = new itemFileReadStore({ data: this.storeData });
        this.comboBox.set('store', this.store);
        this.comboBox.set('searchAttr', 'text');
        this.store._forceLoad();

        var existingText = dojo.byId(this._textId);
        var existingId = dojo.byId(this._picklistId);
        var existingCode = dojo.byId(this._codeId);
        if (items[0]) {
            if (existingText && existingText.value) {
                //this is here when the server control added it to the dom with a value in it
                this.lastValidValue = existingText.value;
                this.initialValue = this.lastValidValue;
                this.comboBox.set('value', this.lastValidValue);
            }

            else if (existingId && existingId.value) {
                storeItem = this.getStoreItemById(existingId.value);
                if (storeItem) {
                    this.lastValidValue = this.store.getValue(storeItem, 'text');
                    this.initialValue = this.lastValidValue;
                    this.comboBox.set('value', this.lastValidValue);
                }
            }
            else if(existingCode && existingCode.value) {
                storeItem = this.getStoreItemByCode(existingCode.value);
                if(storeItem) {
                    this.lastValidValue = this.store.getValue(storeItem, 'text');
                    this.initialValue = this.lastValidValue;
                    this.comboBox.set('value', this.lastValidValue);
                }
            }
            else {
                //this is when it is used as a strictly client-side control and the value may have already been set.
                var val = this.comboBox.get('value');
                if (val || val === '') {
                    this.lastValidValue = val;
                } else {
                    this.lastValidValue = items[0].text;
                    this.comboBox.set('value', this.lastValidValue);
                }
            }
        }
        else { this.comboBox.set('value', ''); }
    }), function (e) {
        // errback
        console.error(e);
    });

    // Adjust control according to properties set in AA

    // Disable textbox to prevent edit
    if (this.get('canEditText') === false) {
        this.comboBox.textbox.readOnly = true;
    }

    var len = this.get('maxLength');
    if (len > 0) {
        this.comboBox.set('maxLength', len);
    }
},
uninitialize: function () {
    this.inherited(arguments);
},
getStoreItemById: function (id) {
    var results = null, tempId;
    if (this.store) {
        if (this.storeData) {
            dojo.forEach(this.storeData.items, function(item, index, array) {
                if (item.id) {
                    tempId = this.store.getValue(item, 'id');
                    if (tempId === id) {
                        results = item;
                        return results;
                    }
                }
            }, this);
        }
    }
    return results;
},
getStoreItemByCode: function(code) {
    var results = null, tempCode;
    if (this.store) {
        if (this.storeData) {
            dojo.forEach(this.storeData.items, function(item, index, array) {
                if (item.code) {
                    tempCode = this.store.getValue(item, 'code');
                    if (tempCode) {
                        tempCode = string.trim(tempCode);
                        tempCode = tempCode.toUpperCase();
                    }
                    code = string.trim(code);
                    code = code.toUpperCase();
                    if (tempCode === code) {
                        results = item;
                        return results;
                    }
                }
            }, this);
        }
    }
    return results;
},
getStoreItemByValue: function(value) {
    var results = null, text;
    if (value) {
        if (this.store) {
            dojo.forEach(this.storeData.items, function(item, index, array) {
                if (item.text) {
                    text = this.store.getValue(item, 'text'); // we must go through store to get value since it could change from a string to an array
                    if (text) {
                        text = string.trim(text);
                        text = text.toUpperCase();
                    }
                    value = string.trim(value);
                    value = value.toUpperCase();
                    if (text === value) {
                        results = item;
                        return results;
                    }
                }
            }, this);
        }
    }

    return results;
},
_onChange: function (newVal) {
    this.onChange(newVal);
},
_setPickListNameAttr: function (value) {
    this.inherited(arguments);
    this._loadData();
},
_setValueAttr: function (value) {
    this.inherited(arguments);
    this.comboBox.set('value', value);
},
_getValueAttr: function () {
    return this.comboBox.get('value');
},
_getCodeAttr: function() {
    var item, code, value;
    code = '';
    value = this._getValueAttr();
    item = this.getStoreItemByValue(value);
    if (item) {
        code = this.store.getValue(item, 'code');
    }
    return code;
},
_getIdAttr: function () {
    var item, id;
    id = '';
    item = this.getStoreItemByValue(this._getValueAttr());
    if (item) {
        id = this.store.getValue(item, 'id');
    }
    return id;
},
// Display properties
templateString: template,
widgetsInTemplate: true,

/**
* @property {object} storeData Data fetched from SData stored here.
*/
storeData: null,

/**
* @property {string} lastValidValue Last valid value entered into the control.
*/
lastValidValue: '',

/**
* @property {string} initialValue Initial value set to the control, if any.
*/
initialValue: '',

/**
* @property {bool} disabled.
*/
disabled: false,

_setDisabledAttr: function (disabled) {
    this.disabled = disabled;


    this.comboBox.set('disabled', disabled);
},
_getDisabledAttr: function () {
    this.disabled = this.comboBox.get('disabled');
    return this.disabled;
},
focus: function () {
    this.comboBox.focus();
},
_onKeyDown: function (evt) {
    if (evt.keyCode === keys.ENTER) {
        this.onChange(this._getValueAttr());
    }
},
onChange: function (newVal) {
    // Send the values to the hidden ASP.NET fields if we are valid, and the value actually changed.
    if (this.storeData) {
        var val = this.comboBox.get('value');
        if (val != this.initialValue) {
            if (this.get('itemMustExist')) {
                // Check if what we have entered is valid or not
                var valid = dojo.some(this.storeData.items, function (item) {
                    // There is no guarantee the types will match so evaluate the type as well
                    // (i.e. do not use === for comparison). This can happen if a custom store is
                    // used to store the data, etc.

                    if (item.text == newVal || newVal == '') { // jshint ignore:line
                        return true;
                    } else {
                        return false;
                    }
                }, this);
                if (valid) {
                    this.lastValidValue = newVal;
                }
                if (!valid) {
                    // Attempt to restore last valid value.
                    if (this.lastValidValue !== 'undefined' && this.lastValidValue !== null) {
                        this.comboBox.set('value', this.lastValidValue);
                        return;
                    }
                }
            }
            if(this.comboBox.isValid()) {
                var code = '',
                    id = '';
                dojo.forEach(this.storeData.items, function (item, index, array) {
                    if (item.text == val) {
                        code = item.code;
                        id = item.id;
                    }
                }, this);
                this.setASPNETInputs(val, code, id);
            }
        }
    }
}
});

return widget;
});


},
'Sage/Extensions/UI/Columns/Radio':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/_base/declare',
    'dojo/_base/lang'
],
function (declare, lang) {
    var widget = declare("Sage.Extensions.UI.Columns.Radio", dojox.grid.cells.Bool, {
        //Formatter used for the editiable = false state.       

        formatEditing: function (inDatum, inRowIndex) {
            var radioName = this.radioType == 'group' ? 'rdo_' + this.field : 'rdo_' + this.field + '_' + inRowIndex;
            var checked = inDatum ? "checked" : "";
            return '<input type="radio" ' + checked + ' name="' + radioName + '"  style="width: auto" />';
        },
        doclick: function (e) {
            if (e.target.tagName == 'INPUT') {               
                this.resetRows(e.grid, e.rowIndex, this.field);                
                this.applyStaticValue(e.rowIndex);                
            }
        },
        resetRows: function (grid, rowIndex, inAttrName) {
            this.currentRow = rowIndex;
            var self = this;
            grid.store.fetch({               
                onComplete: function (items) {
                    dojo.forEach(items, function (item, index) {
                        if (index != self.currentRow) {
                            grid.store.setValue(item, inAttrName, false);
                        }
                    });                    
                }               
            });

        }
    });

    return widget;
});

},
'Sage/Extensions/UI/Columns/CheckBox':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/_base/declare',
    'dojo/_base/lang',
    'dojo/query'
],
function (declare, lang, query) {
    var widget = declare("Sage.Extensions.UI.Columns.CheckBox", dojox.grid.cells.Bool, {
        //Formatter used for the editiable = false state.       
        checkBoxIds: null,        
        constructor: function (inCell) {
            //if they only provide options, we use them as the values...
            this.checkBoxIds = [];
        },
        formatEditing: function (inDatum, inRowIndex) {
            var chkBoxName = 'chk_' + this.field + '_' + inRowIndex;
            if (!this.checkBoxIds[chkBoxName]) {
                this.checkBoxIds.push(chkBoxName);
            }
            var key = "";
            var gridItem = this.grid.getItem(inRowIndex);
            if (gridItem) {
                key = gridItem.EntityId;
            }
            var chkBoxId = 'chk_' + this.field + '_' + key;
            var checkbox = (inDatum === true || inDatum === 1) ? '<input type="checkbox" class="attendeeGridIsPrimary" id="' + chkBoxId + '" name="' + chkBoxName + '" checked="checked" />'
               : '<input type="checkbox" class="attendeeGridIsPrimary" id="' + chkBoxId + '" name="' + chkBoxName + '" />';
            return checkbox;
        },
        doclick: function (e) {
            if (e.target.tagName == 'INPUT') {

                var item = e.grid.getItem(e.rowIndex);
                if (e.target.checked) {
                    item.checked = true;                    
                } else {
                    item.checked = false;                    
                }
                if (this.checkBoxClicked && typeof this.checkBoxClicked === 'function') {
                    this.checkBoxClicked.call(this, item);
                }
                //dojo.publish('/entity/activityAttendee/primaryClicked', [item, this]);

               // this.resetCheckBoxes(e.rowIndex);
                this.resetRows(e.grid, e.rowIndex, this.field, item);
                if (e.grid.mode == "insert") {
                    this.applyStaticValue(e.rowIndex);
                }
              /*  if (e.grid.mode != "insert") {
                    e.grid.saveChanges();
                    e.grid.refresh();
                }*/
            }
        },
      
        resetRows: function (grid, rowIndex, inAttrName, currentItem) {
          
            var count = grid.rowCount;
            var chkBoxId;
            for (var i = 0; i < count; i++) {
                var item = grid.getItem(i);
                if (item && item.EntityId !== currentItem.EntityId) {
                    chkBoxId = 'chk_' + this.field + '_' + item.EntityId;
                    dojo.byId(chkBoxId).checked = false;
                    grid.store.setValue(item, inAttrName, false);
                } else if (item && item.EntityId === currentItem.EntityId) {
                    chkBoxId = 'chk_' + this.field + '_' + item.EntityId;
                    if (grid.mode == "insert") {
                        grid.store.setValue(item, inAttrName, true);
                    } else if (grid.mode !== "insert" && item.IsPrimary) {
                        grid.store.setValue(item, inAttrName, false);
                    } else if (grid.mode !== "insert" && !item.IsPrimary) {
                        grid.store.setValue(item, inAttrName, true);
                    }
                }
            }
            
        },
        resetCheckBoxes: function (index) {
            for (var i = 0; i < this.checkBoxIds.length;i++) {
                console.debug(this.checkBoxIds[i]);
                if (index != i) {
                    dojo.byId(this.checkBoxIds[i]).checked = false;
                }
            }
            query(".attendeeGridIsPrimary").forEach(function (node, index, arr) {
                console.debug(node.innerHTML);
            });

        }

    });

    return widget;
});

},
'Sage/Extensions/UI/Columns/PickListSelect':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/_base/declare',
    "dojox/grid/cells/_base",
    "Sage/UI/Controls/PickList"    
],
function (declare, Select, PickList) {
    var PickListSelect = declare("Sage.Extensions.UI.Columns.PickListSelect", dojox.grid.cells.Select, {
        storeData: null,
        pickList: null,
        storageMode: 'id', //Default for column picklist
        displayMode: 'AsText', //Default for column picklist formatting
        constructor: function (args) {
            this.inherited(arguments);
            if (this.storageMode === 'id' && this.displayMode === 'AsText') {
                if (this.pickListName) {
                   this._loadPickList();
                }
            }
        },
        _loadPickList: function () {
            var deferred = new dojo.Deferred();
            var config = {
                pickListName: this.pickListName, // Required
                // storeOptions: {}, // Optional
                // dataStore: {}, // Optional
                canEditText: false,
                itemMustExist: true,
                maxLength: -1,
                storeMode: this.storageMode, // text, id, code
                sort: false,
                displayMode: this.displayMode
            };
            this.pickList = new PickList(config);
            this.pickList.getPickListData(deferred);
            deferred.then(dojo.hitch(this, this._loadData), function (e) {
                console.error(e); // errback
            });
        },
        _loadData: function (data) {
            var values = [];
            var options = [];
            for (var i = 0; i < data.items.$resources.length; i++) {
                var item = data.items.$resources[i];
                options.push(item.text);
                if (item.code) {
                    values.push(item.code);
                } else {
                    values.push(item.text);
                }
            }
            this.options = options;
            this.values = values.length > 0 ? values : options;
        }
    });
    return PickListSelect;
});
},
'Sage/MainView/ActivityMgr/AttendeeLookup/LookupService':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */

define([
    'Sage/MainView/ActivityMgr/AttendeeLookup/ContactLookupConfig',
    'Sage/MainView/ActivityMgr/AttendeeLookup/LeadLookupConfig',
    'dojo/_base/declare'
],

function (
    ContactLookupConfig,
    LeadLookupConfig,
    declare
) {

    var lookupService = declare('Sage.MainView.ActivityMgr.AttendeeLookup.LookupService', null, {
        _lookupConfigs:null,
        constructor: function () {

           
        },
        _initLookupConfigs: function () {

            this._lookupConfigs = [{
                lookupName: 'Contact',
                lookupDisplayName: 'Contact',
                configProviderType: ContactLookupConfig,
                instance:false
            },{
                lookupName: 'Lead',
                lookupDisplayName: 'Lead Loookup',
                configProviderType: LeadLookupConfig,
                instance: false
            }];
        },
        getLookupConfigs: function () {

            if (this._lookupConfigs) {
                return this._lookupConfigs;
            }
            this._initLookupConfigs();
            return this._lookupConfigs;
        },
        getLookupConfig: function (lookupName) {
            var lookupConfigs = this.getLookupConfigs();
            for (var i = 0; i < lookupConfigs.length; i++) {
                if (lookupConfigs[i].lookupName.toUpperCase() === lookupName.toUpperCase()) {
                    return lookupConfigs[i];
                }
            }
            return null;
        },
        AddLookupConfig: function (lookupConfig) {
            var config = this.getLookupConfig(lookupConfig.lookupName);
            if (config) {
                config.configuration = lookupConfig;
            }
            else {
                var newConfiguration = {
                    lookupName: lookupConfig.lookupName,
                    lookupDisplayName: lookupConfig.lookupDisplayName,
                    configProviderType: lookupConfig,
                    instance: false
                };
                var lookupConfigs = this.getLookupConfigs();
                lookupConfigs.push(newConfiguration);
            }
        },
        RemoveLookupConfig: function (lookupName) {
            
        },
        getLookupConfigInstance: function (lookupName) {
            var lookupConfig = this.getLookupConfig(lookupName);
            if (lookupConfig) {
                if (!lookupConfig.instance) {
                    lookupConfig.instance = new lookupConfig.configProviderType();
                    return lookupConfig.instance;
                } else {
                    lookupConfig.instance.rebuild();
                    return lookupConfig.instance;
                }
            }
        },
        getLookupInstance: function (lookupName, uiid) {
            var lookupConfigInstance = this.getLookupConfigInstance(lookupName);
            var lookupInstance = null;
            if (lookupConfigInstance) {
                lookupInstance = lookupConfigInstance.getLookupInstance(uiid);
            }
            return lookupInstance;
        }
    }); // end dojo declare

   
    if (!Sage.Services.hasService('LookupService')) {
        Sage.Services.addService('LookupService', new lookupService());

    } else {
        var srvc = Sage.Services.getService('LookupService');
        if (actSvc.declaredClass !== 'Sage.MainView.ActivityMgr.AttendeeLookup.LookupService') {
            Sage.Services.removeService('LookupService');
            Sage.Services.addService('LookupService', new lookupService()());
        }
    }
    return lookupService();
})

},
'Sage/MainView/ActivityMgr/AttendeeLookup/ContactLookupConfig':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
     'Sage/MainView/ActivityMgr/AttendeeLookup/BaseLookupConfig',
     'Sage/UI/SDataLookup',
     'dojo/i18n!./nls/ContactLookupConfig',
     'dojo/_base/declare',
     'dojo/_base/lang'
],
function (
    BaseLookupConfig,
    SDataLookup,
    nlsResources,
    declare,
    lang
   ) {
    var associationLookupConfig = declare('Sage.MainView.ActivityMgr.AttendeeLookup.ContactLookupConfig', [BaseLookupConfig], {

        constructor: function () {
            lang.mixin(this, nlsResources);
            //this._nlsResources = nlsResources;
            this.lookupType = SDataLookup;
            this._initConfig();
        },
        _initConfig: function () {
            this.id = '_contactLookup',
            this.lookupName = 'Contact';
            this.lookupDisplayName = 'Contact Lookup';
            this.entityName = 'Contact';
            this.dialogTitle = this.dialogTitleText,
            this.cells = null;
            this.cells = this.getCells();
            this.defaultCell = {
                "sortable": true,
                "width": "150px",
                "editable": false,
                "propertyType": "System.String",
                "excludeFromFilters": false,
                "useAsResult": false,
                "pickListName": null,
                "defaultValue": ""
            };
            this.storeOptions = {
                resourceKind: 'contacts',
                select: ['LastName', 'FirstName', 'Title', 'Type', 'Account/$key', 'Account/AccountName', 'ContactUser/Userid', 'Address/Timezone'],
                sort: [{ attribute: 'LastName' }]
            };
            this.preFilters = [];
            this.gridOptions = {};
            this.query = {};
            this.displayMode = 5;
            this.isModal = true;
            this.initialLookup = false;
            this.seedValue = 'X';
            this.seedProperty = 'Account.Id';

        },
        getCells: function () {

            if (this.cells) {
                return this.cells;
            }
            this.cells = [
            {
                label: this.colFirstName,
                field: 'FirstName'
            }, {
                label: this.colLastName,
                field: 'LastName'
            }, {
                label: this.colTitle,
                field: 'Title'
            }, {
                label: this.colAccount,
                field: 'AccountName'
            }, {
                label: this.colWorkPhone,
                field: 'WorkPhone'
            }, {
                label: this.colEmail,
                field: 'Email'
            }];
            return this.cells;
        },
        doSelected: function (items) {
            alert("override the doSelect method")
        },
        getConfig: function (uiid) {

            var sDataConfig = {
                id: this.id + "_base_" + uiid,
                btnToolTip: '',
                structure: this.cells,
                gridOptions: this.gridOptions,
                displayMode: this.displayMode,
                storeOptions: this.storeOptions,
                isModal: this.isModal,
                initialLookup: this.initialLookup,
                preFilters: this.preFilters,
                query: this.query,
                seedValue: this.seedValue,
                seedProperty: this.seedProperty,
                overrideSeedValueOnSearch: true,
                dialogTitle: this.dialogTitle,
                dialogButtonText: this.dialogButtonText,
                doSelected: this.doSelected,
                cancelText: this.cancelText
            };

            return sDataConfig;
        },

        getLookupInstance: function (uiid) {
            var config = this.getConfig(uiid);
            var lookup = new this.lookupType(config);
            return lookup;
        }

    });
    return associationLookupConfig;
});
},
'Sage/MainView/ActivityMgr/AttendeeLookup/BaseLookupConfig':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
        'Sage/UI/Controls/Lookup',
        'dojo/_base/declare'
],
function (
    Lookup,
    declare
   ) {
    var baseLookupConfig = declare('Sage.MainView.ActivityMgr.AttendeeLookup.BaseLookupConfig', null, {
        lookupName: 'LookupName',
        lookupDisplayName: 'Lookup Display Name',
        lookupType: Lookup,
        entityName: 'entityName',
        id: false,
        cells: [],
        defaultCell: {
            'sortable': true,
            'width': '150px',
            'editable': false,
            'propertyType': 'System.String',
            'excludeFromFilters': false,
            'useAsResult': false,
            'picklistName': null,
            'defaultValue': ''
        },
        gridOptions: {
            contextualCondition: '',
            contextualShow: '',
            selectionMode: 'single'
        },
        storeOptions: {
            resourceKind: 'someEntity',
            sort: [{ attribute: 'SortField' }]
        },
        displayMode: 0,
        isModal: true,
        seedProperty: '',
        seedValue: '',
        overrideSeedValueOnSearch: true,
        initialLookup: true,
        preFilters: [],
        query: {},
        dialogTitle: 'Lookup',
        dialogButtonText: 'Ok',
        allowClearingResult: true,
        readonly: true,
        showEntityInfoToolTip: false,
        _nlsResources: {},
        constructor: function () {


        },
        rebuild: function () {
            this._lookup = null;
        },
        getLookupInstance: function (uiid) {
            var config = this.getConfig(uiid);
            var lookup = new this.lookupType(config);
            return lookup;
        },
        addCell: function (cell, atIndex) {

        },
        removeCell: function (cellName) {

        },
        getCells: function () {
            return this.cells;
        },
        getConfig: function (uiid) {

            var baseConfig = {
                id: this.id + "_base_" + uiid,
                structure: this.cells,
                gridOptions: this.gridOptions,
                storeOptions: this.storeOptions,
                isModal: this.isModal,
                displayMode: this.displayMode,
                initialLookup: this.initialLookup,
                preFilters: this.preFilters,
                returnPrimaryKey: this.returnPrimaryKey,
                dialogTitle: this.dialogTitle,
                dialogButtonText: this.dialogButtonText,
                doSelected: function () { alert("override the doSelect method") }
            };

            var config = {
                id: this.id + "_" + uiid,
                allowClearingResult: this.allowClearingResult,
                readonly: this.readonly,
                showEntityInfoToolTip: this.showEntityInfoToolTip,
                config: baseConfig
            }

            return config;
        }

    });
    return baseLookupConfig;
});
},
'Sage/MainView/ActivityMgr/AttendeeLookup/LeadLookupConfig':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
     'Sage/MainView/ActivityMgr/AttendeeLookup/BaseLookupConfig',
     'Sage/UI/SDataLookup',
     'dojo/i18n!./nls/LeadLookupConfig',
     'dojo/_base/declare',
     'dojo/_base/lang'
],
function (
    BaseLookupConfig,
    SDataLookup,
    nlsResources,
    declare,
    lang
   ) {
    var associationLookupConfig = declare('Sage.MainView.ActivityMgr.AttendeeLookup.LeadLookupConfig', [BaseLookupConfig], {

        constructor: function () {
            lang.mixin(this, nlsResources);
            this.lookupType = SDataLookup;
            this._initConfig();
        },
        _initConfig: function () {
            this.id = '_leadLookup',
            this.lookupName = 'Lead';
            this.lookupDisplayName = 'Lead Lookup';
            this.entityName = 'Lead';
            this.dialogTitle = this.dialogTitleText,
            this.cells = null;
            this.cells = this.getCells();
            this.defaultCell = {
                "sortable": true,
                "width": "150px",
                "editable": false,
                "propertyType": "System.String",
                "excludeFromFilters": false,
                "useAsResult": false,
                "pickListName": null,
                "defaultValue": ""
            };
            this.storeOptions = {
                resourceKind: 'leads',
                select: ['LastName', 'FirstName', 'Title', 'Type', 'Company', 'Address/Timezone'],
                sort: [{ attribute: 'LastName' }]
            };
            this.preFilters = [];
            this.gridOptions = {};
            this.query = {};
            this.isModal = true;
            this.displayMode = 5;
            this.initialLookup = false;
        },
        getCells: function () {

            if (this.cells) {
                return this.cells;
            }
            this.cells = [
            {
                label: this.colFirstName,
                field: 'FirstName'
            }, {
                label: this.colLastName,
                field: 'LastName'
            }, {
                label: this.colTitle,
                field: 'Title'
            }, {
                label: this.colCompany,
                field: 'Company'
            }, {
                label: this.colWorkPhone,
                field: 'WorkPhone'
            }, {
                label: this.colEmail,
                field: 'Email'
            }];
            return this.cells;
        },
        getConfig: function (uiid) {

            var sDataConfig = {
                id: this.id + "_base_" + uiid,
                btnToolTip: '',
                structure: this.cells,
                gridOptions: this.gridOptions,
                displayMode: this.displayMode,
                storeOptions: this.storeOptions,
                isModal: this.isModal,
                initialLookup: this.initialLookup,
                preFilters: this.preFilters,
                query: this.query,
                dialogTitle: this.dialogTitle,
                dialogButtonText: this.dialogButtonText,
                doSelected: function () { alert("override the doSelect method") },
                cancelText: this.cancelText
            };

            return sDataConfig;
        },
        getLookupInstance: function (uiid) {
            var config = this.getConfig(uiid);
            var lookup = new this.lookupType(config);
            return lookup;
        }

    });
    return associationLookupConfig;
});
},
'Sage/Services/UserOptions':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'Sage/Data/SDataServiceRegistry',
    'dojo/_base/declare'
],
function (SDataServiceRegistry, declare) {
    /**
    * Append the UserOptions object to the Sage.Services namespace
    * Declare the UserOptions class and append its methods and properties
    * @constructor
    */
    var widget = declare('Sage.Services.UserOptions', null, {
        constructor: function (options) {
            this.inherited(arguments);
            dojo.mixin(this, options);
            if (!options || !options.service) {
                this.service = SDataServiceRegistry.getSDataService('system', false, true, true);
            }
        },
        get: function (name, category, callback, onError, scope, async) {
            var req = this._createRequest(name, category);

            if (typeof async === 'undefined') {
                async = true;
            }

            if (req) {
                req.read({
                    success: callback,
                    failure: function (response) {
                        console.warn('Error reading request');
                        console.log(response);
                        if (typeof onError === "function") {
                            onError(response);
                        }
                    },
                    scope: scope || this,
                    async: async
                });
            } else {
                console.warn('Unable to create SData request');
            }
        },
        set: function (name, category, newValue, _success, _failure, scope) {
            var req = this._createRequest(name, category);
            _failure = _failure || function (response) {
                console.warn('Error reading request');
                console.log(response);
            };
            if (req) {
                req.read({
                    success: dojo.hitch(req, function (response) {
                        response.value = newValue;
                        SDataServiceRegistry._removeFromLocalStorage("userOptions");
                        this.update(response, { success: _success, scope: this });
                    }),
                    failure: _failure,
                    scope: scope || this
                });
            }
        },
        getByCategory: function (category, callback, scope, onError) {
            var req = new Sage.SData.Client.SDataResourceCollectionRequest(this.service);
            req.setResourceKind('userOptions');
            req.setQueryArg('where', 'category eq \'' + category + '\'');
            req.read({
                success: callback,
                failure: function (response) {
                    console.warn('Error reading user options request %o', response);
                    if (typeof onError === "function") {
                        onError(response);
                    }
                },
                scope: scope || this
            });
        },
        getByCategories: function (categories, callback, scope) {
            var req = new Sage.SData.Client.SDataResourceCollectionRequest(this.service);
            var strCategories = '';
            var strDel = ',';
            for (var i = 0; i < categories.length; i++) {
                if (i == categories.length - 1) {
                    strDel = '';
                }
                strCategories += '"' + categories[i] + '"' + strDel;
            }
            req.setResourceKind('userOptions');
            req.setQueryArg('where', 'category in (' + strCategories + ')');
            req.setQueryArg('count', '500');
            req.read({
                success: callback,
                failure: function (response) {
                    console.warn('Error reading user options request %o', response);
                },
                scope: scope || this
            });
        },
        _formatPredicate: function (n, c) {
            return dojo.string.substitute("category eq '${0}' and name eq '${1}'", [c, n]);
        },
        _createRequest: function (n, c) {
            var req = new Sage.SData.Client.SDataSingleResourceRequest(this.service);
            req.setResourceSelector(this._formatPredicate(n, c));
            req.setResourceKind('userOptions');
            // NOTE is there a need for a select query arg?
            return req;
        },
        _virtuald: function () {
            var match = /^\/([^\/]+)\//.exec(location.pathname);
            return match ? match[1] : '';
        }
    });
    /**
    * Make an instance of this service available to the 
    * Sage.Services.getService method.
    */
    Sage.Services.addService('UserOptions', new Sage.Services.UserOptions());

    //Backward compatibility mark as depricated...
    Sage.UserOptionsService = {
        getCommonOption: function (name, category, callback) {
            if (typeof console !== 'undefined') {
                console.warn(['DEPRECATED: Sage.UserOptionsService is deprecated.  ',
                'Use the UserOptions service instead.',
                'Change code like:',
                'Sage.UserOptionsService.getCommonOption(<option>, <category>, <callback>);',
                'to this: ',
                'var svc = Sage.Services.getService("UserOptions");',
                'if (svc) {',
                '   svc.get(<option>, <category>, <callback>);',
                '}'].join('\n'));
            }
            var origCallback = callback;
            var svc = Sage.Services.getService('UserOptions');
            if (svc) {
                svc.get(name, category, function (option) {
                    var oldFmt = {
                        category: option.category,
                        option: option.name,
                        optionValue: option.value
                    };
                    if (origCallback) {
                        origCallback.call(window, oldFmt);
                    }
                });
            }
        },
        setCommonOption: function (name, category, data, callback) {
            if (typeof console !== 'undefined') {
                console.warn(['DEPRECATED: Sage.UserOptionsService is deprecated.  ',
                'Use the UserOptions service instead.',
                'Change code like:',
                'Sage.UserOptionsService.setCommonOption(<option>, <category>, <newValue>, <callback>);',
                'to this: ',
                'var svc = Sage.Services.getService("UserOptions");',
                'if (svc) {',
                '   svc.set(<option>, <category>, <newValue>, <callback>);',
                '}'].join('\n'));
            }
            var svc = Sage.Services.getService('UserOptions');
            if (svc) {
                svc.set(name, category, data, callback);
            }
        }
    };

    return widget;
});



},
'Sage/MainView/ActivityMgr/RecurringEditor':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dijit/_Widget',
    'Sage/_Templated',
    'dojo/_base/declare',
    'dojo/_base/lang',
    'dojo/dom-class',
    'Sage/Utility/Activity',
    'dijit/form/RadioButton',
    'Sage/UI/Controls/Numeric',
    'dijit/layout/StackContainer',
    'dijit/layout/ContentPane',
    'Sage/UI/NumberTextBox',
    'dijit/form/CheckBox',
    'dijit/form/Select',
    'Sage/UI/Controls/DateTimePicker',
    'dojo/date',
    'dojo/i18n!./nls/RecurringEditor',
    'dojo/text!./templates/RecurringEditor.html'
],
function (_Widget,
    _Templated,
    declare,
    lang,
    domClass,
    activityUtility,
    RadioButton,
    Numeric,
    StackContainer,
    ContentPane,
    NumberTextBox,
    CheckBox,
    Select,
    DateTimePicker,
    dDate,
    recurringEditorStrings,
    template
    ) {

    var _recurringCalculator = declare('Sage.MainView.ActivityMgr._RecurringCalculator', null, {
        startDate: new Date(),
        initialStartDate: new Date(),
        endDate: new Date(),
        interval: 1,
        occurances: 1,
        activityRecurPeriodCode: 0,
        recurPeriod: false,
        editor: false,
        constructor: function (opts) {
            lang.mixin(this, opts);
        },
        calculateEndDate: function () {
            //calculate the end date based on the start date and number of occurances...
            if (!isNaN(this.interval) && !isNaN(this.occurances) && this.recurPeriod) {
                this.endDate = dDate.add(this.startDate, this.recurPeriod, (this.interval * this.occurances) - this.interval);
            }
            return this.endDate || this.startDate;
        },
        calculateNumberOfOccurances: function () {
            //calculate the number of occurances based on the start date and end date...
            var dif = dDate.difference(this.startDate, this.endDate, this.recurPeriod);
            var occCount = (dif / this.interval) + 1;
            occCount = Math.floor(occCount);
            return occCount;
        },
        set: function (prop, val) {
            switch (prop.toLowerCase()) {
                case 'enddate':
                    //should we check to see if it is a date? ...or maybe convert from string to date?
                    this.endDate = val;
                    this.endDate.setHours(0);
                    this.endDate.setMinutes(0);
                    //this.calculateNumberOfOccurances();
                    break;
                case 'interval':
                    this.interval = val;
                    //this.calculateNumberOfOccurances();
                    break;
                case 'occurances':
                    this.occurances = val;
                    //this.calculateEndDate();
                    break;
                case 'startdate':
                    this.startDate = val;
                    this.startDate.setHours(0);
                    this.startDate.setMinutes(0);
                    break;
                case 'initialstartdate':
                    this.initialStartDate = val;
                    this.initialStartDate.setHours(0);
                    this.initialStartDate.setMinutes(0);
                    //now what?
                    break;
                case 'editor':
                    this.editor = val;
                    break;
                case 'activityrecurperiodcode':
                    this.activityRecurPeriodCode = val;
                    break;
            }
        },
        get: function (prop) {
            switch (prop.toLowerCase()) {
                case 'enddate':
                    //should we check to see if it is a date? ...or maybe convert from string to date?
                    return this.endDate;
                case 'interval':
                    return this.interval;
                case 'occurances':
                    return this.occurances;
                case 'startdate':
                    return this.startDate;
                case 'editor':
                    return this.editor;
                case 'activityRecurPeriodCode':
                    return this.activityRecurPeriodCode;
            }
            return false;
        },
        _getTempStartDate: function () {
            // returns a clone of the start date (no time) that can be manipulated for counting occurances
            return new Date(this.startDate.getFullYear(), this.startDate.getMonth(), this.startDate.getDate());
        }
    });

    var dailyRecurringCalculator = declare('Sage.MainView.ActivityMgr.DailyRecurringCalculator', _recurringCalculator, {
        recurPeriod: 'day'//,
        //        calculateNumberOfOccurances: function () {
        //            //... logic from legacy web client - actrecurdaily.js
        //            var day; // = this.startDate.getDate();
        //            var tempStart = this._getTempStartDate();
        //            var occurcount = 1;
        //            while (tempStart < this.endDate && occurcount < 999) {
        //                day = tempStart.getDate();
        //                tempStart.setDate(day + (this.interval * 1));
        //                occurcount++;
        //            }

        //            //... new logic - does it match?
        //            var occCount = this.inherited(arguments);

        //            console.warn('calculating daily occurances.  Old Logic: ' + occurcount + '     New Logic: ' + occCount);

        //            this.occurances = occurcount;
        //            return this.occurances;
        //        }
    });

    var weeklyRecurringCalculator = declare('Sage.MainView.ActivityMgr.WeeklyRecurringCalculator', _recurringCalculator, {
        recurPeriod: 'week',
        _checkedCount: 0,
        _checkedDays: {},
        calculateEndDate: function () {
            if (this.editor) {

                var checkedCount = this.editor.countCheckedDays();
                //if there is only one occurance per week, simple math will do...
                // if none are checked, assume one (the day of the start date)
                if (checkedCount < 2) {
                    if (!isNaN(this.interval) && !isNaN(this.occurances) && this.recurPeriod) {
                        this.endDate = dDate.add(this.startDate, this.recurPeriod, (this.interval * this.occurances) - this.interval);
                    }
                    return this.endDate || this.startDate;
                }
                //but if not, we never know how many of the occurances will be in the first or last weeks without digging in and counting...
                var checkedDays = this.editor.getCheckedDays();
                // (the array of 0's or 1's meaning the day is checked or not)
                var workingDate = this._getTempStartDate();
                //start off assuming the start date is the first occurance.
                var remaining = this.occurances - 1;
                while (remaining > 0) {
                    workingDate = dDate.add(workingDate, 'day', 1);
                    remaining = remaining - checkedDays[workingDate.getDay()]; //if that day is checked, it will lower the remaining.
                }
                return workingDate;
            }
            return this.endDate || this.startDate;
        },       
        calculateNumberOfOccurances: function () { 
                //Adding new logic to count number of occurances if more than one day is selected in week
                var occCount = this.inherited(arguments);
                //If more than one day checked, we need to recalculate the occurances
                var checkedDaysCount = this.editor.countCheckedDays();                
            
                if (checkedDaysCount > 1) {
                    //Find total number of days between start and end dates
                    var daysDif = dDate.difference(this.startDate, this.endDate, "day");
                    //Find total number of weeks between start and end dates
                    var weeksDif = dDate.difference(this.startDate, this.endDate, this.recurPeriod);
                    var extraDays = 0;
                    //If total number of days are greater than whole week days
                    if ((weeksDif * 7) <= daysDif) {
                        //Get number of occurances for whole weeks
                        occCount = weeksDif * checkedDaysCount;
                        //Find the extra days 
                        var r = (daysDif % 7) * -1;
                        //Go over the extra days and if that day is in checked days then add it to occurances
                        var tempStartDate = dDate.add(this.endDate, "day", r);
                        var checkedDays = this.editor.getCheckedDays();
                        while (dDate.compare(this.endDate, tempStartDate, "date") >= 0) {
                            if (checkedDays[tempStartDate.getDay()]) {
                                extraDays++;
                            }
                            tempStartDate = dDate.add(tempStartDate, "day", 1);
                        }
                    }
                    occCount += extraDays;
                }
                return occCount;
                //... ToDo: but neither method of counting is right if there are more than one occurances per week...
                // probably need to implement better logic...(Implemented new logic...see above)

                //            //... logic from Legacy web client - actrecurweekly.js
                //            var dateDiff = (this.endDate - this.startDate);
                //            var Age = Math.round(dateDiff / 86400000);
                //            var occurcount = (Age / (this.interval * 7));
                //            occurcount = (occurcount + 1);
                //            occurcount = Math.floor(occurcount);

                //            //... new logic - does it match?
                //            var occCount = this.inherited(arguments);

                //           
                //            console.warn('calculating weekly occurances.  Old Logic: ' + occurcount + '     New Logic: ' + occCount);

                //            this.occurances = occurcount;
                //            return occurcount;
        }

    });

    var monthlyRecurringCalculator = declare('Sage.MainView.ActivityMgr.MonthlyRecurringCalculator', _recurringCalculator, {
        recurPeriod: 'month',
        calculateStartDate: function () {
            var sDate = lang.clone(this.initialStartDate);
            var firstOccurrenceDate;
            var weekDate = parseInt(this.editor._datesSelect.get('value'), 10);
            var weekDay = parseInt(this.editor._weekdaySelect.get('value'), 10);
            var nthWeek = parseInt(this.editor._weeksSelect.get('value'), 10);

            if (this.editor._rdoMonthlyOn.get('checked')) {
                firstOccurrenceDate = this.getNthDayOfMonth(this.initialStartDate, weekDate);
                sDate = firstOccurrenceDate;
            } else if (this.editor._rdoMonthlyOnThe.get('checked')) {
                firstOccurrenceDate = activityUtility.setDateToNthWeekDay(this.initialStartDate, nthWeek, weekDay);

                firstOccurrenceDate.setHours(this.initialStartDate.getHours());
                firstOccurrenceDate.setMinutes(this.initialStartDate.getMinutes());
                //If first occurence falls before activity start date, update activity start date to first occurrance's date
                var dtCompare = dojo.date.compare(this.initialStartDate, firstOccurrenceDate, "date");
                if (dtCompare != 0) {
                    if (dtCompare > 0) {
                        sDate = this.calculateFirstOccurrance(this.initialStartDate, firstOccurrenceDate, nthWeek, weekDay);
                    } else {
                        sDate = firstOccurrenceDate;
                    }
                }
            }
            return sDate;
        },
        calculateEndDate: function () {
            var eDate = this.inherited(arguments);
            if (this.activityRecurPeriodCode === 5) {
                //adjust to the correct day of the correct week for this option. (eg. first friday or last tuesday of the month)
                var week = activityUtility.getNthWeekOfMonth(this.startDate);
                var day = this.startDate.getDay();
                eDate = activityUtility.setDateToNthWeekDay(eDate, week, day);
            }
            return eDate;
        },
        getNthDayOfMonth: function (startDate, dayNumber) {
            var firstOccurDate = lang.clone(startDate);
            var startDateDay = startDate.getDate();
            if (startDateDay > dayNumber) {
                firstOccurDate = dojo.date.add(startDate, "month", 1);
            }
            firstOccurDate.setDate(dayNumber);

            return firstOccurDate;
        },
        calculateFirstOccurrance: function (currentStartDate, currentFirstOccurranceDate, nthWeek, weekDay) {
            var nDate = currentFirstOccurranceDate;
            while (dojo.date.compare(this.initialStartDate, nDate, "date") > 0) {
                nDate = activityUtility.setDateToNthWeekDay(dojo.date.add(nDate, "month", 1), nthWeek, weekDay);
            }
            return nDate;
        }
    });

    var yearlyRecurringCalculator = declare('Sage.MainView.ActivityMgr.YearlyRecurringCalculator', _recurringCalculator, {
        recurPeriod: 'year',
        calculateEndDate: function () {
            var eDate = this.inherited(arguments);
            if (this.activityRecurPeriodCode === 8) {
                //adjust to the correct day of the correct week for this option. (eg. first friday or last tuesday of the month)
                var week = activityUtility.getNthWeekOfMonth(this.startDate);
                var day = this.startDate.getDay();
                eDate.setMonth(this.startDate.getMonth());
                eDate = activityUtility.setDateToNthWeekDay(eDate, week, day);
            }
            return eDate;
        }
    });

    /**
     * @class Sage.MainView.ActivityMgr.RecurringEditor
     * Editor for editing recurring properties of activities.  Intended to be the "Recurring" tab in a schedule/edit form for activities.
     */
    var recurringEditor = declare('Sage.MainView.ActivityMgr.RecurringEditor', [_Widget, _Templated], {
        /**
        * @property {object} activity - the activity object that is being edited
        */
        activity: {},
        id: '',
        /**
        * @property {string} indicates the width of the labels in the form.
        */
        labelWidth: '80',

        /**
        * @property {Date} Get or set the start date of the activity being edited.
        */
        startDate: new Date(),
        /**
        * @property {Int} Get or set the number of times this recurring activity occurs.
        */
        initialStartDate: new Date(),
        startDateChangedFromParent: false,
        occurances: 2,
        interval: 1,
        activityRecurPeriodCode: 0,
        recurringPeriods: {
            once: 'once',
            daily: 'daily',
            weekly: 'weekly',
            monthly: 'monthly',
            yearly: 'yearly'
        },
        currentPeriod: 'once',
        endCalculators: false,
        _applyingActivityData: false,
        widgetsInTemplate: true,
        widgetTemplate: new Simplate(eval(template)),
        constructor: function () {
            lang.mixin(this, recurringEditorStrings);
        },
        postMixInProperties: function () {
            if (!this.endCalculators) {
                this.endCalculators = {};
                var config = {
                    startDate: this.startDate,
                    endDate: this.endDate,
                    interval: 1,
                    occurances: 1,
                    editor: this
                };
                this.endCalculators[this.recurringPeriods.daily] = new dailyRecurringCalculator(config);
                this.endCalculators[this.recurringPeriods.weekly] = new weeklyRecurringCalculator(config);
                this.endCalculators[this.recurringPeriods.monthly] = new monthlyRecurringCalculator(config);
                this.endCalculators[this.recurringPeriods.yearly] = new yearlyRecurringCalculator(config);
            }
        },

        // property getters and setters............................................................................
        _setStartDateAttr: function (newVal) {
            //when we notify that we've changed the start date, the main activity editor sets the time of the current activity to the new date, then fires
            // its change date functionality which sets this.  Make sure we don't keep cycling through an endless notification of changed dates.  We only
            // care about the date portion of the date anyway.
            if (newVal.getMonth() === this.startDate.getMonth() &&
                    newVal.getDate() === this.startDate.getDate() &&
                    newVal.getFullYear() === this.startDate.getFullYear()) {
                return;
            }
            //This flag is to prevent startdate change notification to parent which will keep cycling
            this.startDateChangedFromParent = true;
            this._applyingActivityData = true;
            this.startDate = newVal;
            this.initialStartDate = newVal;
            this.dtp_startRecur.set('value', newVal);
            this._weeklySyncToStartDate();
            this._monthlySyncToStartDate();
            this._yearlySyncToStartDate();
            //this._calculateStartDate();
            this._calculateEnd();
            this._applyingActivityData = false;
            //Set to true for enabling the start date change notification
            this.startDateChangedFromParent = false;

        },
        _getStartDateAttr: function () {
            return this.startDate;
        },
        _setOccurancesAttr: function (occ) {
            this.occurances = occ;
            this.num_Occurances.set('value', occ);
        },
        _getOccurancesAttr: function () {
            return this.occurances;
        },
        _setActivityAttr: function (activity) {
            //debugger;
            this.activity = activity;
            this._setUI();
            this._applyActivityData();
        },
        _getActivityAttr: function () {
            return this.activity;
        },
        onTabShow: function () {
            //should be called when this tab
            this._panelContainer.resize();
        },
        _setUI: function () {
            var opts = [];
            /*  add the appropriate select options  */
            if (this._datesSelect.getOptions().length < 1) {
                for (var i = 1; i < 32; i++) {
                    opts.push({
                        value: i.toString(),
                        label: i.toString()
                    });
                }
                this._datesSelect.addOption(opts);
                this._yearDatesSelect.addOption(opts);
            }
            if (this._monthNamesSelect.getOptions().length < 1) {
                opts = [
                    { value: '1', label: this.janText },
                    { value: '2', label: this.febText },
                    { value: '3', label: this.marText },
                    { value: '4', label: this.aprText },
                    { value: '5', label: this.mayText },
                    { value: '6', label: this.junText },
                    { value: '7', label: this.julText },
                    { value: '8', label: this.augText },
                    { value: '9', label: this.sepText },
                    { value: '10', label: this.octText },
                    { value: '11', label: this.novText },
                    { value: '12', label: this.decText }
                ];
                this._monthNamesSelect.addOption(opts);
                this._yearMonthNamesSelect.addOption(opts);
            }

            if (this._weeksSelect.getOptions().length < 1) {
                opts = [
                    { value: '1', label: this.firstText },
                    { value: '2', label: this.secondText },
                    { value: '3', label: this.thirdText },
                    { value: '4', label: this.fourthText },
                    { value: '5', label: this.lastText }
                ];
                this._weeksSelect.addOption(opts);
                this._yearWeeksSelect.addOption(opts);
            }
            if (this._weekdaySelect.getOptions().length < 1) {
                opts = [
                    { value: '1', label: this.monText },
                    { value: '2', label: this.tueText },
                    { value: '3', label: this.wedText },
                    { value: '4', label: this.thurText },
                    { value: '5', label: this.friText },
                    { value: '6', label: this.satText },
                    { value: '0', label: this.sunText }
                ];
                this._weekdaySelect.addOption(opts);
                this._yearWeekdaySelect.addOption(opts);
            }
        },

        // handling for recurring period radio buttons..............................................................
        _onceChanged: function (checked) {

            this._setUI();
            if (checked) {
                this._panelContainer.selectChild(this._oncePanel);
                this.interval = 1;
                this._updateRecurringPeriod(this.recurringPeriods.once);
            }
        },
        _dailyChanged: function (checked) {
            if (checked) {
                //console.log('daily is now checked');
                this._panelContainer.selectChild(this._dailyPanel);
                this._dailyUpdateInterval();
                this._updateRecurringPeriod(this.recurringPeriods.daily);
                this._toggleEndCalculatorVisibility(this._rdoDailyEvery.get('checked'));
            }
        },
        _dailyUpdateInterval: function () {
            this.interval = (this._rdoDailyEvery.get('checked')) ? this._dailyEveryText.get('value') : this._dailyEveryAfterText.get('value');
            if (isNaN(this.interval)) {
                this.interval = 1;
            }
        },
        _weeklyChanged: function (checked) {
            if (checked) {
                //console.log('weekly is now checked');
                this._panelContainer.selectChild(this._weeklyPanel);
                this._weeklyUpdateInterval();
                this._updateRecurringPeriod(this.recurringPeriods.weekly);
                this._toggleEndCalculatorVisibility(this._rdoWeeklyEvery.get('checked'));
            }
        },
        _weeklySyncToStartDate: function () {
            this._clearCheckedWeekdays();
            this._enforceWeekdayChecked();
        },
        _weeklyUpdateInterval: function () {
            this._enforceWeekdayChecked();
            this.interval = (this._rdoWeeklyEvery.get('checked')) ? this._weeklyEveryText.get('value') : this._weeklyEveryAfterText.get('value');
            if (isNaN(this.interval)) {
                this.interval = 1;
            }
        },
        _monthlyChanged: function (checked) {
            if (checked) {
                //console.log('monthly is now checked');
                this._panelContainer.selectChild(this._monthlyPanel);
                this._monthlyUpdateInterval();
                this._updateRecurringPeriod(this.recurringPeriods.monthly);
                this._toggleEndCalculatorVisibility(!this._rdoMonthlyAfter.get('checked'));
            }
        },
        _monthlyUpdateInterval: function () {
            this.interval = (this._rdoMonthlyOn.get('checked')) ? this._monthlyEveryText.get('value') :
                                (this._rdoMonthlyOnThe.get('checked')) ? this._monthlyOnTheText.get('value') : this._monthlyAfterText.get('value');
            if (isNaN(this.interval)) {
                this.interval = 1;
            }
        },
        _monthlySyncToStartDate: function () {
            this._datesSelect.set('value', this.startDate.getDate().toString());
            this._weekdaySelect.set('value', this.startDate.getDay().toString());
            this._weeksSelect.set('value', activityUtility.getNthWeekOfMonth(this.startDate).toString());

        },
        _yearlyChanged: function (checked) {
            if (checked) {
                //console.log('yearly is now checked');
                this._panelContainer.selectChild(this._yearlyPanel);
                this._yearlyUpdateInterval();
                this._updateRecurringPeriod(this.recurringPeriods.yearly);
                this._toggleEndCalculatorVisibility(!this._rdoYearlyEveryAfter.get('checked'));
            }
        },
        _yearlyUpdateInterval: function () {
            this.interval = (this._rdoYearlyOn.get('checked')) ? this._yearlyEveryText.get('value') :
                                (this._rdoYearlyEveryAfter.get('checked')) ? this._yearlyEveryAfterText.get('value') : 1;
        },
        _yearlySyncToStartDate: function () {
            this._monthNamesSelect.set('value', (this.startDate.getMonth() + 1).toString());
            this._yearDatesSelect.set('value', this.startDate.getDate().toString());
            this._yearWeeksSelect.set('value', activityUtility.getNthWeekOfMonth(this.startDate).toString());
            this._yearWeekdaySelect.set('value', this.startDate.getDay().toString());
            this._yearMonthNamesSelect.set('value', (this.startDate.getMonth() + 1).toString());
        },
        _updateRecurringPeriod: function (period) {
            //console.log('recurring period changed... ' + period);
            //console.log('recurring period changed, the interval is now ' + this.interval);
            this._toggleEndCalculatorVisibility(period !== this.recurringPeriods.once);

            this.currentPeriod = period;
            this._calculateEnd();
            this.onRecurPeriodChanged(period);
        },
        _toggleEndCalculatorVisibility: function (visible) {
            if (visible) {
                domClass.remove(this._startEndCalculator, 'display-none');
            } else {
                domClass.add(this._startEndCalculator, 'display-none');
            }
        },

        // data handling ......................................................................................
        // databinding controls when opening an existing activity for editing...
        _applyActivityData: function () {
            /* take the recurring information from the activity and set the controls appropriately  */
            /*
            RecurPeriod key:
            0 : Daily - every x days, end after n occurrences
            1 : Daily - every x days after completion
            2 : Weekly - every x weeks on day, end after n occurrences
            3 : Weekly - every x weeks after completion
            4 : Monthly - every x months, on day d, end after n occurrences
            5 : Monthly - every x months, on d'st, day, end after n occurrences
            6 : Monthly - every x months after completion
            7 : Yearly - every x years on mm/dd, end after n occurrences
            8 : Yearly - on the d'st day of mon, end after n occurrences
            9 : Yearly - every x years after completion
            */

            this._applyingActivityData = true;

            if (this.activity && this.activity.hasOwnProperty('Recurring')) {
                this.startDate = Sage.Utility.Convert.toDateFromString(this.activity.StartDate);
                this.initialStartDate = Sage.Utility.Convert.toDateFromString(this.activity.StartDate);
                if (this.activity.Timeless || activityUtility.isDateFiveSecondRuleTimeless(this.startDate)) {
                    this.startDate = new Date(this.startDate.getUTCFullYear(), this.startDate.getUTCMonth(), this.startDate.getUTCDate(), 0, 0, 5);
                }
                this.activityRecurPeriodCode = this.activity.RecurPeriod;
                this.dtp_startRecur.set('value', this.startDate);
                if (!this.activity.Recurring) {
                    this.rdo_Once.set('checked', true);
                    this._toggleEndCalculatorVisibility(false);
                    //set these up so they are ready if the user turns on recurring
                    this._resetInterval();
                    this._weeklySyncToStartDate();
                    this._monthlySyncToStartDate();
                    this._yearlySyncToStartDate();
                    this._applyingActivityData = false;
                    return;
                }
                this._toggleEndCalculatorVisibility(true);
                switch (this.activity.RecurPeriod) {
                    case 0:
                    case 1:
                        this._applyDailyRecurringValues();
                        break;
                    case 2:
                    case 3:
                        this._applyWeeklyRecurringValues();
                        break;
                    case 4:
                    case 5:
                    case 6:
                        this._applyMonthlyRecurringValues();
                        break;
                    case 7:
                    case 8:
                    case 9:
                        this._applyYearlyRecurringValues();
                        break;
                    default:
                        this.rdo_Once.set('checked', true);
                }
                this._applyingActivityData = false;
            }
            
        },
        _applyEndCalculatorValues: function () {
            this.dtp_startRecur.set('value', this.startDate);
            this._rdoEndAfter.set('checked', true);
            this.num_Occurances.set('value', this.activity.RecurIterations);
            this._calculateEnd();
        },
        _applyDailyRecurringValues: function () {
            //console.log('_applyDailyRecurringValues');
            this.rdo_Daily.set('checked', true);
            this._toggleEndCalculatorVisibility(this.activity.RecurPeriod === 0);
            this.interval = this.activity.RecurPeriodSpec;
            if (this.activity.RecurPeriod === 0) {
                this._rdoDailyEvery.set('checked', true);
                this._dailyEveryText.set('value', this.activity.RecurPeriodSpec);
                this._applyEndCalculatorValues();
            } else if (this.activity.RecurPeriod === 1) {
                this._rdoDailyEveryAfter.set('checked', true);
                this._dailyEveryAfterText.set('value', this.activity.RecurPeriodSpec);
            }
        },
        _weekDayValues: {
            sun: 131072,
            mon: 262144,
            tue: 524288,
            wed: 1048576,
            thu: 2097152,
            fri: 4194304,
            sat: 8388608
        },
        _resetInterval: function () {
            this._rdoDailyEvery.set('checked', true);
            this._dailyEveryText.set('value', "1");
            this._dailyEveryAfterText.set('value', "1");

            this._rdoWeeklyEvery.set('checked', true);
            this._weeklyEveryText.set('value', "1");
            this._weeklyEveryAfterText.set('value', "1");

            this._rdoMonthlyOn.set('checked', true);
            this._monthlyEveryText.set('value', "1");
            this._monthlyOnTheText.set('value', "1");
            this._monthlyAfterText.set('value', "1");

            this._rdoYearlyOn.set('checked', true);
            this._yearlyEveryText.set('value', "1");
            this._yearlyEveryAfterText.set('value', "1");

            this.num_Occurances.set('value', "2");
            this.occurances = 2;
            this._intervalChanged(2);

        },
        _clearCheckedWeekdays: function () {
            this._chkSaturday.set('checked', false);
            this._chkFriday.set('checked', false);
            this._chkThursday.set('checked', false);
            this._chkThursday.set('checked', false);
            this._chkWednesday.set('checked', false);
            this._chkTuesday.set('checked', false);
            this._chkMonday.set('checked', false);
            this._chkSunday.set('checked', false);
        },
        _applyWeeklyRecurringValues: function () {
            //console.log('_applyWeeklyRecurringValues');
            this.rdo_Weekly.set('checked', true);
            this._toggleEndCalculatorVisibility(this.activity.RecurPeriod === 2);
            //clear any checked days first...
            this._clearCheckedWeekdays();
            //set the weekly every radio button
            //evaluate the period spec number (and check the right days)
            this.interval = this._evalRecurperiodspec(this.activity.RecurPeriodSpec, this.activity.RecurPeriod);
            if (this.activity.RecurPeriod === 2) {
                this._rdoWeeklyEvery.set('checked', true);
                this._weeklyEveryText.set('value', this.interval);
                this._enforceWeekdayChecked();
                this._applyEndCalculatorValues();
            } else if (this.activity.RecurPeriod === 3) {
                this._rdoWeeklyEveryAfter.set('checked', true);
                this._weeklyEveryAfterText.set('value', this.interval);
            }
        },
        _evalRecurperiodspec: function (recspec, recperiod) {
            //  Figure out what days to check and reduce the RecurPeriodSpec number to the right number of weeks/months/years between occurances.
            //  Several periods need the number reduced, but only check the days for period 2.            
            if (recspec > this._weekDayValues['sat']) {
                recspec = recspec - this._weekDayValues['sat'];
                if (recperiod === 2) { this._chkSaturday.set('checked', true); }
            }
            if (recspec > this._weekDayValues['fri']) {
                recspec = recspec - this._weekDayValues['fri'];
                if (recperiod === 2) { this._chkFriday.set('checked', true); }
            }
            if (recspec > this._weekDayValues['thu']) {
                recspec = recspec - this._weekDayValues['thu'];
                if (recperiod === 2) { this._chkThursday.set('checked', true); }
            }
            if (recspec > this._weekDayValues['wed']) {
                recspec = recspec - this._weekDayValues['wed'];
                if (recperiod === 2) { this._chkWednesday.set('checked', true); }
            }
            if (recspec > this._weekDayValues['tue']) {
                recspec = recspec - this._weekDayValues['tue'];
                if (recperiod === 2) { this._chkTuesday.set('checked', true); }
            }
            if (recspec > this._weekDayValues['mon']) {
                recspec = recspec - this._weekDayValues['mon'];
                if (recperiod === 2) { this._chkMonday.set('checked', true); }
            }
            if (recspec > this._weekDayValues['sun']) {
                recspec = recspec - this._weekDayValues['sun'];
                if (recperiod === 2) { this._chkSunday.set('checked', true); }
            }
            return recspec;
        },
        _applyMonthlyRecurringValues: function () {
            //console.log('_applyMonthlyRecurringValues');
            this.rdo_Monthly.set('checked', true);
            var recspec = this.activity.RecurPeriodSpec;
            if (this.activity.RecurPeriod === 4) {
                //check the Every x months on day n radio
                this._rdoMonthlyOn.set('checked', true);
                //figure out the number of months between occurances...
                recspec = this._evalRecurperiodspec(recspec, this.activity.RecurPeriod);
                if (recspec > 65000) {
                    recspec = recspec % 65536;
                }
                this._monthlyEveryText.set('value', recspec);

                // set the day...
                this._datesSelect.set('value', this.startDate.getDate().toString());
                this._applyEndCalculatorValues();
            } else if (this.activity.RecurPeriod === 5) {

                //debugger;

                //check the every x months on the radio
                this._rdoMonthlyOnThe.set('checked', true);


                var wDay = Math.floor(recspec / 524288) - 1;
                recspec = recspec % 524288;
                var mWeek = Math.floor(recspec / 65536);
                recspec = recspec % 65536;

                //select the n'st day select box
                mWeek++;
                this._weeksSelect.set('value', (mWeek).toString());

                // select the day of the week
                this._weekdaySelect.set('value', wDay.toString());

                //set the number of months between occurances...
                this._monthlyOnTheText.set('value', recspec);
                this._applyEndCalculatorValues();
            } else if (this.activity.RecurPeriod === 6) {
                //ToDo:
                // check the every x months after completion radio
                this._rdoMonthlyAfter.set('checked', true);
                if (recspec > 1048576) {
                    recspec = recspec - 1048576;
                    if (recspec > 1000) {
                        recspec = recspec % 65536;
                    }
                }
                this._monthlyAfterText.set('value', recspec);

            }
            this.interval = recspec;
            this._toggleEndCalculatorVisibility(this.activity.RecurPeriod !== 6);
        },
        _applyYearlyRecurringValues: function () {
            //console.log('_applyYearlyRecurringValues');
            var mon;
            this.rdo_Yearly.set('checked', true);
            var recspec = this.activity.RecurPeriodSpec;
            if (this.activity.RecurPeriod === 7) {
                //select the "every x years on" radio control
                this._rdoYearlyOn.set('checked', true);
                // number of years between occurances...
                if (recspec > 38797312) {
                    recspec = eval(recspec) - 38797312;
                } else {
                    recspec = eval(recspec) - 17825792;
                }
                if (recspec > 1000) {
                    recspec = this._evalRecurperiodspec(recspec, this.activity.RecurPeriod);
                    recspec = recspec % 65536;
                }
                this._yearlyEveryText.set('value', recspec);
                // set the month and day from the start date...
                mon = this.startDate.getMonth();
                mon++;
                this._monthNamesSelect.set('value', mon.toString());

                var d = this.startDate.getDate();
                this._yearDatesSelect.set('value', d.toString());

                this._applyEndCalculatorValues();
            } else if (this.activity.RecurPeriod === 8) {
                //ToDo: This should be right, but something is wrong - either in scheduling them in 7.5.4 or in this logic...
                this._rdoYearlyOnThe.set('checked', true);

                //                console.warn('ToDo: There appears to be problems with this option - Yearly recurring, selecting the n\'st weekday in month.  Check that these are saving correctly in 7.5.4 - they do not seem to be.');

                mon = Math.floor(recspec / 4194304);
                recspec = recspec % 4194304;
                var wDay = Math.floor(recspec / 524288) - 1;
                recspec = recspec % 524288;
                var mWeek = Math.floor(recspec / 65536);
                mWeek++;
                recspec = recspec % 65536;

                this._yearWeeksSelect.set('value', mWeek.toString());
                this._yearWeekdaySelect.set('value', wDay.toString());
                this._yearMonthNamesSelect.set('value', mon.toString());


                this._applyEndCalculatorValues();
            } else if (this.activity.RecurPeriod === 9) {
                this._rdoYearlyEveryAfter.set('checked', true);

                if (recspec > 38797312) {
                    recspec = recspec - 38797312;
                    if (recspec > 1000) {
                        recspec = this._evalRecurperiodspec(recspec, this.activity.RecurPeriod);
                        recspec = recspec % 65536;
                    }
                }
                this._yearlyEveryAfterText.set('value', recspec);

            }
            this.interval = recspec;
            this._toggleEndCalculatorVisibility(this.activity.RecurPeriod !== 9);
        },
        // end databinding controls when opening an existing activity for editing...





        // daily panel handling......................................................................................
        _dailyEveryChanged: function () {
            this._setDailyUI();
            this._applyChangesToActivity();
        },
        _setDailyUI: function () {
            //console.log('_setDailyUI');
            var dailyEveryChecked = this._rdoDailyEvery.get('checked');
            this._dailyEveryText.set('disabled', !dailyEveryChecked);
            this._dailyEveryAfterText.set('disabled', dailyEveryChecked);
            this._dailyUpdateInterval();
            this.activityRecurPeriodCode = this._rdoDailyEvery.get('checked') ? 0 : 1;
            this._toggleEndCalculatorVisibility(dailyEveryChecked);
        },
        // weekly panel handling ....................................................................................
        _weeklyEveryChanged: function () {
            this._setWeeklyUI();
            this._applyChangesToActivity();
        },
        _setWeeklyUI: function () {
            //console.log('_setWeeklyUI');
            var disable = !this._rdoWeeklyEvery.get('checked');
            this._weeklyEveryText.set('disabled', disable);
            this._chkMonday.set('disabled', disable);
            this._chkTuesday.set('disabled', disable);
            this._chkWednesday.set('disabled', disable);
            this._chkThursday.set('disabled', disable);
            this._chkFriday.set('disabled', disable);
            this._chkSaturday.set('disabled', disable);
            this._chkSunday.set('disabled', disable);

            this._weeklyEveryAfterText.set('disabled', !this._rdoWeeklyEveryAfter.get('checked'));
            this._enforceWeekdayChecked();
            this._weeklyUpdateInterval();
            this.activityRecurPeriodCode = this._rdoWeeklyEvery.get('checked') ? 2 : 3;
            this._toggleEndCalculatorVisibility(this._rdoWeeklyEvery.get('checked'));
        },
        _dayChecked: function () {
            this._enforceWeekdayChecked();
            this._calculateEnd();
        },
        _enforceWeekdayChecked: function () {
            var checkedCount = this.countCheckedDays();
            if (checkedCount < 1) {
                var d = this.startDate.getDay();
                switch (d) {
                    case 0:
                        this._chkSunday.set('checked', true);
                        break;
                    case 1:
                        this._chkMonday.set('checked', true);
                        break;
                    case 2:
                        this._chkTuesday.set('checked', true);
                        break;
                    case 3:
                        this._chkWednesday.set('checked', true);
                        break;
                    case 4:
                        this._chkThursday.set('checked', true);
                        break;
                    case 5:
                        this._chkFriday.set('checked', true);
                        break;
                    case 6:
                        this._chkSaturday.set('checked', true);
                        break;
                }
            }
            if (checkedCount > this.occurances) {
                this._setOccurancesAttr(checkedCount);
            }
        },
        getCheckedDays: function () {
            // returns an array of 7 numbers, either 0 or 1 corresponding to the whether
            // the corresponding day is checked or not; 1 means checked 0 means unchecked.
            // The number in the 0 position is sunday, 1 is monday etc.
            return [
                this._chkSunday.get('checked') ? 1 : 0, //'sun': 
                this._chkMonday.get('checked') ? 1 : 0, //'mon': 
                this._chkTuesday.get('checked') ? 1 : 0, //'tue': 
                this._chkWednesday.get('checked') ? 1 : 0, //'wed': 
                this._chkThursday.get('checked') ? 1 : 0, //'thu': 
                this._chkFriday.get('checked') ? 1 : 0, //'fri': 
                this._chkSaturday.get('checked') ? 1 : 0 //'sat': 
            ];
        },
        countCheckedDays: function () {
            var checkedCount = 0;
            var checkedDays = this.getCheckedDays();
            for (var i = 0; i < checkedDays.length; i++) {
                checkedCount += Number(checkedDays[i]);
            }
            return checkedCount;
        },
        // monthly panel handling...................................................................................
        _monthlyOnChanged: function () {
            this._setMonthlyUI();
            if (this._rdoMonthlyAfter.get('checked')) {       //for the other two cases, this has already happened.
                this._applyChangesToActivity();               //                                  <---<<<   <---<<<
            }
        },
        _setMonthlyUI: function () {
            //console.log('_setMonthlyUI');
            var disable = !this._rdoMonthlyOn.get('checked');
            this._monthlyEveryText.set('disabled', disable);
            this._datesSelect.set('disabled', disable);

            disable = !this._rdoMonthlyOnThe.get('checked');
            this._monthlyOnTheText.set('disabled', disable);
            this._weeksSelect.set('disabled', disable);
            this._weekdaySelect.set('disabled', disable);

            this._monthlyAfterText.set('disabled', !this._rdoMonthlyAfter.get('checked'));
            this._monthlyUpdateInterval();
            this.activityRecurPeriodCode = this._rdoMonthlyOn.get('checked') ? 4 : this._rdoMonthlyOnThe.get('checked') ? 5 : 6;
            this._toggleEndCalculatorVisibility(!this._rdoMonthlyAfter.get('checked'));
            if (this.activityRecurPeriodCode < 6) {
                this._calculateEnd();
            }
        },
        _monthlyValidateEndDate: function () {
            if (this.rdo_Monthly.get('checked')) {
                //ToDo:  this logic assumes that the month selected matches
                // the pattern.  For example, if the recurrence is every 6 months and they select
                // a date 7 months away, this will stay in the same month and show a date 
                // that is not actually in the recurrence pattern.
                // Incidentally, I tried the example above in 7.5.4 - and it set the date 5 years later
                // than the date I selected and set occurances to 10.  hmmmm...
                var endDate = this.dtp_endRecur.get('value');
                //console.log('validating end date for monthly recurring... %o', endDate);
                if (this._rdoMonthlyOn.get('checked')) {
                    //make sure the end date matches the date...
                    var correctDate = parseInt(this._datesSelect.get('value'), 10);
                    if (endDate.getDate() !== correctDate) {
                        endDate.setDate(correctDate);
                        this.dtp_endRecur.set('value', endDate);
                        //console.log('montly end date validation failed changing date to %o', endDate);
                        return false;
                    }
                } else if (this._rdoMonthlyOnThe.get('checked')) {
                    //make sure the end date matches the nth weekday...
                    var correctDay = parseInt(this._weekdaySelect.get('value'), 10);
                    var correctWeek = parseInt(this._weeksSelect.get('value'), 10);
                    if (activityUtility.getNthWeekOfMonth(endDate) !== correctWeek || endDate.getDay() !== correctDay) {
                        endDate = activityUtility.setDateToNthWeekDay(endDate, correctWeek, correctDay);
                        this.dtp_endRecur.set('value', endDate);
                        //console.log('montly end date validation failed changing date to %o', endDate);
                        return false;
                    }
                }
            }
            return true;
        },
        // yearly panel handling.....................................................................................
        _yearlyOnChanged: function () {
            this._setYearlyUI();
            this._applyChangesToActivity();
        },
        _setYearlyUI: function () {
            //console.log('_setYearlyUI');
            var disable = !this._rdoYearlyOn.get('checked');
            this._yearlyEveryText.set('disabled', disable);
            this._monthNamesSelect.set('disabled', disable);
            this._yearDatesSelect.set('disabled', disable);

            disable = !this._rdoYearlyOnThe.get('checked');
            this._yearWeeksSelect.set('disabled', disable);
            this._yearWeekdaySelect.set('disabled', disable);
            this._yearMonthNamesSelect.set('disabled', disable);

            this._yearlyEveryAfterText.set('disabled', !this._rdoYearlyEveryAfter.get('checked'));
            this._yearlyUpdateInterval();
            this.activityRecurPeriodCode = this._rdoYearlyOn.get('checked') ? 7 : this._rdoYearlyOnThe.get('checked') ? 8 : 9;
            this._toggleEndCalculatorVisibility(!this._rdoYearlyEveryAfter.get('checked'));
        },
        _yearlyValidateEndDate: function () {
            var valid = true;
            if (this.rdo_Yearly.get('checked')) {
                var endDate = this.dtp_endRecur.get('value');
                var mon = this.startDate.getMonth();
                if (endDate.getMonth() !== mon) {
                    valid = false;
                    endDate.setMonth(mon);
                }
                if (this._rdoYearlyOn.get('checked')) {
                    var dt = this.startDate.getDate();
                    if (endDate.getDate !== dt) {
                        valid = false;
                        endDate.setDate(dt);
                    }
                } else if (this._rdoYearlyOnThe.get('checked')) {
                    //make sure the end date matches the nth weekday...
                    var correctDay = parseInt(this._yearWeekdaySelect.get('value'), 10);
                    var correctWeek = parseInt(this._yearWeeksSelect.get('value'), 10);
                    if (activityUtility.getNthWeekOfMonth(endDate) !== correctWeek || endDate.getDay() !== correctDay) {
                        valid = false;
                        endDate = activityUtility.setDateToNthWeekDay(endDate, correctWeek, correctDay);
                    }
                }
                if (!valid) {
                    this.dtp_endRecur.set('value', endDate);
                }
            }
            return valid;
        },
        _yearlyRecurDateChanged: function () {
            // avoid changing the start date before things have settled down...
            if (this._applyingActivityData) { return; }
            var month, changed = false;
            //debugger;
            var tempStartDate = new Date(this.startDate.getFullYear(), this.startDate.getMonth(), this.startDate.getDate());
            if (this._rdoYearlyOn.get('checked')) {
                //get the date characteristics from the "every x years on" section...
                month = parseInt(this._monthNamesSelect.get('value'), 10) - 1;
                var dt = parseInt(this._yearDatesSelect.get('value'), 10);
                if (tempStartDate.getMonth() !== month) {
                    tempStartDate.setMonth(month);
                    changed = true;
                }
                if (tempStartDate.getDate() !== dt) {
                    tempStartDate.setDate(dt);
                    changed = true;
                }

            } else if (this._rdoYearlyOnThe.get('checked')) {
                //get the date characteristics from the "The n'st weekday in month" section...
                month = parseInt(this._yearMonthNamesSelect.get('value'), 10) - 1;
                if (tempStartDate.getMonth() !== month) {
                    tempStartDate.setMonth(month);
                    changed = true;
                }
                var dy = parseInt(this._weekdaySelect.get('value'), 10);
                var wk = parseInt(this._weeksSelect.get('value'), 10);
                var compareDate = activityUtility.setDateToNthWeekDay(tempStartDate, wk, dy);
                if (tempStartDate.getDate() !== compareDate.getDate()) {
                    if (compareDate < new Date()) {
                        compareDate = dDate.add(compareDate, 'year', 1);
                        compareDate = activityUtility.setDateToNthWeekDay(compareDate, wk, dy);
                    }
                    tempStartDate = compareDate;
                    changed = true;
                }
            }
            if (changed) {
                //if it is in the past, add a year...
                if (tempStartDate < new Date()) {
                    tempStartDate = dDate.add(tempStartDate, 'year', 1);
                }

                //console.log('one of the yearly recurring select boxes has been changed - causing the start date to change.');

                if (!this.startDateChangedFromParent) {
                    this.onStartDateChanged(tempStartDate);
                }

            }
        },
        // common ui handling........................................................................................
        _intervalChanged: function (newVal) {
            // occurs when the interval value changes on any recurring type.
            this.interval = newVal;
            this._calculateEnd();
        },
        _recurringStartDateChanged: function (newStart) {
            //console.log('firing onStartDateChanged...');
            if (!this.startDateChangedFromParent) {
                this.onStartDateChanged(newStart);
            }
        },
        _endCalcModeChanged: function () {

        },
        _numOccurancesChanged: function (occurances) {
            this.occurances = occurances;
            this._calculateEndDate();
        },
        _endRecurChanged: function (newEnd) {
            if (this._rdoEndOn.get('checked')) {
                if (this._monthlyValidateEndDate() && this._yearlyValidateEndDate()) {
                    this._calculateOccurances();
                }
            }
        },
        _calculateEnd: function () {
            if (this.currentPeriod === 'once') {
                this._applyChangesToActivity();
                return;
            }
            if (this._rdoEndAfter.get('checked')) {
                if (this.rdo_Monthly.get('checked') && !this.startDateChangedFromParent) {
                    this._calculateStartDate();
                }
                this._calculateEndDate();
            } else {
                this._calculateOccurances();
            }
        },
        _calculateStartDate: function () {
            var calculator = this.endCalculators[this.currentPeriod];
            if (calculator && this._rdoEndAfter.get('checked')) {
                this._applyCurrentValuesToCalculator(calculator);
                calculator.set('occurances', this.occurances);
                var startDate = calculator.calculateStartDate();
                this.startDate = startDate;
                this.dtp_startRecur.set('value', startDate);
                if (!this.startDateChangedFromParent) {
                    this.onStartDateChanged(startDate);
                }
            }

        },
        _calculateEndDate: function () {
            var calculator = this.endCalculators[this.currentPeriod];
            if (calculator && this._rdoEndAfter.get('checked')) {
                this._applyCurrentValuesToCalculator(calculator);
                calculator.set('occurances', this.occurances);
                var endDate = calculator.calculateEndDate();
                this.dtp_endRecur.set('value', endDate);
                //IS THIS THE RIGHT PLACE TO CALL THIS?????????????????????   <---<<<   <---<<<
                this._applyChangesToActivity();
            }
        },
        _applyCurrentValuesToCalculator: function (calculator) {
            calculator.set('startDate', this.startDate);
            calculator.set('initialStartDate', this.initialStartDate);
            calculator.set('interval', this.interval);
            calculator.set('activityRecurPeriodCode', this.activityRecurPeriodCode);
        },
        _calculateOccurances: function () {
            var calculator = this.endCalculators[this.currentPeriod];
            if (calculator && this._rdoEndOn.get('checked')) {
                this._applyCurrentValuesToCalculator(calculator);
                calculator.set('endDate', this.dtp_endRecur.get('value'));
                var occ = 1;
                if (calculator.endDate < calculator.startDate) {
                    this.dtp_endRecur.set('value', this.startDate);
                } else {
                    occ = calculator.calculateNumberOfOccurances();
                }
                this.occurances = occ;
                this.num_Occurances.set('value', occ);
                //IS THIS THE RIGHT PLACE TO CALL THIS?????????????????????   <---<<<   <---<<<
                this._applyChangesToActivity();
            }
        },
        _applyChangesToActivity: function () {
            //calculate and set the values of the Recurring fields on the activity
            if (this._applyingActivityData) { return; }
            //console.log('calculating and applying recurring data to activity...');
            if (this.rdo_Once.get('checked')) {
                this.activity.RecurIterations = 0;
                this.activity.RecurPeriod = 0;
                this.activity.RecurPeriodSpec = 0;
                this.activity.Recurring = false;
                return;
            }

            var recperiod = this._getCurrentRecperiod();
            this.activity.RecurPeriod = recperiod;
            var modifier = 0;
            var occurances = this.num_Occurances.get('value');
            switch (recperiod) {
                case 0:
                case 1:
                    this._dailyUpdateInterval();
                    if (recperiod === 1) { occurances = -1; }
                    break;
                case 2:
                    modifier = this._sumWeekDays();
                    this._weeklyUpdateInterval();
                    break;
                case 3:
                    modifier = 1048576;
                    this._weeklyUpdateInterval();
                    occurances = -1;
                    break;
                case 4:
                    modifier = 1048576;
                    this._monthlyUpdateInterval();
                    break;
                case 5:
                    modifier = this._sumMonthly();
                    this._monthlyUpdateInterval();
                    break;
                case 6:
                    modifier = 1048576;
                    this._monthlyUpdateInterval();
                    occurances = -1;
                    break;
                case 7:
                    modifier = 38797312;
                    this._yearlyUpdateInterval();
                    break;
                case 8:
                    modifier = this._sumYearly();
                    this.interval = 1;
                    break;
                case 9:
                    modifier = 38797312;
                    this._yearlyUpdateInterval();
                    occurances = -1;
                    break;
            }
            this.activity.RecurIterations = occurances;
            this.activity.RecurPeriodSpec = modifier + this.interval;
            this.activity.Recurring = true;

            //            console.log('calculated and applied the recuring properties of activity.  interval: ' + this.interval);
            //            console.log('RecurIterations: ' + occurances);
            //            console.log('RecurPeriod: ' + recperiod);
            //            console.log('RecurPeriodSpec: ' + this.activity.RecurPeriodSpec);

        },
        _getCurrentRecperiod: function () {
            if (this.rdo_Daily.get('checked')) {
                return (this._rdoDailyEvery.get('checked')) ? 0 : 1;
            }
            if (this.rdo_Weekly.get('checked')) {
                return (this._rdoWeeklyEvery.get('checked')) ? 2 : 3;
            }
            if (this.rdo_Monthly.get('checked')) {
                return (this._rdoMonthlyOn.get('checked')) ? 4 :
                            (this._rdoMonthlyOnThe.get('checked')) ? 5 : 6;
            }
            if (this.rdo_Yearly.get('checked')) {
                return (this._rdoYearlyOn.get('checked')) ? 7 :
                                (this._rdoYearlyOnThe.get('checked')) ? 8 : 9;
            }
            return 0;
        },
        _sumWeekDays: function () {
            var result = 0;
            if (this._chkSaturday.get('checked')) {
                result += this._weekDayValues['sat'];
            }
            if (this._chkFriday.get('checked')) {
                result += this._weekDayValues['fri'];
            }
            if (this._chkThursday.get('checked')) {
                result += this._weekDayValues['thu'];
            }
            if (this._chkWednesday.get('checked')) {
                result += this._weekDayValues['wed'];
            }
            if (this._chkTuesday.get('checked')) {
                result += this._weekDayValues['tue'];
            }
            if (this._chkMonday.get('checked')) {
                result += this._weekDayValues['mon'];
            }
            if (this._chkSunday.get('checked')) {
                result += this._weekDayValues['sun'];
            }
            //console.log('sum week days: ' + result);
            return result;
        },
        _getNthOccurenceOfWeekDay: function () {
            var weekDay = parseInt(this._weekdaySelect.get('value'), 10);
            var nthWeek = parseInt(this._weeksSelect.get('value'), 10);
            var today = new Date();

            for (var i = 0; i < 7; i++) {
                var d = new Date(today.getFullYear(), today.getMonth(), i + 1);
                if (d.getDay() == weekDay) {
                    return dojo.date.add(d, "day", ((nthWeek - 1) * 7));
                }
            }

        },
        _sumMonthly: function () {
            // used to determine the value for periodspec for activities that occur
            // monthly every nth weekday (i.e. every 3 months on the 3rd Friday).

            var weekDay = parseInt(this._weekdaySelect.get('value'), 10) + 1;
            var nthWeek = parseInt(this._weeksSelect.get('value'), 10);
            return ((weekDay * 524288) + ((nthWeek - 1) * 65536));
        },
        _sumYearly: function () {
            // returns the value for recperiodspec for activities that occur
            // yearly every nth weekday of a specific month (i.e. every 3rd Friday of September).

            var weekDay = parseInt(this._yearWeekdaySelect.get('value'), 10) + 1;
            var monthNum = parseInt(this._yearMonthNamesSelect.get('value'), 10);
            var nthWeek = parseInt(this._yearWeeksSelect.get('value'), 10);
            return ((monthNum * 4194304) + (weekDay * 524288) + ((nthWeek - 1) * 65536));

        },
        _setReadOnly: function (readOnly) {
            var recurringDisableList = ["rdo_Once", "rdo_Daily", "rdo_Weekly", "rdo_Monthly", "rdo_Yearly", "_rdoDailyEvery", "_dailyEveryText", "_rdoDailyEveryAfter", "_dailyEveryAfterText", "_rdoWeeklyEvery", "_weeklyEveryText", "_chkMonday", "_chkTuesday", "_chkWednesday", "_chkThursday", "_chkFriday", "_chkSaturday", "_chkSunday", "_rdoWeeklyEveryAfter", "_weeklyEveryAfterText", "_rdoMonthlyOn", "_monthlyEveryText", "_datesSelect", "_rdoMonthlyOnThe", "_monthlyOnTheText", "_weeksSelect", "_weekdaySelect", "_rdoMonthlyAfter", "_monthlyAfterText", "_rdoYearlyOn", "_yearlyEveryText", "_monthNamesSelect", "_yearDatesSelect", "_rdoYearlyOnThe", "_yearWeeksSelect", "_yearWeekdaySelect", "_yearMonthNamesSelect", "_rdoYearlyEveryAfter", "_yearlyEveryAfterText", "dtp_startRecur", "_rdoEndAfter", "num_Occurances", "_rdoEndOn", "dtp_endRecur"];
            if (readOnly) {
                this._bulkSetProperty(this, recurringDisableList, 'disabled', true);
            } else {
                this._bulkSetProperty(this, recurringDisableList, 'disabled', false);
                this._setUI();
                this._applyActivityData();
            }
        },
        _bulkSetProperty: function (ui, propsList, prop, val) {
            for (var i = 0; i < propsList.length; i++) {
                var ctrl = ui[propsList[i]];
                if (ctrl) {
                    ctrl.set(prop, val);
                }
            }
        },
        // events for main editor...
        onStartDateChanged: function (newStartDate) { },
        onRecurPeriodChanged: function (newRecPer) { }
    });
    return recurringEditor;
});

},
'Sage/UI/Controls/Numeric':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
       'dojo/_base/html',
       'dijit/_Widget',
       'Sage/_Templated',
       'Sage/UI/NumberTextBox',
       'dojo/currency',
       'dojo/_base/declare',
       'dojo/_base/sniff',
       'dojo/has'
],
function (html, _Widget, _Templated, NumberTextBox, currency, declare, _sniff, has) {
    //TODO: This hook will be depricated once ClientBindingManagerService has been converted with Dojo.
    dojo.mixin(dijit.form.ValidationTextBox.prototype.attributeMap, { slxchangehook: 'focusNode' });

    var widget = declare("Sage.UI.Controls.Numeric", [_Widget, _Templated], {
        //using Simplate to faciliate conditional display
        //Reference enum for Display Modes
        displayModes: {
            //Renders the control as hyperlinked text.
            'AsHyperlink': 0,
            //Default rendering of the control.
            'AsControl': 1,
            //Renders the control a text only.        
            'AsText': 2
        },
        //Display Mode template object.
        modeTemplates: {
            // This is for future user, this option is not in AA - Renders the control as hyperlinked text.
            'AsHyperlink': new Simplate([
                '<div data-dojo-type="dijit.form.Button" showLabel="true">ONE</div>'
            ]),
            //Default rendering of the control.
            'AsControl': new Simplate([
                '<input  data-dojo-type="Sage.UI.NumberTextBox" ',
                'dojoAttachEvent="onChange:onChanged" ',
                'constraints="{ {%= $.constraintsToString() %} }" ',
                'formatType="{%= $.formatType %}" ',
                'ignorechange="true" ',
                'required="{%= $.required %}" ',
                'id="{%= $.id %}_NumberTextBox" ',
                'style="width:inherit;" ',
                'textAlign="{%= $.textAlign %}" ',
                'hotKey="{%= $.hotKey %}" ',
                '{% if($.disabled === "disabled") { %} ',
                'disabled="disabled" ',
                '{% } %}',
                '{% if($.readonly === "readonly") { %} ',
                'readonly="readonly" ',
                '{% } %}',
                'name="{%= $.name %}" type="text" ',
                'value="{%= $.value %}" required="{%= $.required %}" dojoAttachPoint="focusNode" ',
                'maxLength="{%= $.maxLength %}">'
            ]),
            // This is for future user, this option is not in AA - Renders the control a text only.
            'AsText': new Simplate([
                '<div data-dojo-type="dijit.form.Button" showLabel="true">{%= $.formattedText() %}</div>'
            ])
        },
        postMixInProperties: function () {
            this.inherited(arguments);
        },
        postCreate: function () {
            this.inherited(arguments);
            // If this is generated by the Numeric server control, the container will be a span
            //  and the tabIndex of that span will need to be reset, otherwise a double-tab will
            //  have to be done to hit the actual Numeric textbox
            if (this.domNode.parentNode && this.domNode.parentNode.tagName == 'SPAN') {
                this.domNode.parentNode.tabIndex = -1;
            }

            if (this["class"] && this["class"].length > 0 && this.domNode.firstChild) {
                this.domNode.firstChild.className = this["class"] + ' ' + this.domNode.firstChild.className;
            }
        },
        constructor: function (options) {
            this.constraints = {};
            this.inherited(arguments);
        },
        widgetTemplate: new Simplate([
            '<div style="width:inherit;" slxcompositecontrol="true" id="{%= $.id %}" >',
            '{%= $.modeTemplates[$.displayMode].apply($) %}',
            '</div>'
        ]),
        value: 0,
        //summary:
        //.Net control behavior
        autoPostBack: false,
        width: 15,
        maxLength: 128,
        style: '',
        //These three props are for non-grid modes.  Add to basic control config but not column config.    
        enabled: true, // For non-grid mode. Redundant from grid.column.editable: true
        visible: true, // For non-grid mode. Redundant from field in grid Select but column not included.
        readonly: '',
        disabled: '',
        hotKey: '',
        tabIndex: 0,
        required: false,
        //Sets the display mode that the control will render in.
        displayMode: 'AsControl',
        // appliedSecurity: '',  Note: Not yet enabled on control.    
        widgetsInTemplate: true,
        styles: 'text-align: right;',
        constraints: null,
        name: '',
        formattedText: function () { return this.value; },
        formatType: '',
        constraintsToString: function () {
            // Stringify the constraints object, wrap string values in single quote
            var tmp = [];
            var prop;
            for (prop in this.constraints) {
                if (this.constraints.hasOwnProperty(prop)) {
                    var value = this.constraints[prop];
                    if (typeof value === 'string') {
                        value = "\'" + value + "\'";
                    }
                    tmp.push(prop + ":" + value);
                }
            }
            var results = tmp.join(",");
            return results;
        },
        onChanged: function (e) {
            /*
             * TODO: Something is injecting a __doPostBack anonymouse function for IE.
             */
            if (this.autoPostBack && !has('ie')) {
                if (Sys) {
                    Sys.WebForms.PageRequestManager.getInstance()._doPostBack(this.id, null);
                }
            }
        }
    });

    return widget;
});

},
'Sage/UI/NumberTextBox':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
       'dijit/form/NumberTextBox',
       'dijit/form/ValidationTextBox',
       'dojo/number',
       'Sage/Utility',
       'dojo/_base/declare'
],
function (NumberTextBox, ValidationTextBox, number, Utility, declare) {
    var widget = declare("Sage.UI.NumberTextBox", NumberTextBox, {
        shouldPublishMarkDirty: true,
        //.Net control behavior
        autoPostBack: false,
        hotKey: '',
        maxLength: '',
        formatType: '',
        attributeMap: {
            hotKey: { node: 'textbox', type: 'attribute', attribute: 'accessKey' },
            maxLength: { node: 'textbox', type: 'attribute', attribute: 'maxLength' }
        },
        textAlign: '',
        _getValueAttr: function () {
            var results = this.inherited(arguments);
            // the inherited stuff is too picky about decimal digits, we handle it our way,
            // when dojo doesn't like the number of digits, it returns undefined.
            if ((typeof results === 'undefined' || isNaN(results)) && this.textbox.value !== '') {
                results = this.getTextBoxValue();
            }

            return results;
        },
        _setValueAttr: function (v) {
            this.constraints['locale'] = Sys.CultureInfo.CurrentCulture.name;
            this.inherited(arguments);
        },
        _onFocus: function () {
            this.onFocusFiring = true;
            this.inherited(arguments); // Dojo will format this as a decimal

            // HACK
            if (this.constraints.type === 'percent' || this.formatType === 'Percent') {
                // var whole = Math.round(this.value * 10000) / 100;
                // this.textbox.value = number.format(whole, { locale: Sys.CultureInfo.CurrentCulture.name });
                var whole = ((this.value * 10000) / 100);
                this.textbox.value = number.format(whole, { places: this.constraints.places, locale: Sys.CultureInfo.CurrentCulture.name });
            }

            this.onFocusFiring = false;
        },
        _onBlur: function () {
            this.onBlurFiring = true;
            // HACK
            if (this.formatType === 'Percent' || this.constraints.type === 'percent') {
                // Strange issue if the control is focused on page load,
                // the textbox value should NOT contain a percent sign on blur
                if (this.textbox.value.indexOf(Sys.CultureInfo.CurrentCulture.numberFormat.PercentSymbol) === -1) {
                    var enteredValue = this.getTextBoxValue();
                    var toDecimal = enteredValue / 100;
                    if (typeof (this.constraints.places) === 'number') {
                        this.set('displayedValue', number.format(toDecimal, { places: this.constraints.places + 2, locale: Sys.CultureInfo.CurrentCulture.name })); // trick dojo into thinking we entered a decimal
                    } else if (typeof (this.constraints.places) === 'string' && this.constraints.places.indexOf(',') > 0 && this.constraints.places[2]) {
                        this.set('displayedValue', number.format(toDecimal, { places: Math.floor(this.constraints.places[2]) + 2, locale: Sys.CultureInfo.CurrentCulture.name }));
                    } else {
                        this.set('displayedValue', number.format(toDecimal, { locale: Sys.CultureInfo.CurrentCulture.name }));
                    }
                }
            }
            this.onBlurFiring = false;
            this.inherited(arguments);
        },
        _sageUINumberTextBox_IsValid: function () {
            //In IE dojo makes two passes through validation.  Only on the second pass is the new value present.
            if (this.formatType !== 'Percent' || this.constraints.type !== 'percent') {
                if (dojo.isIE) {
                    if (this.oldValue !== this.textbox.value) {
                        var trim = this._restrictDD();
                        if (trim !== this.textbox.value) {
                            this.textbox.value = trim;
                        }
                    }
                    this.oldValue = this.textbox.value;
                } else {
                    this.textbox.value = this._restrictDD();
                }
            }
            this.inherited(arguments);
        },
        _restrictDD: function () {
            var retVal = this.textbox.value;
            if (this.onBlurFiring || this.onFocusFiring) {
                // Prevent this from running when onFocus or onBlur are firing (dojo makes changes to the text at that point).
                return retVal;
            }
            if (this.constraints.places) {
                retVal = Utility.restrictDecimalDigit(this.textbox.value, this.constraints.places);
            }
            return retVal;
        },
        _sageUINumberTextBox_KeyPress: function (e) {
            var type = typeof this.constraints.type == 'undefined' ? this.formatType : null;
            if (!Utility.restrictToNumberOnKeyPress(e, type)) {
                dojo.stopEvent(e);
            }
        },
        _sageUINumberTextBox_OnFocus: function (/*Event*/e) {
            // Templated widgets are having difficulty remaining selectable in IE.  Reset their attribute to ensure access.
            dojo.setSelectable(this.domNode, true);
        },
        startup: function () {
            this.inherited(arguments);
            //summary:
            // Wire up event handlers and to add keystroke restrictions.
            var self = this;
            //Set the text alignment preference from the configuration object.
            dojo.style(self.focusNode, 'textAlign', self.textAlign);
            self.value = self.value || 0;
            self.onBlurFiring = false;
            self.onFocusFiring = false;
            //Event handlers
            this.connect(self, 'isValid', self._sageUINumberTextBox_IsValid);
            this.connect(self, 'onKeyPress', self._sageUINumberTextBox_KeyPress, true);
            this.connect(self, 'onFocus', self._sageUINumberTextBox_OnFocus, true);

            if (!this.ignorechange) {
                this.connect(self, 'onChange', self.valueChanged);
            }
        },
        valueChanged: function (e) {
            if (this.shouldPublishMarkDirty) {
                dojo.publish("Sage/events/markDirty");
            }
            if (this.autoPostBack) {
                if (Sys) {
                    Sys.WebForms.PageRequestManager.getInstance()._doPostBack(this.id, null);
                }
            }
        },
        getTextBoxValue: function () {
            var results = 0;
            var tbVal = this.textbox.value;

            if (tbVal === '' || tbVal === null) {
                tbVal = '0';
            }

            if (tbVal.lastIndexOf(Sys.CultureInfo.CurrentCulture.numberFormat.NumberDecimalSeparator) === tbVal.length - 1) {
                tbVal = tbVal.slice(0, tbVal.length - 1);
            }

            results = number.parse(tbVal, { locale: Sys.CultureInfo.CurrentCulture.name });

            if (isNaN(results)) {
                results = this.value;
            }
            return results;
        }
    });
    return widget;
});
},
'Sage/UI/Controls/DurationSelect':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'Sage/UI/Controls/_customSelectMixin',
    'Sage/Utility/Activity',
    'dojo/date',
    'dojo/date/locale',
    'dojo/data/ItemFileReadStore',
    'dojo/i18n!./nls/DurationSelect',
    'dojo/_base/declare'
],
function (_customSelectMixin, activityUtility, dojoDate, dojoLocale, ItemFileReadStore, durSelectStrings, declare) {
    var durationSelect = declare('Sage.UI.Controls.DurationSelect', _customSelectMixin, {
        id: '',
        startTime: new Date(),
        timeValue: new Date(),
        valuesAreAfterStart: true,
        _store: null,
        _storeData: {},
        labelFmt: '${amount} ${interval} (${endTime})',
        splitAmoutLabelFmt: '${amount1} ${interval1}, ${amount2} ${interval2} (${endTime})',

        //i18n strings
        minuteText: 'minute',
        minutesText: 'minutes',
        hourText: 'hour',
        hoursText: 'hours',
        dayText: 'day',
        daysText: 'days',
        //end i18n strings.
        timeIncrements: [0, 5, 10, 15, 30, 60, 120, 240],
        items: [],
        itemsByDur: {},
        constructor: function () {
            dojo.mixin(this, durSelectStrings);
        },
        resetItems: function () {
            this.items = [];
            this.itemsByDur = {};
        },
        _fillSelect: function () {
            if (this._select) {
                this.resetItems();
                var hasItemForCurrentValue = false;
                for (var i = 0; i < this.timeIncrements.length; i++) {
                    var inc = this.timeIncrements[i];
                    this.items.push(this._createItem(inc));
                    hasItemForCurrentValue = hasItemForCurrentValue || (this.value === inc);
                }
                if (!hasItemForCurrentValue && (this.value)) {
                    //this.timeIncrements.push(this.value);
                    this.items.push(this._createItem(this.value));
                }
                this._storeData = {
                    identifier: 'value',
                    label: 'label',
                    items: this.items
                };

                this._store = new ItemFileReadStore({ data: this._storeData });
                this._select.set('store', this._store);
                this._select.set('searchAttr', 'label');
                if (this.value || this.value === 0) {
                    this.set('value', this.value);
                }
            }
        },
        _createItem: function (inc) {
            var st = this.startTime;
            if (st.getHours() === 0 && st.getMinutes === 0 && st.getSeconds() === 5) {
                st = new Date(st.getUTCFullYear(), st.getUTCMonth(), st.getUTCDate(), 0, 0, 0);
            }
            var newD;
            newD = dojoDate.add(st, 'minute', (this.valuesAreAfterStart) ? inc : inc * -1);
            var obj = {
                'value': inc,
                'dateValue': newD,
                'label': this._formatLabel(inc, newD)
            };
            this.itemsByDur[inc] = obj;
            return obj;
        },
        _formatLabel: function (inc, dateval) {
            var hourinc;
            var fmtOptions = {
                amount: inc,
                interval: (inc === 1) ? this.minuteText : this.minutesText,
                endTime: dojoLocale.format(dateval, { selector: 'time', locale: Sys.CultureInfo.CurrentCulture.name })
            };
            var fmtStr = this.labelFmt;
            if (inc > 59) {
                var mod = inc % 60;
                hourinc = Math.floor(inc / 60);
                if (mod === 0) {
                    fmtOptions['amount'] = hourinc;
                    fmtOptions['interval'] = (hourinc === 1) ? this.hourText : this.hoursText;
                } else {
                    fmtOptions['amount1'] = hourinc;
                    fmtOptions['interval1'] = (hourinc === 1) ? this.hourText : this.hoursText;
                    fmtOptions['amount2'] = mod;
                    fmtOptions['interval2'] = (mod === 1) ? this.minuteText : this.minutesText;
                    fmtStr = this.splitAmoutLabelFmt;
                }
                if (hourinc > 23) {
                    var dayinc = Math.round(hourinc / 24);
                    fmtOptions['amount'] = dayinc;
                    fmtOptions['interval'] = (dayinc === 1) ? this.dayText : this.daysText;
                    fmtOptions['endTime'] = dojoLocale.format(dateval, { selector: 'datetime', locale: Sys.CultureInfo.CurrentCulture.name });
                }
            }
            return dojo.string.substitute(fmtStr, fmtOptions);
        },
        _handleValueNotInStore: function (newValue) {
            //override this method to create a new item, or revert to last known good value...
            var curVal = this.text;
            var timeReg = /\(([\s\S]*)\)/;
            var newMatches = timeReg.exec(newValue);
            var curMatches = timeReg.exec(curVal);
            if ((newMatches) && (curMatches)) {
                //we have something in parenthesis - 
                if (newMatches[1] === curMatches[1]) {
                    //the time was the same, so focus on what they put as the duration number...
                    newValue = newValue.replace(newMatches[0], '');
                } else {
                    //they changed the time... can we parse it?
                    var timeDate = dojoLocale.parse(newMatches[1], { selector: 'time' });
                    if (timeDate) {
                        timeDate.setFullYear(this.startTime.getFullYear());
                        timeDate.setMonth(this.startTime.getMonth());
                        timeDate.setDate(this.startTime.getDate());
                        this._setTimeValueAttr(timeDate);
                        return this.value;
                    }
                }
            }

            var dur = 0;
            if (typeof newValue === 'number') {
                dur = newValue;
            } else {
                //see if we have one or more numbers and intervals...
                if (newValue.indexOf(',') > 0) {
                    var sections = newValue.split(',');
                    for (var i = 0; i < sections.length; i++) {
                        var partDur = this._getMinutesFromStringPart(sections[i]);
                        if (partDur) {
                            dur += partDur;
                        }
                    }
                } else {
                    dur = this._getMinutesFromStringPart(newValue);
                }
            }
            if (!dur) {
                this._select.set('value', this.text);
                return this.value;
            }
            var newOption = this._createItem(dur);
            this.value = newOption.value;
            this.text = newOption.label;
            this._select.set('displayedValue', newOption.label);
            return newOption.value;
        },
        _setValueAttr: function (value) {
            this._removeOldValueFromStore();
            this.text = value;
            this.value = value;
            if (this._store) {
                this._store.fetchItemByIdentity({
                    identity: value,
                    onItem: function (item) {
                        if (item) {
                            //                        console.log('found the item in the store... %o', item);
                            this._select.set('value', this._store.getValue(item, this._storeData.label));
                            this.value = this._store.getValue(item, this._storeData.identifier);
                            this.text = this._store.getValue(item, this._storeData.label);
                        } else {
                            this._handleValueNotInStore(value);
                            //this._select.set('value', value);
                        }
                    },
                    onError: function () {
                        //console.log('did not find item. ' + this.value);
                    },
                    scope: this
                });
            }
        },
        _removeOldValueFromStore: function () {
            //we may want to leave it...
            for (var i = 0; i < this.timeIncrements.length; i++) {
                if (this.value === this.timeIncrements[i]) {
                    return;
                }
            }
            delete (this.itemsByDur[this.value]);
            var l = this.items.length;
            for (i = 0; i < l; i++) {
                if (this.items[i].value === this.value || this.items[i].value[0] === this.value) {
                    this.items.splice(i, 1);
                    return;
                }
            }
        },
        _getMinutesFromStringPart: function (str) {
            var parts = str.trim().split(' ');
            var num = parseInt(parts[0], 10);
            if (isNaN(num)) {
                return false;
            }
            if (parts.length > 1) {
                if (this.hoursText.indexOf(parts[1]) > -1) {
                    num = num * 60;
                }
            }
            return num;
        },
        _setStartTimeAttr: function (startTime) {
            if (dojoDate.compare(this.startTime, startTime, 'datetime') !== 0) {
                this.startTime = startTime;
                this._fillSelect();
            }
        },
        _setValuesAreAfterStartAttr: function (areAfter) {
            if (this.valuesAreAfterStart !== areAfter) {
                this.valuesAreAfterStart = areAfter;
                this._fillSelect();
            }
        },
        _getTimeValueAttr: function () {
            if (this.itemsByDur.hasOwnProperty(this.value)) {
                var dVal = this.itemsByDur[this.value].dateValue;
                return (dojo.isArray(dVal)) ? dVal[0] : dVal;
            } else {
                if (this.value && this.startTime) {
                    var d = dojoDate.add(this.startTime, 'minute', (this.valuesAreAfterStart) ? this.value : this.value * -1);
                    this.dateValue = d;
                    return this.dateValue;
                }
                return null;
            }
        },
        _setTimeValueAttr: function (time) {
            if (!time) {
                return;
            }
            if (this.items.length < 1) {
                this._fillSelect();
            }
            var d = this.startTime;
            if (d.getHours() === 0 && d.getMinutes === 0 && d.getSeconds() === 5) {
                time = new Date(d.getUTCFullYear(),
                    d.getUTCMonth(),
                    d.getUTCDate(),
                    d.getUTCHours(),
                    d.getUTCMinutes(),
                    d.getUTCSeconds());
            }
            for (var obj in this.itemsByDur) {
                if (obj && this.itemsByDur[obj].dateValue) {
                    var compDate = dojo.isArray(this.itemsByDur[obj].dateValue) ? this.itemsByDur[obj].dateValue[0] : this.itemsByDur[obj].dateValue;
                    if (dojoDate.compare(compDate, time, 'datetime') === 0) {
                        this.set('value', this.itemsByDur[obj].value);
                        this.text = this.itemsByDur[obj].label;
                        this._select.set('displayedValue', this.itemsByDur[obj].label);
                        return;
                    }
                }
            }
            //need to make one...
            //find difference in minutes, then create item
            var dur = dojoDate.difference(this.startTime, time, 'minute');
            if (dur < 0) {
                dur = dur * -1; // ensure it is a positive value...
            }
            var o = {
                'value': dur,
                'dateValue': time,
                'label': this._formatLabel(dur, time)
            };
            this.set('value', dur);
            this.text = o.label;
            this.itemsByDur[dur] = o;
            this._select.set('displayedValue', o.label);
        },
        _setTimeIncrementsAttr: function (incrments) {
            if (this.timeIncrements === incrments) {
                return;
            }
            this.timeIncrements = incrments;
            this._fillSelect();
        }
    });
    return durationSelect;
});
},
'Sage/UI/Controls/_customSelectMixin':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dijit/_Widget',
    'Sage/_Templated',
    'dijit/form/ComboBox',
    'dojo/_base/declare'
],
function (_Widget, _Templated, ComboBox, declare) {
    var customSelectMixin = declare('Sage.UI.Controls._customSelectMixin', [_Widget, _Templated], {
        widgetsInTemplate: true,
        disabled: false,
        value: '',
        text: '',
        widgetTemplate: new Simplate([
            '<div>',
                '<select dojoType="dijit.form.ComboBox" id="{%= $.id %}_select" labelAttr="label" dojoAttachPoint="_select" dojoAttachEvent="onChange:_onChange"></select>',
            '</div>' //root node
        ]),
        postCreate: function () {
            this.inherited(arguments);
            this._fillSelect();
        },
        _fillSelect: function () {
            // override to fill with custom data...
        },
        _setValueAttr: function (value) {
            this.text = value;
            this.value = value;
            if (this._store) {
                this._store.fetchItemByIdentity({
                    identity: value,
                    onItem: function (item) {
                        if (item) {
                            this._select.set('value', this._store.getValue(item, this._storeData.label));
                            this.value = this._store.getValue(item, this._storeData.identifier);
                            this.text = this._store.getValue(item, this._storeData.label);
                        } else {
                            this._handleValueNotInStore(value);
                        }
                    },
                    onError: function () {
                        //console.log('did not find item. ' + this.value);
                    },
                    scope: this
                });
            }
        },
        _getValueAttr: function () {
            if (this._select.item && this._store) {
                this.value = this._store.getValue(this._select.item, this._storeData.identifier);
            }
            return this.value;
        },
        _onChange: function (newValue) {
            //handles the _select control's change event...  newValue is the text
            if ((this.value === newValue) || (this.text === newValue)) {
                return;
            }
            if (this._select.item) {
                var item = this._select.item;
                //this.value = item[this._storeData.identifier];
                //this.text = item[this._storeData.label];                
                this.value = this._store.getValue(item, this._storeData.identifier);
                this.text = this._store.getValue(item, this._storeData.label);
            } else {
                this.value = this._handleValueNotInStore(newValue);
            }
            this.onChange(this.value);
        },
        _handleValueNotInStore: function (newValue) {
            //override this method to create a new item, or revert to last known good value...
            this.text = newValue;
            this.value = newValue;
            return newValue;
        },
        _getTextAttr: function () {
            return this.text;
        },
        _setTextAttr: function (text) {
            this.text = text;
            this._select.set('displayedValue', text);
        },
        _setDisabledAttr: function (disabled) {
            this.disabled = disabled;
            this._select.set('disabled', disabled);
        },
        _getDisabledAttr: function () {
            this.disabled = this._select.get('disabled');
            return this.disabled;
        },
        onChange: function () { }
    });
    return customSelectMixin;
});

},
'Sage/Services/CalendarSecurityService':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */

define([
    'Sage/Data/SDataServiceRegistry',
    'Sage/Utility',
    'dojo/_base/declare'
],
function (sDataServiceRegistry, utility, declare) {
    var service = declare('Sage.Services.CalendarSecurityService', null, {
        /*
        allowAdd : true,
        allowDelete: true,
        allowEdit: true,
        allowSync: true
        */
        _rawList: [],
        _accessList: {},
        _dataAvailable: false,
        constructor: function (opts) {
            this._dataAvailable = false;
            this._loading = false;
            //this._loadData();
        },
        _waiting: [],
        hasAccess: function (userid, accesslevel, callback, scope) {
            //console.log('hasAccess has been called... userid: ' + userid + '    accessLevel: ' + accesslevel + '    %o', scope);
            if (this._dataAvailable) {
                var item = this._accessList[userid];
                var access = false;
                if (item) {
                    access = item[accesslevel];
                }
                if (callback) {
                    callback.call(scope || this, access);
                }
            } else {
                //console.log('connecting to onDataAvailable...');
                this._waiting.push(dojo.connect(this, 'onDataAvailable', this, function () {
                    this.hasAccess(userid, accesslevel, callback, scope);
                }));
                if (!this._loading) {
                    this._loadData();
                }
            }
        },
        getListByAccessLevel: function (level, callback, scope, idAttr, nameAttr) {
            var idattr = idAttr || 'userid';
            var nameattr = nameAttr || 'name';
            if (this._dataAvailable) {
                var list = [];
                for (var i = 0; i < this._rawList.length; i++) {
                    var item = this._rawList[i];
                    if (level === "view" || item[level]) {
                        var obj = {};
                        obj[idattr] = item['accessUserId'];
                        obj[nameattr] = item['accessUserName'];
                        list.push(obj);
                    }
                }
                callback.call(scope || this, list);
            } else {
                this._waiting.push(dojo.connect(this, 'onDataAvailable', this, function () {
                    this.getListByAccessLevel(level, callback, scope, idAttr, nameAttr);
                }));
                if (!this._loading) {
                    this._loadData();
                }
            }
        },
       
        _loadData: function (start, count, initialData) {
            this._loading = true;
            var svc = sDataServiceRegistry.getSDataService('mashups', false, true, true); // cached one...
            //var svc = sDataServiceRegistry.getSDataService('mashups', false, true, false); // not cached one...
            var uid = utility.getClientContextByKey('userID') || '';            
            count = count || 100;
            start = start || 1;            
            var self = this;
            var request = new Sage.SData.Client.SDataNamedQueryRequest(svc);
            request.setApplicationName('$app');
            request.setResourceKind('mashups');
            request.uri.setCollectionPredicate("'UserCalendarQueries'");
            request.setQueryName('execute');
            request.setQueryArg('_resultName', 'UserHasAccessToTheseCalendars');
            request.setQueryArg('_userId', uid);
            request.setQueryArg('startIndex', start);
            request.setQueryArg('count', count);
            request.read({
                success: function (data) {
                    var totalResults = data.$totalResults;
                    if (totalResults > 100 && totalResults > (start + count)) {
                        //if we have more users, make another request to get remaining
                        start = start == 1 ? (start + count) - 1 : start + count;
                        self._loadData(start, (totalResults - start), data['$resources']);
                    } else {
                        if (initialData) {                            
                            initialData.push.apply(initialData, data['$resources']);
                            self._dataReceived(initialData);
                        } else {
                            self._dataReceived(data['$resources']);
                        }
                    }
                },
                failure: function () { console.log('user calendar request failed... %o', arguments); },
                scope: this
            });
        },
        _dataReceived: function (data) {
            this._rawList = data; //data['$resources'];
            var i;
            for (i = 0; i < this._rawList.length; i++) {
                var item = this._rawList[i];
                this._accessList[item['accessUserId']] = {
                    'name': item['accessUserName'],
                    'userid': item['accessUserId'],
                    'allowAdd': item['allowAdd'],
                    'allowDelete': item['allowDelete'],
                    'allowEdit': item['allowEdit'],
                    'allowSync': item['allowSync']
                };
            }
            this._dataAvailable = true;
            this._loading = false;
            //fire event for things that were waiting...
            this.onDataAvailable();
            //clean up waiting connections now that they have fired...
            console.log('cleaning up waiting list');
            for (i = 0; i < this._waiting.length; i++) {
                dojo.disconnect(this._waiting[i]);
            }
            this._waiting = [];
        },
        onDataAvailable: function () { }
    });
    Sage.Services.addService('CalendarSecurityService', new service());
});

},
'Sage/MainView/ActivityMgr/EditEventEditor':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */

define([
    'dijit/_Widget',
    'Sage/_Templated',
    'dijit/Toolbar',
    'dijit/layout/TabContainer',
    'dijit/layout/ContentPane',
    'dijit/form/Textarea',
    'dijit/form/ComboBox',
    'Sage/UI/TextBox',
    'Sage/UI/Controls/DateTimePicker',
    'Sage/UI/SDataLookup',
    'dojox/layout/TableContainer',
    'Sage/Data/SingleEntrySDataStore',
    'Sage/MainView/BindingsManager',
    'dijit/Dialog',
    'Sage/UI/Dialogs',
    'Sage/Utility',
    'Sage/Data/SDataServiceRegistry',
    'Sage/UI/Controls/_DialogHelpIconMixin',
    'dojo/_base/lang',
    'dojo/_base/declare',
    'dojo/i18n!./nls/EditEventEditor',
    'dijit/focus',
    'dojo/_base/lang'
],

function (
    _Widget,
    _Templated,
    Toolbar,
    TabContainer,
    ContentPane,
    Textarea,
    ComboBox,
    TextBox,
    DateTimePicker,
    SDataLookup,
    TableContainer,
    SingleEntrySDataStore,
    BindingsManager,
    Dialog,
    sageDialogs,
    utility,
    sDataServiceRegistry,
    _DialogHelpIconMixin,
    dojoLang,
    declare,
    eventEditorStrings,
    focusUtil,
    lang
) {

    var editEventEditor = declare('Sage.MainView.ActivityMgr.EditEventEditor', [_Widget, _Templated], {
        eventId: null,
        mode: false,
        _dialog: false,
        _currentUserId: null,
        _eventService: false,
        _eventData: false,
        _eventStore: false,
        _bindingMgr: false,
        _eventChangeConnection: false,
        lup_User: false,
        eventDefaultValues: {},
        eventConnections: [],
        widgetsInTemplate: true,

        widgetTemplate: new Simplate([
            '<div>', //root
                '<div data-dojo-type="dijit.Dialog" id="eventDialog" title="" dojoAttachPoint="_dialog" >', //dialog
                    '<div class="event-dialog">', //body
                     '<div data-dojo-type="dijit.layout.ContentPane" id="{%= $.id%}_cp_event" title="" dojoAttachPoint="cp_Event" class="tabContent">',
                        '<div data-dojo-type="dojox.layout.TableContainer" orientation="horiz" cols="1" labelWidth="140">',
                              '<div data-dojo-type="Sage.UI.Controls.DateTimePicker" shouldPublishMarkDirty="false" label="{%= $.lblStartDateText %}" id="{%= $.id%}_tb_StartDate" name="tb_StartDateName" dojoAttachPoint="tb_StartDate" displayDate="true" displayTime="false"  ></div>',
                              '<div data-dojo-type="Sage.UI.Controls.DateTimePicker" shouldPublishMarkDirty="false" label="{%= $.lblEndDateText %}" id="{%= $.id%}_tb_EndDate" name="tb_EndDateName" dojoAttachPoint="tb_EndDate" displayDate="true" displayTime="false" ></div>',
                              '<select  dojoAttachPoint="tb_DayType" data-dojo-type="dijit.form.ComboBox" required="false" name="tb_DayType"  label="{%= $.lblDayTypeText %}" id="{%= $.id%}_tb_DayType" >',
                                  '<option value="Active" >{%=$.eventTypeActiveText %}</option>',
                                  '<option value="Business Trip" >{%=$.eventTypeBusinessTripText %}</option>',
                                  '<option value="Conference" >{%=$.eventTypeConferenceText%}</option>',
                                  '<option value="Holiday" selected="selected" >{%=$.eventTypeHolidayText%}</option>',
                                  '<option value="Off" >{%=$.eventTypeOffText%}</option>',
                                  '<option value="Trade Show" >{%=$.eventTypeTradeShowText%}</option>',
                                  '<option value="Unavailable" >{%=$.eventTypeUnavailableText%}</option>',
                                  '<option value="Vacation" >{%=$.eventTypeVacationText%}</option>',
                               '</select>',
                               '<input data-dojo-type="dijit.form.TextBox" id="{%= $.id %}_tb_Location" label="{%= $.lblLocationText %}" dojoAttachPoint="tb_Location" maxLength="255" />',
                               '<textarea data-dojo-type="dijit.form.SimpleTextarea" label="{%= $.lblDescriptionText %}" id="{%= $.id%}_tb_Description" name="tb_Description" dojoAttachPoint="tb_Description" rows="4" cols="1"  maxLength="128"  ></textarea>',
                               '<div class="event-dialog remove-padding">',
                               '<div dojoType="dijit.layout.ContentPane" label="{%= $.lblUserText %}" dojoAttachPoint="container_UserLup" class="remove-padding lookup-container"></div>',
                                '</div>',
                           '</div>',
                      '</div>',
                       '<div class="button-bar alignright">',
                          '<div data-dojo-type="dijit.form.Button"  id="{%= $.id%}_btn_OK" name="btn_OK" dojoAttachPoint="btn_OK" dojoAttachEvent="onClick:_okClick">{%= $.btnOkayText %}</div>',
                          '<div data-dojo-type="dijit.form.Button"  id="{%= $.id%}_btn_Cancel" name="btn_Cancel" dojoAttachPoint="btn_Cancel" dojoAttachEvent="onClick:_cancelClick">{%= $. btnCancelText %}</div>',
                       '</div>',
                  '</div>', //body                     
                '</div>',  //dialog        
           '</div>' //root                       
        ]),
        constructor: function () {
            dojo.mixin(this, eventEditorStrings);
            this._eventService = sDataServiceRegistry.getSDataService('dynamic');
            this._setEventStore();
            this._currentUserId = utility.getClientContextByKey('userID') || '';
        },
        //postMixInProperties: function() {
        //    this.inherited(arguments); 
        //},
        //startup: function(){
        //    this.inherited(arguments);
        //    this._loadData();             

        //},
        destroy: function () {

            if (this._eventChangeConnection) {
                dojo.disconnect(this._eventChangeConnection);
                this._eventChangeConnection = false;
            }
            if (this._bindingMgr) {
                this._bindingMgr.destroy();
            }
            if (this.lup_User) {
                this.lup_User.destroy();
            }
            this.inherited(arguments);
        },
        show: function (mixinProperties) {
            if (!this.lup_User) {
                this._createUserLookup();
            }

            if (this.mode === 'New') {
                this._dialog.set('title', this.titleScheduleText);
            }
            else {
                this._dialog.set('title', this.titleEditText);
            }
            this.eventDefaultValues = mixinProperties || {};
            this._loadData();
            this._dialog.set('refocus', false);
            this._dialog.show();
            // Create help icon
            if (!this._dialog.helpIcon) {
                dojoLang.mixin(this._dialog, new _DialogHelpIconMixin());
                this._dialog.createHelpIconByTopic('addevent');
            }
        },
        hide: function () {
            this._dialog.hide();
        },
        resize: function () {

        },

        _setModeAttr: function (mode) {
            this.mode = mode;
            if (mode.indexOf('New') === 0) {
                this.mode = 'New';
                this._eventData = false;
                //this._loadData();
            }
        },
        _setEventIdAttr: function (eventId) {
            if (this.eventId !== eventId) {
                this.eventId = eventId;
                this._eventData = false;
                //this._loadData();
            }
        },
        _getEventIdAttr: function () {
            return this.eventId;
        },

        _setEventStore: function () {
            if (!this._eventStore) {
                this._eventStore = new SingleEntrySDataStore({
                    include: [],
                    select: ['StartDate', 'EndDate', 'Description', 'Type', 'Location', 'UserId'],
                    resourceKind: 'events',
                    service: this._eventService
                });
            }
        },

        onChange: function (/* control */control,
        /*attribute-name-string*/attribute,
        /*object | array*/oldValue,
        /*object | array*/newValue) {

        },
        setMode: function (mode) {
            this._mode = mode;
        },

        _loadData: function () {
            this._eventData = false;
            if (this._eventStore) {
                if (this.mode !== 'New') {
                    this._eventStore.fetch({
                        predicate: "'" + this.eventId + "'",
                        onComplete: this._receivedEvent,
                        onError: this._requestFailure,
                        scope: this
                    });
                } else {
                    this._eventStore.newItem({
                        onComplete: function (event) {
                            utility.setValue(event, 'UserId', this._currentUserId);
                            this._receivedEvent(event);
                        },
                        scope: this
                    });
                }
            }
        },

        _receivedEvent: function (event) {
            if (this.mode === 'New') {
                this._eventData = (dojo.mixin(event, this.eventDefaultValues));
            }
            else {
                this._eventData = event;
            }
            this._bind();
        },
        _requestFailure: function (msg, request, opts) {
            console.warn('error requesting data');
        },
        _bind: function () {

            if (this._eventData) {
                if (!this._bindingMgr) {
                    this._bindingMgr = new BindingsManager({
                        defaultBinding: { boundEntity: this._eventData },
                        items: [{
                            boundWidget: this.tb_StartDate,
                            entityProperty: 'StartDate',
                            dataType: 'date'
                        }, {
                            boundWidget: this.tb_EndDate,
                            entityProperty: 'EndDate',
                            dataType: 'date'
                        }, {
                            boundWidget: this.tb_DayType,
                            entityProperty: 'Type'
                        }, {
                            boundWidget: this.tb_Description,
                            entityProperty: 'Description'
                        }, {
                            boundWidget: this.tb_Location,
                            entityProperty: 'Location'
                        }]
                    });

                    this._eventChangeConnection = dojo.connect(this._bindingMgr, 'onChange', this, 'onChange');
                } else {
                    if (!this._bindingMgr.boundEntity || (this._eventData['$key'] !== this._bindingMgr.boundEntity['$key'])) {
                        this._bindingMgr.setBoundEntity(this._eventData);
                    } else {
                        this._bindingMgr.bind();
                    }
                }
                this._bindUserLookup();
            }
        },
        _bindUserLookup: function () {
            if (this._eventData.UserId) {
                if (this._eventData.UserId === this._currentUserId) {
                    var mockUser = {
                        '$key': this._currentUserId,
                        '$descriptor': utility.getClientContextByKey('userPrettyName')
                    };
                    this.lup_User.set('selectedObject', mockUser);
                } else {
                    this._getUserInfoFor(this._eventData.UserId, function (user) {
                        this.lup_User.set('selectedObject', user);
                    });
                }
            } else {
                this.lup_User.set('selectedObject', null);
            }
        },
        _getUserInfoFor: function (userId, callback) {
            var request = new Sage.SData.Client.SDataSingleResourceRequest(sDataServiceRegistry.getSDataService('dynamic', false, true, true)); //go ahead and cache this...
            request.setResourceKind('userInfo');
            request.setResourceSelector("'" + userId + "'");
            //using precedence of 0 we only get $descriptor which is <lastname, firstname>, 
            //...but do we want the UserName property which is <firstname lastname>???
            request.setQueryArg('precedence', '0');
            request.read({
                success: callback,
                scope: this,
                failure: function () { }
            });
        },
        _createUserLookup: function () {
            var userLookupConfig = {
                id: '_eventUser',
                structure: [
                    {
                        label: this.nameText,
                        field: 'Name',
                        sortable: true,
                        width: "400px",
                        editable: false,
                        propertyType: "System.String",
                        excludeFromFilters: false,
                        defaultValue: ""
                    }
                ],
                gridOptions: {
                    contextualCondition: function () {
                        return 'AllowAdd AND (AccessId eq \'' + utility.getClientContextByKey('userID') + '\' OR AccessId eq \'EVERYONE\') AND Type eq \'User\'';
                    },
                    contextualShow: '',
                    selectionMode: 'single'
                },
                storeOptions: {
                    resourceKind: 'activityresourceviews',
                    sort: [{ attribute: 'Name' }]
                },
                isModal: true,
                preFilters: [],
                returnPrimaryKey: true,
                dialogTitle: this.lookupUserText,
                dialogButtonText: this.btnOkayText
            };
            this.lup_User = new Sage.UI.Controls.Lookup({
                id: 'event_lu_user',
                config: userLookupConfig
            });
            this.eventConnections.push(dojo.connect(this.lup_User, 'onChange', this, '_userChanged'));
            dojo.place(this.lup_User.domNode, this.container_UserLup.domNode, 'only');
        },
        _userChanged: function (newUser) {
            utility.setValue(this._eventData, 'UserId', (newUser) ? newUser['$key'].substr(0, 12) : '');
        },
        datesValid: function () {
            var startDate = this.tb_StartDate.value;
            var endDate = this.tb_EndDate.value;
            endDate = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate(), 0, 0);

            this._eventData.EndDate = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate(), new Date().getHours(), new Date().getMinutes(), new Date().getSeconds());
            this._eventData.StartDate = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate(), new Date().getHours(), new Date().getMinutes(), new Date().getSeconds());

            startDate = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate(), 0, 0);

            if (startDate > endDate) {
                sageDialogs.showError(this.invaildDatesText);
                return false;
            }

            return true;
        },
        // ... region click/action handlers
        _okClick: function () {
            var activeElement = focusUtil.curNode;
            if (activeElement) {
                activeElement.blur();
            }
            // IE8 has an issue where the value is saved before the blur realizes the value has changed
            //  and setting a timeout of 1 is enough for the change to be seen after the blur
            setTimeout(lang.hitch(this, function () {
                if (!this.datesValid()) {
                    return;
                }

                if (this.mode === 'New') {
                    this._eventStore.saveNewEntity(this._eventData, this._successEventCreated, this._failedEventCreated, this);
                }
                else {
                    this._eventStore.save({
                        scope: this,
                        success: this._successEventUpdated,
                        failure: this._failedEventUpdated
                    });
                }
            }), 1);
        },
        _cancelClick: function () {
            this.hide();
        },

        _successEventCreated: function (event) {
            dojo.publish('/entity/event/create', [event, this]);
            //dojo.publish('/entity/event/change', [event, this]);
            this.hide();
        },

        _failedEventCreated: function (request) {

            console.log('an error occured saving event %o', request);
            sageDialogs.showError(this.errorText);

        },
        _successEventUpdated: function (event) {

            dojo.publish('/entity/event/change', [event, this]);
            this.hide();
        },

        _failedEventUpdated: function (request) {
            console.log('an error occured saving event %o', request);
            sageDialogs.showError(this.errorText);
        }
        // ... endregion      

    });
    return editEventEditor;
});

},
'Sage/UI/TextBox':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dijit/form/TextBox',
    'dojo/_base/declare'
],
function (TextBox, declare) {
    var widget = declare('Sage.UI.TextBox', TextBox, {
        /**
        * Set the displayed text in the Textbox,
        * checking to see if watermark is specified
        */
        postCreate: function () {
            this.inherited(arguments);
            // reference to the original value
            this._val = this.get('value');
            if (this.get('value') === '' && this._val) {
                this.set('value', this._val);
            }
            this.set('class', 'txt-ss-watermark');
        },
        /**
        * Listener for the onFocus event. if watermark is true
        * it is removed here
        */
        onFocus: function () {
            this.set('value', '');
            this.set('class', 'txt-ss');
        },
        /**
        * When programatically inserting text the onFocus() event isn't fired
        * This method mimics that event so that your hydrated text isn't 
        * watermarked. Pass in a string to display
        * @param {String} val
        */
        forceFocus: function (val) {
            this.set('value', val);
            this.set('class', 'txt-ss-watermark');
        },
        /**
        * Listener for the blur event. The control
        * is left alone if text was input or reset to
        * the initial display with watermark preference if blank
        */
        onBlur: function () {
            if (this.get('value') === '') {
                this.set('class', 'txt-ss-watermark');
                this.set('value', this._val);
            }
        }
    });

    return widget;
});

},
'Sage/MainView/ActivityMgr/QuickCompleteEditor':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
        'dijit/_Widget',
        'Sage/_Templated',
        'dijit/layout/ContentPane',
        'dijit/form/Textarea',
        'Sage/UI/TextBox',
        'Sage/UI/Controls/DateTimePicker',
        'dijit/form/FilteringSelect',
        'Sage/UI/SDataLookup',
        'dojox/layout/TableContainer',
        'Sage/UI/Controls/SingleSelectPickList',
        'dijit/Dialog',
        'dojo/_base/declare',
        'dojo/i18n!./nls/QuickCompleteEditor'
],

function (
    _Widget,
    _Templated,
    ContentPane,
    Textarea,
    TextBox,
    DateTimePicker,
    FilteringSelect,
    SDataLookup,
    TableContainer,
    SingleSelectPickList,
    Dialog,
    declare,
    nlsResources
) {

    //dojo.requireLocalization("Sage.MainView.ActivityMgr", "QuickCompleteEditor");
    var quickCompleteEditor = declare('Sage.MainView.ActivityMgr.QuickCompleteEditor', [_Widget, _Templated], {

        _currentUserId: null,
        _individuallyHandler: false,
        _nowHandler: false,
        _asScheduledHandler: false,
        _selectionContext: false,
        //l18n strings.
        lblcmdMessageText: '',
        lblInfoMessageText: '',
        lblResultText: 'Result:',
        lblNoteText: 'Note (append to all items):',
        btnCompleteIndividuallyText: 'Individually',
        btnAsScheduledText: 'As Scheduled',
        btnCompleteNowText: 'Now',
        btnCancelText: 'Cancel',
        btnCloseText: 'Close',
        btnHelpText: 'Help',
        resultCompletedText: 'Complete',
        titleText:'Quick Complete',
        //end l18n strings.
        widgetsInTemplate: true,
        selectionContext: null,
        widgetTemplate: new Simplate([
            '<div>',
                 '<div data-dojo-type="dijit.Dialog" id="{%= $.id%}_qucikCompleteDialog" title="Quick Complete" dojoAttachPoint="_dialog" >',
                   '<div class="quickComplete-dialog">', //body
                     '<div data-dojo-type="dijit.layout.ContentPane" id="{%= $.id%}_cp_General" title="" dojoAttachPoint="cp_General">',
                          '<div data-dojo-type="dojox.layout.TableContainer" orientation="horiz" cols="1" class="controlPropForm" labelWidth="140">',
                               '<div id="{%= $.id%}_div_actionMessage"  name="div_actionMessage" dojoAttachPoint="div_actionMessage"></div>',
                               '<br>',
                               '<select label="{%= $. lblResultText %}" id="{%= $.id%}_pk_Result" data-dojo-type="Sage.UI.Controls.SingleSelectPickList" dojoAttachPoint="pk_Result" canEditText="true" itemMustExist="false" pickListName="To Do Result Codes" ></select>',
                                '<div data-dojo-type="dijit.form.SimpleTextarea"" label="{%= $.lblNoteText %}" id="{%= $.id%}_ta_Note" name="tb_Note" dojoAttachPoint="ta_Note"></div>',
                           '</div>',
                          '<br>',
                          '<div id="{%= $.id%}_div_cmdMessage"  name="div_cmdMessage" dojoAttachPoint="div_cmdMessage" style="font-weight:bold"></div>',
                          '<br>',
                          '<div class="button-bar alignright">',
                              '<div data-dojo-type="dijit.form.Button"  id="{%= $.id%}_btn_CompleteIndividually" name="btn_CompleteIndividually" dojoAttachPoint="btn_CompleteIndividually" dojoAttachEvent="onClick:_onCompleteIndividually" style="align:left" >{%= $.btnCompleteIndividuallyText %}</div>',
                              '<div data-dojo-type="dijit.form.Button"  id="{%= $.id%}_btn_btnAsScheduled" name="btn_AsScheduled" dojoAttachPoint="btn_AsScheduled" dojoAttachEvent="onClick:_onAsScheduled">{%= $.btnAsScheduledText %}</div>',
                              '<div data-dojo-type="dijit.form.Button" id="{%= $.id%}_btn_CompleteNow" name="btn_CompleteNow" dojoAttachPoint="btn_CompleteNow" dojoAttachEvent="onClick:_onCompleteNow">{%= $.btnCompleteNowText %}</div>',
                              '<div data-dojo-type="dijit.form.Button"  id="{%= $.id%}_btn_Cancel" name="btn_Cancel" dojoAttachPoint="btn_Cancel" dojoAttachEvent="onClick:_cancelClick">{%= $. btnCancelText %}</div>',
                          '</div>',
                      '</div>',
                      '<div data-dojo-type="dijit.layout.ContentPane" id="{%= $.id%}_cp_processing" title="" dojoAttachPoint="cp_processing">',
                           '<div id="{%= $.id%}_div_processingMessage"  name="div_processingMessage" dojoAttachPoint="div_processingMessage"></div>',
                          '<div class="button-bar alignright">',
                             '<div data-dojo-type="dijit.form.Button"  id="{%= $.id%}_btn_Close" name="btn_Close" dojoAttachPoint="btn_Close" dojoAttachEvent="onClick:_cancelClick">{%= $. btnCloseText %}</div>',
                          '</div>',
                      '</div>',
                  '</div>',
                '</div>',
           '</div>'
        ]),
        constructor: function (config) {
            dojo.mixin(this, nlsResources);
            this._currentUserId = Sage.Utility.getClientContextByKey('userID') || '';
        },
        destroy: function () {
            this._dialog.destroyRecursive();
            this.destroyRecursive();
        },
        show: function () {

            if (this.selectionContext) {
                this.div_actionMessage.innerHTML = this.actionMessage;
                this.div_cmdMessage.innerHTML = String.format(this.completeMessage, this.selectionContext.count);
                this._dialog.set('title', this.titleText);
            }

            //this.pk_Result.set('value', this.resultCompletedText);
            dojo.style(this.cp_processing.domNode, "display", "none");
            this._dialog.show();
        },
        hide: function () {
            // this._dialog.hide();
            this.destroy();
        },
        resize: function () {

        },
        _showProcessing: function () {
            dojo.style(this.cp_General.domNode, "display", "none");
            dojo.style(this.cp_processing.domNode, "display", "block");
            this.div_processingMessage.innerHTML = String.format(this.processingMessage, this._selectionContext.count);
        },

        // ... region click/action handlers
        _onCompleteIndividually: function () {
            this.onCompleteIndividually();
            this._dialog.hide();
        },
        _onCompleteNow: function () {
            this._showProcessing();
            var options = {
                selectionContext: this.selectionContext,
                note: this.ta_Note.value,
                result: this.pk_Result.get('value'),
                resultCode: '' //this.pk_Result.get('code') // We dont set this because each type of activity maps to diffrent codes.
            };
            this.onCompleteNow(options);
            this._dialog.hide();
        },
        _onAsScheduled: function () {
            this._showProcessing();
            var options = {
                selectionContext: this.selectionContext,
                note: this.ta_Note.value,
                result: this.pk_Result.get('value'),
                resultCode: '' //this.pk_Result.get('code')
            };
            this.onCompleteAsScheduled(options);
            this._dialog.hide();
        },
        _cancelClick: function () {
            this.onCancel();
            this._dialog.hide();
        },
        onCompleteIndividually: function () { },
        onCompleteNow: function (args) { },
        onCompleteAsScheduled: function (args) { },
        onCancel: function () { }

        // ... endregion      

    });
    return quickCompleteEditor;
});
},
'Sage/Services/ActivityActionProcessor':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */

define([
    'dojo/i18n',
    'Sage/UI/Dialogs',
    'dijit/_Widget',
    'Sage/_Templated',
    'dojo/i18n!./nls/ActivityActionProcessor',
    'dojo/_base/declare'
],
function (
    i18n,
    Dialogs,
    _Widget,
    _Templated,
    nlsStrings,
    declare
) {
    var activityActionProcessor = declare('Sage.Services.ActivityActionProcessor', [_Widget, _Templated], {
        _dialog: false,
        _currentUserId: null,
        _action: false,
        _processing: false,
        _selectionContext: false,
        btnOkayText: 'OK',
        btnCancelText: 'Cancel',
        btnCloseText: 'Close',
        btnHelpText: 'Help',
        processingText: 'Processing request please wait...',
        failureText: 'I\'m sorry, the action was not successful an error occurred.',
        titleText: 'Process',

        //end l18n strings.
        widgetsInTemplate: true,
        widgetTemplate: new Simplate([
            '<div>',
                '<div data-dojo-type="dijit.Dialog" id="activityProcessActionDialog" title="{%= $.titleText%}" dojoAttachPoint="_dialog" style="width:400px">',
                     '<div class="activityProcess-dialog">',
                        '<div data-dojo-type="dijit.layout.ContentPane" id="{%= $.id%}_cp_envet_General" title="" dojoAttachPoint="cp_General">',
                             '<div data-dojo-type="dojox.layout.TableContainer" orientation="horiz" cols="1" class="controlPropForm" labelWidth="140">',
                                 '<div id="{%= $.id%}_div_actionMessage"  name="div_actionMessage" dojoAttachPoint="div_actionMessage"></div>',
                             '</div>',
                        '</div>',
                       '<table class="button-bar"><tr><td class="alignright valignbottom">',
                            '<div data-dojo-type="dijit.form.Button"  id="{%= $.id%}_btn_OK" name="btn_OK" dojoAttachPoint="btn_OK" dojoAttachEvent="onClick:_okClick">{%= $.btnOkayText %}</div>',
                            '<div data-dojo-type="dijit.form.Button"  id="{%= $.id%}_btn_Cancel" name="btn_Cancel" dojoAttachPoint="btn_Cancel" dojoAttachEvent="onClick:_cancelClick">{%= $. btnCancelText %}</div>',
                            '<div data-dojo-type="dijit.form.Button"  id="{%= $.id%}_btn_Close" name="btn_Close" dojoAttachPoint="btn_Close" dojoAttachEvent="onClick:_closeClick">{%= $. btnCloseText %}</div>',
                       '</td><tr></table>',
                   '</div>',
               '</div>',
           '</div>'
        ]),

        constructor: function () {
            this._currentUserId = Sage.Utility.getClientContextByKey('userID') || '';
            dojo.mixin(this, nlsStrings);
        },
        //postMixInProperties: function() {
        //    this.inherited(arguments); 
        //},
        //startup: function(){
        //    this.inherited(arguments);
        //    this._loadData();             

        //},
        destroy: function () {

            this.inherited(arguments);
        },
        start: function (silent) {
            this._processing = false;
            if (this._selectionContext.count < 1) {
                return;
            }
            if (!silent) {
                this._setDisplay();
                this.show();
            } else {
                this._execute();
            }
        },
        show: function () {
            this._dialog.show();
        },
        hide: function () {
            //this._dialog.destroyRecursive();
            this._action = null;
            this._dialog.hide();

        },
        resize: function () {

        },
        _setDisplay: function () {

            dojo.style(this.btn_Close.domNode, "visibility", "hidden");
            dojo.style(this.btn_OK.domNode, "visibility", "visible");
            dojo.style(this.btn_Cancel.domNode, "visibility", "visible");

            if (this._selectionContext) {
                this.div_actionMessage.innerHTML = this._action.message;
                this._dialog.set('title', this._action.description);
            }
        },
        _setActionAttr: function (action) {
            this._action = action;
        },
        _getActionAttr: function () {
            return this._action;
        },
        _setSelectionContextAttr: function (selectionContext) {
            this._selectionContext = selectionContext;
        },
        _getSelectionContextAttr: function () {
            return this._selectionContextInfo;
        },

        _execute: function () {
            if (this._processing) {
                return;
            }
            var me = this;
            this.div_actionMessage.innerHTML = this.processingText;
            this._processing = true;
            dojo.style(this.btn_Close.domNode, "visibility", "visible");
            dojo.style(this.btn_OK.domNode, "visibility", "hidden");
            dojo.style(this.btn_Cancel.domNode, "visibility", "hidden");            
            if (this._action) {
                //this._action._selectionContext = this._selectionContext;
                this._action.execute({
                    scope: this,
                    success: function (result, scope) {
                        scope.hide();
                        scope.onActionComplete(result);
                    },
                    failure: function (result, scope) {
                        scope.onActionComplete(result);
                        Sage.UI.Dialogs.showError(me.failureText);
                    }
                });
            }
        },
        _okClick: function () {
            this._execute();
        },
        _cancelClick: function () {
            this.hide();
        },
        _closeClick: function () {
            this.hide();
        },
        onActionComplete: function (result) { }
        // ... endregion      
    });

    return activityActionProcessor;
});

},
'Sage/Services/ActivityAction':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
        'dojo/i18n',
        'Sage/UI/Dialogs',
        'dijit/_Widget',
        'dojo/_base/declare'
],
function (
   i18n,
   Dialogs,
   _Widget,
   declare
) {

    var activityAction = declare('Sage.Services.ActivityAction', [_Widget], {
        _service: false,
        _contract: 'activities',
        _resourceKind: 'service',
        _operationName: false,
        _payLoad: false,
        _selectionContext: false,
        _publishMap: false,
        _publishMapWithId: false,
        _activityId: false,
        _configuration: false,
        _args: {},
        message: 'Are you sure you want to continue?',
        description: '',
        constructor: function () {
            // this._service =  Sage.Utility.getSDataService('activities');        
        },
        execute: function (options) {
            var map = this._publishMap;
            var mapWithId = this._publishMapWithId;
            var activityId = this._activityId;

            var postUrl = String.format("slxdata.ashx/slx/crm/-/{0}/{1}/{2}", this._contract, this._resourceKind, this._operationName);
            $.ajax({
                type: "POST",
                url: postUrl,
                contentType: "application/json",
                data: dojo.toJson(this._args),
                processData: false,
                success: function (result) {
                    if (map) {
                        dojo.publish(map, [result, this]);
                    }
                    if (mapWithId) {
                        if (activityId) {
                            dojo.publish(mapWithId, [activityId, this]);
                        }
                    }
                    if (options) {
                        options.success(result, options.scope);
                    }
                },
                failure: function (request) {
                    if (options) {
                        options.failure(request, options.scope);
                    }
                }
            });
        },

        _setConfigurationAttr: function (config) {
            this._configuration = config;
        },
        _getConfigurationAttr: function () {
            return this._configuration;
        },

        _setServiceAttr: function (service) {
            this._service = service;
        },
        _getServiceAttr: function () {
            return this._service;
        },
        _setSelectionInfoAttr: function (selectionInfo) {
            this._selectionInfo = selectionInfo;
        },
        _getSelectionInfoAttr: function () {
            return this._selectionInfo;
        },
        _setOperationNameAttr: function (operationName) {
            this._operationName = operationName;
        },
        _getOperationNameAttr: function () {
            return this._operationName;
        },
        _setResourceKindAttr: function (resourceKind) {
            this._resourceKind = resourceKind;
        },
        _getResourceKindAttr: function () {
            return this._resourceKind;
        },
        _setArgsAttr: function (args) {
            this._args = args;
        },
        _getArgsAttr: function () {
            return this._args;
        },
        _setActionDescriptionAttr: function (description) {
            this.description = description;
        },
        _getActionDescriptionAttr: function () {
            return this.description;
        },

        _setActionMessageAttr: function (message) {
            this.message = message;
        },
        _getActionMessageAttr: function () {
            return this.message;
        },
        _setPublishMapAttr: function (publishMap) {
            this._publishMap = publishMap;
        },
        _setPublishMapWithIdAttr: function (publishMapWithId) {
            this._publishMapWithId = publishMapWithId;
        },
        _setActivityIdAttr: function (activityId) {
            this._activityId = activityId;
        }

    });

    return activityAction;
});

},
'Sage/MainView/ActivityMgr/HistoryEditor':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dijit/_Widget',
    'Sage/_Templated',
    'Sage/Data/SingleEntrySDataStore',
    'Sage/MainView/BindingsManager',
    'Sage/Utility',
    'Sage/UI/Controls/_DialogHelpIconMixin',
    'dojo/_base/lang',
    'Sage/UI/_DialogLoadingMixin',
    'Sage/UI/AttachmentList',
    'Sage/Data/SDataServiceRegistry',
    'Sage/UI/Dialogs',
    'dojo/string',
    'dojo/date/locale',
    'Sage/Utility/Activity',
    'Sage/Utility/File',
    'dojo/_base/declare',
    'dojo/i18n!./nls/HistoryEditor',
    'dojo/text!./templates/HistoryEditor.html',
    'dojo/dom-class',
    'Sage/MainView/ActivityMgr/HistoryEditorAttendeesTab',
    'dijit/layout/ContentPane',
    'dojo/dom-style',
    'dojo/on',
    'dojo/dom-geometry',

    'dijit/Toolbar',
    'dijit/layout/TabContainer',
    'dijit/form/Textarea',
    'dojox/layout/TableContainer',
    'Sage/Services/UserOptions',
    'Sage/UI/Controls/SingleSelectPickList',
    'Sage/UI/Controls/DateTimePicker',
    'Sage/UI/Controls/Lookup',
    'dijit/Dialog',
    'Sage/UI/Controls/DurationSelect',
    'Sage/Services/CalendarSecurityService'
],
function (_Widget, _Templated, SingleEntrySDataStore, BindingsManager, utility, _DialogHelpIconMixin,
    dojoLang, _DialogLoadingMixin, AttachmentList, sDataServiceRegistry, SageDialogs, dstring, locale,
    activityUtility, fileUtility, declare, historyEditorStrings, template, domClass, HistoryAttendeesTab, ContentPane, domStyle, on, domGeometry) {
    dojo.requireLocalization("Sage.MainView.ActivityMgr", "HistoryEditor");
    var historyEditor = declare('Sage.MainView.ActivityMgr.HistoryEditor', [_Widget, _Templated], {
        historyId: '',
        mode: '',
        id: '',
        activityType: '',
        _dialog: false,
        _currentUserId: null,
        _activityService: false,
        _historyData: false,
        _historyStore: false,
        _bindingMgr: false,
        //_uaBindingMgr: false,
        lup_Account: false,
        lup_Contact: false,
        lup_Opportunity: false,
        lup_Ticket: false,
        lup_Lead: false,
        lup_Leader: false,
        accountLookupConfig: {},
        contactLookupConfig: {},
        opportunityLookupConfig: {},
        ticketLookupConfig: {},
        leadLookupConfig: {},
        //resourcesLookupConfig: {},
        _isBinding: false,
        _historySaved: false,
        notnullfields: ['ContactId', 'AccountId', 'OpportunityId', 'TicketId', 'LeadId'],
        historyDefaultValues: {},
        _doingFollowup: false,

        //i18n strings...from nls/{language}/HistoryEditor.js

        _attachmentsSaved: false,
        _attachmentList: false,
        _tempIdForAttachments: false,
        _hasAccess: true,
        eventConnections: [],
        widgetsInTemplate: true,
        widgetTemplate: new Simplate(eval(template)),
        constructor: function () {
            dojo.mixin(this, historyEditorStrings);
            this._historyService = Sage.Data.SDataServiceRegistry.getSDataService('dynamic');
            this._setupStore();
            this._currentUserId = Sage.Utility.getClientContextByKey('userID') || '';
            dojo.subscribe('/entity/attachment/create', this, this._updateHistoryETag);
            dojo.subscribe('/entity/attachment/update', this, this._updateHistoryETag);
            dojo.subscribe('/entity/attachment/delete', this, this._updateHistoryETag);
        },
        destroy: function () {
            if (this._historyChangeConnection) {
                dojo.disconnect(this._historyChangeConnection);
                this._historyChangeConnection = false;
            }
            if (this._bindingMgr) {
                this._bindingMgr.destroy();
            }
            //if (this._uaBindingMgr) {
            //    this._uaBindingMgr.destroy();
            //}
            for (var i = 0; i < this.eventConnections.length; i++) {
                dojo.disconnect(this.eventConnections[i]);
            }
            this.lup_Account.destroy();
            this.lup_Contact.destroy();
            this.lup_Opportunity.destroy();
            this.lup_Ticket.destroy();
            this.lup_Lead.destroy();
            this.lup_Leader.destroy();
            this.eventConnections = [];
            this.inherited(arguments);
        },
        isFirstOpen: true,
        show: function (mixinProperties) {
            this._dialog.set('refocus', false);
            if (this.isFirstOpen) {
                // create lookup controls...
                this.isFirstOpen = false;
                this.connect(this._dialog, 'onHide', this._cleanOnClose);
            }

            if (!this.lup_Account) {
                // create lookup controls...
                this.createAccountLookup();
                this.createContactLookup();
                this.createOpportunityLookup();
                this.createTicketLookup();
                this.createLeadLookup();
                this.createLeaderLookup();

            }

            this.historyDefaultValues = {};
            if (this.mode === 'New') {
                this.historyDefaultValues = mixinProperties || {};
                this._loadData();
            }
            if (this.mode === 'Complete') {

            }
            if (this.mode === 'Complete') {
                domClass.add(this.btn_Delete.domNode, 'display-none');
            } else {
                domClass.remove(this.btn_Delete.domNode, 'display-none');
            }
            if ((this.activityType === "atNote") && (this.mode === 'New')) {
                dojo.addClass(this.result_Section.domNode, 'display-none');
            }
            else {
                dojo.removeClass(this.result_Section.domNode, 'display-none');
            }

            this._dialog.show();

            if (!this._dialog._standby) {
                dojoLang.mixin(this._dialog, new _DialogLoadingMixin());
                if (!this._historyData) {
                    this._dialog.showLoading();
                }
            }
            // Create help icon
            if (!this._dialog.helpIcon) {
                dojoLang.mixin(this._dialog, new _DialogHelpIconMixin());
                this._dialog.createHelpIconByTopic('View_Edit_Details_of_a_History_Item');
            }
            if (this.activityType === "atNote") {
                this._dialog.set('helpTopic', 'addnote');
            }
            else {

                this._dialog.set('helpTopic', 'View_Edit_Details_of_a_History_Item');
            }
            //this._availabilityShowing = false;
            this.tc_EditHistory.selectChild(this.cp_General);
            this._doingFollowup = false;
        },
        hide: function (e) {
            this._dialog.hide(e);
            this.set('historyId', '');
        },
        onHide: function () { },
        _onDlgHide: function () {
            this.onHide();
        },
        _cleanOnClose: function () {
            var svc = Sage.Services.getService('ClientEntityContext');
            svc.clearTemporaryContext();
            this.set('historyId', '');

            //Making sure the tooltips are hidden when closing the dialog
            this._hideLookupTooltip(this.lup_Account);
            this._hideLookupTooltip(this.lup_Contact);
            this._hideLookupTooltip(this.lup_Opportunity);
            this._hideLookupTooltip(this.lup_Ticket);
            this._hideLookupTooltip(this.lup_Lead);
            this._hideLookupTooltip(this.lup_Leader);
        },
        _hideLookupTooltip: function (control) {
            if (control) {
                control.hideTooltip();
            }
       },
        _showAttachmentsTab: function () {
            var self = this;
            window.setTimeout(function () {
                self._ensureAttachmentList();
            }, 100);

        },
        _ensureAttachmentList: function () {
            var newAttachmentList = false;
            if (!this._attachmentList) {
                newAttachmentList = true;
                this._attachmentList = new AttachmentList({
                    workspace: '',
                    tabId: '',
                    placeHolder: this.id + '_attachmentsGridPlaceholder',
                    parentRelationshipName: 'historyId'
                });
                var self = this;
                this._attachmentList.startup(function () {
                    if (self.cp_Attachments) {
                        self.cp_Attachments.resize();
                    }
                });
            } 

            if (newAttachmentList || this.mode != 'New') {
                this._attachmentList.resetEntityContext();
            }
        },
        // ... region - History data methods   .....................
        _updateHistoryETag: function (attachment) {
            //listener for attachment record changes.
            if (this._dialog.open && this.historyId) {
                var req = new Sage.SData.Client.SDataSingleResourceRequest(sDataServiceRegistry.getSDataService('dynamic'));
                req.setResourceKind('history');
                req.setResourceSelector('"' + this.historyId + '"');
                req.setQueryArg('precedence', '0');
                req.read({
                    success: function (history) {
                        this._historyData['$etag'] = history['$etag'];
                    },
                    scope: this
                });
            }
        },
        _setModeAttr: function (mode) {
            this.mode = mode;
            var idx = this.tc_EditHistory.getIndexOfChild(dijit.byId("histAttendeesTabPane"));
            if (mode.indexOf('New') === 0) {
                this._historyData = false;
                if (idx > 0) {
                    this.tc_EditHistory.removeChild(dijit.byId("histAttendeesTabPane"));
                    dijit.byId("histAttendeesTabPane").destroy();
                    var self = this;
                    window.setTimeout(function () {
                        self._dialog.resize();
                    }, 100);
                }

            } else {
                if (idx < 0) {
                    this._addAttendeesTab();
                    var self = this;
                    window.setTimeout(function () {
                        self._dialog.resize();
                    }, 100);
                }
            }

        },
        _setActivityTypeAttr: function (type) {

            switch (type) {
                case 'PhoneCall':
                case 'atPhoneCall':
                    this.activityType = 'atPhoneCall';
                    break;
                case 'Meeting':
                case 'atAppointment':
                    this.activityType = 'atAppointment';
                    break;
                case 'ToDo':
                case 'atToDo':
                    this.activityType = 'atToDo';
                    break;
                case 'PersonalActivity':
                case 'atPersonal':
                case 'Personal':
                    this.activityType = 'atPersonal';
                    break;
                case 'atNote':
                case 'Note':
                    this.activityType = 'atNote';
                    break;
                default:
                    this.activityType = 'atNote';
                    break;
            }


        },
        _setHistoryIdAttr: function (historyId) {
            if (this.historyId !== historyId) {
                this.historyId = historyId;
                this._historyData = false;
                //console.log('setting the historyid <' + historyId + '>');
                if (historyId !== '') {
                    this._loadData();
                }
            }
        },
        _getHistoryIdAttr: function () {
            return this.historyId;
        },
        _setupStore: function () {
            if (!this._historyStore) {
                this._historyStore = new SingleEntrySDataStore({
                    include: [],
                    resourceKind: 'history',
                    service: this._historyService
                });
            }
        },
        _loadData: function () {

            if (this._dialog._standby) {
                this._dialog.showLoading();
            }
            this._resetDataProps();
            if (this._historyStore) {
                if (this.mode !== 'New') {
                    this._historyStore.fetch({
                        predicate: '"' + this.historyId + '"',
                        onComplete: this._receivedHistory,
                        onError: this._requestFailure,
                        scope: this
                    });
                } else {
                    this._historyStore.newItem({
                        onComplete: function (data) {
                            Sage.Utility.setValue(data, 'Type', this.activityType);
                            this._receivedHistory(dojo.mixin(data, this.historyDefaultValues));
                            //this._receivedHistory(data);
                        },
                        scope: this
                    });
                }
            }

        },
        _resetDataProps: function () {
            this._historyData = false;
            this._historySaved = false;
            if (this._attachmentList) {
                this._attachmentList.clearNewAttachments();
            }
            if (((this.activityType === "atNote") && (this.mode === 'New'))) {
                Sage.Utility.setValue(this.historyDefaultValues, 'Result', this.resultComplete);
            }
        },
        _receivedHistory: function (data) {
            this._historyData = data;
            this._tempIdForAttachments = false;

            var contextSvc = Sage.Services.getService('ClientEntityContext');
            var context = {
                "EntityId": this._historyData.$key || '',
                "EntityType": "Sage.Entity.Interfaces.IHistory",
                "Description": this._historyData.$descriptor,
                "EntityTableName": "HISTORY"
            };
            contextSvc.setTemporaryContext(context);

            this._ensureIdsNotNull();
            if (this.mode !== 'New') {
                this.activityType = data.Type;
            } else {
                this._applyUserOptionsForNewHistory();
            }
            this._setUIForActivityType(data.Type);
            this._bind();

            //decide if the delete button should show or not...
            if (((this.activityType === "atNote") && (this.mode === 'New'))
                || (data['UserId'] !== this._currentUserId && this._currentUserId.trim() !== 'ADMIN')) {
                dojo.addClass(this.btn_Delete.domNode, 'display-none');
            }
            else {
                dojo.removeClass(this.btn_Delete.domNode, 'display-none');
            }

            if (this._dialog._standby) {
                this._dialog.hideLoading();
            }
        },
        _ensureIdsNotNull: function () {
            for (var i = 0; i < this.notnullfields.length; i++) {
                if (this._historyData[this.notnullfields[i]] === null) {
                    this._historyData[this.notnullfields[i]] = '';
                }
            }
        },
        _applyUserOptionsForNewHistory: function () {
            //set start and alarm time to user options.
            var newDate = new Date();
            newDate.setSeconds(5);
            newDate.setMinutes(0);
            newDate.setHours(0);
            Sage.Utility.setValue(this._historyData, 'Timeless', true);
            Sage.Utility.setValue(this._historyData, 'StartDate', Sage.Utility.Convert.toIsoStringFromDate(newDate));

            //set default duration...
            Sage.Utility.setValue(this._historyData, 'Duration', '60');
        },

        _requestFailure: function (msg, request, opts) {
            console.warn('error requesting data %o', arguments);
        },
        _createBindings: function () {
            if (this._bindingMgr) {
                this._bindingMgr.destroy();
                this._bindingMgr = false;
            }
            this._bindingMgr = new BindingsManager({
                defaultBinding: { boundEntity: this._historyData },
                items: [
                    {
                        boundWidget: this.tb_Location,
                        entityProperty: 'Location'
                    }, {
                        boundWidget: this.pk_Regarding,
                        entityProperty: 'Description',
                        onChange: dojo.hitch(this, '_descriptionChanged')
                    }, {
                        boundWidget: this.pk_Result,
                        entityProperty: 'Result'
                    }, {
                        boundWidget: this.pk_Category,
                        entityProperty: 'Category'
                    }, {
                        boundWidget: this.pk_Priority,
                        entityProperty: 'Priority'
                    }, {
                        boundWidget: this.dtp_startDate,
                        dataType: 'date',
                        entityProperty: 'StartDate',
                        onChange: dojo.hitch(this, '_startDateChanged')
                    }, {
                        boundWidget: this.dtp_completedDate,
                        dataType: 'date',
                        entityProperty: 'CompletedDate'
                        //onChange: dojo.hitch(this, '_completedDateChanged')
                    }, {
                        boundWidget: this.sel_Duration,
                        entityProperty: 'Duration'
                    }, {
                          boundWidget: this.sel_Duration,
                          entityProperty: 'StartDate',
                          widgetProperty: 'startTime',
                          dataType: 'date',
                          twoWay: false
                      }, {
                        boundWidget: this.cb_Timeless,
                        entityProperty: 'Timeless',
                        widgetProperty: 'checked',
                        onChange: dojo.hitch(this, '_timelessChange')
                    }, {
                        boundWidget: this.ta_Notes,
                        entityProperty: 'LongNotes'
                    }
                ]
            });
            //this._historyChangeConnection = dojo.connect(this._bindingMgr, 'onChange', this, 'onChange');
        },
        _bind: function () {
            if (this._historyData) {
                if (!this._bindingMgr) {
                    this._createBindings();
                } else {
                    if (!this._bindingMgr.boundEntity || (this._historyData.HistoryId !== this._bindingMgr.boundEntity.HistoryId)) {
                        this._bindingMgr.setBoundEntity(this._historyData);
                    } else {
                        this._bindingMgr.bind();
                    }
                }
                this._manualBind();
                this._setUI();
            }
        },
        _isNullOrWhitespace: function (str) {
            return (!str || str.trim() === '');
        },
        _manualBind: function () {
            //because there are not relationships to several related entities, we have to manually bind to keep the denormalized data in sync...

            if (this._historyData) {
                this._isBinding = true;  //this prevents the change event handlers from overwriting values that we are going to set here...
                //for example, the account change handler removes the contact, opp, and ticket values.
                // account...
                var his = this._historyData;
                var mockAcctObj = this._isNullOrWhitespace(his.AccountId) ? null : {
                    '$key': his.AccountId,
                    '$descriptor': his.AccountName
                };
                this.lup_Account.set('selectedObject', mockAcctObj);
                // contact...
                var mockContact = this._isNullOrWhitespace(his.ContactId) ? null : {
                    '$key': his.ContactId,
                    '$descriptor': his.ContactName
                };
                this.lup_Contact.set('selectedObject', mockContact);

                // opportunity...
                var mockOpp = this._isNullOrWhitespace(his.OpportunityId) ? null : {
                    '$key': his.OpportutunityId,
                    '$descriptor': his.OpportunityName
                };
                this.lup_Opportunity.set('selectedObject', mockOpp);

                // ticket...
                var mockTick = this._isNullOrWhitespace(his.TicketId) ? null : {
                    '$key': his.TicketId,
                    '$descriptor': his.TicketNumber
                };
                this.lup_Ticket.set('selectedObject', mockTick);

                // lead...
                var mockLead = this._isNullOrWhitespace(his.LeadId) ? null : {
                    '$key': his.LeadId,
                    '$descriptor': his.LeadName
                };

                // Leader...
                var mockLeader = this._isNullOrWhitespace(his.UserId) ? null : {
                    '$key': his.UserId,
                    '$descriptor': his.UserName
                };
                this.lup_Leader.set('selectedObject', mockLeader);

                this.lup_Lead.set('selectedObject', mockLead);
                this.tb_LeadCompanyName.set('value', this._isNullOrWhitespace(his.LeadId) ? '' : his.AccountName);

                this._updateLookupSeedValues(his.AccountId);

                this._isBinding = false;
            }
        },

        _accountChanged: function (newAcct) {

            if (this._isBinding) { return; }

            var newId = (newAcct) ? newAcct['$key'] : '';
            var newActName = (newAcct) ? newAcct['$descriptor'] : '';

            var his = this._historyData;
            var mustSetContact = this._isNullOrWhitespace(his.ContactId);

            his.AccountId = newId;
            his.AccountName = newActName;
            his.PhoneNumber = '';
            his.LeadId = '';
            his.LeadName = '';

            this._isBinding = true;
            this.lup_Lead.set('selectedObject', null);
            this.tb_LeadCompanyName.set('value', '');
            this._updateLookupSeedValues(newId);

            this.lup_Lead.set('selectedObject', null);
            this.tb_LeadCompanyName.set('value', '');
            if (mustSetContact) {
                his.ContactId = '';
                his.ContactName = '';
                this.lup_Contact.set('selectedObject', null);
                this._setContactToCurrentAccountPrimary();
            }
            this._isBinding = false;
        },
        _contactChanged: function (newContact) {
            if (this._isBinding) { return; }
            var his = this._historyData;
            if (!newContact) {
                his.ContactId = '';
                his.ContactName = '';
                his.PhoneNumber = '';
                return;
            }
            his.ContactId = newContact['$key'];
            his.ContactName = newContact['$descriptor'];
            his.PhoneNumber = Sage.Utility.getValue(newContact, 'WorkPhone');

            //remove lead
            his.LeadId = '';
            his.LeadName = '';

            var actAccountEmpty = this._isNullOrWhitespace(his.AccountName);
            //set associated account
            his.AccountId = newContact.Account['$key'];
            his.AccountName = newContact.Account.AccountName;
            //account changed, so update seed values...
            this._updateLookupSeedValues(newContact.Account['$key']);

            this._isBinding = true;
            if (actAccountEmpty) {
                this.lup_Account.set('selectedObject', { '$key': newContact.Account['$key'], '$descriptor': newContact.Account.AccountName });
            }
            this.lup_Lead.set('selectedObject', null);
            this.tb_LeadCompanyName.set('value', '');
            this._isBinding = false;

        },
        _opportunityChanged: function (newOpp) {
            if (this._isBinding) { return; }
            /*
            The logic for when the opportunity changes is like this...
            - If there is already a contact and account selected, and the opportunity is associated to the same account - do nothing
            - If there is no contact or account selected for the activity - or the account is different do the following:
            - Set the account to the associated account and:
            - If ONE associated contact is marked IsPrimary = true set the contact to it.
            - if more than one associated contact is marked primary, or none are marked primary,
            -if one of these is primary for the account and use it
            -if not, just grab the first one.
            -if there are no contacts associate with the opportunity, use the account's primary contact.
            */

            var his = this._historyData;
            if (!newOpp) {
                his.OpportunityId = '';
                his.OpportunityName = '';
                return;
            }
            his.OpportunityId = newOpp['$key'];
            his.OpportunityName = newOpp['$descriptor'];

            if (this._isNullOrWhitespace(his.AccountId) || his.AccountId !== newOpp.Account['$key']) {
                var actAccountEmpty = this._isNullOrWhitespace(his.AccountName);
                var actContactEmpty = this._isNullOrWhitespace(his.ContactName);
                //set the associated account...
                his.AccountId = newOpp.Account['$key'];
                his.AccountName = newOpp.Account.AccountName;
                his.LeadId = '';
                his.LeadName = '';

                this._updateLookupSeedValues(newOpp.Account['$key']);

                this._isBinding = true;
                if (actAccountEmpty) {
                    this.lup_Account.set('selectedObject', { '$key': newOpp.Account['$key'], '$descriptor': newOpp.Account.AccountName });
                }
                this.lup_Lead.set('selectedObject', null);
                this.tb_LeadCompanyName.set('value', '');
                this._isBinding = false;

                if (actContactEmpty) {
                    //remove contact for now, then when we find the primary, we'll set it again.
                    this.lup_Contact.set('selectedObject', null);
                    this._setContactBasedOnOpportunity();
                }
            }
        },
        _ticketChanged: function (newTick) {
            if (this._isBinding) { return; }
            var his = this._historyData;
            if (!newTick) {
                his.TicketId = '';
                his.TicketNumber = '';
                return;
            }

            his.TicketId = newTick['$key'];
            his.TicketNumber = newTick['$descriptor'];
            //update account and contact, if there isn't an account - or if the account is different from the ticket's account
            if (this._isNullOrWhitespace(his.AccountId) || his.AccountId !== newTick.Account['$key']) {
                var actAccountEmpty = this._isNullOrWhitespace(his.AccountName);
                var actContactEmpty = this._isNullOrWhitespace(his.ContactName);
                his.AccountId = newTick.Account['$key'];
                his.AccountName = newTick.Account['AccountName'];
                his.LeadId = '';
                his.LeadName = '';
                this._updateLookupSeedValues();

                //Do we set it to the contact associated with the ticket - or the primary?
                // I'm going with the one on the ticket, but previous versions used the primary...
                his.ContactId = Sage.Utility.getValue(newTick, 'Contact.$key');
                his.ContactName = Sage.Utility.getValue(newTick, 'Contact.NameLF');
                his.PhoneNumber = Sage.Utility.getValue(newTick, 'Contact.WorkPhone');

                this._isBinding = true;
                if (actAccountEmpty) {
                    this.lup_Account.set('selectedObject', { '$key': newTick.Account['$key'], '$descriptor': newTick.Account['AccountName'] });
                }
                if (actContactEmpty) {
                    this.lup_Contact.set('selectedObject', { '$key': newTick.Contact['$key'], '$descriptor': newTick.Contact['NameLF'] });
                }
                this.lup_Lead.set('selectedObject', null);
                this.tb_LeadCompanyName.set('value', '');
                this._isBinding = false;
                // In case I have to change it back to the account's primary...
                //this._setContactToCurrentAccountPrimary();
            }
        },
        _leadChanged: function (newLead) {
            if (this._isBinding) { return; }
            //console.warn('handle new lead: %o', newLead);
            var his = this._historyData;
            if (!newLead) {
                his.LeadId = '';
                his.LeadName = '';
                his.PhoneNumber = '';
                this.tb_LeadCompanyName.set('value', '');
                return;
            }

            his.LeadId = newLead['$key'];
            his.LeadName = newLead['$descriptor'];
            his.AccountName = newLead['Company'];
            his.PhoneNumber = newLead['WorkPhone'];
            this.tb_LeadCompanyName.set('value', newLead['Company']);

            //clear out the TACO and make way for Lead.
            his.ContactId = '';
            his.ContactName = ''; //this.LeadName;
            his.AccountId = '';
            his.AccountName = '';
            his.TicketId = '';
            his.TicketNumber = '';
            his.OpportunityId = '';
            his.OpportunityName = '';
            this._updateLookupSeedValues();
            this._isBinding = true;
            this.lup_Contact.set('selectedObject', null);
            this.lup_Account.set('selectedObject', null);
            this.lup_Opportunity.set('selectedObject', null);
            this.lup_Ticket.set('selectedObject', null);
            this._isBinding = false;
        },
        _leaderChanged: function (newLeader) {
            if (this._isBinding) {
                return;
            }
            this._historyData.UserId = newLeader['$key'].substr(0, 12);
            this._historyData.UserName = newLeader['$descriptor'];
        },
        _setContactBasedOnOpportunity: function () {
            //return;

            var req = new Sage.SData.Client.SDataResourceCollectionRequest(Sage.Data.SDataServiceRegistry.getSDataService('dynamic'));
            req.setResourceKind('opportunities');
            var pathIdx = req.uri.pathSegments.length - 1;
            var resourceSegment = req.uri.getPathSegment(pathIdx);
            resourceSegment['predicate'] = '"' + this._historyData.OpportunityId + '"';
            req.uri.setPathSegment(pathIdx + 1, 'Contacts');
            req.setQueryArg('select', 'IsPrimary,Contact/NameLF,Contact/IsPrimary,Contact/WorkPhone');
            req.setQueryArg('orderby', 'IsPrimary desc');
            req.read({
                success: function (data) {
                    var oppCons = data['$resources'];
                    if (oppCons.length < 1) {
                        this._setContactToCurrentAccountPrimary();
                        return;
                    }
                    var oppPri = false, accPri = false, firstCon = oppCons[0], newActCon;
                    for (var i = 0; i < oppCons.length; i++) {
                        if (oppCons[i].IsPrimary) {
                            if (!oppPri || oppCons[i].Contact.IsPrimary) {
                                oppPri = oppCons[i];
                            }
                        }
                        if (!accPri && oppCons[i].Contact.IsPrimary) {
                            accPri = oppCons[i];
                        }
                    }

                    newActCon = oppPri || accPri || firstCon;

                    if (newActCon) {
                        this._historyData.ContactId = Sage.Utility.getValue(newActCon, 'Contact.$key');
                        this._historyData.ContactName = Sage.Utility.getValue(newActCon, 'Contact.NameLF');
                        this._historyData.PhoneNumber = Sage.Utility.getValue(newActCon, 'Contact.WorkPhone');
                        this._rebindToCurrentContact();
                    }

                },
                failure: function () {
                    this._rebindToCurrentContact();
                },
                scope: this
            });
        },
        _setContactToCurrentAccountPrimary: function () {
            //look up the primary contact...
            var req = new Sage.SData.Client.SDataResourceCollectionRequest(Sage.Data.SDataServiceRegistry.getSDataService('dynamic'));
            req.setResourceKind('accounts');
            var pathIdx = req.uri.pathSegments.length - 1;
            var resourceSegment = req.uri.getPathSegment(pathIdx);
            resourceSegment['predicate'] = '"' + this._historyData.AccountId + '"';
            req.uri.setPathSegment(pathIdx + 1, 'Contacts');
            req.setQueryArg('select', 'NameLF,IsPrimary,WorkPhone');
            req.setQueryArg('orderby', 'IsPrimary desc');  //rather than selecting "where IsPrimary", do it this way so we at least get something - if there is one that is primary, it will come back, otherwise, we'll just get one.
            req.setQueryArg('count', '1');  //only need one...
            req.read({
                success: function (data) {
                    var contacts = data['$resources'];
                    if (contacts.length < 1) {
                        //fall back to the one that was there...
                        this._rebindToCurrentContact();
                        return;
                    }
                    var primaryContact = contacts[0];
                    this._historyData.ContactId = Sage.Utility.getValue(primaryContact, '$key');
                    this._historyData.ContactName = Sage.Utility.getValue(primaryContact, 'NameLF');
                    this._historyData.PhoneNumber = Sage.Utility.getValue(primaryContact, 'WorkPhone');
                    this._isBinding = true;
                    this.lup_Contact.set('selectedObject', primaryContact);
                    this._isBinding = false;
                },
                failure: function () {
                    this._rebindToCurrentContact();
                },
                scope: this
            });
        },
        _rebindToCurrentContact: function () {
            this._isBinding = true;
            this.lup_Contact.set('selectedObject', { '$key': this._historyData.ContactId, '$descriptor': this._historyData.ContactName });
            this._isBinding = false;
        },
        _updateLookupSeedValues: function (newSeed) {
            var accId = newSeed || this._historyData.AccountId;
            this.contactLookupConfig.seedValue = accId;
            this.opportunityLookupConfig.seedValue = accId;
            this.ticketLookupConfig.seedValue = accId;
        },
        // ... endregion - data methods

        // ... region UI interactions   ...
        _setUI: function () {
            this._formatHeader();
            this._setDisabledByTimlessValue();
            if (this._isNullOrWhitespace(this._historyData.LeadId)) {
                this.rdo_Contact.set('checked', true);
            } else {
                this.rdo_Lead.set('checked', true);
            }
            this._setContactLeadVisibility();
            this._setScheduledByLabel();
            this._applySecurity();

        },

        _applySecurity: function () {
            if (this.mode === 'New') {
                this._setAccessToUI(true);
            } else if (this.mode === 'Complete') {
                this._setAccessToUI(true);
            } else {
                var svc = Sage.Services.getService('CalendarSecurityService');
                if (svc) {
                    var curUser = utility.getClientContextByKey('userID').trim();
                    var userId = this._historyData.UserId || curUser;
                    if (curUser !== userId) {
                        svc.hasAccess(userId, 'allowEdit', function (hasAccess) {
                            this._setAccessToUI(hasAccess);
                        },
                        this);
                    }
                    else {
                        this._setAccessToUI(true);
                    }
                }
            }
        },
        _setAccessToUI: function (hasAccess) {
            this._hasAccess = hasAccess;
            if ((this.mode === 'New') || ((this.mode === 'Complete'))) {
                this.rdo_Lead.set('disabled', !hasAccess);
                this.tb_Location.set('disabled', !hasAccess);
                this.pk_Regarding.set('disabled', !hasAccess);
                this.pk_Category.set('disabled', !hasAccess);
                this.pk_Priority.set('disabled', !hasAccess);
                this.dtp_startDate.set('disabled', !hasAccess);
                this.dtp_completedDate.set('disabled', !hasAccess);
                if (!hasAccess) {
                    this.sel_Duration.set('disabled', true);
                }
                this.cb_Timeless.set('disabled', !hasAccess);
                this.ta_Notes.set('disabled', !hasAccess);
                this.lup_Leader.set('disabled', !hasAccess);
                this.lup_Account.set('disabled', !hasAccess);
                this.lup_Contact.set('disabled', !hasAccess);
                this.lup_Lead.set('disabled', !hasAccess);
                this.lup_Ticket.set('disabled', !hasAccess);
                this.lup_Opportunity.set('disabled', !hasAccess);
                this.tb_LeadCompanyName.set('disabled', !hasAccess);
                this.btn_OK.set('disabled', !hasAccess);
            } else {
                this.rdo_Lead.set('disabled', true);
                this.tb_Location.set('disabled', !hasAccess);
                this.pk_Regarding.set('disabled', !hasAccess);
                this.pk_Category.set('disabled', !hasAccess);
                this.pk_Priority.set('disabled', true);
                this.dtp_startDate.set('disabled', true);
                this.dtp_completedDate.set('disabled', true);
                this.sel_Duration.set('disabled', true);
                this.cb_Timeless.set('disabled', true);
                this.ta_Notes.set('disabled', !hasAccess);
                this.lup_Leader.set('disabled', true);
                this.lup_Account.set('disabled', true);
                this.lup_Contact.set('disabled', true);
                this.lup_Lead.set('disabled', true);
                this.lup_Ticket.set('disabled', true);
                this.lup_Opportunity.set('disabled', true);
                this.tb_LeadCompanyName.set('disabled', true);
                this.btn_OK.set('disabled', !hasAccess);
            }
        },
        _setUIForActivityType: function (actType) {
            this.pk_Regarding.set('pickListName', Sage.Utility.Activity.getActivityPicklistName('Regarding', actType));
            this.pk_Category.set('pickListName', Sage.Utility.Activity.getActivityPicklistName('Category', actType));
            this.pk_Result.set('pickListName', Sage.Utility.Activity.getActivityPicklistName('Result', actType));

            //If the user doesn't have access to edit the Leader's calendar, we need to disable the OK button...
            var svc = Sage.Services.getService('CalendarSecurityService');
            this.btn_OK.set('disabled', false);  //enable it in case it was disabled the last time around...
            if (svc && this.mode !== 'New') {
                var curuser = utility.getClientContextByKey('userID').trim();
                var leader = this._historyData.UserId || curuser;
                //console.log('curuser: <' + curuser + '>   leader: <' + leader + '>');
                if (curuser !== leader) {
                    svc.hasAccess(leader, 'allowEdit', function (hasAccess) { this.btn_OK.set('disabled', !hasAccess); }, this);
                }
            }

        },
        _setDisabledByTimlessValue: function () {
            if (!this._historyData) {
                return;
            }
            var tless = this._historyData['Timeless'];
            this.dtp_startDate.set('displayTime', !tless);
            this.sel_Duration.set('disabled', tless || !this._hasAccess);
        },
        _timelessChange: function () {
            this._setDisabledByTimlessValue();
        },
        _descriptionChanged: function () {
            this._formatHeader();
        },

        _startDateChanged: function () {
            var newStartDate = this.dtp_startDate.get('value');
            this.sel_Duration.set('startTime', newStartDate);
        },
        _setContactLeadVisibility: function () {
            var cVisible = this.rdo_Contact.get('checked');
            dojo.removeClass((cVisible) ? this.contactContainer.domNode : this.leadContainer.domNode, 'display-none');
            dojo.addClass((cVisible) ? this.leadContainer.domNode : this.contactContainer.domNode, 'display-none');
        },
        _formatHeader: function () {
            var typeName;
            var typeImage;
            var modeText;
            var description;
            typeImage = Sage.Utility.Activity.getActivityImageClass(this._historyData['Type'] || 'atAppointment', 'small');
            typeName = Sage.Utility.Activity.getActivityTypeName(this._historyData['Type'] || 'atAppointment');
            modeText = (this.mode === 'New') ? this.insertText : '';
			if(typeName===this.noteText && this.mode === 'New'){
				modeText = this.insertNoteText;
				typeName="";
			}
            description = this._historyData['Description'] || '';
            if (description !== '') {
                description = ' - ' + description;
            }
            this._dialog.set('title',
                dojo.string.substitute('<div class="Global_Images icon16x16 ${0}" > </div>&nbsp;<span class="activity-dialog-title" style="max-width: 975px; text-overflow: ellipsis;">${1} ${2} ${3}</span>',
                    [typeImage, modeText, typeName, description]
                )
            );
        },
        _setScheduledByLabel: function () {
            // adds the note:  Scheduled by <user> on <scheduled Date>

            var createDate = Sage.Utility.Convert.toDateFromString(Sage.Utility.getValue(this._historyData, 'CreateDate'));
            if (createDate.getFullYear() < 1000) {
                createDate = new Date();
            }

            var createUser = Sage.Utility.getValue(this._historyData, 'CreateUser').trim();

            if (!createUser || utility.getClientContextByKey('userID') === createUser) {
                createUser = utility.getClientContextByKey('userPrettyName');
            } else if (createUser === 'PROCESS' || createUser === 'ADMIN') {
                createUser = 'Administrator';
            } else {
                this._getUserInfoFor(createUser, function (user) {
                    dojo.html.set(this.lbl_ScheduledBy, dstring.substitute(this.scheduledByFormatText, {
                        user: user['$descriptor'],
                        date: locale.format(createDate, { selector: 'date', fullYear: true, locale: Sys.CultureInfo.CurrentCulture.name })
                    }));
                });
                return;
            }

            var lbl = dstring.substitute(this.scheduledByFormatText, {
                user: createUser,
                date: locale.format(createDate, { selector: 'date', fullYear: true, locale: Sys.CultureInfo.CurrentCulture.name })
            });
            dojo.html.set(this.lbl_ScheduledBy, lbl);

        },
        _getUserInfoFor: function (userId, callback) {
            var request = new Sage.SData.Client.SDataSingleResourceRequest(Sage.Data.SDataServiceRegistry.getSDataService('dynamic', false, true, true)); //go ahead and cache this...
            request.setResourceKind('userInfo');
            request.setResourceSelector("'" + userId + "'");
            //using precedence of 0 we only get $descriptor which is <lastname, firstname>,
            //...but do we want the UserName property which is <firstname lastname>???
            request.setQueryArg('precedence', '0');
            request.read({
                success: callback,
                scope: this,
                failure: function () { }
            });
        },



        // ... endregion UI interactions

        // ... region click/action handlers
        _okClick: function () {
            delete this._historyData['Notes']; //We are dong this so that the notes property does not override it self when posting back.
            delete this._historyData['UserName']; //We are dong this so that the bussiness rules will set this when posting back.
            if (this.rdo_Lead.checked) {
                delete this._historyData['ContactId']; //We are dong this so that the bussiness rules will set this when posting back.
                delete this._historyData['ContactName']; //We are dong this so that the bussiness rules will set this when posting back.
                delete this._historyData['AccountId']; //We are dong this so that the bussiness rules will set this when posting back.
                delete this._historyData['AccountName']; //We are dong this so that the bussiness rules will set this when posting back.
                delete this._historyData['LeadName']; //We are dong this so that the bussiness rules will set this when posting back.
            }
            else {
                delete this._historyData['LeadId']; //We are dong this so that the bussiness rules will set this when posting back.
            }
            if (this.mode === 'New') {
                this._currentUserActivitySaved = true;
                this._historyStore.saveNewEntity(this._historyData, this._successfulHistorySave, this._failedHistorySave, this);
            } else {
                this._historyStore.save({
                    scope: this,
					ignoreETag:true,
                    success: this._successfulHistorySave,
                    failure: this._failedAHistorySave
                });
            }
        },
        _successfulHistorySave: function (history) {
            var waitForAttachmentsToSave = false;
            this._historyData = history;
            this.historyId = history['$key'];
            var svc = Sage.Services.getService('ClientEntityContext');
            svc.clearTemporaryContext();
            this._attachmentsSaved = true;
            if (this._attachmentList) {
                var attachments = this._attachmentList.getNewAttachments();
                if (attachments.length > 0 && this.mode === 'New') {
                    if (this._needsFollowUp()) {
                        waitForAttachmentsToSave = true;
                    }
                    this._saveAttachments(attachments);
                    this._attachmentsSaved = false;
                }
            }
            if (this.mode === 'New') {
                this.attendeesTab._addHistoryAttendee(history);
            }
            dojo.publish('/entity/history/change', [history, this]);
            this._historySaved = true;
            if (!waitForAttachmentsToSave) {
                this._hideIfComplete();
            }
        },
        _failedHistorySave: function (request) {
            console.log('an error occured saving history %o', request);
            Sage.UI.Dialogs.showError(this.couldNotSaveErrorText);
        },
        _cancelClick: function () {
            if (this.mode === 'Complete') {
                this._deleteClick();
            } else {
                this.hide();
            }
        },
        _hideIfComplete: function () {

            if (this._historySaved) {
                if (this._mode !== 'New') {
                    this._doFollowup();
                }
                else {
                    this.hide();
                }
            }
        },

        _deleteClick: function () {
            if (this._historyData && this._historyStore) {
                Sage.UI.Dialogs.raiseQueryDialogExt({
                    title: this.deleteTitle,
                    query: this.deleteMessage,
                    callbackFn: function (result) {
                        if (result) {
                            this._historyStore.deleteEntity(this._historyData, this._successfulHistoryDelete, this._failedHistoryDelete, this);
                        }
                    },
                    yesText: this.okText,
                    noText: this.cancelText,
                    icon: 'questionIcon',
                    scope: this
                });
            }

        },
        _successfulHistoryDelete: function () {
            var svc = Sage.Services.getService('ClientEntityContext');
            svc.clearTemporaryContext();
            dojo.publish('/entity/history/delete', [this._historyData['$key'], this]);
            this.hide();
        },
        _failedHistoryDelete: function (request) {
            var msg = activityUtility.findFailedRequestMessage(request, this.couldNotDeleteErrorText);
            SageDialogs.showError(msg);
        },
        _saveAttachments: function (attachments) {
            this._attachmentRequests = attachments.length;
            for (var i = 0; i < attachments.length; i++) {
                var att = attachments[i];
                var req = new Sage.SData.Client.SDataSingleResourceRequest(sDataServiceRegistry.getSDataService('system'));
                req.setResourceKind('attachments');
                req.setResourceSelector('\'' + att.$key + '\'');
                att.historyId = this.historyId;
                for (var p in this._historyData) {
                    if (p.substring(p.length - 2) === 'Id' && p !== 'UserId') {
                        var attProp = p.substring(0, 1).toLowerCase() + p.substring(1);
                        att[attProp] = this._historyData[p];

                    }
                }
                req.update(att, {
                    success: this._successfulAttachmentSave,
                    failure: this._failedAttachmentSave,
                    scope: this
                });

            }
        },
        _removeAttachments: function () {
            if (!this._attachmentList) {
                return;
            }
            var attachments = this._attachmentList.getNewAttachments();
            for (var i = 0; i < attachments.length; i++) {
                var att = attachments[i];
                var req = new Sage.SData.Client.SDataSingleResourceRequest(sDataServiceRegistry.getSDataService('system'));
                req.setResourceKind('attachments');
                req.setResourceSelector('\'' + att.$key + '\'');
                req['delete'](att, {
                    success: function () { },
                    failure: function () { },
                    scope: this
                });
            }
        },
        getRelationshipsForAttachments: function () {
            var obj = {};
            for (var p in this._activityData) {
                if (p.substring(p.length - 2) === 'Id' && p !== 'UserId') {
                    var attProp = p.substring(0, 1).toLowerCase() + p.substring(1);
                    obj[attProp] = this._activityData[p];
                }
            }
            if (this.mode === 'New' && !fileUtility.supportsHTML5File && !slx.desktop) {
                this._tempIdForAttachments = this._makeTempID();
                obj['historyId'] = this._tempIdForAttachments;
            }
            return obj;
        },
        _makeTempID: function () {
            if (!this._tempIdForAttachments) {
                var uid = this._currentUserId;
                var dstr = utility.Convert.toIsoStringFromDate(this.dtp_completedDate.get('value'));
                dstr = dstr.replace(/[T:-]/g, '').substr(6, 6);
                this._tempIdForAttachments = 'NE' + uid.substr(uid.length - 4, 4) + dstr;
            }
            return this._tempIdForAttachments;
        },
        _attachmentRequests: 0,
        _successfulAttachmentSave: function (attachment) {
            this._attachmentRequests--;
            if (this._attachmentRequests < 1) {
                this._attachmentsSaved = true;
                this._hideIfComplete();
            }
        },
        _failedAttachmentSave: function () {
            this._attachmentRequests--;
            if (this._attachmentRequests < 1) {
                this._attachmentsSaved = true;
                this._hideIfComplete();
            }
        },
        _needsFollowUp: function () {
            var followUp = this.sel_Followup.get('value');
            return followUp != this.noneText;
        },

        // ... endregion
        _doFollowup: function () {
            var followUp = this.sel_Followup.get('value');
            switch (followUp) {
                case this.noneText:
                    this.hide();
                    return;
                case activityUtility.getActivityTypeName('atPhoneCall'):
                    //doing the circles because of localization...
                    followUp = 'atPhoneCall';
                    break;
                case activityUtility.getActivityTypeName('atAppointment'):
                    followUp = 'atAppointment';
                    break;
                case activityUtility.getActivityTypeName('atToDo'):
                    followUp = 'atToDo';
                    break;
            }
            var historyMixin = this._getFollowUpActivityData();
            this._doingFollowup = true;
            this.hide('followup');
            window.setTimeout(function () {
                var svc = Sage.Services.getService('ActivityService');
                if (svc) {
                    svc.scheduleActivity({ 'type': followUp, 'preConfigured': historyMixin });
                }
            }, 250);
        },
        _getFollowUpActivityData: function () {
            var his = this._historyData;
            var ret = {
                AccountId: his.AccountId,
                AccountName: his.AccountName,
                ContactId: his.ContactId,
                ContactName: his.ContactName,
                Description: his.Description,
                LeadId: his.LeadId,
                LeadName: his.LeadName,
                OpportunityId: his.OpportunityId,
                OpportunityName: his.OpportunityName,
                TicketId: his.TicketId,
                TicketNumber: his.TicketNumber

            };
            if (this.ck_coNotes.get('checked')) {
                ret['LongNotes'] = his.LongNotes;
                ret['Notes'] = his.Notes;
            }
            if (this.ck_coAttachments.get('checked')) {
                ret['carryOverAttachmentsFrom'] = his.$key;
            }
            return ret;
        },

        //region lookup configs
        createAccountLookupConfig: function () {
            this.accountLookupConfig = {
                id: '_historyAcc',
                structure: [
                    {
                        "label": this.accountText,
                        "field": "AccountName"
                    },
                            {
                                "label": this.cityText,
                                "field": "Address.City"
                            },
                            {
                                "label": this.stateText,
                                "field": "Address.State"
                            },
                            {
                                "label": this.mainPhoneText,
                                "field": "MainPhone"
                            },
                            {
                                "label": this.typeText,
                                "field": "Type"
                            },
                            {
                                "label": this.subTypeText,
                                "field": "SubType"
                            },
                            {
                                "label": this.statusText,
                                "field": "Status"
                            },
                            {
                                "label": this.acctMgrText,
                                "field": "AccountManager.UserInfo.UserName"
                            },
                            {
                                "label": this.ownerText,
                                "field": "Owner.OwnerDescription"
                            }
                ],
            gridOptions: {
              contextualCondition: '',
              contextualShow: '',
              selectionMode: 'single'
            },
            storeOptions: {
              resourceKind: 'accounts',
              sort: [{ attribute: 'AccountName' }]
            },
            isModal: true,
            seedProperty: '',
            seedValue: '',
            overrideSeedValueOnSearch: false,
            initializeLookup: false,
            preFilters: [],
            returnPrimaryKey: true,
            dialogTitle: this.lookupActText,
            dialogButtonText: this.okText
            };
            return this.accountLookupConfig;
        },
        createAccountLookup: function () {
            this.createAccountLookupConfig();
            this.lup_Account = new Sage.UI.Controls.Lookup({
                id: 'history_lu_account',
                allowClearingResult: true,
                config: this.accountLookupConfig,
                readonly: true,
            });
            this.eventConnections.push(dojo.connect(this.lup_Account, 'onChange', this, '_accountChanged'));
            dojo.place(this.lup_Account.domNode, this.container_AccountLup.domNode, 'only');

        },
        createContactLookupConfig: function () {
            this.contactLookupConfig = {
                id: '_histoyContact',
                structure: [
                        {
                            label: this.nameText,
                            field: 'NameLF'
                        }, {
                            label: this.accountText,
                            field: 'Account.AccountName'
                        }, {
                            label: this.cityText,
                            field: 'Address.City'
                        }, {
                            label: this.stateText,
                            field: 'Address.State'
                        }, {
                            label: this.workphoneText,
                            field: 'WorkPhone'
                        }, {
                            label: this.emailText,
                            field: 'Email'
                        }],
                gridOptions: {
                    contextualCondition: '',
                    contextualShow: '',
                    selectionMode: 'single'
                },
                storeOptions: {
                    resourceKind: 'contacts',
                    sort: [{ attribute: 'NameLF' }]
                },
                isModal: true,
                seedProperty: 'Account.Id',
                seedValue: '',
                overrideSeedValueOnSearch: true,
                initialLookup: true,
                preFilters: [],
                returnPrimaryKey: true,
                dialogTitle: this.lookupContactText,
                dialogButtonText: this.okText
            };
            return this.contactLookupConfig;
        },
        createContactLookup: function () {
            this.createContactLookupConfig();
            this.lup_Contact = new Sage.UI.Controls.Lookup({
                id: 'history_lu_contact',
                allowClearingResult: true,
                readonly: true,
                config: this.contactLookupConfig,
                showEntityInfoToolTip: true
            });
            this.eventConnections.push(dojo.connect(this.lup_Contact, 'onChange', this, '_contactChanged'));
            dojo.place(this.lup_Contact.domNode, this.container_ContactLup.domNode, 'only');
        },
        createOpportunityLookupConfig: function () {
            this.opportunityLookupConfig = {
                id: '_historyOpp',
                structure: [
                    {
                        label: this.descriptionText,
                        field: 'Description'
                    }, {
                        label: this.acctMgrText,
                        field: 'AccountManager.UserInfo.UserName'
                    }, {
                        label: this.accountText,
                        field: 'Account.AccountName'
                    }, {
                        label: this.stageText,
                        field: 'Stage'
                    }, {
                        label: this.statusText,
                        field: 'Status'
                    }, {
                        label: this.ownerText,
                        field: 'Owner.OwnerDescription'
                    }
                ],
                gridOptions: {
                    contextualCondition: '',
                    contextualShow: '',
                    selectionMode: 'single'
                },
                storeOptions: {
                    resourceKind: 'opportunities',
                    sort: [{ attribute: 'Description' }]
                },
                isModal: true,
                seedProperty: 'Account.Id',
                seedValue: '',
                overrideSeedValueOnSearch: true,
                initialLookup: true,
                preFilters: [],
                returnPrimaryKey: true,
                dialogTitle: this.lookupOpportunityText,
                dialogButtonText: this.okText
            };
            return this.opportunityLookupConfig;
        },
        createOpportunityLookup: function () {
            this.createOpportunityLookupConfig();
            this.lup_Opportunity = new Sage.UI.Controls.Lookup({
                id: 'history_lu_opportunity',
                allowClearingResult: true,
                readonly: true,
                config: this.opportunityLookupConfig,
                showEntityInfoToolTip: true
            });
            this.eventConnections.push(dojo.connect(this.lup_Opportunity, 'onChange', this, '_opportunityChanged'));
            dojo.place(this.lup_Opportunity.domNode, this.container_OppLup.domNode, 'only');
        },
        createTicketLookupConfig: function () {
            this.ticketLookupConfig = {
                id: '_historyTicket',
                structure: [
                    {
                        label: this.ticketNumberText,
                        field: 'TicketNumber'
                    }, {
                        label: this.accountText,
                        field: 'Account.AccountName'
                    }, {
                        label: this.nameText,
                        field: 'Contact.NameLF'
                    }, {
                        label: this.phoneText,
                        field: 'Contact.WorkPhone'
                    }, {
                        label: this.statusText,
                        field: 'StatusCode',
                        pickListName: '',
                        propertyType: 'SalesLogix.PickList'
                    }, {
                        label: this.urgencyText,
                        field: 'Urgency.Description'
                    }, {
                        label: this.areaText,
                        field: 'Area'
                    }
                ],
                gridOptions: {
                    contextualCondition: '',
                    contextualShow: '',
                    selectionMode: 'single'
                },
                storeOptions: {
                    resourceKind: 'tickets',
                    sort: [{ attribute: 'TicketNumber' }]
                },
                isModal: true,
                seedProperty: 'Account.Id',
                seedValue: '',
                overrideSeedValueOnSearch: true,
                initialLookup: true,
                preFilters: [],
                returnPrimaryKey: true,
                dialogTitle: this.lookupTicketText,
                dialogButtonText: this.okText
            };
            return this.ticketLookupConfig;
        },
        createTicketLookup: function () {
            this.createTicketLookupConfig();
            this.lup_Ticket = new Sage.UI.Controls.Lookup({
                id: 'history_lu_ticket',
                allowClearingResult: true,
                readonly: true,
                config: this.ticketLookupConfig,
                showEntityInfoToolTip: true
            });
            this.eventConnections.push(dojo.connect(this.lup_Ticket, 'onChange', this, '_ticketChanged'));
            dojo.place(this.lup_Ticket.domNode, this.container_TicketLup.domNode, 'only');
        },
        createLeadLookupConfig: function () {
            this.leadLookupConfig = {
                id: '_historyLead',
                structure: [
                    {
                        label: this.nameText,
                        field: 'LeadFullName'
                    }, {
                        label: this.companyText,
                        field: 'Company'
                    }, {
                        label: this.cityText,
                        field: 'Address.City'
                    }, {
                        label: this.stateText,
                        field: 'Address.State'
                    }, {
                        label: this.postalText,
                        field: 'Address.PostalCode'
                    }, {
                        label: this.statusText,
                        field: 'Status'
                    }, {
                        label: this.workphoneText,
                        field: 'WorkPhone'//,
                        //'styles': 'text-align: right;'
                    }, {
                        label: this.ownerText,
                        field: 'Owner.OwnerDescription'
                    }
                ],
            gridOptions: {
              contextualCondition: '',
              contextualShow: '',
              selectionMode: 'single'
            },
            storeOptions: {
              resourceKind: 'leads',
              sort: [{ attribute: 'LeadFullName' }]
            },
            isModal: true,
            initialLookup: false,
            preFilters: [],
            returnPrimaryKey: true,
            dialogTitle: this.lookupLeadText,
            dialogButtonText: this.okText
            };
            return this.leadLookupConfig;
        },
        createLeadLookup: function () {
            this.createLeadLookupConfig();
            this.lup_Lead = new Sage.UI.Controls.Lookup({
                id: 'history_lu_lead',
                allowClearingResult: true,
                readonly: true,
                config: this.leadLookupConfig,
                showEntityInfoToolTip: true
            });
            this.eventConnections.push(dojo.connect(this.lup_Lead, 'onChange', this, '_leadChanged'));
            dojo.place(this.lup_Lead.domNode, this.container_LeadLup.domNode, 'only');
        },
        createLeaderLookupConfig: function () {
            this.leaderLookupConfig = {
                id: '_historyLeader',
                structure: [
                    {
                        label: this.nameText,
                        field: 'Name',
                        sortable: true,
                        width: "400px",
                        editable: false,
                        propertyType: "System.String",
                        excludeFromFilters: false,
                        defaultValue: ""
                    }
                ],
                gridOptions: {
                    contextualCondition: function () {
                        return 'AllowAdd AND (AccessId eq \'' + utility.getClientContextByKey('userID') + '\' OR AccessId eq \'EVERYONE\') AND Type eq \'User\'';
                    },
                    contextualShow: '',
                    selectionMode: 'single'
                },
                storeOptions: {
                    resourceKind: 'activityresourceviews',
                    sort: [{ attribute: 'Name' }]
                },
                isModal: true,
                preFilters: [],
                returnPrimaryKey: true,
                dialogTitle: this.lookupLeaderText,
                dialogButtonText: this.okText
            };
            return this.leaderLookupConfig;
        },
        createLeaderLookup: function () {
            this.createLeaderLookupConfig();
            this.lup_Leader = new Sage.UI.Controls.Lookup({
                id: 'history_lu_leader',
                readonly: true,
                config: this.leaderLookupConfig
            });
            this.eventConnections.push(dojo.connect(this.lup_Leader, 'onChange', this, '_leaderChanged'));
            dojo.place(this.lup_Leader.domNode, this.container_LeaderLup.domNode, 'only');
        },
        //end region lookup configs

        _updateLocation: function (newLocation, isAdd) {
            var location = this._historyData.Location;
            if (!location || location === '') {
                if (isAdd) {
                    location = newLocation;
                }
            } else {
                var parts = location.split('; ');
                var newParts = [];
                var exists = false;
                for (var i = 0; i < parts.length; i++) {
                    if (parts[i] === newLocation) {
                        if (isAdd) {
                            exists = true;
                        } else {
                            continue;
                        }
                    }
                    newParts.push(parts[i]);
                }
                if (!exists && isAdd) {
                    newParts.push(newLocation);
                }
                location = newParts.join('; ');
            }
            Sage.Utility.setValue(this._historyData, 'Location', location);
            this.tb_Location.set('value', location);
        },

        _formatDateForQuery: function (d) {
            return ["'", d.getUTCFullYear(), '-', d.getUTCMonth() + 1, '-', d.getUTCDate(), "'"].join('');
        },
        postCreate: function () {
            this.inherited(arguments);
            this._addAttendeesTab();

        },
        _addAttendeesTab: function () {
            //Create new attendee tab
            var attendeesTab = this.attendeesTab = new HistoryAttendeesTab();
            // Create a new ContentPane with the agenda tab as the contents
            var cp = new ContentPane({
                id: 'histAttendeesTabPane',
                title: this.tabNameParticipants,
                'class': 'tabContent remove-padding'
            }, attendeesTab.domNode);

            //Add attendees ContentPane to table container that is already defined in the activity editor
            this.tc_EditHistory.addChild(cp);
            attendeesTab.histEditor = this;
            attendeesTab.startup();
            on(cp, 'show', function () { attendeesTab._tabShow(); });
        },

        _successfulComplete: function (history) {

            var self = this;
            var _arguments = arguments;
            var deferred = this.attendeesTab._historySaved(history);
            deferred.then(function (value) {
                //debugger;
                self.inherited(_arguments);
            });

        },

    });
    return historyEditor;

});

},
'Sage/MainView/ActivityMgr/HistoryEditorAttendeesTab':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define('Sage/MainView/ActivityMgr/HistoryEditorAttendeesTab', [
        'dojo',
        'dijit/_Widget',
        'Sage/_Templated',
        'dojo/_base/declare',
        'Sage/Data/SDataServiceRegistry',
        'Sage/Utility',
        'Sage/Utility/Activity',
          'dojo/_base/array',
        'dojo/_base/lang',
        'dojo/i18n!./nls/HistoryEditorAttendeesTab',
        'Sage/UI/GridView',
        'Sage/UI/Controls/GridParts/Columns/CheckBox',
        'dojo/store/Memory',
        'dojo/data/ObjectStore',
        'dijit/form/Select'
],
    function (dojo, _Widget, _Templated, declare, sDataServiceRegistry, utility, activityUtility, array, lang, nlsStrings, GridView, CheckBox, Memory, ObjectStore, Select) {
        //The HistoryEditorAttendeesTab is a customization displaying how to add a tab to the activity dialog
        //  with a datagrid for adding and editing a collection of related entities.
        //The code to add it is below the declaration.
        var attendeesTab = declare('Sage.MainView.ActivityMgr.HistoryEditorAttendeesTab', [_Widget, _Templated], {
            histEditor: null,
            lup_Contact: null,
            lup_ContactConfig: null,
            lup_Lead: null,
            lup_LeadConfig: null,
            widgetsInTemplate: true,
            _timeZones: [],
            //the template for the tab content is simply a placeholder for the grid created in code

            constructor: function () {
                lang.mixin(this, nlsStrings);
                var self = this;
                if (this._timeZones.length == 0) {
                    Sage.Utility.getTimeZones(function (result) {
                        self._timeZones = result;
                    });
                }
            },

            widgetTemplate: new Simplate([
                '<div>',
                    '<div id="{%= $.id %}_hisAttendeesGridPlaceholder" dojoAttachPoint="_histAttendeesGridPlaceholder" style="width:100%;height:100%"></div>',
                '</div>'
            ]),
            //keep an internal list of new _attendee items as they are added
            _newItems: [],
            //this is called once by the code that adds the tab to the activity editor.
            //build the grid and connect event listeners for important events.
            startup: function () {
                //console.log("_attendeesTab startup");
                this._newItems = [];
                //this.actEditor = //dijit.byId('activityEditor');
                //if we cannot find the editor, we really cannot do much, don't create the grid
                if (!this.histEditor) {
                    return;
                }
                this._buildGrid();
                //listen for when activities are saved so we can ensure the correct relationships and save the agenda
                dojo.subscribe('/entity/history/create', this, this._historySaved);
                dojo.subscribe('/entity/history/change', this, this._historySaved);

                // this.createLookups();
            },
            _getTimeZoneDisplayName: function (keyName) {
                var displayName = keyName;
                if (this._timeZones && this._timeZones.length > 0) {
                    var obj = this._timeZones.filter(function (val) {
                        return val.Keyname === keyName;
                    });
                    if (obj && obj[0]) {
                        displayName = obj[0].Displayname;
                    }
                }
                return displayName;
            },
            _buildGrid: function () {
                var self = this;

                var onComplete = function (data, context) {
                    array.forEach(data, function (item, i) {
                        if (item["TimeZone"]) {
                            item["TimeZone"] = self._getTimeZoneDisplayName(item["TimeZone"]);
                        }
                    });
                };

                var attendeeStatusStore = new ObjectStore({
                    objectStore: new Memory({
                        idProperty: "name",
                        data: [
                            { "name": "Attended", "id": "T" },
                            { "name": "Not Attended", "id": "F" },
                            { "name": "Declined", "id": "D" }
                        ]
                    }),
                    labelProperty: "name"
                });

                //define the columns:
                var columns = [
                   {
                       field: 'Name',
                       label: this.header_Name,
                       width: '180px'
                   }, {
                       field: 'AccountName',
                       label: this.header_AccountName,
                       width: '180px'
                   }, {
                       field: 'EntityType',
                       label: this.header_Type,
                       width: '60px'
                   }, {
                       field: 'IsPrimary',
                       label: this.header_Primary,
                       width: '40px',
                       editor: CheckBox,
                       editorArgs: {
                           disabled: true
                       }
                   }, {
                       field: 'IsAttendee',
                       label: this.header_Attendee,
                       width: '40px',
                       editor: CheckBox,
                       editorArgs: {
                           disabled: true
                       }
                   }, {
                       field: 'Status',
                       label: this.header_Status,
                       width: '100px',
                       get: function (item) {
                           for (var i = 0; i < attendeeStatusStore.objectStore.data.length; i++) {
                               if (attendeeStatusStore.objectStore.data[i].id == item[this.field]) {
                                   return attendeeStatusStore.objectStore.data[i].name;
                               }
                           }
                       },
                       set: function (item) {
                           for (var i = 0; i < attendeeStatusStore.objectStore.data.length; i++) {
                               if (attendeeStatusStore.objectStore.data[i].name == item[this.field]) {
                                   return attendeeStatusStore.objectStore.data[i].id;
                               }
                           }
                       },
                       editor: Select,
                       editorArgs: {
                           store: attendeeStatusStore
                       },
                       editOn: 'click'
                   }, {
                       field: 'RoleName',
                       label: this.header_RoleName
                   }, {
                       field: 'PhoneNumber',
                       label: this.header_Phone,
                       width: '80px'
                   }, {
                       field: 'Email',
                       name: this.header_Email,
                       width: '150px'
                   }, {
                       field: 'TimeZone',
                       label: this.header_TimeZone,
                       width: '150px'
                   }
                   /*, {
                       field: 'Note',
                       name: this.header_Notes,
                       width: '240px'
                   }    */
                ];
                //set up the rest of the grid options:
                var options = {
                    columns: columns,
                    storeOptions: {
                        service: sDataServiceRegistry.getSDataService('dynamic'),
                        resourceKind: 'historyAttendees',
                        select: ['EntityType', 'EntityId', 'IsPrimary', 'IsAttendee', 'Name', 'Description', 'Notes', 'Status'],
                        newItemParentReferenceProperty: 'History',
                        onComplete: onComplete,
                        where: function () {
                            return "(HistoryId eq '" + utility.getCurrentEntityId() + "' and (SLXUserAssociationId eq null or SLXUserAssociationId eq ''))";
                        },
                        scope: this
                    },
                    slxContext: { 'workspace': '', tabId: '' },
                    sort: [{ attribute: 'Name' }],
                    minRowsPerPage: 40,
                    placeHolder: this._histAttendeesGridPlaceholder,
                    columnHiding: true,
                    columnResizing: true,
                    columnReordering: true,
                    selectionMode: 'single',
                    rowSelection: true,
                    keyboardNavigation: false
                };

                var grid = this._grid = new GridView(options);
                grid.createGridView();

                dojo.connect(this._grid, 'markDirty', function () {
                    var dirtyDataMsg = dojo.byId(this.dirtyDataMsgID);
                    if (dirtyDataMsg) {
                        dojo.style(dojo.byId(this.dirtyDataMsgID), 'display', 'none');
                    }
                    var bindingMgr = Sage.Services.getService('ClientBindingManagerService');
                    if (bindingMgr) {
                        bindingMgr.clearDirtyAjaxItem(this.id);
                    }
                });
            },
            _tabfShow: function () {
                if (this._grid && !this.gridRefreshed) {
                    this._grid.refresh();
                    this.gridRefreshed = true;
                }
            },
            //Handler for when the tab is opened.
            _tabShowdd: function () {
                if (this._grid && !this.gridRefreshed) {

                    //check to see if the activity is a new one or not so we can set the grid
                    // to be in the correct "mode".
                    var gridmode = this._grid.get('mode');
                    var actid = utility.getCurrentEntityId();
                    if ((!actid && gridmode !== 'insert') || (actid && gridmode === 'insert')) {
                        this._grid.set('mode', (!actid) ? 'insert' : '');
                    }
                    this._grid.refresh();
                    this.gridRefreshed = true;
                }
            },
            _tabShow: function () {
                if (this._grid) {
                    //check to see if the activity is a new one or not so we can set the grid
                    // to be in the correct "mode".
                    var gridmode = this._grid.get('mode');
                    var actid = utility.getCurrentEntityId();
                    if ((!actid && gridmode !== 'insert') || (actid && gridmode === 'insert')) {
                        this._grid.set('mode', (!actid) ? 'insert' : '');
                    }
                    this._grid.refresh();
                    this._grid.grid.resize();
                }
            },
            _historySaved: function (history) {
                // TODO: remove direct grid save reference
                this._grid.grid._grid.save();
            },

            /**         
            * When a history item is created directly (notes) from History Editor, get the primary Contact/Lead and add it to HistoryAttendee
            * @param {object} history    
            */
            _addHistoryAttendee: function (history) {
                if (!history.ContactId && !history.LeadId) {
                    return;
                }

                var attendee = null;

                if (history.ContactId) {
                    activityUtility._getContactData(history.ContactId, function (data) {
                        if (data) {
                            attendee = this._setHistoryAttendeeEntityFromContactLead('Contact', data);
                            attendee.History = { '$key': history.$key };
                            this._saveHistoryAttendee(attendee);
                        }
                    }, this);
                } else if (history.LeadId) {
                    activityUtility._getLeadData(history.LeadId, function (data) {
                        if (data) {
                            attendee = this._setHistoryAttendeeEntityFromContactLead('Lead', data);
                            attendee.History = { '$key': history.$key };
                            this._saveHistoryAttendee(attendee);
                        }
                    }, this);

                }
            },
            _saveHistoryAttendee: function (attendee) {
                var req = new Sage.SData.Client.SDataSingleResourceRequest(sDataServiceRegistry.getSDataService('dynamic'))
                            .setResourceKind('historyAttendees')
                            .create(attendee, {
                                success: function () {
                                    //console.log("success");
                                },
                                failure: function () {
                                    console.log('historyAttendee item did not save');
                                },
                                scope: this
                            });
            },
            _setHistoryAttendeeEntityFromContactLead: function (type, results) {
                var attendeeEntity = false;
                if (results && results.$key) {
                    attendeeEntity = {};
                    attendeeEntity.EntityType = type;
                    attendeeEntity.EntityId = results.$key;
                    attendeeEntity.$key = results.$key;
                    attendeeEntity.IsPrimary = true;
                    attendeeEntity.Name = results.$descriptor;
                    attendeeEntity.$descriptor = results.$descriptor;
                    attendeeEntity.Account = null;
                    attendeeEntity.AccountName = results.AccountName || results.Company;
                    if (type == "Lead") {
                        attendeeEntity.Company = results.Company;
                        attendeeEntity.LeadFullName = results.$descriptor;
                    }
                    attendeeEntity.Company = results.Company;
                    attendeeEntity.Email = results.Email;
                    attendeeEntity.Description = "";
                    attendeeEntity.Notes = "";
                    if (results.Address) {
                        attendeeEntity.TimeZone = results.Address.TimeZone;
                    }
                    attendeeEntity.PhoneNumber = results.WorkPhone;
                    attendeeEntity.RoleName = "";
                    attendeeEntity.general = false;

                }
                return attendeeEntity;
            }
        });
        return attendeesTab;
    });

},
'Sage/MainView/ActivityMgr/OccurrenceOrSeriesQueryDlg':function(){
/*globals define, dojo, Simplate */
define([
    'dijit/_Widget',
    'Sage/_Templated',
    'dojo/string',
    'dijit/Dialog',
    'Sage/UI/_DialogLoadingMixin',
    'dojo/_base/lang',
    'Sage/Data/SingleEntrySDataStore',
    'Sage/Data/SDataServiceRegistry',
    'Sage/MainView/BindingsManager',
    'Sage/Utility',
    'Sage/Utility/Activity',
    'Sage/UI/Dialogs',
    'dijit/form/RadioButton',
    'dojo/_base/declare',
    'dojo/i18n!./nls/OccurrenceOrSeriesQueryDlg'
],
function (_Widget,
    _Templated,
    dString,
    Dialog,
    _DialogLoadingMixin,
    dojoLang,
    SingleEntrySDataStore,
    sDataServiceRegistry,
    BindingsManager,
    utility,
    activityUtil,
    sageDialogs,
    RadioButton,
    declare,
    occurenceDlgStrings) {
    var qryDlg = declare('Sage.MainView.ActivityMgr.OccurrenceOrSeriesQueryDlg', [_Widget, _Templated], {
        activityId: '',
        activityMemberId: '',
        activity: false,
        store: false,
        mode: 'edit',
        widgetsInTemplate: true,
        disableSeriesOption: '',
        widgetTemplate: new Simplate([
            '<div>',
                '<div dojoType="dijit.Dialog" title="" dojoAttachPoint="_dialog" dojoAttachEvent="onHide:_onDlgHide">',
                    '<div class="recur-activity-dialog">',
                        '<div dojoType="dojox.layout.TableContainer" orientation="horiz" cols="1" labelWidth="160" >',
                            '<div dojoType="dijit.layout.ContentPane" label="{%= $.actDateText %}" dojoAttachPoint="container_actDate"></div>',
                            '<div dojoType="dijit.layout.ContentPane" label="{%= $.accountText %}" dojoAttachPoint="container_account"></div>',
                            '<div dojoType="dijit.layout.ContentPane" label="{%= $.contactText %}" dojoAttachPoint="container_contact"></div>',
                            '<div dojoType="dijit.layout.ContentPane" label="{%= $.opportunityText %}" dojoAttachPoint="container_opportunity"></div>',
                        '</div>',  //tableContainer
                        '<div class="dijitContentPane">&nbsp;</div>', //whitespace
                        '<div class="dijitContentPane">',
                            '<input type="radio" dojoType="dijit.form.RadioButton" name="editType" id="{%= $.id %}_thisOccurrence" checked="true" dojoAttachPoint="_thisOccurRadio" />&nbsp;',
                            '<label for="{%= $.id %}_thisOccurrence">{%= ($.mode === "edit") ? $.editOneText : (($.mode === "delete")? $.deleteOneText : $.completeOneText) %}</label>',
                        '</div><div class="dijitContentPane">',
                            '<input type="radio" dojoType="dijit.form.RadioButton" name="editType" id="{%= $.id %}_Series" dojoAttachPoint="_seriesRadio" {%=$.disableSeriesOption%} />&nbsp;',
                            '<label for="{%= $.id %}_Series">{%= ($.mode === "edit") ? $.editAllText : (($.mode === "delete")? $.deleteAllText : $.completeAllText) %}</label>',
                        '</div>',
                        '<div class="general-dialog-actions">', //buttons
                            '<div dojoType="dijit.form.Button" id="{%= $.id %}_btnContinue" name="_btnContinue" dojoAttachPoint="_btnContinue" dojoAttachEvent="onClick:_continueClick" >{%= $.continueText %}</div>',
                        '</div>', //buttons
                    '</div>', //form
                '</div>', //dialog
            '</div>' //root
        ]),
        constructor: function () {
            dojoLang.mixin(this, occurenceDlgStrings);

        },
        show: function () {
           
            this._dialog.show();
            if (!this._dialog._standby) {
                dojoLang.mixin(this._dialog, new _DialogLoadingMixin());
                if (!this.activity) {
                    this._dialog.showLoading();
                }
            }
            this._thisOccurRadio.set('checked', true);
        },
        _setModeAttr: function (mode) {
            this.mode = mode;
        },
        _getModeAttr: function () {
            return this.mode;
        },
        hide: function () {
            this._dialog.hide();
        },
        _onDlgHide: function () {
            this.activity = false;
            this.activityId = '';
        },
        _setActivityIdAttr: function (activityId) {
            this.activityId = activityId;
            if (this.activityId && this.activityId !== '') {
                this._loadData();
            }
        },
        _getActivityIdAttr: function () {
            return this.activityId;
        },
        _setActivityMemebrIdAttr: function (memberId) {
            this.activityMemberId = memberId;
        },
        _getActivityMemberIdAttr: function () {
            return this.activityMemberId;
        },
        _loadData: function () {
            if (this._dialog._standby) {
                this._dialog.showLoading();
            }
            var select = ['Description', 'AccountName', 'ContactName', 'OpportunityName', 'StartDate', 'Type', 'Timeless', 'Recurring', 'RecurrenceState'];
           
            if (!this.store) {
                this.store = new SingleEntrySDataStore({
                    include: [],
                    select: select, // ['Description', 'AccountName', 'ContactName', 'OpportunityName', 'StartDate', 'Type', 'Timeless', 'Recurring', 'RecurrenceState'],
                    resourceKind: 'activities',
                    service: sDataServiceRegistry.getSDataService('system')
                });
            }
            if (this.activityId !== '') {
                this.store.fetch({
                    predicate: '"' + this.activityId + '"',
                    onComplete: this._receiveActivity,
                    onError: this._failLoad,
                    scope: this
                });
            }
        
        },
        _receiveActivity: function (activity) {
            //debugger;
            if (this._dialog._standby) {
                this._dialog.hideLoading();
            }
            this.activity = activity;
            this._bind();
        },
        _receiveActivities: function (data) {
            //debugger;
            if (this._dialog._standby) {
                this._dialog.hideLoading();
            }
            var activities = data['$resources'];
            if (activities.length < 1) {
                this._failLoad();
            }
            this.activity = activities[0];
            this.activityId = this.activity['$key']; //reset this because the original one may not have had the occurrence half
            this._bind();
        },

        _bind: function () {
            var act = this.activity;
            var d = act.Description;
            if (!d) {
                d = '';
            }
            if (d.length > 30) {
                d = d.substring(0, 26) + '...';
            }
            this._dialog.set('title', dString.substitute(this.titleFmt, { type: activityUtil.getActivityTypeName(act.Type), description: d }));

            this.container_actDate.set('content', activityUtil.formatActivityStartDate(utility.Convert.toDateFromString(act.StartDate, act.Timeless)));
            this.container_account.set('content', act.AccountName || '&nbsp;');
            this.container_contact.set('content', act.ContactName || '&nbsp;');
            this.container_opportunity.set('content', act.OpportunityName || '&nbsp;');
        },
        _failLoad: function () {
            if (this._dialog._standby) {
                this._dialog.hideLoading();
            }
            sageDialogs.showWarning(this.failedToLoadMsg);
            this._dialog.hide();
        },
        _continueClick: function (e) {
            this.hide();
            if (this._thisOccurRadio.get('checked')) {
                if (this.activityId.length <= 12) {
                    var timeValue = (utility.Convert.toDateFromString(this.activity.StartDate).getTime() / 1000) + 62135596800;
                    this.activityId = this.activityId + ";" + timeValue;
                }
                this.onSelectOccurrence(this.activityId, utility.Convert.toDateFromString(this.activity.StartDate), this.activityMemberId);
            } else {
                this.onSelectSeries(this.activityId, this.activityMemberId);
            }
        },
        onSelectSeries: function (id) { },
        onSelectOccurrence: function (id, startDate) { }
    });
    return qryDlg;
});
},
'Sage/Services/EntityService':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */

define([
        'Sage/UI/Dialogs',
        'Sage/MainView/EntityMgr/EditEntityOptionsDlg',
        'Sage/Data/SingleEntrySDataStore',
        'Sage/Data/SDataServiceRegistry',
        'dojo/string',
        'Sage/Utility',
        //'dojo/i18n!./nls/ActivityService',
        'dojo/_base/declare',
        'dojo/topic',
        'dojo/_base/lang'
],

function (
    Dialogs,
    EditEntityOptionsDlg,
    SingleEntrySDataStore,
    sDataServiceRegistry,
    dString,
    sageUtility,
    //nlsActivityService,
    declare,
    topic,
    lang
) {

    var entityService = declare('Sage.Services.EntityService', null, {

        _entityDetailsDialog: false,
        constructor: function () {
            //dojo.mixin(this, nlsActivityService);
        },
        editEntityOptions: function (entityId, isRecurring) {
            this.editEntityValues(entityId, isRecurring);
        },
        editEntityValues: function (id, isRecurring) {
            var roleSecurityService = Sage.Services.getService('RoleSecurityService');
            if (roleSecurityService && roleSecurityService.hasAccess('Administration/EntityManager/Entities/Edit')) {
                if (!this._entityDetailsDialog) {
                    this._entityDetailsDialog = new EditEntityOptionsDlg();
                }
                this._entityDetailsDialog.set('entityId', id);
                this._entityDetailsDialog.show();
            }
        },
        getSelectedId: function () {
            var selectionInfo = this.getSelectionInfo();
            var id = "";
            if (selectionInfo) {
                if (selectionInfo.hasCompositeKey) {
                    var entity = selectionInfo.selections[0].entity;
                    return entity["Entity"]["$key"];
                }
                if (selectionInfo.selections.length == 1) {
                    id = selectionInfo.selections[0].id;
                } else {
                    id = selectionInfo.selections[0].id;
                }
            }
            return id;
        },
        getSelectedItem: function () {
            var selectionInfo = this.getSelectionInfo();
            var selectedItem = { id: false, hasCompositeKey: false, entity: false };
            if (selectionInfo) {
                selectedItem.hasCompositeKey = selectionInfo.hasCompositeKey;
                selectedItem.entity = selectionInfo.entity;
                if (selectionInfo.selections.length == 1) {
                    selectedItem.id = selectionInfo.selections[0].id;
                    selectedItem.entity = selectionInfo.selections[0].entity;
                } else {
                    selectedItem.id = selectionInfo.selections[0].id;
                    selectedItem.entity = selectionInfo.selections[0].entity;
                }
            }
            return selectedItem;
        },
        getSelections: function () {
            var selectionInfo = this.getSelectionInfo();
            var selections = null;
            if (selectionInfo) {
                selections = selectionInfo.selections;
            }
            return selections;
        },
        prepareSelections: function () {
            return this.getSelectionInfo();
        },
        getSelectionInfo: function () {
            var selectionInfo = false;
            try {
                var panel = dijit.byId('list');
                if (panel) {
                    selectionInfo = panel.getSelectionInfo(true);
                }
            }
            catch (e) {
                Dialogs.alert(this.txtErrorActionMsg || "error getting selectionInfo");
            }
            return selectionInfo;
        },
        getTotalSelectionCount: function () {
            var count = 0;
            try {
                var panel = dijit.byId('list');
                if (panel) {
                    count = panel.getTotalSelectionCount();
                }
            }
            catch (e) {
            }
            return count;
        },
        verifySelection: function (selectionInfo) {
            if (selectionInfo !== null) {
                return (selectionInfo.selectionCount !== 0);
            }
            return false;
        },
        verifySingleSelection: function (selectionInfo) {
            if (selectionInfo !== null) {
                return (selectionInfo.selectionCount === 1);
            }
            return false;
        },
        setSelectionCount: function () {
            try {
                var panel = dijit.byId('list');
                if (panel) {
                    $("#selectionCount").text(panel.getTotalSelectionCount());
                }
            }
            catch (e) {
            }
        },
        refreshList: function (tabId) {
            try {
                var panel = dijit.byId('list');
                if (panel) {
                    var grpContextSvc = Sage.Services.getService('ClientGroupContext');
                    if (grpContextSvc) {
                        var ctx = grpContextSvc.getContext();
                        if (tabId === ctx.CurrentGroupID) {
                            panel.refreshView(tabId);
                        }
                    }
                }
            }
            catch (e) {
            }
        }

    }); // end dojo declare

    /**
    * Make an instance of this service available to the 
    * Sage.Services.getService method.
    */
    if (!Sage.Services.hasService('EntityService')) {
        Sage.Services.addService('EntityService', new entityService());
    }
    return entityService;
});


},
'Sage/MainView/EntityMgr/EditEntityOptionsDlg':function(){
/*globals define, dojo, Simplate */
define([
    'dijit/_Widget',
    'Sage/_Templated',
    'dojo/string',
    'dijit/Dialog',
    'Sage/UI/_DialogLoadingMixin',
    'dojo/_base/lang',
    'Sage/Data/SingleEntrySDataStore',
    'Sage/Data/SDataServiceRegistry',
    'Sage/MainView/BindingsManager',
    'Sage/Utility',
    'Sage/UI/Dialogs',
    'dijit/form/RadioButton',
    'dojo/_base/declare',
    'dojo/i18n!./nls/_BaseEntityDetailContent',
    'dojo/text!./templates/EditEntityOptionsDlg.html',
    'dojo/store/Memory',
    'dojo/dom-construct',
    'Sage/UI/FilteringSelect',
    'Sage/Data/SDataServiceRegistry',
    'dojo/_base/lang',
    'Sage/UI/Controls/_DialogHelpIconMixin',
    'dijit/registry'
],
function (_Widget,
    _Templated,
    dString,
    Dialog,
    _DialogLoadingMixin,
    dojoLang,
    SingleEntrySDataStore,
    sDataServiceRegistry,
    BindingsManager,
    utility,
    sageDialogs,
    RadioButton,
    declare,
    _nlsResource,
    template,
    Memory,
    domConstruct,
    crmDropDowns,
    SDataServiceRegistry,
    lang,
    _DialogHelpIconMixin,
    registry) {
    var widgetTemplate = utility.makeTemplateFromString(template);
    var qryDlg = declare('Sage.MainView.EntityMgr.EditEntityOptionsDlg', [_Widget, _Templated], {
        entityName: '',
        mode: 'edit',
        widgetsInTemplate: true,
        typeDropDowns: false,
        propertiesDP: false,
        entityStore: false,
        propertyStore: false,
        widgetTemplate: widgetTemplate,
        nlsResource: _nlsResource,

        constructor: function () {
        },
        postCreate: function () {
            
            this.lblName.innerHTML = this.nlsResource.propertyName;
            this.lblDisplayName.innerHTML = this.nlsResource.lblDisplayName;
            this.lblPluralName.innerHTML = this.nlsResource.lblPluralName;
            this.lblTitle.innerHTML = this.nlsResource.lblTitle;
            this.lblExtension.innerHTML = this.nlsResource.IsExtension;
            this.lblAdvancedOptions.innerHTML = this.nlsResource.AdvOptions;
            this.lblPluralName.innerHTML = this.nlsResource.lblPluralName;
            this.lblImport.innerHTML = this.nlsResource.lblImport;
            this.lblMatch.innerHTML = this.nlsResource.lblMatch;
            this.lblBulkUpdate.innerHTML = this.nlsResource.lblBulkUpdate;
            this.lblAudited.innerHTML = this.nlsResource.lblAudited;
            this.lblCanPut.innerHTML = this.nlsResource.lblPut;
            this.lblCanPost.innerHTML = this.nlsResource.lblPost;
            this.lblCanDelete.innerHTML = this.nlsResource.lblDelete;
            this.lblHistory.innerHTML = this.nlsResource.lblHistory;

            dojo.mixin(this._dialog, new _DialogLoadingMixin());

            // help icon
            lang.mixin(this._dialog, new _DialogHelpIconMixin());
            this._dialog.createHelpIconByTopic('EditEntity');

            this.entityStore = new Memory();
            this.propertyStore = new Memory();

            this.typeDropDowns = new crmDropDowns({
                name: 'value',
                value: 0,
                store: this.entityStore,
                searchAttr: 'name'
            });
            domConstruct.place(this.typeDropDowns.domNode, this.entityDP, 'only');

            this.propetiesDP = new crmDropDowns({
                name: 'value',
                value: 0,
                store: this.propertyStore,
                searchAttr: 'name',
                required: false
            });
            domConstruct.place(this.propetiesDP.domNode, this.viewTitle, 'only');

            var context = this;
            //Events
            this.IsExtension.on("change", function (isChecked) {
                if (isChecked) {
                    context.typeDropDowns.set('disabled', false);
                }
                else {
                    context.typeDropDowns.set('value', '');
                    context.typeDropDowns.set('disabled', true);
                }
            }, true);


        },
        _okClick: function () {
            this._dialog.showLoading();
            var context = this;
            this.entity.displayName = context.DisplayName.textbox.value;
            this.entity.displayNamePlural = context.PluralName.textbox.value;
            if (this.IsExtension.get("value") === false)
                this.entity.isExtension = false;
            else {
                this.entity.isExtension = true;
                this.entity.extendedEntity = {
                    "$key": context.typeDropDowns.value
                };
                this.entity.extendedEntityPropertyName = context.typeDropDowns.value;
            }

            //Flags
            this.entity.audited = (this.Audited.get("value") === false) ? false : true;
            this.entity.bulkAction.canBulkUpdate = (this.BulkUpdate.get("value") === false) ? false : true;
            this.entity['import'].canMatch = (this.CanMatch.get("value") === false) ? false : true;
            this.entity['import'].canImport = (this.CanImport.get("value") === false) ? false : true;
            this.entity.sdata.canPost = (this.CanPost.get("value") === false) ? false : true;
            this.entity.sdata.canPut = (this.CanPut.get("value") === false) ? false : true;
            this.entity.sdata.canDelete = (this.CanDelete.get("value") === false) ? false : true;

            //Title
            this.entity.StringExpression = '${'+context.propetiesDP.value+'}';

            var request = new Sage.SData.Client.SDataSingleResourceRequest(Sage.Data.SDataServiceRegistry.getSDataService('metadata'));
            request.setResourceKind('entities(' + "'" + this.entityName + "'" + ')');
            request['update'](this.entity, {
                isSecurityManager: true,
                scope: context,
                ignoreETag: false,
                success: function () {
                    context._dialog.hideLoading();
                    this.hide();
                },
                failure: function (xhr, sdata) {
                    context._dialog.hideLoading();
                    this.hide();
                }
            });

        },
        _cancelClick: function () {
            this.hide();
        },
        destroy: function () {
            this.inherited(arguments);
        },
        show: function () {
            this._dialog.show();
            if (!this._dialog._standby) {
                dojoLang.mixin(this._dialog, new _DialogLoadingMixin());
            }
        },
        _setModeAttr: function (mode) {
            this.mode = mode;
        },
        _getModeAttr: function () {
            return this.mode;
        },
        hide: function () {
            this._dialog.hide();
        },
        _onDlgHide: function () {
            this.entityName = '';
        },
        _setEntityIdAttr: function (entityName) {
            this.entityName = entityName;
            if (this.entityName && this.entityName !== '') {
                this._loadData();
            }
        },
        _getEntityIdAttr: function () {
            return this.entityName;
        },
        _loadData: function () {
            this._dialog.showLoading();
            this._dialog.set('title', this.entityName);
            var context = this;

            //IsExtenison
            if (context.entityStore.data.length === 0) {
                var request = new Sage.SData.Client.SDataResourceCollectionRequest(SDataServiceRegistry.getSDataService('metadata'))
                            .setResourceKind('entities')
                            .setQueryArg('select', 'id,displayName,name')
                            .setQueryArg('Count', '500')
                            .setQueryArg('orderBy', 'name')
                            .setQueryArg('format', 'json');

                request.read({
                    success: function (data) {
                        var entites = data.$resources;
                        for (var i = 0; i <= entites.length - 1; i++) {
                            var entityDisplayName = entites[i].displayName ? entites[i].displayName : entites[i].name;
                            if (entityDisplayName) {
                                context.entityStore.add({
                                    id: entites[i].name,
                                    name: entityDisplayName
                                });
                            }
                        }
                    },
                    failure: function (error) {
                        if (error) {
                            console.error(error);
                        }
                    }
                });
            }

            // populate values for UI
            var entityReq = new Sage.SData.Client.SDataResourceCollectionRequest(SDataServiceRegistry.getSDataService('metadata'));
            entityReq.setResourceKind('entities(' + "'" + this.entityName + "'" + ')');
            entityReq.setQueryArg('include', 'sdata,bulkAction,import');

            entityReq.read({
                success: function (data) {
                    if (typeof (data) !== 'undefined' && typeof (data.$resources) !== 'undefined' && data.$resources.length == 1) {
                        context.entity = data.$resources[0];
                        var entity = data.$resources[0];

                        context.Name.textbox.value = entity.name;
                        context.DisplayName.textbox.value = entity.displayName;
                        context.PluralName.textbox.value = entity.displayNamePlural;
                        context.Audited.set("value", entity.audited); 
                        context.BulkUpdate.set("value", entity.bulkAction.canBulkUpdate);
                        context.CanMatch.set("value", entity['import'].canMatch);
                        context.CanImport.set("value", entity['import'].canImport);
                        context.CanPost.set("value", entity.sdata.canPost);
                        context.CanPut.set("value", entity.sdata.canPut);
                        context.CanDelete.set("value", entity.sdata.canDelete);
                        context.History.textbox.value = entity.historyEntityName;

                        //Populate IsExtension
                        context.IsExtension.set("value", entity.isExtension);
                        if (entity.isExtension) {
                            context.typeDropDowns.set('disabled', false);
                            var objItem = context.entityStore.get(entity.extendedEntity.$key);
                            context.typeDropDowns.set("item", objItem);
                        }
                        else {
                            context.typeDropDowns.set('value', '');
                            context.typeDropDowns.set('disabled', true);
                        }

                        //View Title dropdown values
                        var entites = entity.properties.$resources;
                        var count = context.propertyStore.data.length;
                        for (var i = 0; i < count; i++) {
                            context.propertyStore.remove(context.propertyStore.data[0].id);
                        }

                        for (i = 0; i <= entites.length - 1; i++) {
                            //View Title - only of type string, calc string
                            if (entites[i].dataTypeId == 'f750817f-73ad-4bf3-b2de-bd0f5cc47dfd' || entites[i].dataTypeId == 'ccc0f01d-7ba5-408e-8526-a3f942354b3a') {
                                var displayName = entites[i].displayName ? entites[i].displayName : entites[i].propertyName;
                                if (displayName) {
                                    context.propertyStore.add({
                                        id: entites[i].propertyName,
                                        name: displayName
                                    });
                                }
                            }
                        }

                        //Populate String Expression (Title)
                        if (entity.stringExpression) {
                            var expr = entity.stringExpression;
                            if (expr.substring(0, 2) === "${") {
                                expr = expr.substring(2, expr.length - 1);
                            }
                            var item = context.propertyStore.get(expr);
                            context.propetiesDP.set("item", item);
                        } else {
                            context.propetiesDP.set("item", null);
                        }

                    }
                    context._dialog.hideLoading();
                },
                failure: function (error) {
                    context._dialog.hideLoading();
                    if (error) {
                            console.error(error);
                        }
                }
            });


        }
    });
    return qryDlg;
});
},
'Sage/UI/FilteringSelect':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
        'dijit/form/FilteringSelect',
        'dojo/_base/declare'
], function(FilteringSelect, declare) {
    return declare('Sage.UI.FilteringSelect', FilteringSelect, {
        valueAttr: false,
        _getValueField: function(){
            // Overrides dijit.form.FilteringSelect._getValueField()
            return this.valueAttr || "value";
        }
    });
});
},
'Sage/MainView/EntityMgr/EntityWizard/EntityWizardController':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/_base/declare',
    'dojo/string',
    'dojo/_base/array',
    'Sage/MainView/EntityMgr/EntityWizard/_EntityWizardDialogBase',
    'Sage/MainView/EntityMgr/EntityWizard/EntityWizardUtility',
    'Sage/MainView/EntityMgr/EntityWizard/SelectEntityType',
    'Sage/MainView/EntityMgr/EntityWizard/EntityDetails',
    'Sage/MainView/EntityMgr/EntityWizard/Relationship',
    'Sage/MainView/EntityMgr/EntityWizard/EntityProperties',
    'Sage/MainView/EntityMgr/EntityWizard/AddEditEntity',
    'Sage/MainView/EntityMgr/EntityWizard/Status',
    'dojo/topic'
],
function (
    declare,
    dojoString,
    dojoArray,
    wizardDialogBase,
    entityWizardUtility,
    selectEntityType,
    entityDetails,
    Relationship,
    entityProperties,
    addEditEntity,
    status,
    topic
) {
    var entityWizard = declare('Sage.MainView.EntityMgr.EntityWizard.EntityWizardController', [wizardDialogBase], {
        wizardOptions: null,
        constructor: function (entity, entityType) {
            this.wizardOptions = this.wizardOptions ? this.wizardOptions : this._getDefaultWizardOptions();
            this.subscriptions.push(topic.subscribe("/entityController/entityWizard/nextStep", dojo.hitch(this, function (currentStep) { this._nextStep(currentStep); })));
            this.subscriptions.push(topic.subscribe("/entityController/entityWizard/previousStep", dojo.hitch(this, function (currentStep) { this._previousStep(currentStep); })));
            this.subscriptions.push(topic.subscribe("/entityController/entityWizard/cancel", dojo.hitch(this, function () { this._cancel(); })));
        },
        startWizard: function () {
            this._goToStep(entityWizardUtility.entityWizardStep.EntityDetails, null);
            if (!this.entityDetails.ownerId) {
                entityWizardUtility.getOwnerEntityInfo(this);
            }
        },
        //----------------------------------------
        //Subscription listeners
        //----------------------------------------
        _nextStep: function (currentStep) {
            var nextStep = this._getNextStep(currentStep);
            this._goToStep(nextStep);
        },
        _previousStep: function (currentStep) {
            var previousStep = this._getPreviousStep(currentStep);
            this._goToStep(previousStep);
        },
        _cancel: function () {
            //Give some time for dialogs to finish hide animation before initiating destroy process.
            //See http://mail.dojotoolkit.org/pipermail/dojo-interest/2010-February/043090.html
            setTimeout(dojo.hitch(this, function () { this._destroyObjects(); }), dijit.defaultDuration + 100);
        },
        _getDefaultWizardOptions: function () {
            return {
                hiddenSteps: [entityWizardUtility.entityWizardStep.AddActions]
            };
        },
        //----------------------------------------
        //Wizard workflow
        //----------------------------------------
        _isStepVisible: function (step) {
            var visible = true;
            //If we have a custom list of hidden steps, check whether this step is hidden
            if (this.wizardOptions && this.wizardOptions.hiddenSteps) {
                dojoArray.some(this.wizardOptions.hiddenSteps, function (hiddenStep, i) {
                    if (step === hiddenStep) {
                        visible = false;
                        return true; //this is to break dojo.some
                    }
                });
            }
            if (!visible) {
                //We don't need to keep on processing
                return false;
            }
            return true;
        },
        _getNextStep: function (currentStep) {
            for (var step in entityWizardUtility.entityWizardStep) {
                var stepValue = entityWizardUtility.entityWizardStep[step];
                if (stepValue > currentStep && this._isStepVisible(stepValue)) {
                    return stepValue;
                }
            }
            return null;
        },
        _getPreviousStep: function (currentStep) {
            var stepsInReverseOrder = [];
            for (var step in entityWizardUtility.entityWizardStep) {
                stepsInReverseOrder.unshift(entityWizardUtility.entityWizardStep[step]);
            }
            var previousStep = null;
            dojoArray.some(stepsInReverseOrder, dojo.hitch(this, function (stepValue) {
                if (stepValue < currentStep && this._isStepVisible(stepValue)) {
                    previousStep = stepValue;
                    return true;
                }
            }));
            return previousStep;
        },
        _goToStep: function (step) {
            var nextStep = this._getNextStep(step);
            var isLastStep = (nextStep === null || nextStep === entityWizardUtility.entityWizardStep.EntityProperties);
            var previousStep = this._getPreviousStep(step);
            var isFirstStep = (previousStep === null || previousStep === entityWizardUtility.entityWizardStep.SelectEntityType);
            var options = { isLastStep: isLastStep, isFirstStep: isFirstStep, currentStep: null };
            var dialog;
            switch (step) {
                case entityWizardUtility.entityWizardStep.SelectEntityType:
                    dialog = dijit.byId("dlgSelectEntityType");
                    if (!dialog) {
                        options.currentStep = entityWizardUtility.entityWizardStep.SelectEntityType;
                        dialog = new selectEntityType(options);//new selectFile(options);
                        dialog.startup();
                    }
                    dialog.show();
                    break;
                case entityWizardUtility.entityWizardStep.EntityDetails:
                    dialog = dijit.byId("dlgEntityDetails");
                    if (!dialog) {
                        options.currentStep = entityWizardUtility.entityWizardStep.EntityDetails;
                        dialog = new entityDetails(options);
                    }
                    dialog.show();
                    break;
                case entityWizardUtility.entityWizardStep.Relationship:
                    dialog = dijit.byId("dlgRelationship");
                    if (!dialog) {
                        options.currentStep = entityWizardUtility.entityWizardStep.Relationship;
                        dialog = new Relationship(options);//new selectFile(options);
                        dialog.startup();
                    }
                    dialog.show();
                    break;
                case entityWizardUtility.entityWizardStep.EntityProperties:
                    dialog = dijit.byId("dlgEntityProperties");
                    if (!dialog) {
                        options.currentStep = entityWizardUtility.entityWizardStep.EntityProperties;
                        dialog = new entityProperties(options);
                        dialog.startup();
                    }
                    dialog.show();
                    break;
                case entityWizardUtility.entityWizardStep.AddEditEntity:
                    dialog = dijit.byId("dlgAddEditEntity");
                    if (!dialog) {
                        options.currentStep = entityWizardUtility.entityWizardStep.AddEditEntity;
                        dialog = new addEditEntity(options);
                        dialog.startup();
                    }
                    dialog.show();
                    break;
                case entityWizardUtility.entityWizardStep.Status:
                    dialog = dijit.byId("dlgStatus");
                    if (!dialog) {
                        options.currentStep = entityWizardUtility.entityWizardStep.Status;
                        dialog = new status(options);
                        dialog.startup();
                    }
                    dialog.show();
                    break;
            }
        }
    });
    return entityWizard;
});
},
'Sage/MainView/EntityMgr/EntityWizard/_EntityWizardDialogBase':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/_base/declare',
    'dojo/_base/array',
    'dojo/topic',
    'dojo/_base/lang',
    'dojo/store/Memory',
    'dijit/_Widget',
    'Sage/_Templated',
    "dojo/store/Observable",
    "dojo/store/Memory",
    'Sage/MainView/EntityMgr/EntityWizard/EntityWizardUtility',
    'Sage/MainView/EntityMgr/EntityDetailUtility',
    'dojo/i18n!./nls/_EntityWizardDialog',
    'Sage/UI/_DialogLoadingMixin',
    'dojo/_base/lang',
    'Sage/UI/Controls/_DialogHelpIconMixin'
],
function (
    declare,
    dojoArray,
    topic,
    dojoLang,
    memory,
    widget,
    templated,
    Observable,
    Memory,
    entityWizardUtility,
    entityDetailUtility,
    nlsResources,
    _DialogLoadingMixin,
    lang,
    dialogHelpIconMixin
) {
    var wizardDialogBase = declare('Sage.MainView.EntityMgr.EntityWizard._EntityWizardDialogBase', [widget, templated], {
        _dialog: null,
        _currentStep: null,
        _isFirstStep: false,
        _isLastStep: false,
        _helpIconTopic: "EntityWizard",
        widgetsInTemplate: true,
        subscriptions: [],
        _dialogIds: ["dlgSelectEntityType", "dlgEntityDetails", "dlgRelationship", "dlgEntityProperties", "dlgAddEditEntity", "dlgStatus"],
        entityDetails: {},
        _nlsResources: nlsResources,

        constructor: function () {
            this.subscriptions = [];

        },
        show: function () {
            this._dialog.show();
            if (this._helpIconTopic) {
                if (!this._dialog.helpIcon) {
                    dojoLang.mixin(this._dialog, new dialogHelpIconMixin());
                    this._dialog.createHelpIconByTopic(this._helpIconTopic);
                    this._dialog.helpIcon.tabIndex = "-1";
                }
            }
        },
        /**
        * This is a last method in the initialization process. 
        * It is called after all the child widgets are rendered so it's good for a container widget to finish it's post rendering here. 
        * This is where the container widgets could for example set sizes of their children relative to it's own size.
        */
        startup: function () {
            this.inherited(arguments);
            lang.mixin(this._dialog, new _DialogLoadingMixin());

        },
        /**
        * Default implementation of isValid function. Do not remove, required by classes that inherit from _WizardDialogBase.
        */
        isValid: function () {
            return true;
        },
        //------------------------------------------------
        //Events.
        //------------------------------------------------
        /**
        * Triggered when the user clicks on the "x" button to close the dialog.
        */
        _dialog_OnCancel: function () {
            this._btnCancel_OnClick();
        },
        _btnBack_OnClick: function () {
            this._checkCurrentStep();
            this._dialog.hide();
            topic.publish("/entityController/entityWizard/previousStep", this._currentStep);
        },
        _btnNext_OnClick: function () {
            //Do not remove validation below. Required for triggering validation of the current wizard dialog page.
            if (this.isValid()) {
                this._checkCurrentStep();
                this._dialog.hide();
                topic.publish("/entityController/entityWizard/nextStep", this._currentStep);
            }
        },
        _btnCancel_OnClick: function () {
            this._checkCurrentStep();
            this._dialog.hide();
            topic.publish("/entityController/entityWizard/cancel", null);
        },
        _checkCurrentStep: function () {
            if (this._currentStep === null) {
                console.error("_currentStep has not been defined");
            }
        },
        finishWizard: function () {
            this._destroyObjects();
        },
        _destroyObjects: function () {
            //Destroy hidden dialogs
            dojoArray.forEach(this._dialogIds, function (dialogId) {
                var dialog = dijit.byId(dialogId);
                if (dialog) {
                    dialog.destroyRecursive();
                }
            });
            //Remove suscriptions
            dojoArray.forEach(this.subscriptions, function (handle) {
                handle.remove();
            });
        }
    });
    return wizardDialogBase;
});
},
'Sage/MainView/EntityMgr/EntityWizard/EntityWizardUtility':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/_base/xhr',
    'dojo/string',
    'dojo/date/locale',
    'dojo/dom-class',
    'dojo/_base/lang',
    'Sage/Data/SDataServiceRegistry',
    'Sage/Utility'
],
function (
    dojoXhr,
    dString,
    locale,
    domClass,
    lang,
    SDataServiceRegistry,
    utility
) {
    Sage.namespace('Sage.MainView.EntityMgr.EntityWizard.EntityWizardUtility');
    lang.mixin(Sage.MainView.EntityMgr.EntityWizard.EntityWizardUtility, {
        entityWizardStep: {
            SelectEntityType: 0,
            EntityDetails: 1,
            Relationship:2,
            EntityProperties: 3,
            AddEditEntity: 4,
            Status:5
        },
        getCurrentEntityContext: function () {
            if (Sage.Services.hasService("ClientEntityContext")) {
                var clientEntityContextSvc = Sage.Services.getService("ClientEntityContext");
                if (clientEntityContextSvc) {
                    return clientEntityContextSvc.getContext();
                }
            }
            return null;
        },
        /**
        * Shows/Hides a dom node.
        * @param {Object} domNode - The DOM node to be shown/hidden.
        * @param {Boolean} visible - Whether the object is visible or not.
        */
        setDomNodeVisible: function (domNode, visible) {
            if (domNode && visible) {
                domClass.remove(domNode, "display-none");
            }
            else if (domNode) {
                domClass.add(domNode, "display-none");
            }
        },
        formatDate: function (value) {
            if (utility.Convert.isDateString(value)) {
                var date = utility.Convert.toDateFromString(value);
                return locale.format(date, { selector: 'date', fullYear: true, locale: Sys.CultureInfo.CurrentCulture.name });
            }
            return "";
        },
        getOwnerEntityInfo: function (thisObj) {
            var context = thisObj;
            var propRequest = new Sage.SData.Client.SDataResourceCollectionRequest(SDataServiceRegistry.getSDataService('metadata'))
                        .setQueryArg('where', "isKey eq true")
                            .setResourceKind('entities(' + "'Owner'" + ')/properties')
                            .setQueryArg('select', 'id,propertyName')
                            .setQueryArg('count', 1)
                        .setQueryArg('format', 'json');


            propRequest.read({
                async: true,
                success: function (data) {
                    var props = data.$resources;
                    context.entityDetails.ownerId = props[0].id;
                },
                failure: function (error) {
                    if (error) {
                        console.error(error);
                    }
                }
            });
        }
    });
    return Sage.MainView.EntityMgr.EntityWizard.EntityWizardUtility;
});
},
'Sage/MainView/EntityMgr/EntityDetailUtility':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/_base/declare',
    'dojo/store/Memory',
    'dojo/string',
    'dojo/query',
    'dojo/_base/array',
    'dojo/_base/connect',
    'dojo/i18n!./nls/_BaseEntityDetailContent',

    // Details section, dependent on filter type selected
    'Sage/MainView/EntityMgr/AddEditEntityDetail/DistinctDetailsView',
    'Sage/MainView/EntityMgr/AddEditEntityDetail/RangeDetailsView',
    'Sage/MainView/EntityMgr/AddEditEntityDetail/AMDDetailsView',
    'Sage/MainView/EntityMgr/AddEditEntityDetail/ADDMDDetailsView',
    'Sage/MainView/EntityMgr/AddEditEntityDetail/UserLookupDetailsView',
    'dojo/dom-class',
    'Sage/Utility',
    'Sage/Utility/Filters',
    'Sage/UI/Controls/PropertyStore',
    'Sage/UI/Controls/TextBox',
    'Sage/Utility/GeneralSchemaReader',
    'dojo/request/xhr'
],
function (
    declare,
    Memory,
    dString,
    query,
    arrayUtil,
    connect,
    nlsResource,
    // Details section, dependent on filter type selected
    distinctDetailsView,
    rangeDetailsView,
    AMDDetailsView,
    AddMDDetailsView,
    UserLookupDetailsView,
    domClass,
    SageUtility,
    filterUtility,
    PropertyStore,
    TextBox,
    GeneralSchemaReader,
    dojoRequest
) {
    var widget = declare('Sage.MainView.EntityMgr.EntityDetailUtility', null, {
        //filter and metric types list
        filterTypeDataLoad: false,
        //aggregation List
        aggregation: false,
        //user lookup operation
        operation: false,
        // properties of entity associated with the filter
        propertyNameDataLoad: false,
        propertyIdDataLoad: false,
        // range filter's grid column information
        rangeFilterGridCol: false,
        specialCharacters: false,
        // holds the different data types.
        typeStore: null,
        propertyStore: null,
        propertyInformation: null,
        service: false,
        _nlsResource: false,
        specialDates: Object.getOwnPropertyNames(SageUtility.specialDates),
        picklistSchemaData: null,
        propertySchemaData: null,
        filterSchemaData: null,
        constructor: function () {
            this.service = Sage.Data.SDataServiceRegistry.getSDataService('metadata');
            this.propertyIdDataLoad = new Memory();
            this.propertyNameDataLoad = new Memory();
            this.filterTypeDataLoad = new Memory();
            this.aggregation = new Memory();
            this.operation = new Memory();
            this.rangeFilterGridCol = new Memory();
            this.specialCharacters = new Memory();
            this.propertyInformation = new Memory();
            this._nlsResource = nlsResource;
            this._populateFromSDataMetaDataHelper();
        },
        _populateFromSDataMetaDataHelper: function () {
            var data = new GeneralSchemaReader('system');
            data.getSchemaInformationFromSData();
            this.picklistSchemaData = data.picklistResourceNodes;

            data = new GeneralSchemaReader('metadata');
            data.getSchemaInformationFromSData();
            this.propertySchemaData = data.propertyResourceNodes;
            this.filterSchemaData = data.filterResourceNodes;
        },
        refreshPropertyStore: function (entity, queryOs, addins) {
            this.propertyStore = new PropertyStore(entity, queryOs, addins);
            this.typeStore = this.propertyStore.fStore.typeStore;
        },
        /*
        *   Grabs a list of properties for a given entity
        */
        getPropertiesAssociatedWithFilters: function (entity) {
            this._grabEntityProperties(this, entity, 0, 100);
        },
        /*
        -----------------------------------------------------------------------------------------------------------------------
           Start Helper methods for getPropertiesAssociatedWithFilters
        */
        _grabEntityProperties: function (content, entity, start, count) {
            count = count || 100;
            start = start || 0;

            var where = 'isIncluded ne False';
            var request = new Sage.SData.Client.SDataResourceCollectionRequest(this.service);
            request.setResourceKind('entities(' + "'" + entity.name + "'" + ')/properties');
            request.setQueryArg('startIndex', start);
            request.setQueryArg('count', count);
            request.setQueryArg('where', where);

            request.read({
                success: function (data) {
                    var entityFields = data.$resources;
                    for (var i = 0; i <= entityFields.length - 1; i++) {
                        var pnid = entityFields[i].propertyName;
                        var idid = entityFields[i].id;
                        var noIndex = typeof (content.propertyNameDataLoad.index) === "undefined";

                        //prevent the duplicate error appearing in the console
                        if (noIndex || typeof (content.propertyNameDataLoad.index[pnid]) === "undefined") {
                            content.propertyNameDataLoad.add(
                            {
                                id: pnid,
                                name: entityFields[i].propertyName,
                                type: filterUtility.resolveDataType(entityFields[i].dataTypeId)
                            });
                        }
                        if (noIndex || typeof (content.propertyIdDataLoad.index[idid]) === "undefined") {
                            content.propertyIdDataLoad.add(
                            {
                                id: idid,
                                name: entityFields[i].propertyName,
                                type: filterUtility.resolveDataType(entityFields[i].dataTypeId)
                            });
                        }
                    }
                    var totalResults = data.$totalResults;
                    var newStart = start + count; // to get new start value take start + count
                    var valuesLeft = totalResults - newStart; // how many more records still need to get
                    if (valuesLeft > 0) // we need to get more records if greater than 0, if less than 0, there may be an issue.
                    {
                        if (valuesLeft >= 100) // Limit get to 100 records at a time
                        {
                            content.grabEntityProperties(content, false, newStart, 100);
                        } else // unless there is less, then just grab the rest.
                        {
                            content.grabEntityProperties(content, false, newStart, valuesLeft);
                        }
                    }
                },
                failure: function () {
                }
            });
        },
        /*
           End Helper methods for getPropertiesAssociatedWithFilters
       -----------------------------------------------------------------------------------------------------------------------
       */
        getSpecialValues: function () {
            var arr = Object.getOwnPropertyNames(this.specialDates);
            if (typeof (arr) === 'undefined' || (typeof (arr.length) !== 'undefined' && arr.length === 0)) {
                return this.specialDates;
            }
            for (var i = 0; i < arr.length; i++) {
                if (!this.specialCharacters.get(arr[i])) {
                    this.specialCharacters.add({ name: arr[i], id: arr[i], property: arr[i] });
                }
            }
        },
        /*
        *   Grabs schema information like aggregations, operations, and filter types.
        */
        getSchemasInformationFromSData: function (async) {
            if (async === undefined) {
                async = true;
            }
            var that = this;
            var hand = dojoRequest('slxdata.ashx/slx/metadata/-/$schema',
                {
                    handleAs: 'xml',
                    preventCache: true,
                    sync: !async
                }).then(function (data) {
                    var schemaData = SageUtility.parseXMLNode(data, {});
                    if (schemaData) {
                        that._gSIFSSuccess(schemaData);
                    }
                },
                function (err) {
                    that._onError('Download', err);
                    return err;
                }
            );
        },
        /*
        -----------------------------------------------------------------------------------------------------------------------
           Start Helper methods for getSchemasInformationFromSData
        */
        _gSIFSSuccess: function (data) {
            var context = this;
            var currName = "";
            var schemaNode = data["xs:schema"],
            simpleType = schemaNode["xs:simpleType"],
            complexType = schemaNode["xs:complexType"];

            arrayUtil.forEach(simpleType, function (curr) {
                currName = curr["name"];

                var restriction = curr["xs:restriction"];
                // list of aggregation
                if (currName === "OrmAnalyticsMetricAggregation--enum") {
                    context._populateAggregationList(restriction["xs:enumeration"]);
                }
                // list of operations
                if (currName === "ComparisonValidatorOperator--enum") {
                    context._populateOperationList(restriction["xs:enumeration"]);
                }
            });

            arrayUtil.forEach(complexType, function (curr) {
                currName = curr["name"];

                var all = curr["xs:all"];
                var choice = curr["xs:choice"];
                // list of filter types
                if (currName === "details--choice") {
                    context._populateFilterTypesList(choice["xs:element"]);
                }
                // list of range columns
                if (currName === "range--type") {
                    context._createRangefilterCols(all["xs:element"]);
                }
                // list of property columns
                if (currName === "property--type") {
                    context._populateProperties(all["xs:element"], data);
                }
            });
            connect.publish('Sage/EntityManager/FilterUtilityDone');
        },
        _populateProperties: function (xmlPList, xmlList) {
            var context = this;
            arrayUtil.forEach(xmlPList, function (curr) {
                var isManadtory = curr["sme:isMandatory"] || false;
                context.propertyInformation.add({ name: curr["name"], label: curr["sme:label"], type: curr["type"], manadtory: isManadtory, collection: null, sub: null, value: null });
            });
            var schemaNode = xmlList["xs:schema"],
                simpleType = schemaNode["xs:simpleType"],
                complexType = schemaNode["xs:complexType"];
            var list = this.propertyInformation.data;
            for (var i = 0; i < list.length; i++) {
                var item = list[i];
                var typeName = item.type;

                if (typeName.substring(0, 3) !== "xs:") {
                    if (typeName.substring(typeName.length - 6, typeName.length) === "--enum") {
                        arrayUtil.forEach(simpleType, function (curr2) {
                            var restriction = curr2["xs:restriction"];
                            // list of aggregation
                            if (curr2['name'] === typeName) {
                                context.propertyInformation.data[i].collection = new Memory({ data: restriction["xs:enumeration"] });
                            }
                        });
                    }
                    if (typeName.substring(typeName.length - 6, typeName.length) === "--type") {
                        var subList = new Memory();
                        arrayUtil.forEach(complexType, function (curr3) {
                            var all = curr3["xs:all"];
                            if (curr3['name'] === typeName) {
                                var temp = all["xs:element"];
                                if (typeof (temp) === "object") {
                                    if (temp instanceof Array) {
                                        arrayUtil.forEach(temp, function (curr4) {
                                            var isManadtory1 = curr4["sme:isMandatory"] || false;
                                            subList.add({ name: curr4["name"], label: curr4["sme:label"], type: curr4["type"], manadtory: isManadtory1, collection: null, sub: null });
                                        });
                                    } else {
                                        var isManadtory1 = temp["sme:isMandatory"] || false;
                                        subList.add({ name: temp["name"], label: temp["sme:label"], type: temp["type"], manadtory: isManadtory1, collection: null, sub: null });
                                    }
                                }
                            }
                        });
                        this.propertyInformation.data[i].sub = subList;
                    }
                }
            }
        },
        _populateFilterTypesList: function (xmlList) {
            for (var i = 0; i < xmlList.length; i++) {
                var item = xmlList[i];
                var nm = item["name"];
                this.filterTypeDataLoad.add(this._initialformatDetails(nm));
            }
        },
        _populateAggregationList: function (xmlList) {
            for (var i = 0; i < xmlList.length; i++) {
                var item = xmlList[i];
                this.aggregation.add({ id: item["value"], name: this._nlsResource[item["value"]] });
            }
        },
        _populateOperationList: function (xmlList) {
            for (var i = 0; i < xmlList.length; i++) {
                var item = xmlList[i];
                this.operation.add({ id: item["value"], name: this._nlsResource[item["value"]] });
            }

            this.operation.add({ id: "Contains", name: this._nlsResource["Contains"] });
            this.operation.add({ id: "StartsWith", name: this._nlsResource["StartsWith"] });
            this.operation.add({ id: "EndsWith", name: this._nlsResource["EndsWith"] });
        },
        _createRangefilterCols: function (xmlList) {
            var itemName = "";
            for (var i = 0; i < xmlList.length; i++) {
                var item = xmlList[i];
                var edit = false;
                itemName = item["name"];
                if (itemName === "rangeName") {
                    edit = {
                        label: this._nlsResource[itemName],
                        field: itemName,
                        editOn: "", // forces the control to stay in view.
                        autoSave: itemName !== "rangeId",
                        editable: itemName !== "rangeId",
                        hidden: (itemName === "rangeId" || itemName === "customSql"),
                        unhidable: itemName !== "displayName",
                        id: "AA" + itemName,
                        editor: TextBox,
                        editorArgs: {
                            shouldPublishMarkDirty: false,
                            required: true,
                            placeHolder: this._nlsResource.defaultRangeRowValue
                        },
                        width: 150
                    };
                }
                else {
                    edit = {
                        label: this._nlsResource[itemName],
                        field: itemName,
                        editOn: "", // forces the control to stay in view.
                        autoSave: itemName !== "rangeId",
                        editable: itemName !== "rangeId",
                        hidden: (itemName === "rangeId" || itemName === "customSql"),
                        unhidable: itemName !== "displayName",
                        id: itemName,
                        editor: TextBox,
                        editorArgs: {
                            shouldPublishMarkDirty: false
                        },
                        width: 150
                    };
                }
                this.rangeFilterGridCol.add(edit);
            }
        },
        /*
           End Helper methods for getSchemasInformationFromSData
       -----------------------------------------------------------------------------------------------------------------------
       */
        getStringFormatDetails: function (details) {
            return this.formatDetails(details, false, "").detailsLocalizedName;
        },
        /*
        *   Localized/Reader friendly name of the filter. 
        */
        _initialformatDetails: function (details) {
            var name = "";
            var type = "";
            switch (details) {
                case "distinctFilter":
                    {
                        name = this._nlsResource.FilterGridDetailsDistinctFilter;// "distinct";
                        type = "filter";
                        break;
                    }
                case "dateDiffMetricFilter":
                    {
                        name = this._nlsResource.FilterGridDetailsDateDiffMetricFilter; //"date difference metric";
                        type = "metric";
                        break;
                    }
                case "rangeFilter":
                    {
                        name = this._nlsResource.FilterGridDetailsRangeFilter; //"range";
                        type = "filter";
                        break;
                    }
                case "metricFilter":
                    {
                        name = this._nlsResource.FilterGridDetailsMetricFilter; //"metric";
                        type = "metric";
                        break;
                    }
                case "userLookupFilter":
                    {
                        name = this._nlsResource.FilterGridDetailsLookupFilter; //"user lookup";
                        type = "filter";
                        break;
                    }
                case "lookupFilter":
                    {
                        name = this._nlsResource.FilterGridDetailsLookupFilter; //"lookup";
                        type = "filter";
                        break;
                    }
                default: {
                    name = this._nlsResource.FilterGridDetailsCustom; //"custom";
                    type = "filter";
                    break;
                }
            }
            return { id: details, name: name, type: type };
        },
        /*
        *   Localized/Reader friendly name of the filter.
        *    BUT ALSO chooses a detail's view based on the filter type in other contexts.
        */
        formatDetails: function (details, includeObject, entityName) {
            if (typeof (details) !== 'undefined') {
                if (typeof (details.distinctFilter) !== 'undefined') {
                    return {
                        detailsKey: 'distinctFilter',
                        detailsObject: includeObject ? new distinctDetailsView({ detailUtility: this, details: details, entityName: entityName }) : false,
                        detailsLocalizedName: this._nlsResource.FilterGridDetailsDistinctFilter
                    };
                }
                if (typeof (details.dateDiffMetricFilter) !== 'undefined') {
                    return {
                        detailsKey: 'dateDiffMetricFilter',
                        detailsObject: includeObject ? new AddMDDetailsView({ detailUtility: this, details: details, entityName: entityName }) : false,
                        detailsLocalizedName: this._nlsResource.FilterGridDetailsDateDiffMetricFilter
                    };
                }
                if (typeof (details.rangeFilter) !== 'undefined') {
                    return {
                        detailsKey: 'rangeFilter',
                        detailsObject: includeObject ? new rangeDetailsView({ detailUtility: this, details: details, entityName: entityName }) : false,
                        detailsLocalizedName: this._nlsResource.FilterGridDetailsRangeFilter
                    };
                }
                if (typeof (details.metricFilter) !== 'undefined') {
                    return {
                        detailsKey: 'metricFilter',
                        detailsObject: includeObject ? new AMDDetailsView({ detailUtility: this, details: details, entityName: entityName }) : false,
                        detailsLocalizedName: this._nlsResource.FilterGridDetailsMetricFilter
                    };
                }
                if (typeof (details.userLookupFilter) !== 'undefined') {
                    return {
                        detailsKey: 'userLookupFilter',
                        detailsObject: includeObject ? new UserLookupDetailsView({ detailUtility: this, details: details, entityName: entityName }) : false,
                        detailsLocalizedName: this._nlsResource.FilterGridDetailsLookupFilter
                    };
                }
                if (typeof (details.lookupFilter) !== 'undefined') {
                    return {
                        detailsKey: 'lookupFilter',
                        detailsObject: includeObject ? new UserLookupDetailsView({ detailUtility: this, details: details, entityName: entityName }) : false,
                        detailsLocalizedName: this._nlsResource.FilterGridDetailsLookupFilter
                    };
                }
                return {
                    detailsKey: 'custom',
                    detailsObject: false,
                    detailsLocalizedName: this._nlsResource.FilterGridDetailsCustom
                };
            }
            return false;
        },
        /*
        * determines the details section of the add/edit filter (by default it will be distinct).
        */
        getDetailsSection: function (context, firstload) {
            var selectedId = context._title == this._nlsResource.FilterGridDetailsMetricFilter ? 'metricFilter' : 'distinctFilter';
            var editMode = false;
            if (context._EditData) {
                editMode = true;
            }

            if (firstload && editMode && context._EditData.details) {
                return this.formatDetails(context._EditData.details, true, context.entityName);
            }

            if (context.typeDropDowns && context.typeDropDowns.item && context.typeDropDowns.item.id) {
                selectedId = context.typeDropDowns.item.id;
            }

            var passingValue = false;
            if (editMode) {
                passingValue = context._EditData.details;
            }
            switch (selectedId) {
                case "dateDiffMetricFilter":
                    {
                        return {
                            detailsKey: 'dateDiffMetricFilter',
                            detailsObject: new AddMDDetailsView({ detailUtility: this, details: passingValue, entityName: context.entityName }),
                            detailsLocalizedName: this._nlsResource.FilterGridDetailsDateDiffMetricFilter
                        };
                    }
                case "metricFilter":
                    {
                        return {
                            detailsKey: 'metricFilter',
                            detailsObject: new AMDDetailsView({ detailUtility: this, details: passingValue, entityName: context.entityName }),
                            detailsLocalizedName: this._nlsResource.FilterGridDetailsMetricFilter
                        };
                    }
                case "distinctFilter":
                    {
                        return {
                            detailsKey: 'distinctFilter',
                            detailsObject: new distinctDetailsView({ detailUtility: this, details: passingValue, entityName: context.entityName }),
                            detailsLocalizedName: this._nlsResource.FilterGridDetailsDistinctFilter
                        };
                    }
                case "rangeFilter":
                    {
                        return {
                            detailsKey: 'rangeFilter',
                            detailsObject: new rangeDetailsView({ detailUtility: this, details: passingValue, entityName: context.entityName }),
                            detailsLocalizedName: this._nlsResource.FilterGridDetailsRangeFilter
                        };
                    }
                case "userLookupFilter":
                    {
                        return {
                            detailsKey: 'userLookupFilter',
                            detailsObject: new UserLookupDetailsView({ detailUtility: this, details: passingValue, entityName: context.entityName }),
                            detailsLocalizedName: this._nlsResource.FilterGridDetailsLookupFilter
                        };
                    }
                default:
                    {
                        return false;
                    }
            }
        },
        colonizeLabels: function (labelString) {
            return dString.substitute('${0}:', [labelString]);
        },
        grabReaderFriendlyVersionOfAggregationGivenId: function (id) {
            for (var i = 0; i < this.aggregation.data.length; i++) {
                if (this.aggregation.data[i].id == id) {
                    return this.aggregation.data[i].name;
                }
            }
            return "";
        },
        grabItemOfAggregationGivenId: function (id) {
            for (var i = 0; i < this.aggregation.data.length; i++) {
                if (this.aggregation.data[i].id == id) {
                    return this.aggregation.data[i];
                }
            }
            return "";
        },
        grabIdOfAggregationGivenName: function (name) {
            for (var i = 0; i < this.aggregation.data.length; i++) {
                if (this.aggregation.data[i].name == name) {
                    return this.aggregation.data[i].id;
                }
            }
            return "";
        }
    });
    return widget;
});
},
'Sage/MainView/EntityMgr/AddEditEntityDetail/DistinctDetailsView':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/_base/declare',
    'dojo/_base/event',
    'dojo/text!./templates/DistinctDetailsView.html',
    'Sage/Utility',
    'Sage/MainView/EntityMgr/AddEditEntityDetail/_DetailsAddEditDialogBase',
    'Sage/UI/Controls/TextBox'
],
function (
    declare,
    dojoEvent,
    template,
    utility,
    _DetailsAddEditDialogBase,
    crmTextBox
) {
    var widget = declare('Sage.MainView.EntityMgr.AddEditEntityDetail.DistinctDetailsView', [_DetailsAddEditDialogBase], {

        widgetTemplate: new Simplate(eval(template)),
        widgetsInTemplate: true,

        charactersTextBox: false,

        constructor: function () {
            this.hasProperties = true;
            this.isMetric = false;
        },
        postCreate: function () {

            this._createCharacterController();
            this.startup();
        },
        _createCharacterController: function () {
            this.lblEntityFiltersDetailsContains.innerHTML = this._nlsResources.lblCharacter;

            var self = this;
            //insert a characters text box
            this.charactersTextBox = new crmTextBox({
                shouldPublishMarkDirty: false,
                regExp: '^[0-9]+$',//allow numbers 0-99.
                validator: function (value, constraints) {
                    var oRegExp = new RegExp('^0+', "g"); //leading zeroes
                    value = value.replace(oRegExp, "");
                    if (value.length === 0) {
                        value = 0;
                    }
                    if (value > 99) {
                        value = 99;
                    }
                    if (value < 0) {
                        value = 0;
                    }
                    var str = self.DojoString.substitute("${0}", [value]);
                    var matches = str.match(this.regExp, 'g');
                    if (matches !== null) {
                        this.textbox.value = value;
                        return true;
                    }
                    return false;
                },
                invalidMessage: this._nlsResources.FieldMustBeANumber,
                required: true
            });
            this.DomConstruct.place(this.charactersTextBox.domNode, this.txtEntityFiltersDetailsContains, 'only');

            this.charactersTextBox.textbox.value = 0; //default to zero

            if (typeof (this.details.distinctFilter) !== 'undefined') { // if we have a distinct filter use the character value
                this.charactersTextBox.textbox.value = this.details.distinctFilter.characters;
            }
            if (typeof (this.details.rangeFilter) !== 'undefined') { // if we have a range filter use the character value
                this.charactersTextBox.textbox.value = this.details.rangeFilter.characters;
            }

            this.DojoConnect.connect(this.charactersTextBox, 'onKeyPress', this._onKeyPress, true);

        },

        _onKeyPress: function (e) {
            if (!utility.restrictToNumberOnKeyPress(e, 'number')) {
                dojoEvent.stopEvent(e);
            }
        },

        /**
        * This is a last method in the initialization process. 
        * It is called after all the child widgets are rendered so it's good for a container widget to finish it's post rendering here. 
        * This is where the container widgets could for example set sizes of their children relative to it's own size.
        */
        startup: function () {
            this.inherited(arguments);
        },

        /*
        * This method is used to populate the details section of the sdata feeds when creating and editing the template's values.
        *
        * Currently Distinct filters only have one attribute in the detail's section which is characters. 
        */
        getDetails: function (justValue) {
            if (justValue) {

                return this.charactersTextBox.textbox.value;
            }
            var distinctFilter = { distinctFilter: { characters: this.charactersTextBox.textbox.value } };
            return distinctFilter;
        },
        isValid: function () {
            var val = this.charactersTextBox.isValid(true);
            this.charactersTextBox.onChanged();
            return val;
        }
    });
    return widget;
});
},
'Sage/MainView/EntityMgr/AddEditEntityDetail/_DetailsAddEditDialogBase':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dijit/_Widget',
    'dijit/registry',

    'dojo/dom-construct',
    'dojo/query',
    'dojo/dom-class',
    'dojo/dom-style',
    'dojo/string',

    'dojo/_base/connect',
    'dojo/_base/declare',
    'dojo/_base/lang',

    'dojo/i18n!./nls/AddEditDialog',

    'Sage/_Templated',
    'Sage/UI/Dialogs'
],
function (
    _Widget,
    registry,

    domConstruct,
    query,
    domClass,
    dojoStyle,
    dojoString,

    dojoConnect,
    declare,
    lang,

    nlsResources,

    _Templated,
    dialogue

) {
    var widget = declare('Sage.MainView.EntityMgr.AddEditEntityDetail._DetailsAddEditDialogBase', [_Widget, _Templated], {

        widgetTemplate: new Simplate('<div>Not implemented</div>'),
        _nlsResources: nlsResources,

        Dialog: dialogue,
        DojoString: dojoString,
        DojoStyle: dojoStyle,
        DojoConnect: dojoConnect,
        DomClass: domClass,
        DomConstruct: domConstruct,
        Lang: lang,
        Query: query,
        Registry: registry,

        detailUtility: false,
        hasProperties: false,
        isMetric: false,
        editing: false,
        details: false,
        embedded: false,
        entityName: '',

        constructor: function () {
            var obj = arguments;
            if (obj[0]) {
                var first = obj[0];

                if (first.detailUtility) {
                    this.detailUtility = first.detailUtility;
                }
                if (first.isMetric) {
                    this.isMetric = first.isMetric;
                }
                if (first.details) {
                    this.details = first.details;
                    this.editing = first.details && true;
                }
                if (first.hasProperties) {
                    this.hasProperties = first.hasProperties;
                }
            }
        },

        postCreate: function () {
        },

        startup: function () {
            this.inherited(arguments);
        },

        // ---------------------------------------------------------------
        // This method is to be overwritten by mixin classes
        //  It is used in the saving process.
        //----------------------------------------------------------------
        getDetails: function () {
        },

        // ---------------------------------------------------------------
        // This method is to be overwritten by mixin classes
        //  It is used in to validate the form controls process.
        //----------------------------------------------------------------
        isValid: function () {
            return true; // do special validation done at the moment.
        }

    });
    return widget;
});
},
'Sage/MainView/EntityMgr/AddEditEntityDetail/RangeDetailsView':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/_base/declare',
    'dojo/store/Memory',
    'dojo/text!./templates/RangeDetailsView.html',
    'Sage/MainView/EntityMgr/AddEditEntityDetail/_DetailsAddEditDialogBase',
    'Sage/MainView/EntityMgr/AddEditEntityDetail/DistinctDetailsView',
    'Sage/UI/GridView',
    'Sage/UI/Controls/TextBox',
    'Sage/Utility'
],
function (
    declare,
    Memory,
    template,
    _DetailsAddEditDialogBase,
    distinct,
    GridView,
    crmTextBox,
    utility
) {
    var widget = declare('Sage.MainView.EntityMgr.AddEditEntityDetail.RangeDetailsView', [_DetailsAddEditDialogBase], {

        widgetTemplate: new Simplate(eval(template)),
        widgetsInTemplate: true,

        character: false,
        rangeGridsObj: false,

        lastSelectedRange: false,

        addBtnId: 'rangeGrid_addBtn',
        rmvBtnId: 'rangeGrid_removeBtn',
        gridId: 'RangeDetailsView_grid',

        tmpRwId: 0,

        constructor: function (obj) {
            this.hasProperties = true;
            this.isMetric = false;
            if (this.Registry.byId(this.addBtnId)) {
                this.Registry.byId(this.addBtnId).destroy();
            }
            if (this.Registry.byId(this.rmvBtnId)) {
                this.Registry.byId(this.rmvBtnId).destroy();
            }
            if (this.Registry.byId(this.gridId)) {
                this.Registry.byId(this.gridId).destroy();
            }
        },

        postCreate: function () {
            this._createCharacter();
            this._createRangeGrid();

            this.startup();
        },
        _addItemToGrid: function (context) {

            context.rangeGridsObj.grid.addItem(
                {
                    rangeId: context.tmpRwId,
                    rangeName: '',
                    upper: '',
                    lower: '',
                    displayName: null,
                    customSQL: null
                });
            context.tmpRwId++;
            context.rangeGridsObj.refresh();
        },
        _removeItemFromGrid: function (context) {
            var selectedItemArr = context.rangeGridsObj.getSelectedRowData();
            var noItemsSelected = typeof (selectedItemArr) === "undefined" || selectedItemArr === null || selectedItemArr.length === 0;
            var keyVariable = this.store.idProperty;
            if (noItemsSelected) {
                context.Dialog.showWarning(context._nlsResources.SelectAnItem, "Infor CRM");
                return;
            }
            var somethingRemoved = false;
            for (var i = 0; i < selectedItemArr.length; i++) {
                var container = selectedItemArr[i];
                var deleted = false;
                var id = container[keyVariable];
                var count = this.store.data.length;
                if (typeof (id) !== 'undefined') {
                    this.store.remove(id);
                    if (count > this.store.data.length) {
                        somethingRemoved = true;
                        console.log(context.DojoString.substitute('${0}: was removed', [id]));
                        i--;//reset to the previous index sinve we are removing an item
                        deleted = true;
                    }
                }
                id = container.id;
                count = this.store.data.length;
                if (typeof (id) !== 'undefined') {
                    this.store.remove(id);
                    if (count > this.store.data.length) {
                        somethingRemoved = true;
                        console.log(context.DojoString.substitute('${0}: was removed', [id]));
                        i--;//reset to the previous index sinve we are removing an item
                        deleted = true;
                    }
                }
            }
            if (somethingRemoved) {
                this.grid.refresh();
            }
            else {
                context.Dialog.showWarning(context._nlsResources.SelectAnItem, "Infor CRM");
            }
        },
        _createRangeGrid: function () {
            var dataStore = new Memory({ data: [] });
            if (this.details && this.details.rangeFilter && this.details.rangeFilter.ranges) {
                dataStore = Memory({ idProperty: 'rangeId', data: this.details.rangeFilter.ranges });
            }

            var columns = this.detailUtility.rangeFilterGridCol.data.sort(function (a, b) {
                var nameA = a['id'],
                    nameB = b['id'];

                return (nameA < nameB)
                    ? -1
                    : (nameA > nameB)
                        ? 1
                        : 0;
            });

            var grid = this.rangeGridsObj = new GridView({
                tools: ['add', 'delete'],
                store: dataStore,
                columns: columns,
                addNew: this.Lang.partial(this._addItemToGrid, this), // set the add item function
                deleteSelected: this.Lang.partial(this._removeItemFromGrid, this), // set the remove item function
                placeHolder: this.rangegridwhole,
                columnHiding: true,
                columnResizing: true,
                columnReordering: true,
                selectionMode: 'single',
                rowSelection: true,
                minRowsPerPage: dataStore.data.length,
                maxRowsPerPage: dataStore.data.length,
                id: this.gridI,
                shouldPublishMarkDirty: false
            });
            grid.createGridView();
            grid.innerHTML = this._nlsResources.lblRange;

            // make sure that the grid shows a horizontal scrollbar if all column cannot be displayed.
            grid.grid.onLoadComplete = function () {
                grid.grid.resize();
            };
        },
        _createCharacter: function () {
            this.character = new distinct(
            {
                embedded: true,
                isMetric: false,
                hasProperty: this.hasProperty,
                details: this.details,
                detailUtility: this.detailUtility
            });
            this.DomConstruct.place(this.character.domNode, this.characterContainer, 'only');
        },
        /**
        * This is a last method in the initialization process. 
        * It is called after all the child widgets are rendered so it's good for a container widget to finish it's post rendering here. 
        * This is where the container widgets could for example set sizes of their children relative to it's own size.
        */
        startup: function () {
            this.inherited(arguments);
        },
        getDetails: function () {
            var rangeFilter = {
                rangeFilter: {
                    characters: this.character.getDetails(true),
                    ranges: []
                }
            };
            var store = this.rangeGridsObj.store.data;
            for (var i = 0; i < store.length; i++) {
                var range = {
                    range: store[i]
                };
                range.range.rangeId = this._stripoutNonRangeIds(range);
                if (range.range.rangeId === "") {
                    delete range.range.rangeId;
                }
                if (range.range.displayName === null) {
                    delete range.range.displayName;
                }
                if (range.range.upper === null) {
                    delete range.range.upper;
                }
                if (range.range.lower === null) {
                    delete range.range.lower;
                }
                if (range.range.rangeName === null) {
                    delete range.range.rangeName;
                }
                if (range.range.customSQL === null) {
                    delete range.range.customSQL;
                }
                rangeFilter.rangeFilter.ranges.push(range.range);
            }

            return rangeFilter;
        },
        _stripoutNonRangeIds: function (obj) {
            // an id in this instance is 5 "chunks" of alphanumerics separated by a hyphen/dash.
            var idRegex = "[A-Z|0-9|a-z]+[-][A-Z|0-9|a-z]+[-][A-Z|0-9|a-z]+[-][A-Z|0-9|a-z]+[-][A-Z|0-9|a-z]+";
            var matches = idRegex.match(obj.range.rangeId, 'g');
            if (matches) {
                if (this.Lang.isArray(matches)) {
                    if (matches[0].length == obj.range.rangeId.length) {
                        return obj.range.rangeId;
                    }
                }
            }
            return "";
        },
        isValid: function () {
            var list = this.Query("td.dgrid-cell.dgrid-cell-padding.dgrid-column-AArangeName", this.rangeGridsObj.grid.bodyNode);
            var Lowerlist = this.Query("td.dgrid-cell.dgrid-cell-padding.dgrid-column-lower", this.rangeGridsObj.grid.bodyNode);
            var Upperlist = this.Query("td.dgrid-cell.dgrid-cell-padding.dgrid-column-upper", this.rangeGridsObj.grid.bodyNode);

            var subSection = this.character.isValid();

            var bool = true;
            for (var i = 0; i < list.length; i++) {
                list[i].widget.isValid(true);
                list[i].widget.onChanged();

                var validWid = list[i].widget.state !== 'Error' && !(list[i].widget.state === 'Incomplete' && list[i].widget.required);

                if (!validWid) {
                    list[i].widget.set('state', 'Error');
                }

                var lowerVal = Lowerlist[i].widget.value;
                var upperVal = Upperlist[i].widget.value;

                if (!isNaN(lowerVal) &&
                    !isNaN(upperVal)) {
                    if (lowerVal > upperVal) {
                        this._setErrorStateWithMsg(Lowerlist[i].widget,
                            this._nlsResources.LowerMustBeLessThanUpper,
                            'Error');
                        this._setErrorStateWithMsg(Upperlist[i].widget,
                            this._nlsResources.LowerMustBeLessThanUpper,
                            'Error');
                        validWid = false;
                    }
                } else {
                    // Special Date Placeholders
                    if (lowerVal.startsWith(':') && !utility.specialDates.hasOwnProperty(lowerVal)) {
                        this._setErrorStateWithMsg(Upperlist[i].widget,
                            this._nlsResources.InvalidSpecialDateValue,
                            'Error');
                        validWid = false;
                    }
                    if (upperVal.startsWith(':') && !utility.specialDates.hasOwnProperty(upperVal)) {
                        this._setErrorStateWithMsg(Upperlist[i].widget,
                            this._nlsResources.InvalidSpecialDateValue,
                            'Error');
                        validWid = false;
                    }
					
					var d1;
					var d2;
					var loVal;
					var hiVal;

                    // Compare
                    if (validWid) {
                        if (lowerVal.startsWith(':') && upperVal.startsWith(':')) {
                            // Both are placeholders
                            d1 = utility.specialDates[lowerVal](new Date());
                            d2 = utility.specialDates[upperVal](new Date());
                            if (d1 > d2) {
                                this._setErrorStateWithMsg(Lowerlist[i].widget,
                                    this._nlsResources.LowerMustBeLessThanUpper,
                                    'Error');
                                this._setErrorStateWithMsg(Upperlist[i].widget,
                                    this._nlsResources.LowerMustBeLessThanUpper,
                                    'Error');
                                validWid = false;
                            }
                        } else if (lowerVal.startsWith(':') && !isNaN(upperVal)) {
                            // Lower is placeholder upper is date value
                            d1 = utility.specialDates[lowerVal](new Date());
                            loVal = parseInt('' +
                                d1.getFullYear() +
                                ('0' + (d1.getMonth() + 1)).slice(-2) +
                                ('0' + d1.getDate()).slice(-2), 10);
                            hiVal = parseInt(upperVal, 10);
                            if (loVal > hiVal) {
                                this._setErrorStateWithMsg(Lowerlist[i].widget,
                                    this._nlsResources.LowerMustBeLessThanUpper,
                                    'Error');
                                this._setErrorStateWithMsg(Upperlist[i].widget,
                                    this._nlsResources.LowerMustBeLessThanUpper,
                                    'Error');
                                validWid = false;
                            }
                        } else if (upperVal.startsWith(':') && !isNaN(lowerVal)) {
                            // Upper is placeholder lower is date value
                            d1 = utility.specialDates[upperVal](new Date());
                            hiVal = parseInt('' +
                                d1.getFullYear() +
                                ('0' + (d1.getMonth() + 1)).slice(-2) +
                                ('0' + d1.getDate()).slice(-2), 10);
                            loVal = parseInt(lowerVal, 10);
                            if (loVal > hiVal) {
                                this._setErrorStateWithMsg(Lowerlist[i].widget,
                                    this._nlsResources.LowerMustBeLessThanUpper,
                                    'Error');
                                this._setErrorStateWithMsg(Upperlist[i].widget,
                                    this._nlsResources.LowerMustBeLessThanUpper,
                                    'Error');
                                validWid = false;
                            }
                        } else if (lowerVal > upperVal) {
                            this._setErrorStateWithMsg(Lowerlist[i].widget,
                                this._nlsResources.LowerMustBeLessThanUpper,
                                'Error');
                            this._setErrorStateWithMsg(Upperlist[i].widget,
                                this._nlsResources.LowerMustBeLessThanUpper,
                                'Error');
                            validWid = false;
                        }
                    }
                }

                bool = bool && validWid;
            }
            return bool && subSection;
        },
        _setErrorStateWithMsg: function (obj, msg, state) {
            if (!obj || typeof(obj.set) !== 'function') return;
            if (msg) {
                obj.set('message', msg);
            }
            if (state) {
                obj.set('state', state);
            }
        }
    });
    return widget;
});
},
'Sage/MainView/EntityMgr/AddEditEntityDetail/AMDDetailsView':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dijit/registry',
    'dojo/_base/declare',
    'dojo/text!./templates/AMDDetailsView.html',
    'dojo/store/Memory',
    'Sage/MainView/EntityMgr/AddEditEntityDetail/_DetailsAddEditDialogBase',
    'Sage/UI/FilteringSelect'
],
function (
    registry,
    declare,
    template,
    memory,
    _DetailsAddEditDialogBase,
    crmDropdown
) {
    var widget = declare('Sage.MainView.EntityMgr.AddEditEntityDetail.AMDDetailsView', [_DetailsAddEditDialogBase], {

        widgetTemplate: new Simplate(eval(template)),
        widgetsInTemplate: true,
        aggregations: null,
        propertyValues: null,
        aggregationDropDown: false,
        _idForAggregtDropDown: 'aggregationDpItems',

        constructor: function (obj) {
            if (!this.embedded) {
                this.hasProperties = true;
                this.isMetric = true;
            }
            if (this.Registry.byId(this._idForAggregtDropDown)) {
                this.destroy(this.Registry.byId(this._idForAggregtDropDown));
            }
        },

        destroy: function (context) {
            context.destroy();
        },

        postCreate: function () {

            this._createAggregateController();

            this.startup();
        },
        _populateDefaultAggregate: function () {
            //insert a characters text box
            var defValue = '';
            if (this.details) {
                if (this.details.metricFilter && this.details.metricFilter.aggregation) { // load to edit an existing metric
                    defValue = this.details.metricFilter.aggregation;
                }
                if (this.details.dateDiffMetricFilter && this.details.dateDiffMetricFilter.aggregation) { // carry over from an edit of a date difference metric
                    defValue = this.details.dateDiffMetricFilter.aggregation;
                }
                if (this.details.aggregation) { // load from within a date difference metric
                    defValue = this.details.aggregation;
                }
            }
            if (this.aggregation) { // load from within a date difference metric
                defValue = this.aggregation;
            }

            var obj = {
                context: this,
                idValue: defValue
            };
            this.DojoConnect.subscribe('Sage/EntityManager/detailUtilityDone', obj, function () {
                // set the item.
                this.Registry.byId(this.context._idForAggregtDropDown).item = this.context.detailUtility.grabItemOfAggregationGivenId(this.idValue);
                // make that item's name value visible.
                this.Registry.byId(this.context._idForAggregtDropDown).focusNode.value = this.Registry.byId(this.context._idForAggregtDropDown).item.name || "";
            });

            // if we are editing, then we have the property control, which has the current property value and a lookup function.
            if (this.editing) {
                var arrProperty = this.details.propertyInfo.propertyLookup(); // use the property lookup function to get a list of appropriate aggregations.

                var ppt = arrProperty[0]; // lookup returns a list incase of duplicates, so just grab first.

                return { value: defValue, aggs: this._setAggregations(ppt.dataType.aggregate) };
            } else {
                return { value: defValue, aggs: this.detailUtility.aggregation };
            }
        },
        _createAggregateController: function () {
            this.lblEntityFiltersDetailsAggregation.innerHTML = this._nlsResources.lblAggregation;

            var val = this._populateDefaultAggregate();

            this.aggregationDropDown = new crmDropdown(
                {
                    id: this._idForAggregtDropDown,
                    name: 'aggregations',
                    value: val.value,
                    store: val.aggs,
                    searchAttr: 'name',
                    fetchProperties: { sort: [{ attribute: "name", descending: false }] }
                }, this._idForAggregtDropDown
                );

            this.DojoConnect.subscribe('Sage/UI/Controls/PropertDropDown', this, function (items) {
                this._setAggregations(items);
            });

            this.DomConstruct.place(this.aggregationDropDown.domNode, this.dpEntityFiltersDetailsAggregation, 'only');
        },

        _setAggregations: function (items) {
            var arrQry = this.detailUtility.aggregation;

            arrQry = arrQry.query(function (item) {

                // two different was to set the aggregations, if items.dataType exits, then the user is editing the drop down.
                if (typeof (items.dataType) !== "undefined" && items.dataType !== null && items.dataType !== "") {
                    return items.dataType.aggregate.indexOf(item.id.toLowerCase()) >= 0;
                }
                else { // the other way is when a user is editing a metric and is called on the intial load.
                    return items.indexOf(item.id.toLowerCase()) >= 0;
                }
            });

            if (this.aggregationDropDown) {
                // user is selecting from the drop down, so add the new list to the existing store.
                this.aggregationDropDown.store = new memory({ data: arrQry });

                // if by chance the aggregation control had a selected item that does not curerntly exist in the store,
                // set to the first item in the store.
                var selectedValid = (this.aggregationDropDown.store.index[this.aggregationDropDown.value] >= 0);
                if (!selectedValid) {
                    this.aggregationDropDown.set('value', this.aggregationDropDown.store.data[0].id);
                }
            }
            else {
                // initial load return the list. control is currently being built.
                return new memory({ data: arrQry });
            }
        },

        /**
        * This is a last method in the initialization process. 
        * It is called after all the child widgets are rendered so it's good for a container widget to finish it's post rendering here. 
        * This is where the container widgets could for example set sizes of their children relative to it's own size.
        */
        startup: function () {
            this.inherited(arguments);
        },
        getDetails: function (JustValue) {

            var aggregateValueToSave = this.aggregationDropDown.displayedValue;
            if (this.aggregationDropDown.item && this.aggregationDropDown.item.id) {
                aggregateValueToSave = this.aggregationDropDown.item.id;
            }


            if (JustValue) {
                return aggregateValueToSave;
            }
            else {
                var metricFilter = { metricFilter: { aggregation: aggregateValueToSave } };
                return metricFilter;
            }
        },
        isValid: function () {
            var val = this.aggregationDropDown.isValid(true);
            if (!val) {
                this.aggregationDropDown.set("state", "Error");
            }
            else {
                this.aggregationDropDown.set("state", "");
            }
            return val;
        }
    });
    return widget;
});
},
'Sage/MainView/EntityMgr/AddEditEntityDetail/ADDMDDetailsView':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
        'dojo/_base/declare',
        'dojo/text!./templates/ADDMDDetailsView.html',
        'Sage/MainView/EntityMgr/AddEditEntityDetail/AMDDetailsView',
        'Sage/MainView/EntityMgr/AddEditEntityDetail/_DetailsAddEditDialogBase',
        'Sage/UI/Controls/PropertyDropDown'
],
    function (
        declare,
        template,
        aggregate,
        _DetailsAddEditDialogBase,
        PropertyDropDown
    ) {
        var widget = declare('Sage.MainView.EntityMgr.AddEditEntityDetail.ADDMDDetailsView', [_DetailsAddEditDialogBase], {
            widgetTemplate: new Simplate(eval(template)),
            widgetsInTemplate: true,

            aggregation: false,
            PropertyTextBoxFrom: null,
            PropertyTextBoxTo: null,

            constructor: function (obj) {
                this.hasProperties = false;
                this.isMetric = true;
                this.entityName = obj.entityName;

            },
            postCreate: function () {

                this._createAggregation();
                this._createFromFS();
                this._createToFS();

                this.startup();
            },
            _createFromFS: function () {
                this.PropertyTextBoxFrom = new PropertyDropDown({ entityName: this.entityName, superType: "DateTime" });
                this.DomConstruct.place(this.PropertyTextBoxFrom.domNode, this.fieldsContainerFrom, 'replace');

                this.lblMetricRangeFrom.innerHTML = this._nlsResources.lblFrom;
                var defFrom = '';
                if (this.details.dateDiffMetricFilter && this.details.dateDiffMetricFilter.fromPropertyName) {
                    defFrom = this.details.dateDiffMetricFilter.fromPropertyName;
                }
                this.PropertyTextBoxFrom.entitySelected.textbox.value = defFrom;
            },
            _createToFS: function () {
                this.PropertyTextBoxTo = new PropertyDropDown({ entityName: this.entityName, superType: "DateTime" });
                this.DomConstruct.place(this.PropertyTextBoxTo.domNode, this.fieldsContainerTo, 'replace');

                this.lblMetricRangeTo.innerHTML = this._nlsResources.lblTo;
                var defTo = '';
                if (this.details.dateDiffMetricFilter && this.details.dateDiffMetricFilter.toPropertyName) {
                    defTo = this.details.dateDiffMetricFilter.toPropertyName;
                }
                this.PropertyTextBoxTo.entitySelected.textbox.value = defTo;
            },
            _createAggregation: function () {
                this.aggregation = new aggregate(
                {
                    embedded: true,
                    isMetric: true,
                    hasProperty: this.hasProperty,
                    details: this.details,
                    detailUtility: this.detailUtility
                });
                this.DomConstruct.place(this.aggregation.domNode, this.aggregate, 'only');
            },


            /**
        * This is a last method in the initialization process. 
        * It is called after all the child widgets are rendered so it's good for a container widget to finish it's post rendering here. 
        * This is where the container widgets could for example set sizes of their children relative to it's own size.
        */
            startup: function () {
                this.inherited(arguments);
            },
            getDetails: function () {
                var dateDiffMetricFilter = { dateDiffMetricFilter: { aggregation: this.aggregation.getDetails(true), fromPropertyName: this.PropertyTextBoxFrom.entitySelected.textbox.value, toPropertyName: this.PropertyTextBoxTo.entitySelected.textbox.value } };
                return dateDiffMetricFilter;
            },
            isValid: function () {
                var subSection = this.aggregation.isValid();
                if (subSection === true) {
                    var val = this.PropertyTextBoxFrom.entitySelected.isValid(true);

                    if (this.PropertyTextBoxFrom.entitySelected.textbox.value === ':now') {
                        val = false;
                        this.PropertyTextBoxFrom.entitySelected.set('state', 'Error'); // If the control is not valid, mark  it's state as error.
                    }
                    this.PropertyTextBoxFrom.entitySelected.onChange();

                    val = val && this.PropertyTextBoxTo.entitySelected.isValid(true);
                    if (this.PropertyTextBoxTo.entitySelected.textbox.value === ':now') {
                        val = val && false;
                        this.PropertyTextBoxTo.entitySelected.set('state', 'Error'); // If the control is not valid, mark  it's state as error.
                    }
                    this.PropertyTextBoxTo.entitySelected.onChange();

                    return val;
                } else {
                    return subSection;
                }
            }
        });
        return widget;
    });
},
'Sage/UI/Controls/PropertyDropDown':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define 
 * custom widget that displays dropdown box, on click of the dropdown arrow it shows
 * a tree of properties and associated entities for a given entity
 */
define([
    'Sage/MainView/EntityMgr/AddEditEntityDetail/_DetailsAddEditDialogBase',
    'dojo/_base/declare',
    'dojo/text!./templates/PropertyDropDown.html',
    'dijit/Tree',
    'Sage/UI/Controls/PropertyStore',
    'Sage/Utility',
    'dojo/string',
    'dijit/TooltipDialog',
    'dojo/dom-style',
    'dojo/dom-class'
],
function (
    _DetailsAddEditDialogBase,
    declare,
    template,
    Tree,
    PropertyStore,
    utility,
    dojoString,
    TooltipDialog,
    dojoStyle,
    domClass
) {
    var widget = declare('Sage.UI.Controls.PropertyDropDown', [_DetailsAddEditDialogBase], {

        widgetsInTemplate: true,
        widgetTemplate: new Simplate(eval(template)),

        entityName: null,

        // type filters
        byTypeId: null,      // if the user knows exact id then filter by that.
        bySuperType: null,   // if the user knows the general type then filter by it. the general type will treat fields like short, int, and double as number for example.
        byKeywords: null,
        allMatch: false,

        tree: null,
        eleTextBox: null,
        maxLevels: -1,
        _required: true,


        constructor: function (obj) {
            this.entityName = obj.entityName;

            if (typeof (obj.type) !== "undefined") {
                this.byTypeId = obj.typeId;
            }
            if (typeof (obj.superType) !== "undefined") {
                this.bySuperType = obj.superType;
            }
            if (typeof (obj.Keywords) !== "undefined") {
                this.byKeywords = obj.Keywords;
            }
            if (typeof (obj.allMatch) !== "undefined") {
                this.allMatch = obj.allMatch;
            }
            if (typeof (obj.maxLevels) !== "undefined") {
                this.maxLevels = obj.maxLevels;
            }
            if (typeof (obj.onlyProperties) !== "undefined") {
                this.onlyProperties = obj.onlyProperties;
            }
            if (typeof (obj.required) !== "undefined") {
                this._required = obj.required;
            }
        },
        postCreate: function () {
            this._createTree();

            if (typeof (this._required) !== "undefined") {
                this.entitySelected.required = this._required;
            }

            this.startup();
        },
        startup: function () {
            this.inherited(arguments);
        },
        /*
         Given an Entity name(strEntity) and a property name(strProperty). This function will search for an entity with the name provided 
         that has a property name with the property provided.

         if the entity name is not given then the current one is used.

         If the property name is not given then the current one is used.

         useful in that it allows the implementer to get the field information of a property, which includes information like the appropriate aggregate functions
         that can be used on this property.
        */
        propertyLookup: function (strEntity, strProperty) {
            if (typeof (strEntity) === "undefined" || strEntity === null) {
                strEntity = this.entityName;
            }

            if (typeof (strProperty) === "undefined" || strProperty === null) {
                strProperty = this.entitySelected.textbox.value;
            }
            return new PropertyStore().lookup(strEntity, strProperty);
        },
        //creates a tree of properties and associated entities for a given entity
        _createTree: function () {
            var self = this;
            var ps = null;
            if (this.byKeywords) {
                ps = new PropertyStore(this.entityName, { Keywords: this.byKeywords, allMatch: this.allMatch, maxLevels: this.maxLevels, onlyProperties: this.onlyProperties });
            }
            else {
                ps = new PropertyStore(this.entityName, { typeId: this.byTypeId, superType: this.bySuperType, maxLevels: this.maxLevels, onlyProperties: this.onlyProperties });
            }
            this.tree = new Tree({
                model: ps.store,
                showRoot: false,
                onClick: function (item) {
                    self.entitySelected.set('value', item.property);
                    dijit.popup.close();
                    dojo.publish('Sage/UI/Controls/PropertDropDown', item);
                }
            });
            domClass.add(this.tree.domNode, 'height250');
            var defValue = ' ';
            if (this._EditData && this._EditData.propertyName) {
                defValue = this._EditData.propertyName;
                this.entitySelected.set('value', defValue);
            }
            this.eleTextBox = this.entitySelected.domNode;
        },

        //shows the tree in a tooltip dialog, this method is called in template
        showDDTree: function () {
            var width = dojoStyle.getComputedStyle(this.eleTextBox).width;
            var myTooltipDialog = new TooltipDialog({
                style: dojoString.substitute("width:${0};", [width]),
                content: this.tree
            });
            domClass.add(myTooltipDialog.domNode, 'propertyDialog');
            dijit.popup.open({
                popup: myTooltipDialog,
                around: this.eleTextBox
            });
        }
    });
    return widget;
});
},
'Sage/UI/Controls/PropertyStore':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/string',
    'dojo/_base/declare',
    'dojo/store/Memory',
	'Sage/Data/SDataServiceRegistry',
    'dojo/store/JsonRest',
    'dojo/json',
    'dojo/_base/Deferred',
    'dojo/DeferredList',
    'dojo/request',
    'dojo/i18n!./nls/PropertyStore',
    'Sage/UI/Controls/FieldStore'
],
function (
    dString,
    declare,
    memory,
	SDataServiceRegistry,
    JsonRest,
    json,
    Deferred,
    DeferredList,
    request,
    nlsResource,
    FieldStore
) {

    var PropertyStoreModel = declare('Sage.UI.Controls.PropertyStore', null, {
        _nlsResource: null,
        fStore: null,

        // queryOptions contains the 5 different type filters.
        constructor: function (id, queryOptions, addin) {

            this._nlsResource = nlsResource;

            this.store.selectedEntity = id;
            this.store.addins = addin;
            this.fStore = new FieldStore();
            this.store.allTypes = this.fStore.typeStore;

            // queryOptions:{Keywords:[{Key,value}],allMatch}
            if (typeof (queryOptions) !== "undefined" && typeof (queryOptions.Keywords) !== "undefined") {
                if (queryOptions.allMatch) {
                    this.store.types = this.fStore.queryByKeyWordsAllMatch(queryOptions.Keywords);
                }
                else {
                    this.store.types = this.fStore.queryByKeywordsOneMatchMatch(queryOptions.Keywords);
                }
            }
            else {
                this.store.types = this.fStore.query(queryOptions);
            }

            this.store.filterByType = this.store.types.data.length;
            if (typeof (queryOptions) !== "undefined") {
                if (typeof (queryOptions.onlyProperties) !== "undefined") {
                    this.store.onlyProperties = queryOptions.onlyProperties;
                }
                if (typeof (queryOptions.maxLevels) !== "undefined") {
                    this.store.maxLevel = queryOptions.maxLevels;
                }
            }
        },


        lookup: function (strEntity, strProperty) {
            var where = "${0} eq '${1}'";
            var entity = 'entities("${0}")/properties';
            var foundProperties = [];

            var request = new Sage.SData.Client.SDataSingleResourceRequest(SDataServiceRegistry.getSDataService('metadata'))
                     .setResourceKind(dString.substitute(entity, [strEntity]))
                     .setQueryArg('format', 'json')
                     .setQueryArg('where', dString.substitute(where, ['propertyName', strProperty]));

            request.read({
                async: false,
                scope: this,
                success: function (response) {

                    var typeName = this.store.dataTypeIdToTypeName(response.dataTypeId);

                    // if the type cannot be found return a blank type object.
                    if (typeof (typeName) === "undefined") {
                        typeName = this.fStore.blankTemplate;
                    }

                    foundProperties.push({
                        id: response.id,
                        name: response.propertyName,
                        property: response.propertyName,
                        dataType: typeName
                    });
                },
                failure: function (data) {
                }
            });
            return foundProperties;
        },

        store: new JsonRest({
            target: "",
            selectedEntity: '',

            types: null,
            filterByType: false,
            onlyProperties: false,
            allTypes: null,

            baseTemplate: "${0}:${1}${2}", // BaseEntity:[relationTemplate]{Field}
            relationTemplate: "${0}${1}${2}.${3}!",//{ParentKey}(> or = depending on the relation){ChildKey}.ChildEntity!

            maxLevel: -1,

            addins: false,

            dataTypeIdToTypeName: function (id) {
                var index = this.types.index[id];
                return this.types.data[index];
            },
            getChildren: function (object, onComplete) {
                var items = new memory();
                var entity, property, oldrelationPath, base;

                var baseTemplate = this.baseTemplate;
                var relationTemplate = this.relationTemplate;

                var typesWanted = this.types;
                var filterByType = this.filterByType;
                var allTypes = this.allTypes;

                if (object.name == 'rootNode') {
                    entity = this.selectedEntity;
                    property = '';
                    oldrelationPath = '';
                    base = entity;
                }
                else {
                    entity = object.relatedEntity;
                    property = object.property + '.';
                    oldrelationPath = object.oldrelationPath ? object.oldrelationPath : '';
                    base = object.base;
                }

                var currentLevel = object.Level + 1;

                var wait = [], deferred;
                deferred = new Deferred();
                var listOfDeferred = [];
                ///////////////////////////////////////////////////
                // Request 1
                if (entity.length > 0) {
                    var promise1 = request(new Sage.SData.Client.SDataSingleResourceRequest(Sage.Data.SDataServiceRegistry.getSDataService('metadata'))
                        .setResourceKind('entities')
                        .setResourceSelector('"' + entity + '"')
                        .setQueryArg('select', 'properties/*').setQueryArg('format', 'json').setQueryArg('Count', '500')).then(function (response) {
                            var result = json.parse(response);
                            var entityFields = result.properties.$resources;
                            for (var i = 0; i <= entityFields.length - 1; i++) {
                                var enFi = entityFields[i];
                                if (enFi.isIncluded === true) {
                                    if (filterByType) {
                                        var index = typesWanted.index[enFi.dataTypeId];
                                        if (index >= 0) {
                                            var typeName = typesWanted.data[index];
                                            items.add({
                                                id: enFi.id,
                                                display: enFi.displayName,
                                                columName: property + enFi.columnName,
                                                name: enFi.propertyName,
                                                property: property + enFi.propertyName,
                                                dataType: typeName,
                                                Level: currentLevel,
                                                legacyPath: dString.substitute(baseTemplate, [base, oldrelationPath, enFi.columnName])
                                            });
                                        }
                                    }
                                    else {
                                        var tni = allTypes.index[enFi.dataTypeId];
                                        if (tni >= 0) {
                                            var tn = allTypes.data[tni];
                                            items.add({
                                                id: enFi.id,
                                                display: enFi.displayName,
                                                columName: property + enFi.columnName,
                                                name: enFi.propertyName,
                                                property: property + enFi.propertyName,
                                                dataType: tn,
                                                Level: currentLevel,
                                                legacyPath: dString.substitute(baseTemplate, [base, oldrelationPath, enFi.columnName])
                                            });
                                        }
                                    }
                                }
                            }
                        });

                    listOfDeferred.push(promise1);
                    if (!this.onlyProperties) {
                        // Request 2
                        var whereString = dString.substitute(
                                '(parentEntity.name eq "${0}") or (childEntity.name eq "${0}")', [entity]
                                );
                        if (filterByType < 26) {
                            whereString = dString.substitute(
                                '(parentEntity.name eq "${0}" and cardinality eq "M:1") or (childEntity.name eq "${0}" and cardinality eq "1:M")', [entity]
                            );
                        }
                        var promise2 = request(new Sage.SData.Client.SDataResourceCollectionRequest(Sage.Data.SDataServiceRegistry.getSDataService('metadata'))
                            .setResourceKind('relationships')
                            .setQueryArg('select', 'isDynamic,cardinality,parentEntity/*,childEntity/*,parentProperty/*,childProperty/*,columns/*')
                            .setQueryArg('where', whereString)
                            .setQueryArg('format', 'json')
                                .setQueryArg('Count', '500')).then(function (response) {
                                    var result = json.parse(response);
                                    var entityFields = result.$resources;
                                    for (var i = 0; i <= entityFields.length - 1; i++) {

                                        var relItem = entityFields[i];
                                        var childColName = relItem.childEntity.properties.$resources.filter(function (v) {
                                            return v.id === relItem.columns.$resources[0].childPropertyId;
                                        });
                                        if (childColName[0] && childColName[0].columnName) {
                                            childColName = childColName[0].columnName;
                                        }
                                        var parentColName = relItem.parentEntity.properties.$resources.filter(function (v) {
                                            return v.id === relItem.columns.$resources[0].parentPropertyId;
                                        });
                                        if (parentColName[0] && parentColName[0].columnName) {
                                            parentColName = parentColName[0].columnName;
                                        }
                                        if (entity == relItem['parentEntity']['$key'] && relItem['parentProperty']['isIncluded']) {
                                            items.add({
                                                name: relItem['parentProperty']['propertyName'],
                                                id: relItem['parentProperty']['id'],
                                                relatedEntity: relItem['childEntity']['$key'],
                                                "children": "test",
                                                property: property + relItem['parentProperty']['propertyName'],
                                                base: base,
                                                dataType: '',
                                                Level: currentLevel,
                                                parentTable: relItem.parentEntity.tableName,
                                                childTable: relItem.childEntity.tableName,
                                                parentKey: parentColName,
                                                childKey: childColName,
                                                oldrelationPath: oldrelationPath + dString.substitute(relationTemplate, [parentColName, "=", childColName, relItem.childEntity.tableName])
                                            });
                                        }
                                        else if (entity == relItem['childEntity']['$key'] && relItem['childProperty']['isIncluded']) {
                                            items.add({
                                                name: relItem['childProperty']['propertyName'],
                                                id: relItem['childProperty']['id'],
                                                "children": "test",
                                                property: property + relItem['childProperty']['propertyName'],
                                                base: base,
                                                relatedEntity: relItem['parentEntity']['$key'],
                                                dataType: '',
                                                Level: currentLevel,
                                                parentTable: relItem.parentEntity.tableName,
                                                childTable: relItem.childEntity.tableName,
                                                parentKey: parentColName,
                                                childKey: childColName,
                                                oldrelationPath: oldrelationPath + dString.substitute(relationTemplate, [childColName, "=", parentColName, relItem.parentEntity.tableName])
                                            });
                                        }
                                    }
                                });
                        listOfDeferred.push(promise2);
                        // Request 3
                        var promise3 = request(new Sage.SData.Client.SDataSingleResourceRequest(Sage.Data.SDataServiceRegistry.getSDataService('metadata'))
                            .setResourceKind('entities')
                            .setQueryArg('where',
                                dString.substitute(
                                    'extendedEntity.name eq "${0}"', [entity]
                                ))
                            .setQueryArg('select', 'extendedEntityPropertyName').setQueryArg('format', 'json').setQueryArg('Count', '500')).then(function (response) {
                                var result = json.parse(response);
                                var entityFields = result.$resources;
                                for (var i = 0; i <= entityFields.length - 1; i++) {
                                    var itemEF = entityFields[i];
                                    items.add({
                                        name: itemEF.$key,
                                        id: itemEF.$key,
                                        "children": "test",
                                        property: property + itemEF.$key,
                                        base: base,
                                        relatedEntity: itemEF.$key,
                                        dataType: '',
                                        Level: currentLevel
                                    });
                                }
                                this.currentLevel++;
                            });
                        listOfDeferred.push(promise3);
                    }
                }
                else {
                    var promise4 = request(new Sage.SData.Client.SDataSingleResourceRequest(Sage.Data.SDataServiceRegistry.getSDataService('metadata'))
                      .setResourceKind('entities')
                      .setQueryArg('select', 'extendedEntityPropertyName').setQueryArg('format', 'json').setQueryArg('Count', '500')).then(function (response) {
                          var result = json.parse(response);
                          var entityFields = result.$resources;
                          for (var i = 0; i <= entityFields.length - 1; i++) {
                              var itemEF = entityFields[i];
                              items.add({
                                  name: itemEF.$key,
                                  id: itemEF.$key,
                                  "children": "test",
                                  property: property + itemEF.$key,
                                  base: base,
                                  relatedEntity: itemEF.$key,
                                  dataType: '',
                                  Level: currentLevel
                              });
                          }
                      });
                    listOfDeferred.push(promise4);
                }

                var list = new DeferredList(listOfDeferred);
                list.then(function (result) {

                    var sortOn = 'name';
                    items.data.sort(function (a, b) {
                        var nameA = a[sortOn],
                            nameB = b[sortOn];

                        return (nameA < nameB)
                            ? -1
                            : (nameA > nameB)
                                ? 1
                                : 0;
                    });
                    onComplete(items.data);
                });
            },
            getRoot: function (onItem) {
                var data =
                       {
                           "name": "rootNode",
                           "id": "root",
                           "Level": 0
                       };
                onItem(data);
            },
            mayHaveChildren: function (item) {
                var bool = "children" in item;
                return bool && ((this.maxLevel >= 0 && item.Level < this.maxLevel) || this.maxLevel < 0);
            },
            getLabel: function (object) {
                return object.name;
            }
        })

    });
    return PropertyStoreModel;
});


},
'Sage/UI/Controls/FieldStore':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/string',
    'dojo/_base/declare',
    "dojo/_base/lang",
    'dojo/store/Memory',
    'dojo/i18n!./nls/PropertyStore',
    'Sage/UI/Controls/FieldPropertyObject'
],
function (
    dString,
    declare,
    lang,
    memory,
    nlsResource,
    FieldPropertyObject
) {


    var FieldStoreModel = declare('Sage.UI.Controls.FieldStore', null, {
        typeStore: null,
        _nlsResource: null,
        isUnicode: false,
        blankTemplate: null,

        // queryOptions contains the 3 different type filters.
        constructor: function (queryOptions) {
            this._nlsResource = nlsResource;
            this.populateSystemOptions();

            this.blankTemplate = new FieldPropertyObject("", "", this.isUnicode);

            //FieldPropertyObject({type id}, {localized name}, {db encoding=unicode?}, {This type is currently supported})
            // all types should be in this list since it is used to get the localized type name.
            this.typeStore = new memory({
                data: [
                    // property types; type=base
                        new FieldPropertyObject('47f90249-e4c8-4564-9ae6-e1fa9904f8b8', this._nlsResource['integer'], this.isUnicode, true),            // integer
                        new FieldPropertyObject('f37c635c-9fbf-40d8-98d5-750a54a3cca1', this._nlsResource['double'], this.isUnicode, true),             // double
                        new FieldPropertyObject('a6bf2690-3477-4a18-9849-56abf8693934', this._nlsResource['single'], this.isUnicode, true),             // single
                        new FieldPropertyObject('2596d57d-89d6-4b72-9036-b18c64c5324c', this._nlsResource['decimal'], this.isUnicode, true),            // decimal
                        new FieldPropertyObject('6b0b3d51-0728-4b67-9473-52836a81da53', this._nlsResource['short'], this.isUnicode, true),              // short
                        new FieldPropertyObject('30053f5a-8d40-4db1-b185-1e4128eb26cc', this._nlsResource['standardId'], this.isUnicode, true),         // standard id
                        new FieldPropertyObject('92432b4d-8206-4a96-ba7b-e4cbd374f148', this._nlsResource['trueFalse'], this.isUnicode, true),          // true/false
                        new FieldPropertyObject('95ca9d52-6f0b-4a96-bd40-43583f41faf8', this._nlsResource['yesNo'], this.isUnicode, true),              // yesNo
                        new FieldPropertyObject('3edc7c52-e711-431d-b150-969d88ebabf4', this._nlsResource['boolean'], this.isUnicode, true),            // boolean
                        new FieldPropertyObject('1f08f2eb-87c8-443b-a7c2-a51f590923f5', this._nlsResource['dateTime'], this.isUnicode, true),           // dateTime
                        new FieldPropertyObject('31e8638d-4232-4c61-8827-d94132a33887', this._nlsResource['email'], this.isUnicode, true),              // email
                        new FieldPropertyObject('85f2bba5-1fb7-4ecf-941a-d98d4739c305', this._nlsResource['phone'], this.isUnicode),                    // phone
                        new FieldPropertyObject('b71918bf-fac1-4b62-9ed5-0b0294bc9900', this._nlsResource['pickList'], this.isUnicode, true),           // picklist
                        new FieldPropertyObject('17541523-fc31-4269-ac97-df63290d0e31', this._nlsResource['owner'], this.isUnicode, true),              // owner
                        new FieldPropertyObject('a3b52518-801b-44be-96bf-fdca3de84f7f', this._nlsResource['lookup'], this.isUnicode, false),            // lookup
                        new FieldPropertyObject('517d5e69-9efa-4d0a-8e7a-1c7691f921ba', this._nlsResource['dependencyLookup'], this.isUnicode, false),  // dependency lookup
                        new FieldPropertyObject('189a1a4e-396c-4146-95c0-93b5d9e7d160', this._nlsResource['char'], this.isUnicode, true),               // character
                        new FieldPropertyObject('8edd8fce-2be5-4d3d-bedd-ea667e78a8af', this._nlsResource['enum_'], this.isUnicode, false),             // enumeration
                        new FieldPropertyObject('3ca925e1-4b76-4621-a39c-a0d4cb7327d5', this._nlsResource['guid'], this.isUnicode, true),               // guid
                        new FieldPropertyObject('68e04249-f7e2-4b63-90be-55fbb1f4aa77', this._nlsResource['byte'], this.isUnicode, true),               // byte
                        new FieldPropertyObject('07370ef3-ad24-409f-86a8-ff2db5ee6d69', this._nlsResource['binary'], this.isUnicode, true),             // binary
                        new FieldPropertyObject('5685161e-5f0a-4a36-83fe-89e8e462e9e7', this._nlsResource['url'], this.isUnicode, true),                // url
                        new FieldPropertyObject('f750817f-73ad-4bf3-b2de-bd0f5cc47dfd', this._nlsResource['calcSF'], this.isUnicode, true),             // calculated string field 
                        new FieldPropertyObject('44bc190a-99f3-4fa9-98a3-d5b2336d6e7c', this._nlsResource['calcNF'], this.isUnicode, true),             // calculated number field 
                        new FieldPropertyObject('76c537a8-8b08-4b35-84cf-fa95c6c133b0', this._nlsResource['text'], this.isUnicode, this.isUnicode),     // Text (unicode)
                        new FieldPropertyObject('b2ed309e-ea89-4eef-8051-6244987953a4', this._nlsResource['memo'], this.isUnicode, this.isUnicode),     // Memo (unicode)
                        new FieldPropertyObject('ccc0f01d-7ba5-408e-8526-a3f942354b3a', this._nlsResource['text'], this.isUnicode, !this.isUnicode),    // Text
                        new FieldPropertyObject('f4ca6023-9f5f-4e41-8571-50ba94e8f233', this._nlsResource['memo'], this.isUnicode, !this.isUnicode)     // Memo
                ]
            });
        },
        _addSystemIfNeeded: function (strVal) {
            if (strVal.indexOf("System") < 0) {
                strVal = dString.substitute("System.${0}", [strVal]);
            }
            return strVal;
        },
        query: function (queryOptions) {
            var typeIdArg = null;
            var parentTypeArg = null;

            if (typeof (queryOptions) !== "undefined") {
                if (typeof (queryOptions.superType) !== "undefined" && queryOptions.superType !== null) { // apply a filter to the superType ie if the type is text it is apart of the string superType
                    parentTypeArg = queryOptions.superType;
                    if (lang.isArray(parentTypeArg)) {
                        for (var i = 0; i < parentTypeArg.length; i++) {
                            parentTypeArg[i] = this._addSystemIfNeeded(parentTypeArg[i]);
                        }
                    }
                    else {
                        parentTypeArg = this._addSystemIfNeeded(parentTypeArg);
                    }
                }
                // apply a filter to the id... assuming one knows the id ahead of time
                if (typeof (queryOptions.typeId) !== "undefined" && queryOptions.typeId !== null) { 
                    typeIdArg = queryOptions.typeId;
                }
            }

            var data = this.typeStore.query(
                function (curr) {
                    var include = true;

                    // handles the relationship between the lookup by id and lookup by a readable name, which is for now if either match then include.
                    var tmp = false; 
                    if (parentTypeArg !== null) {
                        tmp = parentTypeArg.indexOf(curr.ClrDataType) >= 0;
                        include = tmp;
                    }

                    if (typeIdArg !== null) {
                        tmp = tmp || parentTypeArg.indexOf(curr.id) >= 0;
                        include = tmp; 
                    }
                    return include;
                });

            return new memory({ data: data }); // place in a memory object incase user wants to reference via index.
        },

        queryByKeyWordsAllMatch: function (keywords) {
            var data = this.typeStore.query(
                function (curr) {
                    var include = false;
                    for (var i = 0; i < keywords.length; i++) {
                        var k = keywords[i];
                        var v = false;
                        if (curr[k.name] === k.value) {
                            v = true;
                            if (i === 0) {
                                include = true;
                            }
                        }
                        include = include && v;
                    }
                    return include;
                });

            return new memory({ data: data }); // place in a memory object incase user wants to reference via index.
        },
        queryByKeywordsOneMatchMatch: function (keywords) {
            var data = this.typeStore.query(
                function (curr) {
                    for (var i = 0; i < keywords.length; i++) {
                        var k = keywords[i];
                        if (curr[k.name] === k.value) {
                            return true;
                        }
                    }
                    return false;
                });

            return new memory({ data: data }); // place in a memory object incase user wants to reference via index.
        },
        // Handles querying for the User Options
        populateSystemOptions: function () {
            var callback = this._receivedUnicode;
            var selfContext = this;
            var optionsSvc = Sage.Services.getService('SystemOptions');
            if (optionsSvc) {
                optionsSvc.get('Unicode',
                    function (v) {
                        callback(v, selfContext);
                    });
            }
        },
        // once options are recieved, set the appropreate attributes.
        _receivedUnicode: function (value, selfContext) {
            selfContext.isUnicode = value ? value.toLowerCase() === "true" : false; // we want to display a selector column
        }

    });
    return FieldStoreModel;
});


},
'Sage/UI/Controls/FieldPropertyObject':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/string',
    'dojo/_base/declare',
    'dojo/store/Memory',
    'dojo/i18n!./nls/PropertyStore',
    'dojo/_base/lang'
],
function (
    dString,
    declare,
    memory,
    nlsResource,
    lang
) {
    var base =
        {
            ClrDataType: '',
            SqlType: '',
            ThisObj: '',

            //categrories
            number: false,
            calculated: false,
            idType: false,
            bitType: false,
            complex: false,
            isBoolean: false,
            dateTime: false,

            initializeBaseData: function () {
                switch (this.id) {
                    //BASE
                    case 'a6bf2690-3477-4a18-9849-56abf8693934': //single
                        this.ClrDataType = "System.Single";
                        this.SqlType = "Single";
                        this.ThisObj = "Single";
                        this.number = true;
                        break;
                    case '6b0b3d51-0728-4b67-9473-52836a81da53': //short
                        this.ClrDataType = "System.Int16";
                        this.SqlType = "Int16";
                        this.ThisObj = "Short Integer";
                        this.number = true;
                        break;
                    case '47f90249-e4c8-4564-9ae6-e1fa9904f8b8': //integer
                        this.ClrDataType = "System.Int32";
                        this.SqlType = "Int32";
                        this.ThisObj = "Integer";
                        this.number = true;
                        break;
                    case '95ca9d52-6f0b-4a96-bd40-43583f41faf8': //yesNo
                        this.ClrDataType = "System.Boolean";
                        this.SqlType = "AnsiStringFixesLength";
                        this.ThisObj = "Yes/No";
                        this.isBoolean = true;
                        break;
                    case '3edc7c52-e711-431d-b150-969d88ebabf4': //boolean
                        this.ClrDataType = "System.Boolean";
                        this.SqlType = "Boolean";
                        this.ThisObj = "Boolean";
                        this.isBoolean = true;
                        break;
                    case '1f08f2eb-87c8-443b-a7c2-a51f590923f5': //dateTime
                        this.ClrDataType = "System.DateTime";
                        this.SqlType = "DateTime";
                        this.ThisObj = "DateTime";
                        this.dateTime = true;
                        break;
                    case '189a1a4e-396c-4146-95c0-93b5d9e7d160': //char
                        this.ClrDataType = "System.Char";
                        this.SqlType = "AnsiString(Length=1)";
                        this.ThisObj = "Char";
                        break;
                    case '68e04249-f7e2-4b63-90be-55fbb1f4aa77': //byte
                        this.ClrDataType = "System.Byte";
                        this.SqlType = "Byte";
                        this.ThisObj = "Byte";
                        this.bitType = true;
                        break;

                        //Length&ENCRYPTED
                    case 'ccc0f01d-7ba5-408e-8526-a3f942354b3a': //text
                        this.ClrDataType = "System.String";
                        this.SqlType = "AnsiString";
                        this.ThisObj = "Text";
                        break;
                    case 'f4ca6023-9f5f-4e41-8571-50ba94e8f233': //memo
                        this.ClrDataType = "System.String";
                        this.SqlType = "AnsiString";
                        this.ThisObj = "Memo";
                        break;
                    case '31e8638d-4232-4c61-8827-d94132a33887': //email
                        this.ClrDataType = "System.String";
                        this.SqlType = "AnsiString";
                        this.ThisObj = "Email";
                        break;
                    case '07370ef3-ad24-409f-86a8-ff2db5ee6d69': //binary
                        this.ClrDataType = "System.Byte[]";
                        this.SqlType = "Binary";
                        this.ThisObj = "Binary";
                        this.bitType = true;
                        break;
                    case '76c537a8-8b08-4b35-84cf-fa95c6c133b0': //unicodetext
                        this.ClrDataType = "System.String";
                        this.SqlType = "String";
                        this.ThisObj = "Unicode Text";
                        break;
                    case 'b2ed309e-ea89-4eef-8051-6244987953a4': //unicodeMemo
                        this.ClrDataType = "System.String";
                        this.SqlType = "String";
                        this.ThisObj = "Unicode Memo";
                        break;
                    case 'f750817f-73ad-4bf3-b2de-bd0f5cc47dfd': //calculatedString
                        this.ClrDataType = "System.String";
                        this.SqlType = "AnsiString";
                        this.ThisObj = "Calculated String field";
                        this.calculated = true;
                        break;
                    case '5685161e-5f0a-4a36-83fe-89e8e462e9e7': //url
                        this.ClrDataType = "System.String";
                        this.SqlType = "AnsiString";
                        this.ThisObj = "URL";
                        break;
                    case '85f2bba5-1fb7-4ecf-941a-d98d4739c305': //phone
                        this.ClrDataType = "System.String";
                        this.SqlType = "AnsiString";
                        this.ThisObj = "Phone Number";
                        break;
                    case '2596d57d-89d6-4b72-9036-b18c64c5324c': //decimal
                        this.ClrDataType = "System.Decimal";
                        this.SqlType = "Decimal";
                        this.ThisObj = "Decimal";
                        this.number = true;
                        break;
                    case 'f37c635c-9fbf-40d8-98d5-750a54a3cca1': //double
                        this.ClrDataType = "System.Double";
                        this.SqlType = "Double";
                        this.ThisObj = "Double";
                        this.number = true;
                        break;
                    case '44bc190a-99f3-4fa9-98a3-d5b2336d6e7c': //calculatedNumber
                        this.ClrDataType = "System.Double";
                        this.SqlType = "Double";
                        this.ThisObj = "Calculated Numeric Field";
                        this.number = true;
                        this.calculated = true;
                        break;
                    case '30053f5a-8d40-4db1-b185-1e4128eb26cc': //standardId
                        this.ClrDataType = "System.String";
                        this.SqlType = "AnsiStringFixedLength";
                        this.ThisObj = "Standard Id";
                        this.idType = true;
                        break;
                    case '17541523-fc31-4269-ac97-df63290d0e31': //owner
                        this.ClrDataType = "System.String";
                        this.SqlType = "AnsiStringFixedLength";
                        this.ThisObj = "owner";
                        break;
                    case '92432b4d-8206-4a96-ba7b-e4cbd374f148': //trueFalse
                        this.ClrDataType = "System.Boolean";
                        this.SqlType = "AnsiStringFixedLength";
                        this.ThisObj = "True/False";
                        this.isBoolean = true;
                        break;
                    case 'b71918bf-fac1-4b62-9ed5-0b0294bc9900': //pickList
                        this.ClrDataType = "System.String";
                        this.SqlType = "AnsiString";
                        this.ThisObj = "PickList";
                        this.complex = true;
                        break;
                    case 'a3b52518-801b-44be-96bf-fdca3de84f7f': //lookup
                        this.ClrDataType = "System.String";
                        this.SqlType = "AnsiString";
                        this.ThisObj = "Lookup";
                        this.complex = true;
                        break;
                    case '517d5e69-9efa-4d0a-8e7a-1c7691f921ba': //dependencyLookup
                        this.ClrDataType = "System.String";
                        this.SqlType = "AnsiString";
                        this.ThisObj = "Dependency Lookup";
                        this.complex = true;
                        break;
                    case '8edd8fce-2be5-4d3d-bedd-ea667e78a8af': //enum
                        this.ClrDataType = "System.Enum";
                        this.SqlType = "AnsiString(Length=255)";
                        this.ThisObj = "Enum";
                        this.complex = true;
                        break;
                    case '3ca925e1-4b76-4621-a39c-a0d4cb7327d5': //guid
                        this.ClrDataType = "System.Guid";
                        this.SqlType = "Guid";
                        this.ThisObj = "Guid";
                        this.idType = true;
                        break;
                }
            }
        };
    var Length =
        {
            Length: 0,

            initializeLengthData: function () {
                switch (this.id) {
                    //BASE
                    case 'a6bf2690-3477-4a18-9849-56abf8693934': //single
                        this.Length = 64;
                        this.SqlType = dString.substitute("${0}(Length=${1})", [this.SqlType, this.Length]);
                        break;
                    case '95ca9d52-6f0b-4a96-bd40-43583f41faf8': //yesNo
                        this.Length = 1;
                        this.SqlType = dString.substitute("${0}(Length=${1})", [this.SqlType, this.Length]);
                        break;

                        //Length&ENCRYPTED
                    case 'ccc0f01d-7ba5-408e-8526-a3f942354b3a': //text
                        this.Length = 255;
                        this.SqlType = dString.substitute("${0}(Length=${1})", [this.SqlType, this.Length]);
                        break;
                    case 'f4ca6023-9f5f-4e41-8571-50ba94e8f233': //memotext
                        this.Length = 2147483647;
                        this.SqlType = dString.substitute("${0}(Length=${1})", [this.SqlType, this.Length]);
                        break;
                    case '31e8638d-4232-4c61-8827-d94132a33887': //email
                        this.Length = 128;
                        this.SqlType = dString.substitute("${0}(Length=${1})", [this.SqlType, this.Length]);
                        break;
                    case '07370ef3-ad24-409f-86a8-ff2db5ee6d69': //binary
                        this.Length = 8000;
                        this.SqlType = dString.substitute("${0}(Length=${1})", [this.SqlType, this.Length]);
                        break;
                    case '76c537a8-8b08-4b35-84cf-fa95c6c133b0': //unicodetext
                        this.Length = 255;
                        this.SqlType = dString.substitute("${0}(Length=${1})", [this.SqlType, this.Length]);
                        break;
                    case 'b2ed309e-ea89-4eef-8051-6244987953a4': //unicodeMemo
                        this.Length = 2147483647;
                        this.SqlType = dString.substitute("${0}(Length=${1})", [this.SqlType, this.Length]);
                        break;
                    case 'f750817f-73ad-4bf3-b2de-bd0f5cc47dfd': //calculatedString
                        this.Length = 255;
                        this.SqlType = dString.substitute("${0}(Length=${1})", [this.SqlType, this.Length]);
                        break;
                    case '5685161e-5f0a-4a36-83fe-89e8e462e9e7': //url
                        this.Length = 150;//2147483647;
                        this.SqlType = dString.substitute("${0}(Length=${1})", [this.SqlType, this.Length]);
                        break;
                    case '85f2bba5-1fb7-4ecf-941a-d98d4739c305': //phone
                        this.Length = 255;
                        this.SqlType = dString.substitute("${0}(Length=${1})", [this.SqlType, this.Length]);
                        break;
                    case '30053f5a-8d40-4db1-b185-1e4128eb26cc': //standardId
                        this.Length = 12;
                        this.SqlType = dString.substitute("${0}(Length=${1})", [this.SqlType, this.Length]);
                        break;
                    case '17541523-fc31-4269-ac97-df63290d0e31': //owner
                        this.Length = 12;
                        this.SqlType = dString.substitute("${0}(Length=${1})", [this.SqlType, this.Length]);
                        break;
                    case '92432b4d-8206-4a96-ba7b-e4cbd374f148': //trueFalse
                        this.Length = 1;
                        this.SqlType = dString.substitute("${0}(Length=${1})", [this.SqlType, this.Length]);
                        break;
                    case 'b71918bf-fac1-4b62-9ed5-0b0294bc9900': //pickList
                        this.Length = 64;
                        this.SqlType = dString.substitute("${0}(Length=${1})", [this.SqlType, this.Length]);
                        break;
                    case 'a3b52518-801b-44be-96bf-fdca3de84f7f': //lookup
                        this.Length = 64;
                        this.SqlType = dString.substitute("${0}(Length=${1})", [this.SqlType, this.Length]);
                        break;
                    case '517d5e69-9efa-4d0a-8e7a-1c7691f921ba': //dependencyLookup
                        this.Length = 64;
                        this.SqlType = dString.substitute("${0}(Length=${1})", [this.SqlType, this.Length]);
                        break;

                }
            }
        };
    var encrypted =
                {
                    IsEncrypted: false

                };
    var PrecisionScale =
        {
            Precision: 17,
            Scale: 4,

            initializePrecisionScaleData: function () {
                this.SqlType = dString.substitute("${0}(Precision=${1},Scale=${2})", [this.SqlType, this.Precision, this.Scale]);
            }
        };
    var IsPercentage =
        {
            IsPercentage: false
        };
    var Storage =
        {
            Display: '',
            Storage: '',
            StorageOptions: [],
            DisplayOptions: [],

            initializeStorageData: function () {
                this.Display = '';
                this.Storage = '';
                this.StorageOptions = [];
                this.DisplayOptions = [];
                switch (this.id) {

                    case 'b71918bf-fac1-4b62-9ed5-0b0294bc9900': //pickList

                        this.StorageOptions = [{ id: 'Id', name: nlsResource['id'] }, { id: 'Number', name: nlsResource['number'] }];
                        this.DisplayOptions = [{ id: 'Id', name: nlsResource['id'] }, { id: 'Number', name: nlsResource['number'] }, { id: 'Text', name: nlsResource['text'] }, { id: 'Code', name: nlsResource['code'] }];

                        this.Display = "Text"; // <--used by picklist only.
                        if (this.unicode) {
                            this.Storage = 'TextUnicode';
                            this.StorageOptions.push({ id: 'TextUnicode', name: nlsResource['text'] });
                            this.StorageOptions.push({ id: 'CodeUnicode', name: nlsResource['code'] });
                        }
                        else {
                            this.Storage = 'Text';
                            this.StorageOptions.push({ id: 'Text', name: nlsResource['text'] });
                            this.StorageOptions.push({ id: 'Code', name: nlsResource['code'] });
                        }
                        break;
                    case '8edd8fce-2be5-4d3d-bedd-ea667e78a8af': //enum

                        this.StorageOptions = [{ id: 'Value', name: nlsResource['value'] }];
                        if (this.unicode) {
                            this.Storage = 'NameUnicode';
                            this.StorageOptions.push({ id: 'NameUnicode', name: nlsResource['name'] });
                            this.StorageOptions.push({ id: 'CodeUnicode', name: nlsResource['code'] });
                        }
                        else {
                            this.Storage = 'Name';
                            this.StorageOptions.push({ id: 'Name', name: nlsResource['name'] });
                            this.StorageOptions.push({ id: 'Code', name: nlsResource['code'] });
                        }
                        break;
                    case '3ca925e1-4b76-4621-a39c-a0d4cb7327d5': //guid

                        //this.StorageOptions = [{ id: 'Native', name: nlsResource['native'] }]; //<-- this is not supported by Sage.Saleslogix
                        if (this.unicode) {
                            this.Storage = 'StringUnicode';
                            this.StorageOptions.push({ id: 'StringUnicode', name: nlsResource['string'] });
                        }
                        else {
                            this.Storage = 'String';
                            this.StorageOptions.push({ id: 'String', name: nlsResource['string'] });
                        }
                        break;
                }
            }
        };
    var _Enum =
        {
            //Storage WILL BE INCLUDED
            Items: [],
            MultiSelect: false,
            OverriddenName: ''
        };
    var dLookup =
        {
            //Length WILL BE INCLUDED
            LookupEntityName: '',
            LookupGroup: 1.0,
            ParentProperty: ''

        };
    var lookup =
        {
            //include Length
            EnableHyperLinking: false,
            LookupEntityName: '',
            LookupPreFilters: [],
            LookupProperties: [],
            ReturnPrimaryKey: true

        };
    var picklist =
        {
            //Include Storage and Length
            PickListId: '',
            PickListName: '',
            AllowMultiples: false,
            AlphaSort: false,
            MustExistInList: true,
            NoneEditable: false,
            PickListFilter: '',
            ValueStoredAsText: true
        };
    var calculated =
        {
            DisplayName: "", //defaults as the displayName of the field
            Description: "",
            Template: "",
            type: -1, //-1 - Not set, type invalid; 0 - Calculated String Field; 1 - Calculated Number Field.
            oldTemplate: ""
        };
    var property = declare('Sage.UI.Controls.FieldPropertyObject', null, {
        id: '',
        name: '',
        aggregate: [],
        show: [],
        unicode: false,
        supported: true,
        numbers: ['Int16', 'Int32', 'Double', 'Float', 'Decimal', 'Single', 'DateTime', 'Date', 'Time'],

        hidden: [],

        constructor: function (id, name, isUnicode, isSupported) {
            var NumericAggs = ['sum', 'count', 'avg', 'min', 'max'];
            var OtherAggs = ['count', 'min', 'max'];

            if (isSupported !== null && typeof (isSupported) !== "undefined") {
                this.supported = isSupported;
            }

            if (isUnicode !== null && typeof (isUnicode) !== "undefined") {
                this.unicode = isUnicode;
            }
            this.id = id;
            this.name = name;

            lang.mixin(this, base);
            this.initializeBaseData();

            // blank SqlTypes should probably show all of the aggregrate options
            if (this.numbers.indexOf(this.SqlType) >= 0 || this.SqlType === "" || typeof (this.SqlType) === 'undefined') {
                this.aggregate = NumericAggs;
            } else {
                this.aggregate = OtherAggs;
            }

            switch (this.id) {
                //BASE
                case 'a6bf2690-3477-4a18-9849-56abf8693934': //single
                case '6b0b3d51-0728-4b67-9473-52836a81da53': //short
                case '47f90249-e4c8-4564-9ae6-e1fa9904f8b8': //integer
                case '95ca9d52-6f0b-4a96-bd40-43583f41faf8': //yesNo
                case '3edc7c52-e711-431d-b150-969d88ebabf4': //boolean
                case '1f08f2eb-87c8-443b-a7c2-a51f590923f5': //dateTime
                case '189a1a4e-396c-4146-95c0-93b5d9e7d160': //char
                case '68e04249-f7e2-4b63-90be-55fbb1f4aa77': //byte
                case '30053f5a-8d40-4db1-b185-1e4128eb26cc': //standardId ->contains Length, but it is not editable
                case '17541523-fc31-4269-ac97-df63290d0e31': //owner->contains Length, but it is not editable
                case '92432b4d-8206-4a96-ba7b-e4cbd374f148': //trueFalse->contains Length, but it is not editable
                    break;
                    //Length&ENCRYPTED
                case 'ccc0f01d-7ba5-408e-8526-a3f942354b3a': //text
                case 'f4ca6023-9f5f-4e41-8571-50ba94e8f233': //memo
                case '31e8638d-4232-4c61-8827-d94132a33887': //email
                case '76c537a8-8b08-4b35-84cf-fa95c6c133b0': //unicodetext
                case 'b2ed309e-ea89-4eef-8051-6244987953a4': //unicodeMemo
                case '5685161e-5f0a-4a36-83fe-89e8e462e9e7': //url
                case '85f2bba5-1fb7-4ecf-941a-d98d4739c305': //phone
                case '07370ef3-ad24-409f-86a8-ff2db5ee6d69': //binary -> contains Length and encrypted fields, but only encrypted is editable.
                    lang.mixin(this, Length);
                    this.initializeLengthData();
                    lang.mixin(this, encrypted);
                    this.show = ["Length", "IsEncrypted"];
                    break;
                case '2596d57d-89d6-4b72-9036-b18c64c5324c': //decimal
                    lang.mixin(this, PrecisionScale);
                    this.initializePrecisionScaleData();
                    this.show = ["Precision", "Scale"];
                    break;
                case 'f37c635c-9fbf-40d8-98d5-750a54a3cca1': //double
                    lang.mixin(this, IsPercentage);
                    this.show = ["IsPercentage"];
                    break;
                case 'b71918bf-fac1-4b62-9ed5-0b0294bc9900': //pickList
                    lang.mixin(this, Length);
                    this.initializeLengthData();
                    lang.mixin(this, Storage);
                    this.initializeStorageData();
                    lang.mixin(this, picklist);
                    this.show = ["Length", "Display", "Storage", "PickListName", "AllowMultiples", "AlphaSort", "MustExistInList", "NoneEditable", "ValueStoredAsText"];
                    break;
                case 'a3b52518-801b-44be-96bf-fdca3de84f7f': //lookup
                    lang.mixin(this, Length);
                    this.initializeLengthData();
                    lang.mixin(this, Storage);
                    this.initializeStorageData();
                    lang.mixin(this, lookup);
                    this.show = ["Length", "LookupEntityName", "EnableHyperLinking", "ReturnPrimaryKey", "LookupProperties", "LookupPreFilters"];
                    break;
                case '517d5e69-9efa-4d0a-8e7a-1c7691f921ba': //dependencyLookup
                    lang.mixin(this, Length);
                    this.initializeLengthData();
                    lang.mixin(this, dLookup);
                    this.show = ["Length", "LookupEntityName", "LookupGroup", "ParentProperty"];
                    break;
                case '8edd8fce-2be5-4d3d-bedd-ea667e78a8af': //enum
                    lang.mixin(this, Storage);
                    this.initializeStorageData();
                    lang.mixin(this, _Enum);
                    this.show = ["Storage", "MultiSelect", "Items", "OverriddenName"];
                    break;
                case '3ca925e1-4b76-4621-a39c-a0d4cb7327d5': //guid
                    lang.mixin(this, Storage);
                    this.initializeStorageData();
                    this.show = ["Storage"];
                    break;

                case 'f750817f-73ad-4bf3-b2de-bd0f5cc47dfd': //calculatedString
                    lang.mixin(this, calculated);
                    this.type = 0;
                    this.show = ["Description", "Template"];
                    this.hidden = ["oldTemplate"];
                    break;

                case '44bc190a-99f3-4fa9-98a3-d5b2336d6e7c': //calculatedNumber
                    lang.mixin(this, calculated);
                    this.type = 1;
                    this.show = ["Description", "Template"];
                    this.hidden = ["oldTemplate"];
                    break;
            }
        }
    });
    return property;
});


},
'Sage/MainView/EntityMgr/AddEditEntityDetail/UserLookupDetailsView':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/_base/declare',
    'dojo/store/Memory',
    'dojo/text!./templates/UserLookupDetailsView.html',
    'Sage/MainView/EntityMgr/AddEditEntityDetail/_DetailsAddEditDialogBase',
    'Sage/UI/Controls/Grid',
    'Sage/UI/Controls/CheckBox'
],
function (
    declare,
    memory,
    template,
    _DetailsAddEditDialogBase,
    Grid,
    crmCheckBox) {
    var widget = declare('Sage.MainView.EntityMgr.AddEditEntityDetail.UserLookupDetailsView', [_DetailsAddEditDialogBase], {
        widgetTemplate: new Simplate(eval(template)),
        constructor: function () {
            this.hasProperties = true;
            this.isMetric = false;
        },
        postCreate: function () {
            this._createOperationsGrid();
            this.startup();
        },
        _createCustomCheckBox: function () {
            var custCheckBox = declare('Sage.MainView.EntityMgr.AddEditEntityFilter.customChkBx', Sage.UI.Controls.CheckBox, {
                shouldPublishMarkDirty: false,
                constructor: function () {
                },
                postCreate: function () {
                    if (this.hotKey !== '') {
                        this.focusNode.accessKey = this.hotKey;
                    }

                    this.connect(this, 'onChange', this.onChanged);
                }
            });
            return custCheckBox;
        },
        _createDataForList: function () {
            var list = this.detailUtility.operation.data;
            var datastore = new memory();

            for (var i = 0; i < list.length; i++) {
                var isChecked = false;
                if (this.details && this.details.userLookupFilter && this.details.userLookupFilter.operators && list[i].id) {
                    isChecked = this.details.userLookupFilter.operators.indexOf(list[i].id) >= 0;
                }
                datastore.add({ id: list[i].id, data: isChecked, label: list[i].name });
            }
            return datastore;
        },
        _createOperationsGrid: function () {
            var datastore = this._createDataForList();

            var grid = new Grid({
                gridLabel: this._nlsResources.lblOperators,
                store: datastore,
                sort: [{ attribute: 'label', descending: false }],
                columns: [
                    {
                        label: '',
                        field: 'data',
                        autoSave: true,
                        editable: true,
                        editor: this._createCustomCheckBox(),
                        id: 'col1',
                        width: 250
                    },
                {
                    label: '',
                    field: 'label',
                    autoSave: true,
                    editable: false,
                    id: 'col2',
                    width: 250
                }
                ],
                placeHolder: this.rangegridwhole,
                columnResizing: true,
                selectionMode: 'single',
                rowSelection: true,
                minRowsPerPage: datastore.data.length,
                maxRowsPerPage: datastore.data.length
            });
            this.rangeGridsObj = grid;
            this.lookupGridLabel.innerHTML = this._nlsResources.lblOperators;
            // make sure that the grid shows a horizontal scrollbar if all column cannot be displayed.
            grid._grid.onLoadComplete = function () {
                grid._grid.resize();
            };
        },
        /**
        * This is a last method in the initialization process. 
        * It is called after all the child widgets are rendered so it's good for a container widget to finish it's post rendering here. 
        * This is where the container widgets could for example set sizes of their children relative to it's own size.
        */
        startup: function () {
            this.inherited(arguments);
        },
        getDetails: function () {
            var list = this.rangeGridsObj.store.data;
            var datasource = [];
            for (var i = 0; i < list.length; i++) {
                var item = list[i];
                if (typeof (item) !== 'undefined' && typeof (item.data) !== 'undefined' && item.data) {
                    datasource.push(item.id);
                }
            }
            return { userLookupFilter: { operators: datasource } };
        }
    });
    return widget;
});
},
'Sage/UI/Controls/CheckBox':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
       'dijit/form/CheckBox',
       'dojo/_base/declare'
],
function(checkBox, declare) {
    var widget = declare('Sage.UI.Controls.CheckBox', checkBox, {
        hotKey: '',
        //.Net control behavior
        autoPostBack: false,
        labelText: '',
        labelPlacement: '',
        // @property {boolean} - Indicates whether the implementation should publish that it has dirty data to the ClientBindingManagerService.
        // default = true
        shouldPublishMarkDirty: true,
        constructor: function() {
        },
        postCreate: function () {
            if(this.hotKey !== '') {
                this.focusNode.accessKey = this.hotKey;
            }

            this.connect(this, 'onChange', this.onChanged);

            this._insertLabel();

            this.inherited(arguments);
        },
        _insertLabel: function() {
            var position = 'before',
                labelNode = null;

            if(this.labelPlacement === 'right') {
                position = 'after';
            }

            if(this.labelPlacement !== 'none') {
                labelNode = dojo.create('label', {'for': this.id, innerHTML: this.labelText}, this.domNode, position);
                if(this.labelPlacement === 'top') {
                    // Insert a break after the label, so it appears on top of the checkbox
                    dojo.create('br', null, labelNode, 'after');
                }
            }
        },
        onChanged: function (e) {
            // If configured to do so, publishes the markDirty event, showing that there is un-saved data. 
            if (this.shouldPublishMarkDirty) {
                dojo.publish("Sage/events/markDirty");
            }
            if (this.autoPostBack) {
                if (Sys) {
                    Sys.WebForms.PageRequestManager.getInstance()._doPostBack(this.id, '');
                }
            }
        }
    });
    
    return widget;
});


},
'Sage/Utility/GeneralSchemaReader':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/_base/declare',
    'dojo/store/Memory',
    'dojo/string',
    'dojo/_base/array',
    'Sage/Utility',
    'Sage/Utility/PropertySchemaReader',
    'Sage/Utility/FilterSchemaReader',
    'Sage/Utility/PickListSchemaReader',
    'dojo/request/xhr'
],
function (
    declare,
    Memory,
    dString,
    arrayUtil,
    SageUtility,
    _propertySchemaReader,
    _filterSchemaReader,
    _picklistSchemaReader,
    dojoRequest
) {
    var widget = declare('Sage.Utility.GeneralSchemaReader', [_propertySchemaReader, _filterSchemaReader, _picklistSchemaReader], {
        service: null,
        endpointBase: 'metadata',

        constructor: function (base) {
            this.changeService(base);
        },

        // Changes the base the service points to (system, metadata)
        changeService: function (base) {
            this.endpointBase = base;
            this.service = Sage.Data.SDataServiceRegistry.getSDataService(this.endpointBase);
        },
        // get the schema information
        getSchemaInformationFromSData: function () {
            var that = this;
            var hand = dojoRequest(dString.substitute('slxdata.ashx/slx/${0}/-/$schema', [this.endpointBase]),
                {
                    handleAs: 'xml',
                    preventCache: true,
                    sync: true
                }).then(function (data) {
                    var schemaData = SageUtility.parseXMLNode(data, {});
                    if (schemaData) {
                        that.sDataSuccessful(schemaData);
                    }
                },
                function (err) {
                    that._onError('Download', err);
                    return err;
                }
            );
        },
        sDataSuccessful: function (data) {
            var schemaData = data["xs:schema"];

            switch (this.endpointBase.toLocaleLowerCase()) {
                case "system": {
                    this._getPickListSchemaInformation(schemaData);
                    break;
                }
                default: {
                    this._getPropertySchemaInformation(schemaData);
                    this._getFilterSchemaInformation(schemaData);
                    break;
                }

            }
        }
    });
    return widget;
});
},
'Sage/Utility/PropertySchemaReader':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/_base/declare',
    'dojo/store/Memory',
    'dojo/string',
    'dojo/_base/array',
    'Sage/Utility/_SchemaReaderHelper'
],
function (
    declare,
    Memory,
    dString,
    arrayUtil,
    _schemaReaderHelper
) {
    var widget = declare('Sage.Utility.PropertySchemaReader', [_schemaReaderHelper], {

        propertyResourceNodes: null,
        property_object: null,
        constructor: function () {
            this.resetPropertySchemaInformation();
        },
        resetPropertySchemaInformation: function () {
            this.propertyResourceNodes=new Memory();
        },
        _getPropertySchemaInformation: function (endPointData) {
            var headName = 'property';
            this._findAndAdd(endPointData, headName);
            this.propertyResourceNodes = this._gatherNodesFromQueue(headName);
            if (this.propertyResourceNodes.data.length > 0) {
                this.property_object = this._buildObjectFromNodeList(this.propertyResourceNodes.data[0]);
            }
        }
    });
    return widget;
});
},
'Sage/Utility/_SchemaReaderHelper':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/_base/declare',
    'dojo/store/Memory',
    'dojo/string',
    'dojo/_base/array',
    'dojo/_base/lang'
],
function (
    declare,
    Memory,
    dString,
    arrayUtil,
    lang
) {
    var widget = declare('Sage.Utility._SchemaReaderHelper', null, {

        xsct: "xs:complexType",
        xsst: "xs:simpleType",
        xse: "xs:element",
        xsn: "xs:enumeration",
        xsr: "xs:restriction",
        xsa: "xs:all",
        xsy: "xs:anyAttribute",
        xss: "xs:sequence",
        xsc: "xs:choice",

        ddEnum: "${0}--enum",
        ddType: "${0}--type",
        ddList: "${0}--list",
        ddChoice: "${0}--choice",

        fieldNameSearch: "name",
        fieldTypeSearch: "type",
        fieldRelationshipSearch: "relationship",
        fieldIsCollectionSearch: "isCollection",

        nodeList: null,
        __populationQueue: null,
        constructor: function () {
            this.nodeList = new Memory();
            this.__populationQueue = [];
        },
        __getHeaderNodeByNameReturnAllElements: function (endPointData, nodeType, NodeName) {
            var header = this.__getHeaderNodeByNameReturnObject(endPointData, nodeType, NodeName);

            if (header !== null) {
                return this.__determineCorrectPathToTake(header);
            }
            else {
                return null;
            }
        },
        __getHeaderNodeByNameReturnObject: function (endPointData, nodeType, NodeName) {
            var header = endPointData[nodeType].filter(function (d) { return d['name'] === NodeName; });

            if (typeof (header) !== "undefined" && header !== null && header.length > 0) {
                return header[0];
            }
            else {
                return null;
            }
        },

        __addToNodeList: function (node, subKeep, collectionKeep) {
            var selfAware = this;
            if (dojo.isArray(node)) {
                arrayUtil.forEach(node, function (curr) {
                    selfAware.__addOrUpdateSingleNodeToNodeList(curr, subKeep, collectionKeep, null);
                });
            } else {
                selfAware.__addOrUpdateSingleNodeToNodeList(node, subKeep, collectionKeep, null);
            }
        },
        __addOrUpdateSingleNodeToNodeList: function (sdataList, collection, sub, index) {
            var isNew = index === null;
            var data = this.__populateNodeListItem(sdataList, collection, sub, isNew);
            if (!isNew) {
                this.__populationQueue[index] = data;
            }


        },
        __truthy: function (value) {
            var retValue = null;
            if (typeof (value) === "string") {
                value = value.toLowerCase();
                if (value === "true" || value === "1" || value === "t" || value === "yes" || value === "y") {
                    retValue = true;
                }
                if (value === "false" || value === "0" || value === "f" || value === "no" || value === "n") {
                    retValue = false;
                }
            }
            else {
                if (value === true || value === 1) {
                    retValue = true;
                }
                if (value === false || value === 0) {
                    retValue = false;
                }
            }
            return retValue;
        },
        __createNodeItem: function (node) {
            var isManadtory = typeof (node["sme:isMandatory"]) === "undefined" ? false : node["sme:isMandatory"],
                maxLength = typeof (node["sme:maxLength"]) === "undefined" ? null : node["sme:maxLength"],
                name = (node["name"]) === "undefined" ? "" : node["name"],
                label = typeof (node["sme:label"]) === "undefined" ? ((node["label"]) === "undefined" ? "" : node["label"]) : node["sme:label"],
                type = (typeof (node["type"]) === "undefined" ? "xs:string" : node["type"]),
                relationship = typeof (node["sme:relationship"]) === "undefined" ? null : node["sme:relationship"],
                isCollection = typeof (node["sme:isCollection"]) === "undefined" ? false : node["sme:isCollection"],
                sub = typeof (node["sub"]) === "undefined" ? null : node["sub"],
                collection = typeof (node["collection"]) === "undefined" ? null : node["collection"],
                value = typeof (node["value"]) === "undefined" ? null : node["value"];

            isCollection = this.__truthy(isCollection);

            var data = {
                name: name,
                label: label,
                type: type,
                maxLength: maxLength,
                manadtory: isManadtory,
                relationship: relationship,
                isCollection: isCollection,
                collection: collection,
                sub: sub,
                value: null,
                nameValue: value
            };
            if (node.superParentNodeName !== null && typeof (node.superParentNodeName) !== "undefined") {
                data.superParentNodeName = node.superParentNodeName;
            }
            if (node.pathFromParent !== null && typeof (node.pathFromParent) !== "undefined") {
                data.pathFromParent = node.pathFromParent;
            }
            this.__addToQueue(data);
            return data;
        },
        __inQueue: function (searchField, searchValue) {
            var matches = this.__populationQueue.filter(
                function (d) {
                    return d[searchField] === searchValue;
                }
            );
            if (matches === null) {
                return false;
            }
            return matches.length > 0;
        },
        __addToQueue: function (node) {
            var doesDataExist = typeof (node) !== "undefined" && node !== null && typeof (node[this.fieldNameSearch]) !== "undefined" && node[this.fieldNameSearch] !== null;
            if (doesDataExist && !this.__inQueue(this.fieldNameSearch, node[this.fieldNameSearch])) {
                this.__populationQueue.push(node);
                return true;
            }
            return false;
        },
        __populateNodeListItem: function (node, subKeep, collectionKeep, isNew) {

            var selfAware = this, item = {};
            if (subKeep !== null && typeof (subKeep) !== "undefined") {
                node.sub = [];
                if (dojo.isArray(subKeep)) {
                    arrayUtil.forEach(subKeep, function (curr) {
                        item = selfAware.__createNodeItem(curr);
                        node.sub.push(item);
                    });
                }
                else {
                    item = this.__createNodeItem(subKeep);
                    node.sub.push(item);
                }
            }

            item = {};

            if (collectionKeep !== null && typeof (collectionKeep) !== "undefined") {
                node.collection = [];
                if (dojo.isArray(collectionKeep)) {
                    arrayUtil.forEach(collectionKeep, function (curr) {
                        item = selfAware.__createNodeItem(curr);
                        node.collection.push(item);
                    });
                }
                else {
                    item = this.__createNodeItem(collectionKeep);
                    node.collection.push(item);
                }
            }
            if (isNew) {
                node = this.__createNodeItem(node);
            }
            return node;
        },
        /**
            populates a queue with the nodes visited with current object's header name headerName
            @param: sdata - the object that contains the sdata schema feed in object form.
        **/
        _findAndAdd: function (sdata, headerName) {
            /*console.log(JSON.stringify(sdata)); //uncomment to generate 'mocked' data for testing*/
            var base = dString.substitute(this.ddList, [headerName]);
            var header = this.__getHeaderNodeByNameReturnAllElements(sdata, this.xsct, base);
            var indexNL = 0;
            this.__populationQueue = [];

            if (header !== null) {
                this.__addToNodeList(header);

                for (indexNL = 0; indexNL < this.__populationQueue.length; indexNL++) {
                    var queueItem = this.__populationQueue[indexNL];
                    var relats = queueItem.relationship || null;
                    var coll = queueItem.isCollection || false;

                    base = queueItem.type;

                    header = this.__getHeaderNodeByNameReturnAllElements(sdata, this.xsct, base);
                    if (header !== null) {
                        this.__complexTypeHandler(queueItem, header, indexNL);
                    }

                    header = this.__getHeaderNodeByNameReturnAllElements(sdata, this.xsst, base);
                    if (header !== null) {
                        this.__complexTypeHandler(queueItem, header, indexNL);
                    }
                }
            }
        },
        __complexTypeHandler: function (queueItem, header, indexNL) {
            var type = queueItem.type;
            var nodeNameKey = type.substring((type.lastIndexOf('--') + 2)).toLowerCase();
            switch (nodeNameKey) {
                case "list":
                    this.__addOrUpdateSingleNodeToNodeList(queueItem, header, queueItem.collection, indexNL);
                    break;
                case "enum":
                    this.__addOrUpdateSingleNodeToNodeList(queueItem, queueItem.sub, header, indexNL);
                    break;
                case "choice":
                    this.__addOrUpdateSingleNodeToNodeList(queueItem, queueItem.sub, header, indexNL);
                    break;
                case "type":
                    this.__addOrUpdateSingleNodeToNodeList(queueItem, header, queueItem.collection, indexNL);
                    break;
            }
        },
        /**
            takes the queue and produces a list of nodes with children. The root, or first element containing all the nodes. 
        **/
        _gatherNodesFromQueue: function (headerName) {

            var tags = ["--type", "--list", "--choice"]; // no --enum they are not stored in sub, but in collection.
            var list = new Memory({ idProperty: 'name' });
            var selfAware = this;
            var data = this.__populationQueue.filter(
                function (c) {
                    return typeof (c.pathFromParent) !== "undefined" && c.superParentNodeName === dString.substitute(selfAware.ddList, [headerName]);
                });
            if (data.length > 0) {
                list.add(data[0]);
            }
            for (var plrn_i = 0; plrn_i < list.data.length; plrn_i++) {
                var plrn_item = list.data[plrn_i];

                if (plrn_item.sub) {
                    var subsWithMore = plrn_item.sub.filter(
                        function (d) {
                            for (var tag_i = 0; tag_i < tags.length; tag_i++) {
                                var tag_item = tags[tag_i];

                                var len = tag_item.length;
                                var index = d.type.indexOf(tag_item);

                                if (index + len == d.type.length) {
                                    return true;
                                }
                            }
                            return false;
                        });
                    for (var sub_i = 0; sub_i < subsWithMore.length; sub_i++) {
                        if (list.index[subsWithMore[sub_i].name]) {
                            list.add(subsWithMore[sub_i]);
                        }
                    }
                }
            }

            return list;
        },
        _buildObjectFromNodeList: function (header) {
            var queue = []; // {path:'propertyName.propertyName.arrayIndex.propertyName',subList, currentItem}
            var treeObj = {};
            var list_i, queue_i = 0;
            var obj = {};

            obj[header.name] = {};
            queue.push({ path: header.name, sub: header.sub, item: obj });

            do {
                var queue_item = queue[queue_i];

                obj = treeObj;

                var path = queue_item.path.split('.');
                for (var i = 0; i < path.length; i++) {
                    var currVariable = path[i];

                    if (currVariable in obj) {
                        obj = obj[path[i]];
                    }
                    else {
                        obj[path[i]] = {};
                    }
                }
                obj[path[path.length - 1]] = queue_item.item[path[path.length - 1]];

                if (dojo.isArray(queue_item.sub)) {
                    for (list_i = 0; list_i < queue_item.sub.length; list_i++) {
                        var sub_item = queue_item.sub[list_i];
                        var sub_object = {};
                        sub_object[sub_item.name] = {};
                        queue.push({ path: dString.substitute("${0}.${1}", [queue_item.path, sub_item.name]), sub: sub_item.sub, item: sub_object });
                    }
                }

                queue_i++;
            } while (queue_i < queue.length);
            return treeObj;
        },
        __determineCorrectPathToTake: function (node) {
            //possible paths:
            //              ['xs:all']['xs:element']
            //              ['xs:sequence']['xs:element']
            //              ['xs:restriction']['xs:enumeration']
            //              ['xs:choice']['xs:element']
            var nodeNameKey = node["name"].substring((node["name"].lastIndexOf('--') + 2)).toLowerCase();
            var ItemsOnPath = {};
            var strPath = "";
            var testField = {};

            switch (nodeNameKey) {
                case "list":
                    ItemsOnPath = node[this.xss];
                    strPath = this.xss;
                    break;
                case "enum":
                    ItemsOnPath = node[this.xsr];
                    strPath = this.xsr;
                    break;
                case "choice":
                    ItemsOnPath = node[this.xsc];
                    strPath = this.xsc;
                    break;
                case "type":
                    ItemsOnPath = node[this.xsa];
                    if (ItemsOnPath !== null && typeof (ItemsOnPath) !== "undefined") {
                        strPath = this.xsa;
                    } else {
                        ItemsOnPath = node[this.xsy];
                        if (ItemsOnPath !== null && typeof (ItemsOnPath) !== "undefined") {
                            strPath = this.xsy;
                        }
                    }
                    break;
            }


            if (ItemsOnPath) {
                switch (nodeNameKey) {
                    case "list":
                    case "choice":
                    case "type":
                        testField = ItemsOnPath[this.xse];
                        if (testField !== null && typeof (testField) !== "undefined") {
                            strPath = dString.substitute("${0}///${1}", [strPath, this.xse]);
                            ItemsOnPath = ItemsOnPath[this.xse];
                        }
                        break;
                    case "enum":
                        testField = ItemsOnPath[this.xsn];
                        if (testField !== null && typeof (testField) !== "undefined") {
                            strPath = dString.substitute("${0}///${1}", [strPath, this.xsn]);
                            ItemsOnPath = ItemsOnPath[this.xsn];
                        }
                        break;
                }

                ItemsOnPath.superParentNodeName = node["name"];
                ItemsOnPath.pathFromParent = strPath;
                return ItemsOnPath;
            }

            return null;
        }

    });
    return widget;
});
},
'Sage/Utility/FilterSchemaReader':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/_base/declare',
    'dojo/store/Memory',
    'dojo/string',
    'dojo/_base/array',
    'Sage/Utility/_SchemaReaderHelper'
],
function (
    declare,
    Memory,
    dString,
    arrayUtil,
    _schemaReaderHelper
) {
    var widget = declare('Sage.Utility.FilterSchemaReader', [_schemaReaderHelper], {

        filterResourceNodes: null,
        filter_object: null,
        constructor: function () {
            this.resetFilterSchemaInformation();
        },
        resetFilterSchemaInformation: function () {
            this.filterResourceNodes = new Memory();
        },
        _getFilterSchemaInformation: function (endPointData) {
            var headName = 'filter';
            this._findAndAdd(endPointData, headName);
            this.filterResourceNodes = this._gatherNodesFromQueue(headName);
            if (this.filterResourceNodes.data.length > 0) {
                this.filter_object = this._buildObjectFromNodeList(this.filterResourceNodes.data[0]);
            }
        }
    });
    return widget;
});
},
'Sage/Utility/PickListSchemaReader':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/_base/declare',
    'dojo/store/Memory',
    'dojo/string',
    'dojo/_base/array',
    'Sage/Utility/_SchemaReaderHelper'
],
function (
    declare,
    Memory,
    dString,
    arrayUtil,
    _schemaReaderHelper
) {
    var widget = declare('Sage.Utility.PickListSchemaReader', [_schemaReaderHelper], {

        picklistResourceNodes: null,
        picklist_object: null,
        constructor: function () {
            this.picklist_object = {};
            this.resetPickListSchemaInformation();
        },
        resetPickListSchemaInformation: function () {
            this.picklistResourceNodes = new Memory();
        },
        _getPickListSchemaInformation: function (endPointData) {
            var headName = 'pickList';
            this._findAndAdd(endPointData, headName);
            this.picklistResourceNodes = this._gatherNodesFromQueue(headName);
             if (this.picklistResourceNodes.data.length > 0) {
                 this.picklist_object = this._buildObjectFromNodeList(this.picklistResourceNodes.data[0]);
            }
        },
        cleanupPicklistObject: function () {
            var retObj = this.picklist_object.pickList;
            retObj.items = retObj.items.pickListItem;
            return retObj;
        }
    });
    return widget;
});
},
'Sage/MainView/EntityMgr/EntityWizard/SelectEntityType':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/_base/declare',
    'dojo/_base/connect',
    'dojo/number',
    'dojo/string',
    'Sage/MainView/EntityMgr/EntityWizard/_EntityWizardDialogBase',
    'dojo/text!./templates/SelectEntityType.html',
    //'dojo/i18n!./nls/SelectFile',
    'Sage/MainView/EntityMgr/EntityWizard/EntityWizardUtility',
    'Sage/Utility',
    'Sage/Utility/File/Attachment'
],
function (
    declare,
    connect,
    dNumber,
    dString,
    wizardDialogBase,
    template,
    //nlsResources,
    entityWizardUtility,
    utility,
    attachmentUtility
) {
    var widgetTemplate = utility.makeTemplateFromString(template);
    var selectEntityType = declare('Sage.MainView.EntityMgr.EntityWizard.SelectEntityType', [wizardDialogBase], {
        id: "dlgSelectEntityType",
        widgetTemplate: widgetTemplate,
        //_nlsResources: nlsResources,
        _currentStep: entityWizardUtility.entityWizardStep.SelectEntityType,
        _fileInputOnChange: null,
        constructor: function () {
            this.inherited(arguments);
        },
        startup: function () {
            this.inherited(arguments);
        },
        isValid: function () {
            return true;
        },
        destroy: function () {
            this.inherited(arguments);
        }
    });
    return selectEntityType;
});
},
'Sage/MainView/EntityMgr/EntityWizard/EntityDetails':function(){
require({cache:{
'url:Sage/MainView/EntityMgr/EntityWizard/templates/EntityDetails.html':"<div>\r\n    <div data-dojo-type=\"dijit.Dialog\" title=\"New Entity Wizard\" data-dojo-attach-point=\"_dialog\" data-dojo-attach-event=\"onCancel:_btnCancel_OnClick\" style=\"position:absolute;width: 625px;height:625px;\">\r\n        <div data-dojo-type=\"dijit.form.Form\" style=\"height:600px !important;\" dojoattachpoint=\"Form\">\r\n\r\n            <div style=\"padding-bottom:30px;\">\r\n                <label style=\"font-weight:bold;\" data-dojo-attach-point=\"lblCreateEntity\">Create Entity</label>\r\n                <p><label data-dojo-attach-point=\"lblCreateEntityFromTable\">Create a new entity from a table</label></p>\r\n                <hr />\r\n            </div>\r\n            \r\n            <table class=\"detailTableContainer formtable HundredPercentWidth\">\r\n                <tr data-dojo-attach-point=\"_displayNameSection\">\r\n                    <td class=\"FManagerDialogFieldLabel\">\r\n                        <div style=\"padding:0 !important;\" class=\"lbl alignright\">\r\n                            <label style=\"line-height:32px !important;\" data-dojo-attach-point=\"lblDisplayName\">\r\n                                Display Name\r\n                            </label>\r\n                        </div>\r\n                        <div class=\"fld dijitInline\" data-dojo-attach-point=\"displayName\">\r\n                        </div>\r\n                    </td>\r\n                </tr>\r\n                <tr data-dojo-attach-point=\"_filterNameSection\">\r\n                    <td class=\"FManagerDialogFieldLabel\">\r\n                        <div style=\"padding:0 !important;\" class=\"lbl alignright\">\r\n                            <label style=\"line-height:32px !important;\" data-dojo-attach-point=\"lblEntityName\">\r\n                                Entity Name\r\n                            </label>\r\n                        </div>\r\n                        <div class=\"fld  dijitInline\" data-dojo-attach-point=\"Name\">\r\n                        </div>\r\n                    </td>\r\n                </tr>\r\n                <tr data-dojo-attach-point=\"_filterNameSection\">\r\n                    <td class=\"FManagerDialogFieldLabel\">\r\n                        <div class=\"lbl alignright\">\r\n                            <label style=\"line-height:32px !important;\">\r\n                            </label>\r\n                        </div>\r\n                        <div class=\"fld  dijitInline\"  data-dojo-attach-point=\"\" style=\"color:red\">\r\n                            <label style=\"line-height:32px !important;\" data-dojo-attach-point=\"divValidationMessage\">\r\n                            </label>\r\n                        </div>\r\n                    </td>\r\n                </tr>\r\n            </table>\r\n\r\n            <div align=\"right\" style=\"position:absolute;bottom:30px;width:90%;\">\r\n                <!--<div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnBack\" data-dojo-attach-event=\"onClick:_btnBack_OnClick\">Back</div>-->\r\n                <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnNext\" data-dojo-attach-event=\"onClick:_btnNext_OnClick\">Next ></div>\r\n                <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnCancel\" data-dojo-attach-event=\"onClick:_btnCancel_OnClick\" style=\"margin-left:5px;\">Cancel</div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>"}});
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/_base/declare',
    'dojo/_base/connect',
    'dojo/number',
    'dojo/string',
    'Sage/MainView/EntityMgr/EntityWizard/_EntityWizardDialogBase',
    'dojo/text!./templates/EntityDetails.html',
    'Sage/MainView/EntityMgr/EntityWizard/EntityWizardUtility',
    'Sage/Utility',
    'Sage/Utility/File/Attachment',
    'dojo/topic',
    'Sage/UI/Controls/TextBox',
    'dojo/dom-construct',
    'Sage/UI/FilteringSelect',
    'dojo/store/Memory',
    'Sage/Data/SDataServiceRegistry',
    'Sage/UI/_DialogLoadingMixin',
    'dojo/_base/lang',
    'dijit/form/Form',
    'Sage/MainView/EntityMgr/EntityDetailUtility'

],
function (
    declare,
    connect,
    dNumber,
    dString,
    wizardDialogBase,
    template,
    entityWizardUtility,
    utility,
    attachmentUtility,
    topic,
    crmTextBox,
    domConstruct,
    crmDropDowns,
    Memory,
    SDataServiceRegistry,
    _DialogLoadingMixin,
    lang,
    Form,
    entityDetailUtility
) {
    var widgetTemplate = utility.makeTemplateFromString(template);
    var entityDetails = declare('Sage.MainView.EntityMgr.EntityWizard.EntityDetails', [wizardDialogBase], {
        id: "dlgEntityDetails",
        widgetTemplate: widgetTemplate,
        _currentStep: entityWizardUtility.entityWizardStep.EntityDetails,
        _fileInputOnChange: null,
        nameTextBox: null,
        displayNameTextBox: null,

        constructor: function () {
            this.inherited(arguments);
        },
        startup: function () { 
            this.inherited(arguments);
        },
        postCreate: function () {
            this._dialog.set("title", this._nlsResources.lblNewEntityWizard);
            this.lblCreateEntity.innerHTML = this._nlsResources.lblCreateEntity;
            this.lblCreateEntityFromTable.innerHTML = this._nlsResources.lblCreateEntityFromTable;
            this.lblDisplayName.innerHTML = this._nlsResources.lblDisplayName;
            this.lblEntityName.innerHTML = this._nlsResources.lblEntityName;
            this.btnNext.set("label", this._nlsResources.lblNext + ' >');
            this.btnCancel.set("label", this._nlsResources.lblCancel);
            
            if (!this._dialog._standby) {
                lang.mixin(this._dialog, new _DialogLoadingMixin());
            }
            this._createTextboxControls();

            dojo.connect(this.displayNameTextBox, "onChange", this, function (value) {
                var valueNoSpecialChars = value.replace(/[^A-Za-z0-9]/g, '');
                this.nameTextBox.set("value", this._capitalizeFirstLetter(valueNoSpecialChars.replace(/\s/g, "")));
            });

        },
        _capitalizeFirstLetter: function(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        },
        _createTextboxControls: function () {

            this.nameTextBox = new crmTextBox(
            {
                shouldPublishMarkDirty: false,
                required: true,
                validator: this._NameValidator,
                invalidMessage: this._nlsResources.lblInvalidEntry
            });

            domConstruct.place(this.nameTextBox.domNode, this.Name, 'only');
            
            this.displayNameTextBox = new crmTextBox(
                {
                    shouldPublishMarkDirty: false,
                    required: true,
                    //id: "idDisplayName",
                    //validator: null,
                    invalidMessage: 'Required'
                });
            domConstruct.place(this.displayNameTextBox.domNode, this.displayName, 'only');
        },
        _NameValidator: function (value, constraints) {
            // value needs to start with a letter, but can also contain numbers
            var regex = '^[A-Z][A-Za-z0-9]*$';
            var matches = value.match(regex, 'g');
            if (matches) {
                if (lang.isArray(matches)) {
                    return matches[0].length == value.length;
                }
                else {
                    return matches[0].length == value.length;
                }
            }
            return false;
        },
        _validateUniqueName: function () {
            this._dialog.showLoading();
            var request = new Sage.SData.Client.SDataResourceCollectionRequest(SDataServiceRegistry.getSDataService('metadata'));
            request.setResourceKind(dString.substitute('entities'));
            request.setQueryArg('count', 1);
            request.setQueryArg('where', dString.substitute("name like '${0}'", [this.nameTextBox.value.toLowerCase()]));
            var context = this;
            var retValue = true;
            request.read({
                async: false,
                success: function (data) {
                    if (typeof (data) !== 'undefined' && typeof (data.$resources) !== 'undefined' && data.$resources.length == 1) {
                        context.divValidationMessage.innerHTML = context._nlsResources.lblEntityUsed;

                        retValue = false;
                    }
                    else {
                        retValue = true;
                    }
                    context._dialog.hideLoading();
                },
                failure: function (data) {
                    context._dialog.hideLoading();
                    retValue = false;
                }
            });

            return retValue;
        },
        isValid: function () { 
            var myform = this.Form;
            var isValid = myform.validate();
            if (isValid) {
                isValid = this._validateUniqueName();
            }
            return isValid;
        },
        destroy: function () {
            this.inherited(arguments);
        },
        _btnNext_OnClick: function () {
            this._dialog.showLoading();
            var context = this;

            setTimeout(function () {
                context.divValidationMessage.innerHTML = '';
                context.entityDetails.entityName = context.nameTextBox.value;
                context.entityDetails.entityDisplayName = context.displayNameTextBox.value;
                context.entityDetails.status = 'ok';

                if (context.isValid()) {
                    context._dialog.hideLoading();
                    context._checkCurrentStep();
                    context._dialog.hide();
                    topic.publish("/entityController/entityWizard/nextStep", context._currentStep);
                } else {
                    context._dialog.hideLoading();
                }
            }, 1000);

        }
    });
    return entityDetails;
});
},
'Sage/MainView/EntityMgr/EntityWizard/Relationship':function(){
require({cache:{
'url:Sage/MainView/EntityMgr/EntityWizard/templates/Relationship.html':"<div>\r\n    <div data-dojo-type=\"dijit.Dialog\" title=\"New Entity Wizard\" data-dojo-attach-point=\"_dialog\" data-dojo-attach-event=\"onCancel:_btnCancel_OnClick\" style=\"position:absolute;width: 625px;height:625px;\">\r\n        <div data-dojo-type=\"dijit.form.Form\" style=\"height:600px !important;\" dojoattachpoint=\"Form\">\r\n            <div style=\"padding-bottom:30px;\">\r\n                <label style=\"font-weight:bold;\" data-dojo-attach-point=\"lblRelationship\">Primary Relationship</label>\r\n                <p>\r\n                    <label data-dojo-attach-point=\"lblSelectEntity\">Choose wheather this entity has a primary relationship to another entity</label>\r\n                </p>\r\n                <hr />\r\n            </div>\r\n\r\n            <table class=\"detailTableContainer formtable HundredPercentWidth\">\r\n                <tr data-dojo-attach-point=\"_TypeDropDownSection\">\r\n                    <td class=\"FManagerDialogFieldLabel\">\r\n\r\n                        <div style=\"padding:0 !important;\" class=\"lbl alignright\">\r\n                            <label style=\"line-height:32px !important;\" data-dojo-attach-point=\"lblExistingEntity\">\r\n                                Relate to an existing Entity\r\n                            </label>\r\n                        </div>\r\n                        <div style=\"padding-top:6px;\">\r\n                            <input type=\"checkbox\" data-dojo-attach-point=\"IsExtension\"\r\n                                   data-dojo-type=\"dijit/form/CheckBox\" />\r\n                        </div>\r\n                    </td>\r\n                </tr>\r\n                <tr data-dojo-attach-point=\"_TypeDropDownSection\">\r\n                    <td class=\"FManagerDialogFieldLabel\">\r\n                        <div style=\"padding:0 !important;\" class=\"lbl alignright\">\r\n                            <label style=\"line-height:32px !important;\" data-dojo-attach-point=\"lblRelatedEntity\">\r\n                                Related Entity\r\n                            </label>\r\n                        </div>\r\n                        <div class=\"fld dijitInline\" data-dojo-attach-point=\"typePkg\"></div>\r\n                    </td>\r\n                </tr>\r\n                <tr data-dojo-attach-point=\"_TypeDropDownSection\">\r\n                    <td class=\"FManagerDialogFieldLabel\">\r\n                        <div style=\"padding:0 !important;\" class=\"lbl alignright\">\r\n                            <label style=\"line-height:32px !important;\" data-dojo-attach-point=\"lblRelationType\">\r\n                                Relation Type\r\n                            </label>\r\n                        </div>\r\n                        <div class=\"fld dijitInline\" data-dojo-attach-point=\"typeRel\"></div>\r\n                    </td>\r\n                </tr>\r\n            </table>\r\n            <br />\r\n            <div data-dojo-attach-point=\"divValidationMessage\" style=\"color:red\">\r\n                <span data-dojo-attach-point=\"spanValidationMessage\">&nbsp;</span>\r\n            </div>\r\n            <div align=\"right\" style=\"position:absolute;bottom:30px;width:90%;\">\r\n                <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnBack\" data-dojo-attach-event=\"onClick:_btnBack_OnClick\">< Back</div>\r\n                <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnNext\" data-dojo-attach-event=\"onClick:_btnNext_OnClick\">Next ></div>\r\n                <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnCancel\" data-dojo-attach-event=\"onClick:_btnCancel_OnClick\" style=\"margin-left:5px;\">Cancel</div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>"}});
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/_base/declare',
    'dojo/_base/connect',
    'dojo/number',
    'dojo/string',
    'Sage/MainView/EntityMgr/EntityWizard/_EntityWizardDialogBase',
    'dojo/text!./templates/Relationship.html',
    //'dojo/i18n!./nls/SelectFile',
    'Sage/MainView/EntityMgr/EntityWizard/EntityWizardUtility',
    'Sage/Utility',
'Sage/UI/Controls/CheckBox',
    'Sage/Utility/File/Attachment',
    'dojo/topic',
    'Sage/UI/Controls/TextBox',
    'dojo/dom-construct',
    'Sage/UI/FilteringSelect',
    'dojo/store/Memory',
    'Sage/Data/SDataServiceRegistry',
    'Sage/UI/_DialogLoadingMixin',
    'dojo/_base/lang',
    'dijit/registry'
],
function (
    declare,
    connect,
    dNumber,
    dString,
    wizardDialogBase,
    template,
    //nlsResources,
    entityWizardUtility,
        utility,
crmCheckBox,
    attachmentUtility,
    topic,
    crmTextBox,
    domConstruct,
    crmDropDowns,
    Memory,
    SDataServiceRegistry,
    _DialogLoadingMixin,
    lang,
    registry
) {
    var widgetTemplate = utility.makeTemplateFromString(template);
    var selectEntityType = declare('Sage.MainView.EntityMgr.EntityWizard.Relationship', [wizardDialogBase], {
        id: "dlgRelationship",
        widgetTemplate: widgetTemplate,
        //_nlsResources: nlsResources,
        _currentStep: entityWizardUtility.entityWizardStep.Relationship,
        _fileInputOnChange: null,
        typeDropDowns: false,
        typeDropDownsRel: false,
        checkBox: false,
        _pkgType: '',
        //_relType:'typeRelation',
        chkItem: 'chk',
        _dialog: null,
        entityInfo: false,

        constructor: function () {
            this.inherited(arguments);

        },
        startup: function () {
            this.inherited(arguments);
        },
        postCreate: function () {
            this._dialog.set("title", this._nlsResources.lblNewEntityWizard);
            this.lblRelationship.innerHTML = this._nlsResources.lblRelationship;
            this.lblSelectEntity.innerHTML = this._nlsResources.lblSelectEntity;
            this.lblExistingEntity.innerHTML = this._nlsResources.lblExistingEntity;
            this.lblRelatedEntity.innerHTML = this._nlsResources.lblRelatedEntity;
            this.lblRelationType.innerHTML = this._nlsResources.lblRelationType;
            this.btnBack.set("label", '< ' + this._nlsResources.lblBack);
            this.btnNext.set("label", this._nlsResources.lblNext + ' >');
            this.btnCancel.set("label",this._nlsResources.lblCancel);

            if (!this._dialog._standby) {
                lang.mixin(this._dialog, new _DialogLoadingMixin());
            }
            this._createTextboxControls();
            
        },
        _createTextboxControls: function () {
            var request = new Sage.SData.Client.SDataResourceCollectionRequest(SDataServiceRegistry.getSDataService('metadata'))
                        .setResourceKind('entities')
                        .setQueryArg('Count', '1000')
                        .setQueryArg('select', 'id,displayName,name')
                        .setQueryArg('orderBy', 'name')
                        .setQueryArg('format', 'json');
            var context = this;
            this.entityStore = new Memory();

            request.read({
                scope: this,
                success: function (data) {
                    var entities = data.$resources;
                    this.entityInfo = entities;
                    for (var i = 0; i <= entities.length - 1; i++) {
                        var entityDisplayName = entities[i].displayName ? entities[i].displayName : entities[i].name;
                        if (entities[i].name) {
                            context.entityStore.add({
                                id: entities[i].name,
                                name: entityDisplayName
                            });
                        }
                    }
                    context._dialog.hideLoading();
                },
                failure: function (error) {
                    if (error) {
                        console.error(error);
                    }
                    context._dialog.hideLoading();
                }
            });

            this.typeDropDowns = new crmDropDowns({
                id: this._pkgType,
                name: 'value',
                store: this.entityStore,
                searchAttr: 'name'
            }, this._pkgType
            );
            domConstruct.place(this.typeDropDowns.domNode, this.typePkg, 'only');
            this.typeDropDowns.set('disabled', true);

            //relation Type
            var data = new Memory({
                data: [
                  { id: "1:1", name:this._nlsResources.ExtensionEntity },
                  { id: "1:M", name:this._nlsResources.ChildEntity }
                ]
            });
            this.typeDropDownsRel = new crmDropDowns({
                //id: this._relType,
                name: 'value',
                store: data,
                searchAttr: 'name'
            }//, this._relType
            );
            domConstruct.place(this.typeDropDownsRel.domNode, this.typeRel, 'only');
            this.typeDropDownsRel.set('disabled', true);
            //Events
            this.IsExtension.on("change", function (isChecked) {
                if (isChecked) {
                    if (context.entityStore.data.length < 1) {
                        //context._dialog.showLoading();
                    }
                    context.typeDropDowns.set('disabled', false);
                    context.typeDropDownsRel.set('disabled', false);
                }
                else {
                    context.typeDropDowns.set('value', '');
                    context.typeDropDowns.set('disabled', true);

                    context.typeDropDownsRel.set('value', '');
                    context.typeDropDownsRel.set('disabled', true);
                }
            }, true);

        },
        isValid: function () {
            var myform = this.Form;
            var isValid = myform.validate();
            //if (isValid) {
            //    isValid = this._validateUniqueName();
            //}
            return isValid;
        },
        destroy: function () {
            this.inherited(arguments);
        },
        _btnNext_OnClick: function () {
            this._dialog.showLoading();
            var context = this;
           
            if (this.isValid()) {
                this.entityDetails.relatedEntity = this.typeDropDowns.value;
                this.entityDetails.relatedEntityDispName = this.typeDropDowns.displayedValue;
                this.entityDetails.relationType = this.typeDropDownsRel.value;
                this.entityDetails.relatedProperty = false;

                if (this.IsExtension.checked && this.typeDropDownsRel.value === '1:M') {
                    var propRequest = new Sage.SData.Client.SDataResourceCollectionRequest(SDataServiceRegistry.getSDataService('metadata'))
                        .setQueryArg('where', "isKey eq true")
                            .setResourceKind('entities(' + "'" + this.entityDetails.relatedEntity + "'" + ')/properties')
                            .setQueryArg('select', 'id,dataTypeId,displayName,propertyName')
                            .setQueryArg('count', 1)
                        .setQueryArg('format', 'json');
                        

                        propRequest.read({
                            async: false,
                            success: function (data) {
                                var props = data.$resources;
                                context.entityDetails.relatedPropertyId = props[0].id;

                                context._dialog.hideLoading();
                                context._checkCurrentStep();
                                context._dialog.hide();
                                topic.publish("/entityController/entityWizard/nextStep", context._currentStep);
                            },
                            failure: function (error) {
                                if (error) {
                                    console.error(error);
                                }
                                this._dialog.hideLoading();
                            }
                        });
                }
                else {
                    this._dialog.hideLoading();
                    this._checkCurrentStep();
                    this._dialog.hide();
                    topic.publish("/entityController/entityWizard/nextStep", this._currentStep);
                }
                    
            }else {
                this._dialog.hideLoading();
            }
        }
    });
    return selectEntityType;
});
},
'Sage/MainView/EntityMgr/EntityWizard/EntityProperties':function(){
require({cache:{
'url:Sage/MainView/EntityMgr/EntityWizard/templates/EntityProperties.html':"<div>\r\n    <div data-dojo-type=\"dijit.Dialog\" title=\"New Entity Wizard\" data-dojo-attach-point=\"_dialog\" data-dojo-attach-event=\"onCancel:_btnCancel_OnClick\" style=\"position:absolute;width: 625px;height:625px;\">\r\n        <div style=\"padding-bottom:30px;\">\r\n            <label style=\"font-weight:bold;\" data-dojo-attach-point=\"lblEnterProperties\">Enter Fields</label>\r\n            <p><label data-dojo-attach-point=\"lblAddNewProperty\">Click the add(+) button to add new fields to the entity</label></p>\r\n            <hr />\r\n        </div>\r\n        <div data-dojo-type=\"dijit.form.Form\"  style=\"height:400px !important;\" class=\"mainContentContent DialogMainForm\">\r\n            <div style=\"width:100%;\" class=\"fld dijitInline\" data-dojo-attach-point=\"placeGrid\"></div>\r\n        </div>\r\n        <div data-dojo-attach-point=\"divValidationMessage\" style=\"color:red\">\r\n            <span data-dojo-attach-point=\"spanValidationMessage\">&nbsp;</span>\r\n        </div>\r\n        <div class=\"lookupButtonWrapper\">\r\n            <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnBack\" data-dojo-attach-event=\"onClick:_btnBack_OnClick\">< Back</div>\r\n            <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnNext\" data-dojo-attach-event=\"onClick:_btnNext_OnClick\">Next ></div>\r\n            <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnCancel\" data-dojo-attach-event=\"onClick:_btnCancel_OnClick\" style=\"margin-left:5px;\">Cancel</div>\r\n        </div>\r\n    </div>\r\n</div>"}});
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/_base/declare',
    'dojo/_base/connect',
    'dojo/number',
    'dojo/string',
    'Sage/MainView/EntityMgr/EntityWizard/_EntityWizardDialogBase',
    'dojo/text!./templates/EntityProperties.html',
    'Sage/MainView/EntityMgr/EntityWizard/EntityWizardUtility',
    'Sage/Utility',
    'Sage/Utility/File/Attachment',
    'Sage/UI/GridView',
    'dojo/dom-construct',
    'dojo/_base/lang',
    'dojo/_base/connect',
        'dojo/store/Memory',
    "dojo/store/Observable",
    'Sage/MainView/EntityMgr/AddEditEntityDetail/AddEditPropertiesDialog',
    'Sage/MainView/EntityMgr/EntityDetailUtility',
    'dojo/topic',
    'Sage/UI/Controls/FieldStore',
    "dojo/_base/array",
    'Sage/UI/Controls/GridParts/Columns/CheckBox',
    'Sage/UI/Dialogs'

],
function (
    declare,
    connect,
    dNumber,
    dString,
    wizardDialogBase,
    template,
    entityWizardUtility,
    utility,
    attachmentUtility,
    GridView,
    domConstruct,
    lang,
    dojoConnect,
    Memory,
    Observable,
    addEditPropertiesDialog,
    entityDetailUtility,
    topic,
    FieldStore,
    array,
    CheckBox,
    dialogs
) {
    var widgetTemplate = utility.makeTemplateFromString(template);
    var entityProperties = declare('Sage.MainView.EntityMgr.EntityWizard.EntityProperties', [wizardDialogBase], {
        id: "dlgEntityProperties",
        widgetTemplate: widgetTemplate,
        //_nlsResources: nlsResources,
        _currentStep: entityWizardUtility.entityWizardStep.EntityProperties,
        _fileInputOnChange: null,
        fStore: null,
        propGrid: null,
        sysProps: [],
        dataStore: Observable(new Memory({ idProperty: "propertyName", data: [] })),
        constructor: function () {
            this.inherited(arguments);
            this.fStore = new FieldStore();
        },
        startup: function () { 
            this.inherited(arguments);
            this._createPropsGrid();
        },
        postCreate: function () {
            this._dialog.set("title", this._nlsResources.lblNewEntityWizard);
            this.lblEnterProperties.innerHTML = this._nlsResources.lblEnterProperties;
            this.lblAddNewProperty.innerHTML = this._nlsResources.lblAddNewProperty;
            this.btnBack.set("label", '< ' + this._nlsResources.lblBack);
            this.btnNext.set("label", this._nlsResources.lblNext + ' >');
            this.btnCancel.set("label",this._nlsResources.lblCancel);
        },
        isValid: function () { 
            return true;
        },
        destroy: function () {
            this.inherited(arguments);
        },
        populateDefaultProps: function () {
            var count = this.dataStore.data.length;
            for (var i = 0; i < count; i++) {
                this.dataStore.remove(this.dataStore.data[0].propertyName);
            }

            var entityName = this.entityDetails.entityName;
            var relprop = this.entityDetails.relatedProperty;
            var relEntity = this.entityDetails.relatedEntity;
            var property;
            this.sysProps = ["CreateUser", "CreateDate", "ModifyUser", "ModifyDate", "SeccodeId" ];

            // Set primary key property
            if (this.entityDetails.relationType === "1:1") {//For 1:1, id should be parents id
                property = { "propertyName": relEntity + 'Id', "displayName": relEntity + ' Id', "isKey": true, "isNullable": false, "columnName": relEntity.toUpperCase() + 'ID', "DataType": "Standard Id", "length": 12, "dataTypeId": '30053f5a-8d40-4db1-b185-1e4128eb26cc' };
                this.dataStore.put(property);
                this.sysProps.push(relEntity + 'Id');
            } else {
                property = { "propertyName": entityName + 'Id', "displayName": entityName + ' Id',"isKey": true, "isNullable": false, "columnName": entityName.toUpperCase() + 'ID', "DataType": "Standard Id", "length": 12, "dataTypeId": '30053f5a-8d40-4db1-b185-1e4128eb26cc'};
                this.dataStore.put(property);
                this.sysProps.push(entityName + 'Id');
            }

            //Related entity key
            if (this.entityDetails.relationType === "1:M") {
                relEntity = this.entityDetails.relatedEntity;
                property = { "propertyName": relEntity + 'Id', "displayName": relEntity + ' Id', "isKey": false, "isNullable": false, "columnName": relEntity.toUpperCase() + 'ID', "DataType": "Standard Id", "length": 12, "dataTypeId": '30053f5a-8d40-4db1-b185-1e4128eb26cc' };
                this.dataStore.put(property);
                this.sysProps.push(entityName + relEntity + 'Id');
            }

            //Other default properties
            this.dataStore.put({ "propertyName": "CreateUser", "displayName": this._nlsResources.CreateUser, "isKey": false, "isNullable": true, "columnName": "CREATEUSER", "DataType": "Standard Id", "length": 12, "dataTypeId": '30053f5a-8d40-4db1-b185-1e4128eb26cc' });
            this.dataStore.put({ "propertyName": "CreateDate", "displayName": this._nlsResources.CreateDate, "isKey": false, "isNullable": true, "columnName": "CREATEDATE", "DataType": "Date Time", "length": 0, "dataTypeId": '1f08f2eb-87c8-443b-a7c2-a51f590923f5' });
            this.dataStore.put({ "propertyName": "ModifyUser", "displayName": this._nlsResources.ModifyUser, "isKey": false, "isNullable": true, "columnName": "MODIFYUSER", "DataType": "Standard Id", "length": 12, "dataTypeId": '30053f5a-8d40-4db1-b185-1e4128eb26cc' });
            this.dataStore.put({ "propertyName": "ModifyDate", "displayName": this._nlsResources.ModifyDate, "isKey": false, "isNullable": true, "columnName": "MODIFYDATE", "DataType": "Date Time", "length": 0, "dataTypeId": '1f08f2eb-87c8-443b-a7c2-a51f590923f5' });
            this.dataStore.put({ "propertyName": "SeccodeId", "displayName": "Seccode Id", "isKey": false, "isNullable": false, "columnName": "SECCODEID", "DataType": "Standard Id", "length": 12, "dataTypeId": '30053f5a-8d40-4db1-b185-1e4128eb26cc' });

        },
        _createPropsGrid: function () {
            var self = this;
            this.populateDefaultProps();

            var columns = [
                {
                    field: 'displayName',
                    label: this._nlsResources.lblDisplayName
                },
                {
                    field: 'propertyName',
                    label: this._nlsResources.lblPropertyName
                },
               {
                   field: 'dataTypeId',
                   label: this._nlsResources.lblDataType,
                   formatter: function (data) {
                       var typeIndex = self.fStore.typeStore.index[data];
                       if (typeIndex >= 0) {
                           var obj = self.fStore.typeStore.data[typeIndex];
                           return obj.name;
                       }
                       else {
                           return "";
                       }
                   }
               },
               {
                   field: 'length',
                   className: 'alignright',
                   label: this._nlsResources.lblLength
               },
               {
                   field: 'isNullable',
                   label: this._nlsResources.lblNullable,
                   renderCell: function (object, value, node, options) {
                       var button = new CheckBox({
                           shouldPublishMarkDirty: false,
                           readonly: true,
                           disabled: true
                       });
                       var retValue = false;
                       if (value) {
                           retValue = value;
                       }
                       button.setChecked(retValue);
                       button.placeAt(node);
                   }
               }
            ];
            
            var grid = new GridView({
                tools: ['add', 'edit', 'delete'],
                store: this.dataStore,
                columns: columns,
                placeHolder: this.placeGrid,
                addItem: lang.partial(this.addItem, this),        // set the add item function
                removeItem: lang.partial(this.removeItem, this),  // set the remove item function
                editItem: lang.partial(this.editItem, this),//,      // set the edit item function
                columnHiding: true,
                columnResizing: true,
                columnReordering: true,
                selectionMode: 'single',
                rowSelection: true,
                classNames: 'dgrid-autoheight',
                minRowsPerPage: this.dataStore.data.length,
                maxRowsPerPage: this.dataStore.data.length
            });
            this.propGrid = grid;
            grid.createGridView();
        },
        addItem: function (context) {
            
            if (context.entityDetails.detailUtility === undefined) {
                context._dialog.showLoading();

                setTimeout(function () {
                    //populate detail Utility
                    context.entityDetails.detailUtility = new entityDetailUtility();
                    var async = false;
                    context.entityDetails.detailUtility.getSchemasInformationFromSData(async);
                    context.entityDetails.detailUtility.getSpecialValues();

                    context.showAddEditPropsDialog(context);
                }, 1000);

            } else {
                context.showAddEditPropsDialog(context);
            }
            
        },
        showAddEditPropsDialog: function (context) {
            var propsDialog = new addEditPropertiesDialog('', context._nlsResources.addFieldDialogTitle, context.entityDetails.detailUtility, false, null, true, context.dataStore);
            context._dialog.hideLoading();
            propsDialog.show();
            dojoConnect.connect(propsDialog._dialog, "hide", lang.partial(context.onReset, context));
        },
        editItem: function (context) {
            var selectedGridRow = context.propGrid.grid.getSelectedRowData();
            if (selectedGridRow.length === 0) {
                dialogs.showInfo(context._nlsResources.NoRecordsSelected);
                return;
            }
            if (array.indexOf(context.sysProps, selectedGridRow[0].propertyName) !== -1) {
                dialogs.showInfo(context._nlsResources.noEditSysProps);
                return;
            }
            
            if (selectedGridRow[0]) {
                var box = new addEditPropertiesDialog('', context._nlsResources.editFieldDialogTitle, context.entityDetails.detailUtility, false, selectedGridRow[0], true, context.dataStore);
                box.show();
                dojoConnect.connect(box._dialog, "hide", lang.partial(context.onReset, context));
            }
        },
        onReset: function (context) {
            context.propGrid.grid.refresh();
        },
        removeItem: function (context) {
            var selectedGridRow = context.propGrid.grid.getSelectedRowData();
            if (selectedGridRow.length === 0) {
                dialogs.showInfo(context._nlsResources.NoRecordsSelected);
                return;
            }
            if (array.indexOf(context.sysProps, selectedGridRow[0].propertyName) !== -1) {
                dialogs.showInfo(context._nlsResources.noDeleteSysProps);
                return;
            }
            var key = selectedGridRow[0].propertyName;
            if (key) {
                context.dataStore.remove(key);
                context.propGrid.grid.refresh();
            }
        },
        _btnNext_OnClick: function () {
            this.entityDetails.data = this.dataStore.data;

            if (this.isValid()) {
                this._checkCurrentStep();
                this._dialog.hide();
                topic.publish("/entityController/entityWizard/nextStep", this._currentStep);
            }
        }
    });
    return entityProperties;
});
},
'Sage/MainView/EntityMgr/AddEditEntityDetail/AddEditPropertiesDialog':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define, cookie */
define([
    'dijit/_Widget',

    'dojo/dom-construct',
    'dojo/dom-class',
    'dojo/dom-style',
    'dojo/json',
    'dojo/on',
    'dojo/query',
    'dojo/string',
    'dojo/_base/connect',
    'dojo/_base/declare',
    'dojo/_base/lang',
    'dojo/text!./templates/AddEditPropertiesDialog.html',
    'dojo/i18n!./nls/AddEditDialog',
    'dojo/store/Memory',

    'Sage/_Templated',
    'Sage/UI/Dialogs',
	'Sage/Data/SDataServiceRegistry',
    'Sage/UI/_DialogLoadingMixin',
    'Sage/UI/FilteringSelect',
    'Sage/UI/Controls/_DialogHelpIconMixin',
    'Sage/UI/Controls/CheckBox',
    'Sage/UI/Controls/FieldAttributeControlFactory',
    'Sage/UI/Controls/PropertyDropDown',
    'Sage/UI/Controls/TextBox',
    'Sage/MainView/EntityMgr/AddEditEntityDetail/DisplayName'

],
function (
    _Widget,

    domConstruct,
    domClass,
    dojoStyle,
    json,
    dojoOn,
    query,
    dojoString,
    dojoConnect,
    declare,
    lang,
    template,
    nlsResources,
    memory,

    _Templated,
    crmDialogue,
	SDataServiceRegistry,
    _DialogLoadingMixin,
    crmDropDowns,
    _DialogHelpIconMixin,
    crmCheckBox,
    FieldAttributeController,
	PropertyDropDown,
    crmTextBox,
    displayNameCNTRL
) {
    var widget = declare('Sage.MainView.EntityMgr.AddEditEntityDetail.AddEditPropertiesDialog', [_Widget, _Templated], {
        _dialog: null,

        widgetTemplate: new Simplate(eval(template)),
        _nlsResources: nlsResources,
        widgetsInTemplate: true,

        _EditData: false,           //  Filter information
        entityName: false,          //  current name of the entity

        detailUtility: false,

        service: false,             //  Reference to SData
        _title: false,

        details: null,
        _inEditMode: false,
        justWidget: false,
        showTypeAttributes: false,
        dataTypeData: null,
        typeAttributeObj: null,

        activeControllers: null,
        isNewEntity: false,
        dataStore: null,
        newProperty: null,
        rowTemplate: ['<tr data-dojo-attach-point="_{%= $.name %}Section" name="_{%= $.name %}Section">',
                        '<td class="FManagerDialogFieldLabel {%= $.display %}">',
                            '<div style="padding:0 !important;" class="lbl alignright">',
                                '<label style="line-height:32px !important;">',
                                    '{%= $.label %}',
                                '</label>',
                            '</div>',
                            '<div class="fld  dijitInline" data-dojo-attach-point="{%= $.name %}"></div>',
                        '</td>',
                    '</tr>'],

        constructor: function (entity, title, dUtility, onlyCalc, data, isNewEntity, dataStore) {
            if (dUtility === null) {
                var selectedData = { name: entity };
                dUtility = new Sage.MainView.EntityMgr.EntityDetailUtility();
                dUtility.getSchemasInformationFromSData(false);
                dUtility.getPropertiesAssociatedWithFilters(selectedData);
                dUtility.getSpecialValues();
                dUtility.refreshPropertyStore(selectedData.name);
                if (!this.service) {
                    this.service = dUtility.service;
                }
            }
            if (dUtility) {
                this.detailUtility = dUtility;
                this.detailUtility.refreshPropertyStore();
            }

            this._EditData = data;
            this.entityName = entity;
            if (title === null) {
                var strTemp = this._EditData ? nlsResources.editDialogTitle : nlsResources.dialogTitleAddField;
                this._title = dojoString.substitute(strTemp, [this.entityName]);
            }
            else {
                this._title = title;
            }
            this.justWidget = onlyCalc;
            this.isNewEntity = false;

            if (this._EditData) {
                this._inEditMode = true;
                this.dataTypeData = JSON.parse(this._EditData.dataTypeData);
            }

            if (isNewEntity) {
                this.isNewEntity = isNewEntity;
                this.dataStore = dataStore;
            }

            this._createDynamicFieldProperties();

        },

        destroy: function (context) {
            context.destroy();
            dijit.popup.close();
        },

        postCreate: function () {
            var contentArr = this.activeControllers.data;

            for (var i = 0; i < contentArr.length; i++) {
                this._moveActiveControlFromBackGroundToPage(contentArr[i]);
            }

            //create buttons
            this.cmdSave.containerNode.innerHTML = this._nlsResources.lblSaveButton;
            this.cmdCancel.containerNode.innerHTML = this._nlsResources.lblCancelButton;

            // help icon
            lang.mixin(this._dialog, new _DialogHelpIconMixin({ titleBar: this._dialog.titleBar }));
            this._dialog.createHelpIconByTopic('Adding_Editing_Properties');

            //loading
            lang.mixin(this._dialog, new _DialogLoadingMixin());

            this.hideControlsBasedOffSelectedFieldType();

            dojoOn(this._dialog, "onCancel", lang.partial(this._cmdCancel_OnClick, this));

            this.startup();
            query('.dijitDialog').on('click', function (e) {
                var target = e.target || e.srcElement;
                if (target.type !== 'button') {
                    dijit.popup.close();
                }
            });


            dojoConnect.subscribe('/form/addEditProperty/showLoad', this, function () {
                this._dialog.showLoading();
            });
            dojoConnect.subscribe('/form/addEditProperty/hideLoad', this, function () {
                this._dialog.hideLoading();
            });
        },

        _moveActiveControlFromBackGroundToPage: function (item) {
            var simplateRowTemplate, row, rowDom;

            if (item) {

                if (item.name !== "propertyName") {
                    simplateRowTemplate = new Simplate(this.rowTemplate);
                    row = simplateRowTemplate.apply(item);
                    rowDom = domConstruct.toDom(row);

                    domConstruct.place(item.control.domNode, rowDom.lastElementChild.lastElementChild, 'only');

                    if (item.control.domNode.className.indexOf("dijitCheckBox") >= 0) {
                        domClass.add(item.control.domNode.parentNode, "checkbox");
                    }

                    this._DynamicSection.appendChild(rowDom);
                }
                else {
                    rowDom = item.control.domNode;

                    this._DisplayName.appendChild(rowDom);
                }
            }
        },

        _createDisplayNameController: function () {
            var defValueD = '', defValueN = '';

            if (this._EditData && this._EditData.displayName) {
                defValueD = this._EditData.displayName;
            }

            if (this._EditData && this._EditData.propertyName) {
                defValueN = this._EditData.propertyName;
            }

            var nameTextBox = new displayNameCNTRL({
                dUtility: this.detailUtility,
                editMode: this._inEditMode && !this.isNewEntity,
                dataStore: this.dataStore,
                query: {
                    entityName: this.entityName,
                    resourceKind: dojoString.substitute('entities("${0}")/properties', [this.entityName]),
                    name: "propertyName",
                    displayName: "displayName"
                },
                values: {
                    display: {
                        data: defValueD,
                        mapDisplayToName: this._nameToDisplayMap
                    },
                    name: {
                        data: defValueN,
                        validation: this._NameValidator,
                        disabled: this._inEditMode && !this.isNewEntity,
                        invalidMessage: this._nlsResources.validNameMsg
                    }
                }
            });

            return nameTextBox;
        },
        _NameValidator: function (value, constraints) {
            // value needs to start with a letter or underscore, but can also contain numbers
            var regex = '^[A-Z][A-Za-z0-9_]*$';
            var matches = value.match(regex, 'g');
            if (matches) {
                if (lang.isArray(matches)) {
                    return matches[0].length == value.length;
                }
                else {
                    return matches[0].length == value.length;
                }
            }
            return false;
        },
        _nameToDisplayMap: function (val) {
            var regexp = new RegExp(/\w*/gm);
            var matches = val.match(regexp);
            if (matches) {
                if (lang.isArray(matches)) {
                    val = matches.join('');
                    regexp = new RegExp(/[A-Za-z]/gm);
                    matches = regexp.exec(val);
                    if (matches && matches.length > 0) {
                        val = val.substring(matches.index);
                        if (val && val.length > 0) {
                            return val.charAt(0).toUpperCase() + val.slice(1);
                        }
                        else {
                            return '';
                        }
                    }

                }
                else {
                    return matches;
                }
            }
            return '';
        },

        _addToListofControls: function (id, type, label, val, collection) {

            var control = this._assignControlBasedOffType(id, type.substring(3), val, collection);
            var displayClass = this._setDisplayString(control, id);
            var controlLabel = typeof (this._nlsResources[id]) === "undefined" || this._nlsResources[id] === null ? label : this._nlsResources[id];

            this.activeControllers.add({ control: control, label: controlLabel, name: id, display: displayClass });
        },
        // determines if the form property should be displayed.
        _displayControl: function (control, id) {
            var hideIfNoControls = ["dataTypeData"]; // list of controls that will be hidden(class="display-none") if there are no sub controls present.

            var applyRule = true;
            if (typeof (id) !== "undefined" && id !== null) {
                applyRule = hideIfNoControls.indexOf(id) >= 0; // if the control does not exist in the list, then the hide rule will not apply.
            }
            if (applyRule) {
                return ((typeof (control.activeControls) !== "undefined" && control.activeControls !== null) && control.activeControls.length > 0);
            }
            else {
                return true;
            }
        },
        // used during the inital loading of the form; returns a string value for the display class to be added to the domNode
        _setDisplayString: function (control, id) {
            return this._displayControl(control, id) ? "display" : "display-none";
        },
        // used once the dom has been added to the displayed form; manipulates the dom classes via the add and remove methods
        _setParentDisplayClass: function (control, parentDom) {
            if (this._displayControl(control)) { // display dom if there are controls to display
                domClass.remove(parentDom, 'display-none');
                domClass.add(parentDom, 'display');
            }
            else { // if there are no controls to display, then hide the dom.
                domClass.remove(parentDom, 'display');
                domClass.add(parentDom, 'display-none');
            }
        },
        _createDynamicFieldProperties: function () {
            var dynamicArr = this.detailUtility.propertyInformation.data;

            this.activeControllers = new memory({ idProperty: "name" });

            var suppress = ['id', 'displayName', 'columnName', 'isDynamic', 'length', 'isReadOnly', 'scale', 'precision', 'displayCategory', 'isKey']; // remove displayCategory from list to test auto generated drop down controls

            if (!this.isNewEntity) {
                suppress.push('isNullable');
            }
            for (var index = 0; index < dynamicArr.length; index++) {
                var item = dynamicArr[index];
                var control = null;
                var type = item.type;
                var lbl = item.name;


                var insertExlcusions = (!this._inEditMode && (lbl === "isIncluded")); // isIncluded is to always be true
                var block = suppress.indexOf(lbl) >= 0 || insertExlcusions;

                if (!block) {
                    if (type.substring(0, 3) === "xs:") {
                        var val = null;
                        if (this._inEditMode && (typeof (this._EditData[lbl]) !== "undefined" && this._EditData[lbl] !== null)) {
                            val = this._EditData[lbl];
                        }
                        this._addToListofControls(lbl, type, item.label, val, null);
                    }
                    else {
                        var len = type.length;
                        if (type.substring(len - 6, len) === "--type") {
                            var subArr = item.sub.data;
                            if (subArr !== null) {
                                for (var i1 = 0; i1 < subArr.length; i1++) {
                                    var subItem = subArr[i1];
                                    var subName = subItem.name;
                                    var subType = subItem.type;

                                    var insertSubExlcusions = (!this._inEditMode && (lbl === "sdata") && (subName === "generate"));
                                    if (!insertSubExlcusions) {
                                        if (subType.substring(0, 3) === "xs:") {
                                            var val1 = null;
                                            if (this._inEditMode && (typeof (this._EditData[item.name][subName]) !== "undefined" && this._EditData[item.name][subName] !== null)) {
                                                val1 = this._EditData[item.name][subName];
                                            }
                                            this._addToListofControls(subName, subType, subItem, val1, null);
                                        }
                                    }
                                }
                            }
                        }
                        else if (type.substring(len - 6, len) === "--enum") {
                            var subArr1 = item.collection;
                            var val2 = null;
                            if (this._inEditMode && (typeof (this._EditData[lbl]) !== "undefined" && this._EditData[lbl] !== null)) {
                                val2 = this._EditData[lbl];
                            }
                            if (subArr1 !== null) {
                                subArr1 = new memory({ idProperty: "@value", data: subArr1.data });
                                this._addToListofControls(lbl, "xs:enum", item, val2, { text: "@sme:label", id: "@value", data: subArr1 });
                            }
                        }
                    }
                }
            }
        },
        _assignControlBasedOffType: function (name, type, val, collection) {
            var control = null;
            if (name === "dataTypeId") {
                var form = this;
                control = new crmDropDowns(
                {
                    shouldPublishMarkDirty: false,
                    required: true,
                    value: val,
                    store: this.detailUtility.typeStore,
                    searchAttr: 'name',
                    idAttr: 'id',
                    maxHeight: 175,//drop down height
                    query: { supported: true },
                    fetchProperties: { sort: [{ attribute: "name", descending: false }] },
                    invalidMessage: this._nlsResources.InvalidFilterName,
                    disabled: this._inEditMode && !this.isNewEntity,// problems can arrise when a type is changed after a field has been created, so disable if in edit mode.
                    onChange: function (id) {
                        form._setTypeAttribute();
                    }
                });
                this.typeDropDown = control;
                if (typeof (val) !== "undefined") {
                    this._setTypeAttribute();
                    this.showTypeAttributes = true;
                }
                else {
                    this.typeAttribute.containerNode.innerHTML = this._nlsResources.lblMore;
                }
            }
            else if (name === "dataTypeData") {
                control = this.typeAttributeObj;
            }
            else if (name === "propertyName") {
                control = this._createDisplayNameController();
            }
            else {
                switch (type) {
                    case "string":
                    case "int":
                    case "byte":
                    case "date":
                        control = new crmTextBox({
                            shouldPublishMarkDirty: false,
                            disabled: this._inEditMode && !this._EditData.isDynamic && name !== "displayName" && !this.isNewEntity
                        });
                        if (typeof (val) !== "undefined" && val !== null) {
                            control.textbox.value = val;
                        }
                        break;
                    case "boolean":
                        control = new crmCheckBox({
                            shouldPublishMarkDirty: false
                        });
                        if (typeof (val) !== "undefined" && val !== null) {
                            control.setChecked(val);
                        } else if (name === "isNullable") {
                            control.setChecked(true);
                        }
                        break;
                    case "picklist":
                    case "enum":
                        control = new crmDropDowns({
                            value: val,
                            store: collection.data,
                            idProperty: collection.id,
                            searchAttr: collection.text,
                            shouldPublishMarkDirty: false,
                            disabled: this._inEditMode && !this._EditData.isDynamic && name !== "displayName" && !this.isNewEntity,
                            required: false
                        });
                        break;
                }
            }

            domClass.remove(control.domNode, "dijitInline");
            return control;
        },

        _setTypeAttribute: function () {
            var i = this.detailUtility.typeStore.index[this.typeDropDown.value];
            if (this._EditData && typeof (this._EditData) !== "undefined") {
                if (this.typeDropDown.value === "2596d57d-89d6-4b72-9036-b18c64c5324c") {
                    lang.mixin(this.dataTypeData, { Precision: this._EditData.precision, Scale: this._EditData.scale });
                }
                if (typeof (this._EditData.length) !== "undefined" || this._EditData.length !== null) {
                    lang.mixin(this.dataTypeData, { Length: this._EditData.length });
                }
            }


            var readOnly = !(this._inEditMode ? this._EditData.isDynamic : true);
            if (this.isNewEntity)
                readOnly = false;
            // list of values where if they contain the default value are not provided by the endpoint, so a value is provided here(otherwise they get no ui).
            var updateDefaultsOf = ['IsEncrypted', 'IsPercentage', 'ValueStoredAsText', 'AllowMultiples', 'EnableHyperLinking', 'MultiSelect',
                                'NoneEditable', 'ReturnPrimaryKey', 'AlphaSort', 'MustExistInList', 'NoneEditable', 'ReturnPrimaryKey', 'IsNullable'];

            for (var x = 0; x < updateDefaultsOf.length; x++) {
                var valueUDO = updateDefaultsOf[x];
                this._adjustForValuesMatchingBooleanDefaultsMissing(this.detailUtility.typeStore.data[i], valueUDO);
            }

            this.typeAttributeObj = new FieldAttributeController({ viewOnly: readOnly, formData: lang.mixin(this.detailUtility.typeStore.data[i], this.dataTypeData), entity: this.entityName, editMode: this._inEditMode, picklistSchema: this.detailUtility.picklistSchemaData });

            var dataTypeDataDomNode = this._findControllerDom("dataTypeData");
            if (dataTypeDataDomNode !== null) {
                this._setParentDisplayClass(this.typeAttributeObj, dataTypeDataDomNode.parentNode);
                domConstruct.place(this.typeAttributeObj.domNode, dataTypeDataDomNode, 'only');
            }
            if (typeof (this._DynamicSection) !== 'undefined') {
                this.hideControlsBasedOffSelectedFieldType();
            }
        },


        hideControlsBasedOffSelectedFieldType: function () {
            var contentArr = this.activeControllers.data;
            var sectionTemplate = "_${0}Section";

            //First show all, then systematically hide as needed.
            for (var i = 0; i < contentArr.length; i++) {

                var contentItem = contentArr[i];

                if (contentItem && contentItem.name) {
                    this.findDomAndShowDom(dojoString.substitute(sectionTemplate, [contentItem.name]));
                }
            }
			var items2Hide = [];
            var calculatedField = false;
            var typeId = this.typeDropDown.value;
            if (typeof (typeId) === "undefined" && typeId === null) {
                typeId = this._EditData.dataTypeId;
            }
            // hide doms via type
            switch (typeId) {

                case 'f750817f-73ad-4bf3-b2de-bd0f5cc47dfd': //calculatedString
                case '44bc190a-99f3-4fa9-98a3-d5b2336d6e7c':
				{
					items2Hide.push('audited', 'canBulkUpdate', 'canImport', 'canMatch');
                    calculatedField = true;
                    break;
				}
            }
			// hide properties that will not be updated when field is not dynamic and not calculated
            if (this._EditData && !this._EditData.isDynamic && !calculatedField) {
                items2Hide.push('audited', 'isIncluded');
            }

           for (var x = 0; x < items2Hide.length; x++) {
                var item2Hide = items2Hide[x];
                this.findDomAndHideDom(dojoString.substitute(sectionTemplate, [item2Hide]));
            }
        },
        findDomAndHideDom: function (controlAttachPointName) {
            var domToHide = this._findControllerDom(controlAttachPointName, true);
            if (domToHide) {
                domClass.add(domToHide, "display-none");
                domClass.remove(domToHide, "display");
            }
        },
        findDomAndShowDom: function (controlAttachPointName) {
            var domToHide = this._findControllerDom(controlAttachPointName, true);
            if (domToHide) {
                domClass.add(domToHide, "display");
                domClass.remove(domToHide, "display-none");
            }
        },

        _findControllerDom: function (controlAttachPointName, section) {
            var strTemplate = "div.fld[data-dojo-attach-point='${0}']";
            if (section) {
                strTemplate = "tr[data-dojo-attach-point='${0}']";
            }
            var strQuery = dojoString.substitute(strTemplate, [controlAttachPointName]);

            if (this._DynamicSection) {
                var result = query(strQuery, this._DynamicSection);

                if (typeof (result) !== "undefined" && result !== null &&
                    typeof (result.length) !== "undefined" && result.length !== null && result.length > 0) {

                    return result[0]; //return first
                }
            }

            return null;
        },
        _adjustForValuesMatchingBooleanDefaultsMissing: function (typeStoreDataElement, strVar) {
            var hasValueStoredAsText = typeof (typeStoreDataElement) !== "undefined" &&
                (typeof (typeStoreDataElement[strVar]) !== "undefined" &&
                (this.dataTypeData !== null && typeof (this.dataTypeData[strVar]) === "undefined"));
            if (hasValueStoredAsText) {
                this.dataTypeData[strVar] = false;
            }
        },

        /**
        * This is a last method in the initialization process. 
        * It is called after all the child widgets are rendered so it's good for a container widget to finish it's post rendering here. 
        * This is where the container widgets could for example set sizes of their children relative to it's own size.
        */
        startup: function () {
            this.inherited(arguments);
        },

        show: function () {
            if (this._EditData) {
                this._dialog.titleNode.innerHTML = this._title;
            }
            else {
                this._dialog.titleNode.innerHTML = this._title;
            }

            this._dialog.show();
            this.inherited(arguments);
        },
        _cmdSave_OnClick: function () {
            if (this.isNewEntity) {
                this._addItemToStore();
            }
            else {
                this._saveExistingEntity();
            }

        },
        _addItemToStore: function () {
            this._dialog.showLoading();
            var objectsStore = this._generalPropertyValueAdjustments(false, true);
            var property = objectsStore.property;

            this.newProperty = property;
            if (!this.isValid()) {
                this._dialog.hideLoading();
                return;
            }

            if (this._EditData) {
                this.dataStore.remove(this._EditData.propertyName);
            }

            this.dataStore.put(property);
            this._dialog.hideLoading();
            this._dialog.hide();

        },
        _generalPropertyValueAdjustments: function (formValidation, createNew) {
            var activeValues = this.typeAttributeObj.getActiveValues();
            if (formValidation && this.addEditFiltersForm.validate() === false)
                return;

            var propertyObj = this._populdateSDataObject();

            if (!propertyObj.displayName)
                propertyObj.displayName = propertyObj.propertyName;
            if (this.typeDropDown.value === "44bc190a-99f3-4fa9-98a3-d5b2336d6e7c" || this.typeDropDown.value === "f750817f-73ad-4bf3-b2de-bd0f5cc47dfd") {
                activeValues["DisplayName"] = propertyObj.displayName;
                activeValues["isReadOnly"] = true;
            }
            propertyObj["dataTypeData"] = json.stringify(activeValues);
            if (createNew) {
                propertyObj = this._createPropertyValueAdjustments(propertyObj, activeValues);
            }
            return { property: propertyObj, activity: activeValues };
        },
        _createPropertyValueAdjustments: function (propertyObj, activeValues) {
            propertyObj["columnName"] = propertyObj.propertyName.toUpperCase();
            propertyObj["isIncluded"] = true;
            if (typeof (propertyObj["sdata"]) === "undefined" || propertyObj["sdata"] === null) {
                propertyObj["sdata"] = { generate: true };
            }
            else {
                propertyObj["sdata"]["generate"] = true;
            }

            switch (this.typeDropDown.value) {
                case "2596d57d-89d6-4b72-9036-b18c64c5324c":
                    propertyObj["precision"] = activeValues["Precision"];
                    propertyObj["scale"] = activeValues["Scale"];
                    break;
                case "44bc190a-99f3-4fa9-98a3-d5b2336d6e7c":
                case "f750817f-73ad-4bf3-b2de-bd0f5cc47dfd":
                    propertyObj["isReadOnly"] = true;
                    break;
            }

            if (typeof (activeValues["Length"]) !== "undefined" && activeValues["Length"] !== null) {
                propertyObj["length"] = activeValues["Length"];
            }
            return propertyObj;
        },

        _saveExistingEntity: function () {
            var resourceRequest = new Sage.SData.Client.SDataSingleResourceRequest(this.service).setResourceKind(dojoString.substitute('entities("${0}")/properties', [this.entityName]));
            resourceRequest.setQueryArg('language', cookie.getCookie("SLXLanguageSetting"));

            this._dialog.showLoading();
            if (!this.isValid()) {
                this._dialog.hideLoading();
                return;
            }

            var createNew = !this._inEditMode;

            var objectsStore = this._generalPropertyValueAdjustments(true, createNew);
            var property = objectsStore.property;
            var activeValues = objectsStore.activity;

            if (createNew) { //create
                resourceRequest.create(property, {
                    success: function (data) {
                        this._onSaveSuccess(data);
                    },
                    failure: function (data) {
                        this._dialog.hide();
                    },
                    scope: this
                });
            }
            else { //update
                lang.mixin(this._EditData, property);

                if (this.typeDropDown.value === "2596d57d-89d6-4b72-9036-b18c64c5324c") {
                    this._EditData.precision = activeValues["Precision"];
                    this._EditData.scale = activeValues["Scale"];
                }
                if (typeof (activeValues["Length"]) !== "undefined" && activeValues["Length"] !== null) {
                    this._EditData["length"] = activeValues["Length"];
                }

                resourceRequest.setResourceSelector(dojoString.substitute("'${0}'", [this._EditData['$key']]));

                resourceRequest['update'](this._EditData, {
                    isSecurityManager: true,
                    scope: this,
                    ignoreETag: false,
                    success: function (data) {
                        this._onSaveSuccess(data);
                    },
                    failure: function (data) {
                        this._dialog.hide();
                    }
                });
            }
        },
        onSaveSuccess: function (data) {
        },
        _onSaveSuccess: function (data) {
            SDataServiceRegistry._removeFromLocalStorage(this.entityName);
            this._dialog.hideLoading();
            this._dialog.hide();
            this.onSaveSuccess(data);
        },
        _cmdCancel_OnClick: function (context) {
            if (this._dialog) {
                this._dialog.hideLoading();
                this._dialog.hide();
            }
            else if (context._dialog) // context is passed when the 'x' button is pressed
            {
                context._dialog.hideLoading();
                context._dialog.hide();
            }
            dojoConnect.publish('Sage/EntityManager/FieldCanceled');
        },
        isValid: function () {
            this.divValidationMessage.innerHTML = ""; // reset the error message line to blank
            var valid = this.addEditFiltersForm.validate(); // validate the form as a whole

            for (var i = 0; i < this.activeControllers.data.length; i++) {
                var ob = this.activeControllers.data[i];
                if (typeof (ob.control.disabled) !== "undefined" && ob.control.disabled !== true) {
                    var validControl = true;

                    var hitCustom = false;
                    //---- custom validations

                    // ensure that the propertyName being saved is unique.
                    switch (ob.name) {
                        case "propertyName": {
                            validControl = ob.control.isValid(!this._inEditMode);
                            if (typeof (validControl) === "object") {
                                validControl = validControl.value;
                            }
                            hitCustom = true;
                            break;
                        }
                        case "dataTypeId": {
                            var dTIallowed = this.detailUtility.typeStore.query({ supported: true });
                            dTIallowed = new memory({ data: dTIallowed });
                            if (ob.control.item !== null && ob.control.item.id) {
                                validControl = dTIallowed.query({ id: ob.control.item.id }).length > 0;
                            }
                            else {
                                validControl = false;
                            }
                            hitCustom = true;
                            break;
                        }
                    }

                    //----- end custom validations

                    // if the control has its own isValid function run it.
                    if (!hitCustom && typeof (ob.control.isValid) === "function") {
                        ob.control.isValid(true); // should effect control's state
                    }

                    // if the control has its own onChanged function run it.
                    if (typeof (ob.control.onChanged) === "function") {
                        ob.control.onChanged(); // should redraw the control taking into account the state.
                    }

                    // now make sure the state of the control is boiled now into a boolean value
                    if (typeof (ob.control.state) !== "undefined" && typeof (ob.control.required) !== "undefined") {
                        validControl = validControl && ob.control.state !== 'Error' && !(ob.control.state === 'Incomplete' && ob.control.required);
                    }

                    if (!validControl) {
                        ob.control.set('state', 'Error'); // If the control is not valid, mark  it's state as error.
                    }

                    valid = valid && validControl; // want to retain false values to reflect the form's validity as a whole so use &&.
                }
            }
            valid = valid && this.typeAttributeObj.isValid(); // validate the type attributes.
            return valid;
        },

        _populdateSDataObject: function () {
            var retObj = {};

            var dynamic = this.detailUtility.propertyInformation.data;
            for (var i = 0; i < dynamic.length; i++) {
                var item = dynamic[i];

                var sub = {};
                if (item.sub !== null) {

                    for (var x = 0; x < item.sub.data.length; x++) {
                        var data = item.sub.data[x];

                        var svli = this.activeControllers.index[data.name];
                        if (svli > 0) {
                            var svl = this.activeControllers.data[svli];
                            var sv = this._getValue(svl);

                            if (sv !== null) {
                                sub[data.name] = sv;
                            }
                        }
                    }
                    retObj[item.name] = sub;
                }
                else {
                    var vli = this.activeControllers.index[item.name];
                    if (vli >= 0) {
                        var vl = this.activeControllers.data[vli];
                        var v = this._getValue(vl);
                        if (typeof (v) === "object") {
                            lang.mixin(retObj, v);
                        }
                        else if (v !== null) {
                            retObj[item.name] = v;
                        }
                    }
                }
            }
            return retObj;
        },


        _getValue: function (ob) {

            var dClass = ob.control.declaredClass;
            if (dClass.indexOf("TextBox") >= 0) {
                return ob.control.value;
            }
            else if (dClass.indexOf("DisplayName") >= 0) {
                return ob.control.getDetails();
            }
            else if (dClass.indexOf("CheckBox") >= 0) {
                return ob.control.checked;
            }
            else if (dClass.indexOf("FilteringSelect") >= 0) {
                return ob.control.value;
            }
            return null;
        }

    });

    return widget;
});
},
'Sage/UI/Controls/FieldAttributeControlFactory':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'Sage/UI/Forms/FormFromSData',
    'dojo/_base/connect',
    'dojo/_base/declare',
    'dojo/_base/lang',
    'dojo/dom-class',
    'dojo/string',
    'dojo/query',
    'Sage/UI/Controls/TextBox',
    'Sage/UI/Controls/CheckBox',
    'Sage/UI/Controls/SimpleTextarea',
    'Sage/UI/Dialogs',
    'Sage/UI/FilteringSelect',
    'Sage/UI/ComboBox',
    'dojo/store/Memory',
    'Sage/UI/Controls/PropertyDropDown',
    'dojo/aspect',
    'dojo/string',
    'dojo/data/ObjectStore',
    'dojo/store/Observable',
    'dojo/i18n!./nls/FieldAttributeControlFactory',
    'dojo/dom-construct',
    'Sage/UI/Controls/DndSortList',
    'dijit/form/Button',
    'dijit/form/ValidationTextBox',
    'Sage/UI/Forms/PickListManagerForm'
],
function (
    GeneralForm,
    dojoConnect,
    declare,
    lang,
    DomClass,
    dString,
    Query,
    TextBox,
    CheckBox,
    SimpleTextarea,
    dialogue,
    FilteringSelect,
    ComboBox,
    memory,
    PropertyDropDown,
    dojoAspect,
    dojoString,
    ObjectStore,
    Observable,
    nlsResource,
    DomConstruct,
    DndSortList,
    dijitButton,
    ValidationTextBox,
    PickListManagerForm
) {

    var widget = declare('Sage.UI.Controls.FieldAttributeControlFactory', [GeneralForm], {

        store: null,
        defaultEntity: null,
        pickList: null,
        viewOnly: false,
        activeControls: null,
        hiddenValues: null,
        calculatedMapDotToLegacyPath: null,
        picklistManagerForm: PickListManagerForm,
        pickListManagerFormDiv: null,
        picklistSchema: null,
        domConstruct: DomConstruct,
        domClass: DomClass,
        query: Query,
        pickListLoading: false,
        // used to limit access to the pick list after onChange event
        formStatus: 0,


        // a texttbox that does not get marked as dirty
        _createCustomTextBox: function () {
            var custText = declare('Sage.UI.Controls.FieldAttributeControlFactory.customTextBox', Sage.UI.Controls.TextBox, {
                shouldPublishMarkDirty: false
            });
            return custText;
        },
        // a checkbox that does not get marked as dirty
        _createCustomCheckBox: function () {
            var custText = declare('Sage.UI.Controls.FieldAttributeControlFactory.customCheckBox', Sage.UI.Controls.CheckBox, {
                shouldPublishMarkDirty: false
            });
            return custText;
        },
        // a filteringselect that does not get marked as dirty
        _createCustomFilteringSelect: function () {
            var CustomTxtBox = declare('Sage.UI.Controls.FieldAttributeControlFactory.customFilteringSelect', Sage.UI.FilteringSelect, {
                shouldPublishMarkDirty: false,
                required: false
            });
            return CustomTxtBox;
        },
        _createCustomCombBox: function () {
            var CustomTxtBox = declare('Sage.UI.Controls.FieldAttributeControlFactory.customComboBox', Sage.UI.ComboBox, {
                shouldPublishMarkDirty: false,
                required: false
            });
            return CustomTxtBox;
        },
        // a TextArea that does not get marked as dirty:: used by calculated fields
        _createCustomTextArea: function () {
            var CustomTxtBox = declare('Sage.UI.Controls.FieldAttributeControlFactory.customCustomTextArea', [Sage.UI.Controls.SimpleTextarea, ValidationTextBox], {
                shouldPublishMarkDirty: false,
                required: true, // if the calculation is blank, then errors will occur in the detail view of certain smartparts.
                baseClass: "dijitReset dijitInline dijitLeft dijitTextArea dijitValidationContainer",
                templateString: "<div><div class='dijitReset dijitValidationContainer'><input class='dijitReset dijitInputField dijitValidationIcon dijitValidationInner' value='' type='text' tabindex='-1' readonly='readonly' role='presentation'/></div><div class='dijitReset dijitInputField dijitInputContainer'><textarea ${!nameAttrSetting} dojoAttachPoint='focusNode,containerNode,textbox' autocomplete='on'></textarea></div></div>",
                width: '100%'
            });
            return CustomTxtBox;
        },
        _FormSpecificFields: function (obj) {
            this.pickList = [];
            this.activeControls = [];
            this.hiddenValues = [];
            this.pickListManagerFormDiv = {};
            this.calculatedMapDotToLegacyPath = new Observable(new memory({ idProperty: 'dot' }));

            if (typeof (obj) !== 'undefined' && obj !== null) {
                if (typeof (obj.formData) !== 'undefined' && obj.formData !== null) {
                    this.store = obj.formData;
                }
                if (typeof (obj.viewOnly) !== 'undefined' && obj.viewOnly !== null) {
                    this.viewOnly = obj.viewOnly;
                }
                if (typeof (obj.entity) !== 'undefined' && obj.entity !== null) {
                    this.defaultEntity = obj.entity;
                }
                if (typeof (obj.picklistSchema) !== 'undefined' && obj.picklistSchema !== null) {
                    this.picklistSchema = obj.picklistSchema;
                }
            }
        },
        // go through and check what data needs to be shown and display it in the proper control.
        _createForm: function () {
            var self = this;
            var hidden = false;
            if ((typeof (this.store.ClrDataType) !== 'undefined' && this.store.show && this.store.show.indexOf('ClrDataType') >= 0)) {
                this.createAttributeEditor('ClrDataType', this._createCustomTextBox(), this.store.ClrDataType, this.viewOnly);
            }
            if ((typeof (this.store.IsEncrypted) !== 'undefined' && this.store.show && this.store.show.indexOf('IsEncrypted') >= 0)) {
                this.createAttributeEditor('IsEncrypted', this._createCustomCheckBox(), this.store.IsEncrypted, this.viewOnly);
            }
            if ((typeof (this.store.Length) !== 'undefined' && this.store.show && this.store.show.indexOf('Length') >= 0)) {
                this.createAttributeEditor('Length', this._createCustomTextBox(), this.store.Length, this.viewOnly);
            }
            if ((typeof (this.store.SqlType) !== 'undefined' && this.store.show && this.store.show.indexOf('SqlType') >= 0)) {
                this.createAttributeEditor('SqlType', this._createCustomTextBox(), this.store.SqlType, this.viewOnly);
            }
            if ((typeof (this.store.This) !== 'undefined' && this.store.show && this.store.show.indexOf('This') >= 0)) {
                this.createAttributeEditor('this', this._createCustomTextBox(), this.store.This, this.viewOnly);
            }
            if ((typeof (this.store.Precision) !== 'undefined' && this.store.show && this.store.show.indexOf('Precision') >= 0)) {
                this.createAttributeEditor('Precision', this._createCustomTextBox(), this.store.Precision, this.viewOnly);
            }
            if ((typeof (this.store.Scale) !== 'undefined' && this.store.show && this.store.show.indexOf('Scale') >= 0)) {

                this.createAttributeEditor('Scale', this._createCustomTextBox(), this.store.Scale, this.viewOnly);
            }
            if ((typeof (this.store.IsPercentage) !== 'undefined' && this.store.show && this.store.show.indexOf('IsPercentage') >= 0)) {
                this.createAttributeEditor('IsPercentage', this._createCustomCheckBox(), this.store.IsPercentage, this.viewOnly);
            }
            if ((typeof (this.store.MultiSelect) !== 'undefined' && this.store.show && this.store.show.indexOf('MultiSelect') >= 0)) {
                this.createAttributeEditor('MultiSelect', this._createCustomCheckBox(), this.store.MultiSelect, this.viewOnly);
            }
            if ((typeof (this.store.OverriddenName) !== 'undefined' && this.store.show && this.store.show.indexOf('OverriddenName') >= 0)) {
                this.createAttributeEditor('OverriddenName', this._createCustomTextBox(), this.store.OverriddenName, this.viewOnly);
            }
            if ((typeof (this.store.StorageOptions) !== 'undefined' && this.store.show && (this.store.show.indexOf('Storage') >= 0))) {
                hidden = typeof (this.store.ClrDataType) !== 'undefined' && this.store.ClrDataType.indexOf('Guid') >= 0;
                if (hidden) {
                    this.hiddenValues.push({ Storage: this.store.Storage });
                }
                else {
                    this.createAttributeStorage('Storage', this._createCustomFilteringSelect(), this.store.Storage, this.store.StorageOptions, this.viewOnly || this.editMode, false);
                }
            }
            if ((typeof (this.store.StorageOptions) !== 'undefined' && this.store.show && (this.store.show.indexOf('Display') >= 0))) {
                var hideAndDisable = (this.store.show.indexOf('Storage') >= 0);
                this.createAttributeStorage('Display', this._createCustomFilteringSelect(), this.store.Display, this.store.DisplayOptions, hideAndDisable, hideAndDisable);
            }
            if ((typeof (this.store.EnableHyperLinking) !== 'undefined' && this.store.show && this.store.show.indexOf('EnableHyperLinking') >= 0)) {
                this.createAttributeEditor('EnableHyperLinking', this._createCustomCheckBox(), this.store.EnableHyperLinking, this.viewOnly);
            }
            if ((typeof (this.store.ReturnPrimaryKey) !== 'undefined' && this.store.show && this.store.show.indexOf('ReturnPrimaryKey') >= 0)) {
                this.createAttributeEditor('ReturnPrimaryKey', this._createCustomCheckBox(), this.store.ReturnPrimaryKey, this.viewOnly);
            }
            if ((typeof (this.store.PickListName) !== 'undefined' && this.store.show && this.store.show.indexOf('PickListName') >= 0)) {
                this._grabPickList();
                this.createAttributeStorage('PickListName', this._createCustomCombBox(), this.store.PickListName, this.pickList, this.viewOnly, false);
                dojoConnect.subscribe('Sage/picklist/form/reload', lang.hitch(this, this.reloadPickListForm));
            }
            if ((typeof (this.store.AllowMultiples) !== 'undefined' && this.store.show && this.store.show.indexOf('AllowMultiples') >= 0)) {
                this.createAttributeEditor('AllowMultiples', this._createCustomCheckBox(), this.store.AllowMultiples, this.viewOnly);
            }
            if ((typeof (this.store.AlphaSort) !== 'undefined' && this.store.show && this.store.show.indexOf('AlphaSort') >= 0)) {
                this.createAttributeEditor('AlphaSort', this._createCustomCheckBox(), this.store.AlphaSort, this.viewOnly);
            }
            if ((typeof (this.store.MustExistInList) !== 'undefined' && this.store.show && this.store.show.indexOf('MustExistInList') >= 0)) {
                this.createAttributeEditor('MustExistInList', this._createCustomCheckBox(), this.store.MustExistInList, this.viewOnly);
            }
            if ((typeof (this.store.NoneEditable) !== 'undefined' && this.store.show && this.store.show.indexOf('NoneEditable') >= 0)) {
                this.createAttributeEditor('NoneEditable', this._createCustomCheckBox(), this.store.NoneEditable, this.viewOnly);
            }
            if ((typeof (this.store.PickListFilter) !== 'undefined' && this.store.show && this.store.show.indexOf('PickListFilter') >= 0)) {
                this.createAttributeEditor('PickListFilter', this._createCustomTextBox(), this.store.PickListFilter, this.viewOnly);
            }
            if ((typeof (this.store.ValueStoredAsText) !== 'undefined' && this.store.show && this.store.show.indexOf('ValueStoredAsText') >= 0)) {
                this.createAttributeEditor('ValueStoredAsText', this._createCustomCheckBox(), this.store.ValueStoredAsText, this.viewOnly || this.editMode);
            }
            if ((typeof (this.store.DisplayName) !== 'undefined' && this.store.show && (this.store.show.indexOf('DisplayName') >= 0))) {
                hidden = typeof (this.store.ThisObj) !== 'undefined' && this.store.ThisObj.indexOf('Calculated String field') >= 0;
                if (hidden) {
                    this.hiddenValues.push({ DisplayName: this.store.DisplayName });
                }
                else {
                    this.createAttributeEditor('Display', this._createCustomTextBox(), this.store.DisplayName, this.viewOnly);
                }
            }
            if ((typeof (this.store.Description) !== 'undefined' && this.store.show && (this.store.show.indexOf('Description') >= 0))) {
                this.createAttributeEditor('Description', this._createCustomTextBox(), this.store.Description, this.viewOnly && (this.store.show.indexOf('Template') < 0));
            }
            if ((typeof (this.store.Template) !== 'undefined' && this.store.show && (this.store.show.indexOf('Template') >= 0))) {
                this._createDropDownSelectorWithDisplayTextField('Template', this.store.Template, this.viewOnly, true);
            }
        },
        // Creates a pair of controls, one relying on the other: A Property Selector that can populate a textbox.
        _createDropDownSelectorWithDisplayTextField: function (attach, store, dis, useProperties) {
            var selfAware = this;
            var Widget = this._createCustomTextArea();

            var useAsDropDown = null;
            var typeFilter = [{ name: 'calculated', value: false }];
            var buttonArry = [];
            if (this.store.type !== 0) {
                typeFilter.push({ name: 'number', value: true });
            }

            if (store && store !== '') {
                this._buildDotPathFromLegacy(store); // converts and adds to the property list
            }

            store = this._convertLegacyToDot(store); // converts for use in text area

            var valArr = [];
            var values = null;
            var cntr = {
                PropertyDropDown: new PropertyDropDown({
                    entityName: this.defaultEntity,
                    Keywords: typeFilter,
                    allMatch: true,
                    required: false
                }),
                TextBox: new Widget({
                    value: store,
                    shouldPublishMarkDirty: false,
                    autoComplete: true,
                    isValid: function () {
                        var validity = this.textbox.value.replace(/\s+$/g) !== '';
                        if (!validity) {
                            this.textbox.validity.badInput = true;
                            this.textbox.validity.tooShort = true;
                            this.textbox.validity.valueMissing = true;
                            this.textbox.validity.valid = false;
                        }
                        if (selfAware.store.type !== 0) {
                            var re = new RegExp('({.*?}|[0-9]|[+]|[*]|[/]|[(]|[)]|[-])', 'gm'),
                                str = this.textbox.value,
                                matchesStr = '',
                                m;
                            while ((m = re.exec(str)) !== null) {
                                if (m.index === re.lastIndex) {
                                    re.lastIndex++;
                                }
                                matchesStr = matchesStr + m[0];

                            }
                            validity = validity && matchesStr.length === this.textbox.value.length;
                            if (!validity) {
                                this.textbox.validity.badInput = true;
                                this.textbox.validity.valid = false;
                            }
                            else {
                                this.textbox.validity.badInput = false;
                                this.textbox.validity.valid = true;
                            }
                        }
                        return validity;
                    }
                })
            };

            if (this.store.type !== 0) {
                cntr.TextBox.invalidMessage = nlsResource.CalculatedNumberInputError;
                var btnLbl = [{ l: '+', t: nlsResource.add }, { l: '-', t: nlsResource.substract }, { l: '*', t: nlsResource.multiply }, { l: '/', t: nlsResource.divide }, { l: '(', t: nlsResource.openParens }, { l: ')', t: nlsResource.closeParens }];
                var buttonListCntrl = this.domConstruct.toDom(this.buttonListTemplate.apply());

                for (var ix = 0; ix < btnLbl.length; ix++) {
                    var myButton = new dijitButton({
                        label: btnLbl[ix].l,
                        title: btnLbl[ix].t,
                        onClick: function () {
                            cntr.TextBox.textbox.value = dString.substitute('${0}${1}', [cntr.TextBox.textbox.value, this.label]);
                        }
                    });
                    this.domClass.add(myButton.domNode, 'calcuNumberButton');
                    buttonListCntrl.appendChild(myButton.domNode);
                }
                cntr.ButtonList = buttonListCntrl;

            }
            this.domClass.remove(cntr.PropertyDropDown.domNode, 'dijitInline');
            this.domClass.remove(cntr.TextBox.domNode, 'dijitInline');

            // This updates the Template Textbox when the property drop down's selected a value
            cntr.PropertyDropDown.entitySelected.onChange = function () {
                var selected = cntr.PropertyDropDown.tree.selectedItem;
                if (selected) {
                    var cValue = selected.columName;
                    if (typeof (cValue) !== 'undefined' && cValue !== '') {
                        selfAware.calculatedMapDotToLegacyPath.put({ dot: cValue, legacy: selected.legacyPath });
                        cntr.TextBox.set('value', dString.substitute('${0}{${1}}', [cntr.TextBox.get('value'), cValue]));
                    }
                }
            };

            // create a blank line with the control group's label
            this.activeControls.push({ label: nlsResource[attach], name: attach, control: null, isDom: false, template: 'rowTemplate', display: 'display', Include: true, fieldClassAppendix: 'typeattributedetails' });
            this.activeControls.push({ label: nlsResource['AddField'], name: attach, control: cntr.PropertyDropDown, isDom: false, template: 'rowTemplate', display: 'display', Include: false, fieldClassAppendix: 'typeattributedetails' });
            if (cntr.ButtonList) {
                this.activeControls.push({ label: '', name: attach, control: cntr.ButtonList, isDom: true, template: 'rowTemplate', display: 'display', Include: false, fieldClassAppendix: 'typeattributedetails' });
            }
            this.activeControls.push({ label: '', name: attach, control: cntr.TextBox, isDom: false, template: 'rowTemplate', display: 'display', Include: true, fieldClassAppendix: 'typeattributedetails' });

            return cntr;
        },
        //Used to parse out potential fields added to the template
        _grabEntityPropertyNamesFromString: function (strValue) {
            // {.+?} - looks for anything within curly braces, and takes the shortest match so in the string '{{a}{b}}'. {a} and {b} should be returned, but not {{a}{b}}.
            // . is a wildcard for anything; 
            // + means 1 or more times, since assuming no blank values in braces; 
            // ? limits the inside of the braces to shortest match.
            var regex = new RegExp(/([{].+?[}])/gm);
            var propertySplits = strValue.match(regex);

            var retVal = new memory();

            // clean up the spaces, and add to a memory data structure.
            for (var i = 0; propertySplits !== null && i < propertySplits.length; i++) {
                var name = propertySplits[i];
                name = name.replace('{', '');
                name = name.replace('}', '');
                name = name.replace(' ', '');
                if ((typeof (retVal.index[name]) === 'undefined' || retVal.index[name] < 0) && name !== '') {
                    retVal.add({ id: name, name: name });
                }
            }

            return retVal;
        },
        // takes the legacy value provided by the server, and converts it to a more readable format ('dot' notation).
        _buildDotPathFromLegacy: function (legacy) {
            var list = this._grabEntityPropertyNamesFromString(legacy);
            for (var i = 0; i < list.data.length; i++) {
                var leg = list.data[i].name;
                var dot = '';
                var regex1 = new RegExp(/([.].*?!)/gm);//find the related entities they should look like .(Related Entity)!
                var legacyParts = leg.match(regex1);
                if (legacyParts !== null && legacyParts) {
                    for (var x = 0; x < legacyParts.length; x++) {
                        var rEntity = legacyParts[x].replace('.', '').replace('!', '');
                        dot = dojoString.substitute('${0}${1}${2}', [dot, x === 0 ? '' : '.', rEntity]);
                    }
                }
                var index = leg.lastIndexOf('!');
                if (index < 0) {
                    index = -1;
                }

                dot = dojoString.substitute('${0}${1}${2}', [dot, dot.length === 0 ? '' : '.', leg.substring(index + 1)]);
                this.calculatedMapDotToLegacyPath.put({ dot: dot, legacy: leg });
            }
        },
        _convertDotToLegacy: function (value) {
            return this._propertyPathConverter(value, 'dot', 'legacy');
        },
        _convertLegacyToDot: function (value) {
            return this._propertyPathConverter(value, 'legacy', 'dot');
        },
        _propertyPathConverter: function (value, fromField, toField) {
            var together = value;
            var regex1 = new RegExp(/(.*?|[+|\\|\/|*|-]?)([{].*?[}])(.*?|[+|\\|\/|*|-]?)/gm);
            var wordList = value.match(regex1);
            var matchArray = [];
            for (var i = 0; wordList !== null && i < wordList.length; i++) {
                var word = wordList[i];
                var matchArrayEntry = { from: word, to: {} };

                var startIndex = word.indexOf('{') + 1;
                var length = word.indexOf('}') - startIndex;

                if (startIndex >= 0 && length > 0 && (length - startIndex) <= word.length) {
                    var where = word.substr(startIndex, length);

                    var qry = this.calculatedMapDotToLegacyPath.query(function (v) {
                        return v[fromField] === where;
                    });

                    var match = new memory({ data: qry });
                    if (match.data.length === 1) {
                        var basePattern = dojoString.substitute('${0}:', [this.defaultEntity]);
                        var newWord = match.data[0][toField].replace(basePattern, '');
                        word = word.replace(match.data[0][fromField], newWord);
                    }
                    matchArrayEntry.to = word;
                    matchArray.push(matchArrayEntry);
                }
            }
            for (i = 0; i < matchArray.length; i++) {
                together = together.replace(matchArray[i].from, matchArray[i].to);
            }
            return together;
        },
        // handles the creation of checkboxes and 
        createAttributeEditor: function (attach, Widget, val, dis) {
            var txt = new Widget({
                value: val,
                shouldPublishMarkDirty: false,
                disabled: dis
            });
            if (Widget.prototype.declaredClass.indexOf('CheckBox') >= 0) {
                txt.setChecked(val);
            }

            this.domClass.remove(txt.domNode, 'dijitInline');


            this.activeControls.push({ label: nlsResource[attach], name: attach, control: txt, isDom: false, template: 'rowTemplate', display: 'display', Include: true, fieldClassAppendix: 'typeattributedetails' });
        },
        createAttributeStorage: function (attach, Widget, val, options, dis, hidden) {
            var dataS = null, selfAware = this;
            if (attach === 'PickListName') {
                dataS = new memory({ data: options, idProperty: 'name' });
                attach = 'PickList';
            }
            else {
                dataS = new memory({ data: options });
            }

            var cntrl = new Widget({
                shouldPublishMarkDirty: false,
                disabled: dis,
                name: attach,
                searchAttr: 'name',
                store: dataS,
                fetchProperties: { sort: [{ attribute: 'name', descending: false }] }
            });

            var result = val;
            if (attach === 'PickList') {
                dojoAspect.before(cntrl, 'loadAndOpenDropDown', lang.partial(this._startPKListLoad, cntrl, this));
                cntrl.onChange = function () {
                    selfAware._pickListOnChange(selfAware, this.value, this.item);
                };
            }  
            if (attach === 'Storage' || attach === 'Display') {
                switch(val) {
                    case 'Text':
                    case 'TextUnicode':
                        result = options.filter(function(x){ return x.id === 'Text' || x.id === 'TextUnicode';});
                        break;
                    case 'Code':
                    case 'CodeUnicode':
                        result = options.filter(function(x){ return x.id === 'Code' || x.id === 'CodeUnicode';});
                    break;
                }
                if(result  && result.length > 0) {
                    result = result[0].id;
                }
            }
            if (attach === 'Storage' && (this.store.show.indexOf('Display') >= 0)) {
                cntrl.onChange = function () {
                    var queryResult = $(this.domNode.offsetParent.offsetParent).find("[name='Display']");
                    if (!(this.viewOnly || this.editMode) && queryResult !== null && queryResult[0] !== null) {
                        var foundControl = queryResult[0];
                        if (foundControl) {
                            foundControl.value = this.value;
                        }
                        foundControl = foundControl.previousSibling;
                        if (foundControl) {
                            foundControl.value = this.value;
                        }
                    }
                };
            }
            cntrl.set('value', result); // allows the picklist onChange override to be applied to provided data.
            this.domClass.remove(cntrl.domNode, 'dijitInline');
            this.activeControls.push({ label: nlsResource[attach], name: attach, control: cntrl, isDom: false, template: 'rowTemplate', display: hidden ? 'display-none' : 'display', Include: true, fieldClassAppendix: 'typeattributedetails' });
        },
        _pickListOnChange: function (selfAware, value, item) {
            var newDisplayText = dString.substitute("--- ${0} ---", [nlsResource.newPickList]);
            var formObject = {
                defaultLanguage: '',
                name: value || newDisplayText,
                allowMultiples: false, valueMustExist: false, required: false, alphaSorted: false, noneEditable: false,
                items: []
            };
            var hideShow = ['AllowMultiples', 'AlphaSort', 'MustExistInList', 'NoneEditable'];
            var service = Sage.Data.SDataServiceRegistry.getSDataService('system', false, true, false);
            if (typeof (item) === 'undefined' || item === null) {
                var request1 = new Sage.SData.Client.SDataResourceCollectionRequest(service);
                request1.setResourceKind('picklists')
                    .setQueryArg('select', '*') // there can be a lot of items associated with a pick list, load these once an items has been selected.
                    .setQueryArg('format', 'json')
                    .setQueryArg('where', dString.substitute("lower(name) eq '${0}'", [value.toLowerCase()]));
                request1.setQueryArg('count', 1);
                this.pickList = [];

                this.pickListLoading = true;
                request1.read({
                    async: false,
                    scope: this,
                    success: function (data) {
                        if (data.$resources && data.$resources.length > 0) {
                            item = data.$resources[0];
                            item.id = item.$key;
                            if (item.defaultLanguage) {
                                formObject.defaultLanguage = item.defaultLanguage;
                            }
                        }
                    },
                    failure: this._pkListLoadFailure
                });
            }
            var preExisting = item !== null && (item.id !== '000new');
            // check if the form is reloading, need to remove old version of form later.
            var plmIndexInActiveControls = selfAware._getIndexFromActivityListFromName('PickListForm');
            var plmIndexInActiveControlsValid = plmIndexInActiveControls > -1;

            // get reference to the drop down to possibly set the displayed value.
            var pk_cntrl_indx = this._getIndexFromActivityListFromName('PickList');
            var pk_cntrl = null;
            if (pk_cntrl_indx > -1) {
                pk_cntrl = this.activeControls[pk_cntrl_indx];
            }
            if (preExisting) { // populate with data here if we know we have data to use
                formObject.$key = item.id;
                var request2 = new Sage.SData.Client.SDataResourceCollectionRequest(service);
                request2.setResourceKind(dString.substitute("picklists('${0}')",[formObject.$key]))
                    .setQueryArg('select', '*,items/*') // there can be a lot of items associated with a pick list, load these once an items has been selected.
                    .setQueryArg('format', 'json');
                request2.setQueryArg('count', 1);
                this.pickList = [];

                this.pickListLoading = true;
                request2.read({
                    async: false,
                    scope: this,
                    success: function (data) {
                        if (data.$resources && data.$resources.length > 0) {
                            data = data.$resources[0];
                        }
                        if (data.defaultLanguage) {
                            formObject.defaultLanguage = data.defaultLanguage;
                        }
                        if (data.items && data.items.$resources) {
                            formObject.items = data.items.$resources;
                        }
                        else {
                            formObject.items = [];
                        }
                        if (this.editMode === false) {
                            this.setControlValue('AllowMultiples', data.allowMultiples);
                            this.setControlValue('AlphaSort', data.alphaSorted);
                            this.setControlValue('MustExistInList', data.valueMustExist);
                            this.setControlValue('NoneEditable', data.noneEditable);
                        }
                    },
                    failure: this._pkListLoadFailure
                });
                if (pk_cntrl !== null) {
                    pk_cntrl = pk_cntrl.control;
                    pk_cntrl.focusNode.value = value; // set in a viewable way the displayed value without triggering the onchange event
                }
            } else {
                if (value && value !== newDisplayText) {
                    formObject.name = lang.clone(value);
                    if (pk_cntrl !== null) {
                        pk_cntrl = pk_cntrl.control;
                        pk_cntrl.focusNode.value = newDisplayText; // set in a viewable way the displayed value without triggering the onchange event
                    }
                } else {
                    formObject.name = '';
                }
            }
            // hide the needed property fields, because we are using the forms
            selfAware._showHideElementsByNames(selfAware, hideShow, !preExisting, 'grandparent');

            if (plmIndexInActiveControlsValid) { // if we have an old reference to the picklist manager remove it from active list and screen
                var controlObj = this.activeControls[plmIndexInActiveControls].control.domNode;
                DomClass.add(controlObj, 'display-hidden');
                selfAware.domConstruct.destroy(controlObj);
                selfAware.activeControls.splice(plmIndexInActiveControls, 1);
            }
            // add new pick list manager
            selfAware._createPickListManagerForm(selfAware, formObject, preExisting, plmIndexInActiveControlsValid);

        },
        _createPickListManagerForm: function (selfAware, formObject, existingPickList, replace) {
            var supressFields = ['createuser', 'createdate', 'modifydate', 'modifyuser'];
            if (existingPickList) { // supress on edits
                supressFields.push('valuestoredastext');
                supressFields.push('allowmultiples');
                supressFields.push('valuemustexist');
                supressFields.push('alphasorted');
                supressFields.push('required');
                supressFields.push('noneeditable');
                supressFields.push('name');
            } else {
                supressFields.push('defaultlanguage');
            }
            var obj = {
                schemaReader: selfAware.picklistSchema,
                suppressFields: supressFields,
                excludeOnNew: [],
                formData: formObject,
                displayFormButtons: ['ok'],
                editMode: existingPickList
            };

            var plmfObj = new selfAware.picklistManagerForm(obj);
            var placement = 'after';
            var referenceNode = selfAware.attributeContainer;

            if (replace) {
                placement = 'replace';
                var plmfHeaderNode = selfAware.attributeContainer.parentNode.children[1];
                if (typeof (plmfHeaderNode) !== 'undefined') {
                    referenceNode = plmfHeaderNode;
                }
                else {
                    placement = 'after';
                }
            }
            selfAware.domConstruct.place(plmfObj.domNode.firstChild, referenceNode, placement);
            selfAware.activeControls.push({ label: '', name: 'PickListForm', control: plmfObj, isDom: true, template: 'rowTemplate', display: 'display', Include: true, fieldClassAppendix: 'typeattributedetails' });
        },
        reloadPickListForm: function (value) {
            this._grabPickList(false);
            var pk_idx = this._getIndexFromActivityListFromName('PickList');
            var pk_cntrl = this.activeControls[pk_idx].control;
            // Force an onChange to occur by resetting the value in the picklist to the standard new pick list label
            if (pk_cntrl.displayedValue === value.name) {
                pk_cntrl.set('value', '--- ' + nlsResource.newPickList + ' ---');
            }
            this.formStatus = 1; // used to limit access to the pick list after onChange event
            dojoAspect.after(pk_cntrl, 'onChange', lang.hitch(this, function () {
                if (this.formStatus === 1) {
                    this.formStatus = 0;
                    value.id = value.$key;
                    if (value) {
                        this._pickListOnChange(this, value.name, value);
                    }
                }
            }));

            pk_cntrl.set('value', value.name);
        },
        _grabPickList: function (async, count) {
            var request = new Sage.SData.Client.SDataResourceCollectionRequest(Sage.Data.SDataServiceRegistry.getSDataService('system', false, true, false));
            if (typeof (count) === 'undefined' || count === null) {
                count = 500;
            }
            request.setResourceKind('picklists')
                .setQueryArg('select', '*') // grab the items only once the picklist has been selected.
                .setQueryArg('orderby', 'name')
                .setQueryArg('format', 'json');
            request.setQueryArg('count', count);

            this.pickList = [];
            if (typeof (async) === 'undefined' || async === null) {
                async = true;
            }
            this.pickListLoading = true;
            var key = request.read({
                async: async,
                scope: this,
                success: this._pkListLoadSuccess,
                failure: this._pkListLoadFailure
            });
        },
        _startPKListLoad: function (cntrl, context) {
            var domForStandby=cntrl.domNode;
            var standby = new dojox.widget.Standby({
                target: domForStandby,
                color: 'white',
                image: 'css/themes/inforSoHoXi/images/loadingAnimation.gif'
            });
            domForStandby.appendChild(standby.domNode);

            if (context.pickListLoading) {
                standby.startup();
                standby.show();
            }
            var closeItDown = function () {
                standby.hide();
            };
            dojoAspect.before(cntrl, 'closeDropDown', closeItDown);
        },
        _pkListLoadSuccess: function (data) {
            this.pickListLoading = false;
            var plFields = data.$resources;
            for (var i = 0; i <= plFields.length - 1; i++) {
                this.pickList.push({
                    id: plFields[i].$key,
                    name: plFields[i].$descriptor,
                    use: plFields[i].name,
                    items: plFields[i].items
                });
            }
            if (Sage.Services.getService('RoleSecurityService').hasAccess('Administrator/Picklist/add')) {
                this.pickList.push({
                    id: '000new',
                    name: '--- ' + nlsResource.newPickList + ' ---',
                    use: '--- ' + nlsResource.newPickList + ' ---',
                    items: null
                });
            }
            // update the pick list store so that newly created lists get included.
            var control_index = this._getIndexFromActivityListFromName('PickList');
            var control = null;
            if (control_index > -1) {
                control = this.activeControls[control_index];
            }
            if (control !== null && control.control) {
                control.control.set('store', new memory({ data: this.pickList, idProperty: 'name' }));
            }
        },
        _pkListLoadFailure: function (error) {
            this.pickListLoading = false;
            if (error) {
                console.error(error);
            }
        },
        customValidation: function (ob) {
            if (typeof (ob.control.isValid) === 'function') {
                if (ob.Include && ob.name === 'Template' || ob.name === 'PickListForm') {
                    var validControl = ob.control.isValid(true);
                    if (ob.name === 'PickListForm' && validControl) {
                        this._grabPickList();
                    } else {
                        return null;
                    }
                    return validControl;
                }
                else {
                    return ob.control.isValid(true);
                }
            }
            return null;
        },
        _getActiveValuesAdjustments: function () {
            var holder = {};
            var newPL = this.activeControls.filter(function (c) { return c.name.toLowerCase() === 'picklistform'; });
            if (typeof (newPL) === 'object' && newPL.length && newPL.length > 0) {
                newPL = newPL[0].control;
                var valueArr = newPL.getActiveValues();
                var doNotMatchByName = [{ name: 'alphasort', key: 'alphaSorted' }, { name: 'mustexistinlist', key: 'valueMustExist' }];
                var listOfList = [newPL.activeControls, doNotMatchByName];
                for (var lol_i = 0; lol_i < listOfList.length; lol_i++) {
                    var lol_item = listOfList[lol_i];
                    for (var ilol_i = 0; ilol_i < lol_item.length; ilol_i++) {
                        var ilol_item = lol_item[ilol_i];
                        var grab = this.activeControls.filter(function (c) {
                            return c.name.toLowerCase() === ilol_item.name.toLowerCase();
                        });
                        if (typeof (grab) === 'object' && grab.length && grab.length > 0) {
                            var potential_V = valueArr[ilol_item.name];
                            if (typeof (potential_V) === 'undefined' && ilol_item.key && typeof (valueArr[ilol_item.key]) !== 'undefined') {
                                potential_V = valueArr[ilol_item.key];
                            }
                            if (typeof (potential_V) !== 'undefined') {
                                holder[grab[0].name] = potential_V;
                            }
                        }
                    }
                }
                var newName=valueArr['name'];
                if (typeof (newName) !== 'undefined') {
                    holder['PickListName'] = newName;
                }
            }
            return holder;
        },
        _changeObjectPathParameters: function (path, value, propName, skip, stringifyValue) {
            // build path is used to build json object.
            return {
                propName: propName === 'PickList' ? 'PickListName' : propName,
                path: path === 'PickList' ? 'PickListName' : path,
                builtUpPath: dString.substitute('"${0}":${1}', [propName === 'PickList' ? 'PickListName' : propName, JSON.stringify(value)]),
                skip: skip,
                stringify: stringifyValue,
                lineEscape: ''
            };
        }
    });

    return widget;
});
},
'Sage/UI/Forms/FormFromSData':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define, cookie  */
define([
    'dijit/_Widget',
    'Sage/_Templated',
    'dojo/_base/connect',
    'dojo/_base/declare',
    'dojo/_base/lang',
    'dojo/dom-class',
    'dojo/string',
    'Sage/UI/Controls/TextBox',
    'Sage/UI/Controls/CheckBox',
    'Sage/UI/Controls/SimpleTextarea',
    'Sage/UI/FilteringSelect',
    'Sage/UI/Controls/DndSortList',
    'Sage/UI/Controls/PropertyDropDown',
    'Sage/UI/Controls/DateTimePicker',
    'Sage/UI/GridView',
    'dojo/aspect',
    'dojo/store/Memory',
    'dojo/data/ObjectStore',
    "dojo/store/Observable",
    'dojo/dom-construct',
    'dojo/_base/connect',
    'dijit/form/Button',
    "dijit/form/ValidationTextBox",
    "dojo/i18n!./../nls/GridView",
    'dojo/i18n!./nls/FormFromSData',
    'dojo/query'
],
function (
    _Widget,
    _Templated,
    dojoConnect,
    declare,
    lang,
    domClass,
    dString,
    TextBox,
    CheckBox,
    SimpleTextarea,
    FilteringSelect,
    DndSortList,
    PropertyDropDown,
    DateTimePicker,
    GridView,
    dojoAspect,
    memory,
    ObjectStore,
    Observable,
    domConstruct,
    connect,
    dijitButton,
    ValidationTextBox,
    gridNLS,
    formNLS,
    query
) {

    var widget = declare('Sage.UI.Forms.FormFromSData', [_Widget, _Templated], {

        widgetsInTemplate: true,
        widgetTemplate: new Simplate(eval(["<div>", "<table style='overflow-y:show;' class='detailTableContainer formtable' dojoattachpoint='attributeContainer' />", "</div>"])),

        rowTemplate: ['<tr data-dojo-attach-point="_{%= $.name %}Section" name="_{%= $.name %}Section">',
                         '<td class="FManagerDialogFieldLabel {%= $.display %}">',
                             '<div style="padding:0 !important;" class="lbl alignright">',
                                 '<label style="line-height:32px !important;">',
                                     '{%= $.label %}',
                                 '</label>',
                             '</div>',
                             '<div class="fld  dijitInline {%= $.fieldClassAppendix %}" data-dojo-attach-point="{%= $.name %}"></div>',
                         '</td>',
                     '</tr>'],
        validationAndButtonRowTemplate: ['<div>',
                                 '<div data-dojo-attach-point="divValidationMessage" class="errorText">',
                                     '<span data-dojo-attach-point="spanValidationMessage">&nbsp;</span>',
                                 '</div>',
                                     '<div class="lookupButtonWrapper" data-dojo-attach-point="btnController">',
                                 '</div>',
                         '</div>'],
        formIssueTemplate: [
                             '<div style="padding:0 !important;" class="lbl alignright">',
                                 '<label style="line-height:32px !important;">',
                                     '{%= $.label %}',
                                 '</label>',
                             '</div>'],
        buttonListTemplate: new Simplate(["<div class='ButtonActionList'></div>"]),


        activeControls: null,
        editMode: false,
        dumbDTControlCounterForId: 0,
        excludeOnNew: [],
        listOfSupressFields: [],
        useDisplayNameControl: true,
        formData: {},
        _oformData: {},
        gridNlsResource: gridNLS,
        formNlsResource: formNLS,
        formButtonControl: [],
        displayFormButtons: ['ok', 'cancel'],
        _dialogue: null,
        _embedded: false,
        schema: [],
        permittedActions: [],
        // security
        allowViaAddRule: "",
        allowViaEditRule: "",
        allowViaViewRule: "",
        allowViaDeleteRule: "",
        // the sdata endpoint backing the form. ie picklist, entity, entity/filter...
        formBase: "main",
        // used during validation to signify what fields need to be checked if a duplicate exists, and the where statement.
        duplicateCheck: [],
        saveIfValid: { update: false, insert: false },

        constructor: function (obj) {

            this.formButtonControl = [{ label: formNLS.okText, dojoattachpoint: "ok", onClick: "save" }, { label: formNLS.cancelText, dojoattachpoint: "cancel", onClick: "cancel" }];

            this.dumbDTControlCounterForId = 0;
            var reader = {};

            this.schema = [];
            this.permittedActions = [];
            this.activeControls = [];

            if (obj.schemaReader) {
                reader = obj.schemaReader;
            }
            if (obj.suppressFields) {
                this.listOfSupressFields = obj.suppressFields;
            }
            if (obj.excludeOnNew) {
                this.excludeOnNew = obj.excludeOnNew;
            }
            if (obj.formData !== null && typeof (obj.formData) === "object") {
                this.formData = obj.formData;
                this._oformData = lang.clone(obj.formData);
                this.editMode = true;
            }
            if (typeof (obj.editMode) === "boolean") { // the case where there is data passed to the form on create.
                this.editMode = obj.editMode;
            }
            if (typeof (obj.embedded) === "boolean") {
                this._embedded = obj.embedded;
            }
            this._FormSpecificFields(obj);
            this.securityRules();

            this._createForm(reader);
        },
        postCreate: function () {
            var contentArr = this.activeControls;

            if (this._embedded) {
                domClass.remove(this.attributeContainer, "mainContentContent");
                domClass.remove(this.attributeContainer, "DialogMainForm");
            }
            else {
                domClass.add(this.attributeContainer, "mainContentContent");
                domClass.add(this.attributeContainer, "DialogMainForm");
            }

            for (var contentArr_i = 0; contentArr_i < contentArr.length; contentArr_i++) {
                this._moveActiveControlFromBackGroundToPage(contentArr[contentArr_i]);
            }

            var simplateRowTemplate = new Simplate(this.validationAndButtonRowTemplate);
            var row = simplateRowTemplate.apply();
            var rowDom = domConstruct.toDom(row);

            if (this.permittedActions.indexOf('add') >= 0) {
                for (contentArr_i = 0; contentArr_i < this.formButtonControl.length; contentArr_i++) {

                    var btnObj = this.formButtonControl[contentArr_i];


                    if (this.displayFormButtons.indexOf(btnObj.dojoattachpoint) > -1) {
                        var btn = new dijitButton();

                        btn.containerNode.innerHTML = btnObj.label;
                        connect.connect(btn.domNode, "onclick", this, this[btnObj.onClick]);
                        rowDom.lastElementChild.appendChild(btn.domNode);
                    }
                }
            }

            this.attributeContainer.appendChild(rowDom);
        },

        /** start: To be implemented elsewhere **/
        _CustomDisplay: function () { return null; },
        customValidation: function (ob) { return null; },
        // used by implementers to create grids, since they are a bit tricky to provide OOB functionality.
        _createGridControl: function (name, type, val, collection) { return null; },
        // used by implementers to deviate from OOB functionality.
        assignControlBasedOffOfName: function (name, type, val, collection) { return null; },
        _FormSpecificFields: function () { },
        _changeObjectPathParameters: function (path, value, propName, skipFirst, stringifyValue) { return null; },
        _save: function (formName) { },
        _getActiveValuesAdjustments: function () { return {}; },
        /** end: To be implemented elsewhere **/


        securityRules: function () {
            var permittedActions = [];
            var svc = Sage.Services.getService('RoleSecurityService');
            if (this.allowViaAddRule !== "" && svc.hasAccess(this.allowViaAddRule)) {
                this.permittedActions.push('add');
            }
            if (this.allowViaDeleteRule !== "" && svc.hasAccess(this.allowViaDeleteRule)) {
                this.permittedActions.push('delete');
            }
            if (this.allowViaEditRule !== "" && svc.hasAccess(this.allowViaEditRule)) {
                this.permittedActions.push('edit');
            }
            if (this.allowViaViewRule !== "" && svc.hasAccess(this.allowViaViewRule)) {
                this.permittedActions.push('view');
            }
        },
        save: function (formName) {
            dojoConnect.publish('/form/addEditProperty/showLoad');
            this._save(formName);
            dojoConnect.publish('/form/addEditProperty/hideLoad');
        },
        _createForm: function (reader) {
            if (reader) {
                this._createFormFromSDataReader(reader);
            }
        },
        _createFormFromSDataReader: function (reader) {
            if (this.permittedActions.indexOf('view') < 0) {
                this.activeControls.push({ name: 'error', label: this.formNlsResource.permissionsToView, control: null, template: 'formIssueTemplate' });
                return;
            }

            var reader_index = 0,
                arr = reader.data ? reader.data : reader,
                reader_item = {},
                selfAware = this,
                control = {};

            //initial read from reader
            for (reader_index = 0; reader_index < arr.length; reader_index++) {
                reader_item = arr[reader_index];
                this.schema.push(reader_item);
            }

            // then traverse the objects from the reader to flush out controls
            for (reader_index = 0; reader_index < this.schema.length; reader_index++) {

                reader_item = this.schema[reader_index];
                var type = reader_item.type,
                    name = reader_item.name,
                    pathMarker = dString.substitute('"${0}":""', [name]);

                var nameLC = name.toLowerCase();
                var val = this._getProvidedData(name);

                var insertExlcusions = (!this.editMode && this.excludeOnNew.indexOf(nameLC) >= 0); // isIncluded is to always be true
                var block = this.listOfSupressFields.indexOf(nameLC) >= 0 || insertExlcusions;

                control = null;

                if (!block) {

                    if (typeof (reader_item["sdataPath"]) === "undefined") {
                        reader_item["sdataPath"] = pathMarker;
                        reader_item["sdataPathInDot"] = name;
                    }
                    var nodeNameIndex = type.lastIndexOf('--');

                    if (nodeNameIndex < 0) {
                        this._addToListofControls(name, type, reader_item.label, val, null, { path: reader_item["sdataPath"], dot: reader_item["sdataPathInDot"] });
                    }
                    else {
                        var nodeNameKey = type.substring(nodeNameIndex + 2).toLowerCase();
                        var subArr = {};
                        switch (nodeNameKey) {
                            case "choice":
                            case "enum":
                                subArr = reader_item.collection;
                                for (var collec_i = 0; collec_i < subArr.length; collec_i++) {
                                    var defaultLabel = this._onBlankValue(subArr[collec_i].name, subArr[collec_i].nameValue);
                                    defaultLabel = this._onBlankValue(defaultLabel, "item " + collec_i);
                                    subArr[collec_i].label = this._onBlankValue(subArr[collec_i].label, defaultLabel);
                                }
                                if (subArr !== null) {
                                    subArr = subArr.filter(function (c) {
                                        var nLC0 = c.name;
                                        if (typeof (nLC0) !== "undefined") {
                                            nLC0 = nLC0.toLowerCase();
                                            var sub_insertExlcusions0 = (!selfAware.editMode && selfAware.excludeOnNew.indexOf(nLC0) >= 0); // isIncluded is to always be true

                                            return !(selfAware.listOfSupressFields.indexOf(nLC0) >= 0 || sub_insertExlcusions0);
                                        }
                                        return true;
                                    });

                                    this._addToListofControls(name, "xs:enum", reader_item.label, val, { text: "label", id: "value", data: subArr }, { path: reader_item["sdataPath"], dot: reader_item["sdataPathInDot"] });
                                }
                                break;
                            case "list":
                            case "type":
                                if (reader_item.sub !== null) {
                                    subArr = reader_item.sub.data ? reader_item.sub.data : reader_item.sub;
                                }
                                if (reader_item.isCollection && reader_item.relationship === "child") {
                                    if (subArr !== null && subArr.length > 0) {
                                        if (subArr[0].sub) {
                                            subArr = subArr[0].sub.filter(function (c) {
                                                var nLC1 = c.name.toLowerCase();
                                                var sub_insertExlcusions1 = (!selfAware.editMode && selfAware.excludeOnNew.indexOf(nLC1) >= 0); // isIncluded is to always be true
                                                return !(selfAware.listOfSupressFields.indexOf(nLC1) >= 0 || sub_insertExlcusions1);
                                            });
                                            subArr = new memory({ idProperty: "value", data: subArr });
                                            if (typeof (reader_subItem["sdataPath"]) === "undefined") {
                                                reader_item["sdataPath"] = pathMarker;
                                            }
                                            this._addToListofControls(name, "xs:grid", "", val, { text: "label", id: "value", data: subArr }, { path: reader_item["sdataPath"], dot: reader_item["sdataPathInDot"] });
                                        }
                                    }
                                }
                                else {

                                    for (var reader_subIndex = 0; reader_subIndex < subArr.length; reader_subIndex++) {
                                        var reader_subItem = subArr[reader_subIndex];

                                        var newHolder = dString.substitute('"${0}":""', [reader_subItem.name]);
                                        if (!reader_item["sdataPath"]) {
                                            reader_subItem["sdataPath"] = pathMarker;
                                        }
                                        else {
                                            newHolder = "{" + newHolder + "}";
                                        }
                                        reader_subItem["sdataPath"] = reader_item["sdataPath"].replace('""', newHolder);
                                        reader_subItem["sdataPathInDot"] = reader_item["sdataPathInDot"] + "." + reader_subItem.name;
                                        this.schema.push(reader_subItem);
                                    }
                                }
                                break;
                        }
                    }
                }
            }
        },
        _getProvidedData: function (name) {
            var value = null;
            // removed the this.editMode from the below logic to allow values to be passed in during creates
            if ((typeof (this.formData[name]) !== "undefined" && this.formData[name] !== null)) {
                value = this.formData[name];
            }
            return value;
        },
        _addToListofControls: function (id, type, label, val, collection, path) {

            var control = this._assignControlBasedOffType(id, type.substring(3), val, collection);
            var displayClass = this._setDisplayString(control, id);
            var controlLabel = typeof (this.formNlsResource[id]) === "undefined" || this.formNlsResource[id] === null ? label : this.formNlsResource[id];
            controlLabel = typeof (controlLabel) !== "undefined" && controlLabel !== null ? controlLabel : id;
            var saveIfValidLocal = this.saveIfValid;
            if (control.saveIfValid) {
                saveIfValidLocal = control.saveIfValid;
            }
            this.activeControls.push({ control: control, label: controlLabel, name: id, display: displayClass, Include: true, sdataPath: path, template: 'rowTemplate', isDom: false, fieldClassAppendix: "", saveIfValid: saveIfValidLocal });
        },
        // used during the inital loading of the form; returns a string value for the display class to be added to the domNode
        _setDisplayString: function (control, id) {
            return this._displayControl(control, id) ? "display" : "display-none";
        },
        // determines if the form property should be displayed.
        _displayControl: function (control, id) {
            var hideIfNoControls = ["dataTypeData"]; // list of controls that will be hidden(class="display-none") if there are no sub controls present.

            var applyRule = true;
            if (typeof (id) !== "undefined" && id !== null) {
                applyRule = hideIfNoControls.indexOf(id) >= 0; // if the control does not exist in the list, then the hide rule will not apply.
            }
            if (applyRule) {
                return ((typeof (control.activeControls) !== "undefined" && control.activeControls !== null) && control.activeControls.length > 0);
            }
            else {
                return true;
            }
        },

        _blankString: function (v) {
            return v === null || typeof (v) === "undefined" || v.trim() === "";
        },
        _onBlankValue: function (cv, dv) {
            if (this._blankString(cv)) {
                return dv;
            }
            return cv;
        },

        _assignControlBasedOffType: function (name, type, val, collection) {
            var editsAllowed = this.permittedActions.indexOf('add') >= 0;
            if (this.editMode) {
                editsAllowed = this.permittedActions.indexOf('edit') >= 0;
            }
            var disableViaSec = this.permittedActions.indexOf('view') >= 0 && !editsAllowed;


            var control = this.assignControlBasedOffOfName(name, type, val, collection, disableViaSec);
            if (control === null) {
                switch (type.toLowerCase()) {
                    case "string":
                    case "int":
                    case "byte":
                    case "date":
                        control = new TextBox({
                            shouldPublishMarkDirty: false,
                            disabled: disableViaSec
                        });
                        if (typeof (val) !== "undefined" && val !== null) {
                            control.textbox.value = val;
                        }
                        break;
                    case "boolean":
                        control = new CheckBox({
                            shouldPublishMarkDirty: false,
                            disabled: disableViaSec
                        });
                        if (typeof (val) !== "undefined" && val !== null) {
                            control.setChecked(val);
                        }
                        break;
                    case "datetime":
                        control = new DateTimePicker({
                            id: 'SDataForm_DateTimePicker_' + this.dumbDTControlCounterForId,
                            displayDate: true,
                            displayTime: true,
                            shouldPublishMarkDirty: false,
                            disabled: disableViaSec
                        });
                        this.dumbDTControlCounterForId++;
                        break;
                    case "picklist":
                    case "enum":
                        control = new FilteringSelect({
                            value: val,
                            store: new memory({ idProperty: collection.id, data: collection.data }),
                            idProperty: collection.id,
                            searchAttr: collection.text,
                            shouldPublishMarkDirty: false,
                            required: false,
                            disabled: disableViaSec
                        });
                        break;
                    case "grid":
                        control = this._createGridControl(name, type, val, collection, disableViaSec);
                        break;
                }
            }
            if (control) {
                if (control.domNode) {
                    domClass.remove(control.domNode, "dijitInline");
                }
            }
            return control;
        },

        reLoadData: function (data) {
            for (var i = 0; i < this.activeControls.length; i++) {
                var ob = this.activeControls[i];

                if (ob.control !== null) {
                    var propName = ob.name;
                    var dClass = ob.control.declaredClass;

                    var newValue = this._getValueFromData(data, propName);

                    if (dClass.indexOf("DndSortList") >= 0) {

                    }
                    if (dClass.indexOf("TextBox") >= 0) {
                        ob.control.textbox.value = newValue;
                    }
                    if (dClass.indexOf("TextArea") >= 0) {
                    }
                    if (dClass.indexOf("CheckBox") >= 0) {
                        ob.control.checked = newValue;
                    }
                    if (dClass.indexOf("FilteringSelect") >= 0) {
                    }
                    if (dClass.indexOf("PropertyDropDown") >= 0) {
                    }
                    if (dClass.indexOf("_AbstractGrid") >= 0) {
                        ob.control.grid._setStore(dojo.data.ObjectStore(dojo.store.Memory({ idProperty: '$key', data: this.formData[name] })));
                        ob.control.grid.refresh();
                        ob.control.grid.startup();
                        // make sure that the grid shows a horizontal scrollbar if all column cannot be displayed.
                        ob.control.grid.onLoadComplete = function () {
                            ob.control.grid.resize();
                        };
                    }
                }
            }
        },

        _getValueFromData: function (data, field) {
            var obj = data[field];
            switch (typeof (obj)) {
                case "object":
                    return obj;
                case "undefined":
                    return null;
                default:
                    return null;
            }
        },

        _moveActiveControlFromBackGroundToPage: function (item) {
            var simplateRowTemplate, row, rowDom;

            if (item) {

                rowDom = this._CustomDisplay(item);

                if (rowDom === null) {

                    item.label = this._onBlankValue(item.label, "<br>");

                    simplateRowTemplate = new Simplate(this[item.template]);
                    row = simplateRowTemplate.apply(item);
                    rowDom = domConstruct.toDom(row);

                    this.attributeContainer.appendChild(rowDom);

                    if (item.control) {
                        if (item.control.type && item.control.type === "Grid") {
                            // The Grid Requires the placeholder to already be attached to the form
                            if (item.control && item.control.type && item.control.type === "Grid") {
                                var ph = this._findControllerDom("items");
                                if (ph !== null) {
                                    lang.mixin(item.control.options, { placeHolder: ph });
                                    item.control = new GridView(item.control.options);
                                    dojoConnect.publish('sdata/form/setGrid', [item.control]);
                                    item.control.createGridView();
                                    item.control.grid.onLoadComplete=function () {
                                        item.control.grid.resize();
                                    };
                                }
                            }
                        }
                        else {
                            if (item.isDom) {
                                domConstruct.place(item.control, rowDom.lastElementChild.lastElementChild, 'only');
                                if (item.control.className.indexOf("dijitCheckBox") >= 0) {
                                    domClass.add(item.control.parentNode, "checkbox");
                                }
                            }
                            else {
                                domConstruct.place(item.control.domNode, rowDom.lastElementChild.lastElementChild, 'only');
                                if (item.control.domNode.className.indexOf("dijitCheckBox") >= 0) {
                                    domClass.add(item.control.domNode.parentNode, "checkbox");
                                }
                            }
                            if (item.control.startup) {
                                item.control.startup();
                            }
                        }
                    }
                    else {
                        domConstruct.place('<br>', rowDom.lastElementChild.lastElementChild, 'only');
                    }
                }
            }
        },

        isValid: function () {
            var valid = true;

            for (var i = 0; i < this.activeControls.length; i++) {
                var ob = this.activeControls[i];
                var obControl = ob.control;
                var customValidation = null;
                if (obControl !== null) {
                    customValidation = this.customValidation(ob);
                    if (customValidation === null) {
                        var validControl = true;
                        if (typeof (obControl.isValid) === "function") {
                            obControl.isValid(true);
                        }
                        if (typeof (obControl.onChanged) === "function") {
                            obControl.onChanged();
                        }
                        if (typeof (obControl.state) !== "undefined" && typeof (obControl.required) !== "undefined") {
                            validControl = validControl && obControl.state !== 'Error' && !(obControl.state === 'Incomplete' && obControl.required);
                        }
                        if (!validControl) {
                            obControl.set('state', 'Error');
                        }
                        valid = valid && validControl;
                    } else {
                        valid = valid && customValidation;
                    }
                    if (valid && obControl.saveIfValid) {
                        if (obControl.editMode !== null && typeof (obControl.editMode) !== "undefined" &&
                            ((obControl.editMode && obControl.saveIfValid.update) ||
                            (!obControl.editMode && obControl.saveIfValid.insert))) {
                            obControl.save(this.formBase);
                        }
                    }
                }
            }
            return valid;
        },
        cancel: function (context) {
            var gridId = null;
            if (this.domNode && this.domNode.parentNode && this.domNode.parentNode.offsetParent && this.domNode.parentNode.offsetParent.id.indexOf('Dialog') >= 0) {
                gridId = this.domNode.parentNode.offsetParent.id;
            }
            else if (context.domNode && context.domNode.parentNode && context.domNode.parentNode.offsetParent && context.domNode.parentNode.offsetParent.id.indexOf('Dialog') >= 0) // context is passed when the 'x' button is pressed
            {
                gridId = context.domNode.parentNode.offsetParent.id;
            }
            if (gridId !== null) {
                if (dijit.byId(gridId).hideLoading) {
                    dijit.byId(gridId).hideLoading();
                }
                dijit.byId(gridId).hide();
            }
        },

        // return the first node whose bounding client rectangle elements are not zero sum, if none exist return the first node.
        _grabCorrectElementAndPlace: function (control, nodeName) {
            var nodeArr = document.getElementsByName(nodeName);
            var node = nodeArr[0];
            var exit = false;
            for (var i = 0; i < nodeArr.length && !exit; i++) {
                var br = nodeArr[i].getBoundingClientRect();
                var sum = br.bottom + br.height + br.left + br.right + br.top + br.width;
                if (sum > 0) {//assume the node is the correct one
                    node = nodeArr[i];
                    exit = true;
                }
            }
            domConstruct.place(control.domNode, node, 'only');
        },

        findDomAndHideDom: function (controlAttachPointName) {
            var domToHide = this._findControllerDom(controlAttachPointName, true);
            if (domToHide) {
                domClass.add(domToHide, "display-none");
                domClass.remove(domToHide, "display");
            }
        },
        findDomAndShowDom: function (controlAttachPointName) {
            var domToHide = this._findControllerDom(controlAttachPointName, true);
            if (domToHide) {
                domClass.add(domToHide, "display");
                domClass.remove(domToHide, "display-none");
            }
        },

        _findControllerDom: function (controlAttachPointName, section) {
            var strTemplate = "div.fld[data-dojo-attach-point='${0}']";
            if (section) {
                strTemplate = "tr[data-dojo-attach-point='${0}']";
            }
            var strQuery = dString.substitute(strTemplate, [controlAttachPointName]);

            var sectionLimitor = null;
            if (this._DynamicSection) {
                sectionLimitor = this._DynamicSection;
            }
            else if (this.domNode) {
                sectionLimitor = this.domNode;
            }

            var result = null;
            if (sectionLimitor) {
                result = query(strQuery, sectionLimitor);
            }
            else {
                result = query(strQuery);
            }

            if (typeof (result) !== "undefined" && result !== null &&
                typeof (result.length) !== "undefined" && result.length !== null && result.length > 0) {

                return result[0]; //return first
            }

            return null;
        },
        _showHideElementsByNames: function (context, names, isHiding, nodeToHide) {
            if (lang.isArray(names)) {
                for (var idx = 0; idx < names.length; idx++) {
                    var hs_i = names[idx];
                    context._showHideElementsByNamesHelper(context, hs_i, isHiding, nodeToHide);
                }
            }
            else {
                context._showHideElementsByNamesHelper(context, names, isHiding, nodeToHide);
            }
        },
        _showHideElementsByNamesHelper: function (context, name, isHiding, nodeToHide) {
            var i = context._getIndexFromActivityListFromName(name);
            if (i > -1) {
                var control = context.activeControls[i].control;
                if (!context.activeControls[i].isDom) {
                    control = control.domNode;
                }
                if (nodeToHide !== null && typeof (nodeToHide) !== "undefined") {
                    switch (nodeToHide.toLowerCase()) {
                        case "parent":
                            control = control.parentNode;
                            break;
                        case "grandparent":
                            control = control.parentNode.parentNode;
                            break;
                    }
                }
                if (isHiding) {
                    context.domClass.add(control, "display-none");
                    context.domClass.remove(control, "display");
                }
                else {
                    context.domClass.add(control, "display");
                    context.domClass.remove(control, "display-none");
                }
            }
        },

        _adjustForValuesMatchingBooleanDefaultsMissing: function (typeStoreDataElement, strVar) {
            var hasValueStoredAsText = typeof (typeStoreDataElement) !== "undefined" &&
                (typeof (typeStoreDataElement[strVar]) !== "undefined" &&
                (this.dataTypeData !== null && typeof (this.dataTypeData[strVar]) === "undefined"));
            if (hasValueStoredAsText) {
                this.dataTypeData[strVar] = false;
            }
        },
        _setParentDisplayClass: function (control, parentDom) {
            if (this._displayControl(control)) { // display dom if there are controls to display
                domClass.remove(parentDom, 'display-none');
                domClass.add(parentDom, 'display');
            }
            else { // if there are no controls to display, then hide the dom.
                domClass.remove(parentDom, 'display');
                domClass.add(parentDom, 'display-none');
            }
        },

        getActiveValues: function () {
            var retObj = {};
            for (var i = 0; i < this.activeControls.length; i++) {
                lang.mixin(retObj, this._getActiveValue(this.activeControls[i]));
            }

            lang.mixin(retObj, this._getActiveValuesAdjustments());

            if (typeof (this.hiddenValues) === "object") {
                for (var y = 0; y < this.hiddenValues.length; y++) {
                    var hval = this.hiddenValues[y];
                    lang.mixin(retObj, hval);
                }
            }
            return retObj;
        },
        _getActiveValue: function (ob) {
            var retObj = {};

            if (ob.Include && ob.control !== null) {
                var propName = ob.name;
                var dClass = ob.control.declaredClass;
                if (dClass.indexOf("DndSortList") >= 0) {
                    var sourceToGrab = ob.control.getSource(0);
                    if (sourceToGrab) {
                        retObj = ob.control.getASourcesContentsInString(sourceToGrab);
                    }
                }
                if (dClass.indexOf("TextBox") >= 0) {
                    retObj = ob.control.getValue();
                    if (retObj === null || typeof (retObj) === "undefined") {
                        retObj = "";
                    }
                }
                if (dClass.indexOf("TextArea") >= 0) {
                    if (propName === "Template") {
                        retObj = this._convertDotToLegacy(ob.control.textbox.value);
                    }
                    else {
                        retObj = ob.control.value;
                    }
                }
                if (dClass.indexOf("DisplayName") >= 0) {
                    retObj = ob.control.getDetails();
                }
                if (dClass.indexOf("CheckBox") >= 0) {
                    retObj = ob.control.checked;
                }
                if (dClass.indexOf("FilteringSelect") >= 0) {
                    retObj = ob.control.value === null ? "" : ob.control.value;
                }
                if (dClass.indexOf("ComboBox") >= 0) {
                    retObj = ob.control.value === null ? "" : ob.control.value;
                    if (propName === "PickList" && ob.control.store.query(function (a) { return a.name === retObj; }).id !== "000new") {
                        propName = "PickListName";
                    }
                }
                if (dClass.indexOf("PropertyDropDown") >= 0) {
                    var entityProperty = ob.control.entitySelected.displayedValue;
                    var valueArr = entityProperty.split('.');
                    var strProperty = valueArr[valueArr.length - 1];
                    var strEntity = valueArr[valueArr.length - 2];

                    if (typeof (strProperty) !== "undefined") {
                        retObj = strProperty;
                    }
                    if (typeof (strEntity) !== "undefined") {
                        retObj = strEntity;
                    }
                }
                if (dClass.indexOf("GridView") >= 0) {
                    var subObjs = [];
                    var gridStore = {};
                    gridStore = ob.control.getStore();
                    if (gridStore.data) {
                        gridStore = gridStore.data;
                        for (var x = 0; x < gridStore.length; x++) {
                            var obj = gridStore[x];
                            if (typeof (obj) !== "undefined") {
                                if (typeof (obj["undefined"]) !== "undefined") {
                                    delete obj["undefined"];
                                }
                                var arrExists = this._oformData[propName].filter(function (r) {
                                    return r.$key === obj.$key;
                                });
                                if (typeof (obj.$key) !== "undefined" && arrExists.length <= 0) {
                                    delete obj.$key;
                                }
                                if (typeof (obj.filter) !== "undefined" && obj.filter === null) {
                                    delete obj.filter;
                                }
                                // remove because these fields are auto generated from metadata
                                if (typeof (obj.$updated) !== "undefined") {
                                    delete obj.$updated;
                                }
                                if (typeof (obj.$httpStatus) !== "undefined") {
                                    delete obj.$httpStatus;
                                }
                                if (typeof (obj.$etag) !== "undefined") {
                                    delete obj.$etag;
                                }
                                if (typeof (obj.$descriptor) !== "undefined") {
                                    delete obj.$descriptor;
                                }
                                subObjs.push(obj);
                            }
                        }
                    }
                    retObj = subObjs;
                }
                var sdataFieldPath = [propName];
                if (ob.sdataPath && ob.sdataPath.dot) {
                    sdataFieldPath = ob.sdataPath.dot.split('.');
                }
                return this._setToObjectPath(sdataFieldPath, retObj, propName, 1, false);
            }
            return null;
        },

        _setToObjectPath: function (path, value, propName, last, stringifyValue) {
            var strTmplt = '"${0}":${1}',
                itm,
                lastValue = last,
                strEscapes = "",
                parameterObject = {
                    propName: propName,
                    path: path,
                    builtUpPath: JSON.stringify(value),
                    skip: 1,
                    stringify: stringifyValue,
                    lineEscape: ""
                };

            var adjustedParams = this._changeObjectPathParameters(path, value, propName, last, stringifyValue);
            if (adjustedParams !== null) {
                parameterObject = lang.mixin(parameterObject, adjustedParams);
                if (parameterObject.stringify) {
                    strTmplt = '${0}:${1}';
                }
            }

            for (var i = parameterObject.path.length - parameterObject.skip; i >= lastValue; i--) {
                itm = parameterObject.path[i];
                strEscapes = parameterObject.stringify ? Array(i).join("\\\\") : "";
                if (typeof (itm) !== "undefined") {
                    if (parameterObject.builtUpPath.indexOf("{") !== 0 && i !== parameterObject.path.length - parameterObject.skip) {
                        parameterObject.builtUpPath = "{" + parameterObject.builtUpPath + "}";
                    }

                    if (parameterObject.stringify) {
                        itm = dString.substitute("${0}${1}${2}${0}${1}", [strEscapes, parameterObject.lineEscape, itm]);
                        if (i == lastValue) {
                            parameterObject.builtUpPath = dString.substitute("${0}${1}${2}${0}${1}", [strEscapes, parameterObject.lineEscape, parameterObject.builtUpPath]);
                        }
                    }
                    parameterObject.builtUpPath = dString.substitute(strTmplt, [itm, parameterObject.builtUpPath]);
                }
            }
            if (parameterObject.builtUpPath.indexOf("{") !== 0 && parameterObject.builtUpPath.indexOf("[") !== 0) {
                parameterObject.builtUpPath = "{" + parameterObject.builtUpPath + "}";
            }
            return JSON.parse(parameterObject.builtUpPath);
        },

        _getIndexFromActivityListFromName: function (name) {
            var retVal = -1;
            for (var ac_i = 0; ac_i < this.activeControls.length; ac_i++) {
                var ac_item = this.activeControls[ac_i];
                if (ac_item.name === name) {
                    return ac_i;
                }
            }
            return retVal;
        },


        _checkIfDuplicate: function (service, control, field) {
            var duplicateFound = false;
            var request = new Sage.SData.Client.SDataResourceCollectionRequest(service);

            if (typeof (field) === "undefined" || field === null) {
                field = control.name;
            }

            if (this.formBase) {
                request.setResourceKind(this.formBase);

                var foundField = this.duplicateCheck.filter(function (d) { return d.field === field; });

                for (var ff_i = 0; foundField.length && ff_i < foundField.length; ff_i++) {
                    var ff_item = foundField[ff_i];

                    var data = this._getActiveValue(control);
                    if (typeof (data) !== "undefined" && data !== null && data !== {}) {
                        request.setQueryArg('where', dString.substitute(ff_item.where,[ff_item.ignoreCase?data[field].toLowerCase():data[field]]));

                        request.setQueryArg('startIndex', 0);
                        request.setQueryArg('count', 1);


                        request.read({
                            async: false,
                            scope: this,
                            success: function (data) {
                                if (typeof (data) !== 'undefined' && typeof (data.$resources) !== 'undefined' && data.$resources.length == 1) {
                                    duplicateFound = true;
                                    control.control.invalidMessage = dString.substitute(this.formNlsResource.picklistAlreadyExists, [data.$resources[0].name]);
                                    control.control.set('state', 'Error');
                                }
                                else {
                                    duplicateFound = false;
                                }
                            },
                            failure: function (data) {
                                duplicateFound = true;
                                control.control.invalidMessage = dString.substitute("Error: ${0}", ["Picklist Name:"]);
                                control.control.set('state', 'Error');
                            }
                        });
                    }


                }
            }
            return duplicateFound;
        },
        setControlValue: function (cntrlName, value) {
            var retArray = this.activeControls.filter(function (x) { return x.name === cntrlName; }),
                controlWrapper = null;
            if (retArray.length > 0) {
                controlWrapper = retArray[0];
            }

            if (controlWrapper !== null) {
                controlWrapper.control.set('value', value);
            }
        }
    });

    return widget;
});
},
'Sage/UI/Controls/SimpleTextarea':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
       'dijit/form/SimpleTextarea',
       'dojo/_base/declare',
       'dojo/_base/lang',
       'dojo/string',
       'dojo/json',
       'dojo/date/locale',
       'dojo/has'
],
function (simpleTextarea, declare, lang, dString, json, dLocale, has) {
    var widget = declare("Sage.UI.Controls.SimpleTextarea", [simpleTextarea], {
        baseClass: "dijitTextBox dijitTextArea sageTextArea",
        templateString: "<div><textarea ${!nameAttrSetting} class='none' dojoAttachPoint='focusNode,containerNode,textbox' autocomplete='off'></textarea></div>",
        hotKey: '',
        defaultValue: '',
        multiLineMaxLength: '',
        shouldPublishMarkDirty: true,
        _setHotKeyAttr: { node: 'textbox', type: 'attribute', attribute: 'accessKey' },
        constructor: function (args) {
            this.maxLength = args.multiLineMaxLength;
            this.userDateStamp = !!(args.userdatestamp && args.userdatestamp === 'true');
            var newClassName = "";
            if (args.textareaclass) {
                // If there is a class existing, keep it and append the textareaclass property to it
                if (args["class"]) {
                    newClassName = args["class"] + ' ' + args.textareaclass;
                } else {
                    newClassName = args.textareaclass;
                }
            } else if (args["class"]) {
                newClassName = args["class"];
                args["class"] = "";
            }
            this.templateString = this.templateString.replace("class='none'", (newClassName.length > 0 ? "class='" + newClassName + "'" : ""));
            this.connect(this, 'onFocus', this.onFocus);
        },

        postMixInProperties: function () {
            this.inherited(arguments);

            if (!this.defaultValue && this.srcNodeRef) {
                this.defaultValue = this.srcNodeRef.value;
            }
        },

        buildRendering: function () {
            this.inherited(arguments);

            if (has("ie") || has("trident")) {
                if (this.domNode && this.domNode.childElementCount > 0) {
                    for (var index = 0; index < this.domNode.childElementCount; index++) {
                        var child = this.domNode.childNodes[index];
                        if (child && child instanceof HTMLTextAreaElement) {
                            if (!child.defaultValue) {
                                child.defaultValue = this.defaultValue;
                            }
                        }
                    }
                }
            }
        },
        onFocus: function (e) {
            //there are two different options which need to be enabled in order to add a default user date time stamp. The first the control has 
            //quickform control has to have the userdatestamp attribute enabled and the second the user has to have enabled the 
            //'Default username/Time Stamp in Memo Fields' user option enabled, which can be set in Tools/Options General tab
            if (this.getValue('value') === '' && this.userDateStamp) {
                var optionsService = Sage.Services.getService("UserOptions");
                if (optionsService) {
                    var cacheKey =  'EGL_USER_OPTION_UserDateTimeStamp';
                    var value = this._getFromSessionStorage(cacheKey);
                    var userDateStamp = false;
                    if (value !== null && typeof value !== 'undefined') {
                        this._assignUserDateTimeStamp(value);
                    }
                    else {
                        optionsService.get('UserDateTime', 'CustomerService', lang.hitch(this, function (option) {
                            if (option && option.value) {
                                userDateStamp = option.value === 'T';
                                this._assignUserDateTimeStamp(userDateStamp);
                                this._addToSessionStorage(cacheKey, userDateStamp);
                            }
                        }), null, null, true);
                    }
                }
            }
        },
        onChange: function (e) {
            if (this.shouldPublishMarkDirty) {
                dojo.publish("Sage/events/markDirty");
            }
            this.inherited(arguments);
        },
        _getFromSessionStorage: function (cacheKey) {
            var cacheData = sessionStorage.getItem(cacheKey);
            var data;
            if (cacheData !== null && typeof cacheData !== 'undefined') {
                data = json.parse(cacheData);
            }
            return data;
        },
        _addToSessionStorage: function (cacheKey, data) {
            sessionStorage.setItem(cacheKey, json.stringify(data));
        },
        _assignUserDateTimeStamp: function(userDateStamp) {
            if (userDateStamp) {
                var contextService = Sage.Services.getService("ClientContextService");
                var user = contextService.containsKey("userPrettyName") ? contextService.getValue("userPrettyName") : contextService.getValue("userID");
                var timeZone = contextService.containsKey("userTimeZoneKey") ? contextService.getValue("userTimeZoneKey") : "";
                var dateFormat = contextService.containsKey("userDateFmtStr") ? contextService.getValue("userDateFmtStr") : Sys.CultureInfo.CurrentCulture.dateTimeFormat.FullDateTimePattern;
                var dateStamp = dLocale.format(new Date(), { datePattern: dString.substitute("${0}", [dateFormat]) });
                this.setValue(dString.substitute("${0} ${1} (${2})", [user, dateStamp, timeZone]));
            }
        }
    });
    return widget;
});
},
'Sage/UI/Controls/DndSortList':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dijit/_Widget',
    'Sage/_Templated',
    'dojo/_base/declare',
    'dojo/dnd/Source',
    'dojo/_base/lang',
    'dojo/dom-class',
    'dojo/dom-construct',
    "dojo/store/Observable",
    'dojo/store/Memory',
    'dojo/string'

],
function (
    _Widget,
    _Templated,
    declare,
    source,
    lang,
    domClass,
    domConstruct,
    observable,
    memory,
    dojoString
) {

    var widget = declare('Sage.UI.Controls.DndSortList', [_Widget, _Templated], {

        widgetsInTemplate: true,
        ListNamesIds: [],
        ListOfItems: null,
        horizontal: false,
        widgetTemplate:new Simplate(eval(["<div><div dojoattachpoint='DndSortList' /></div>"])),
        headerTemplate: new Simplate(["<div dojoattachpoint='{%= $.id %}_ListContainer'><div>{%= $.name %}</div><ul dojoattachpoint='{%= $.id %}_List' style='min-height:50px'></div>"]),
        listBulletTemplate: new Simplate(["<li class='dojoDndItem'>{%= $.Item.name %}</li>"]),

        sortList:[],

        /*
            obj:
                -ListNamesIds: List: List containing list label Names and their ids;
                    - NameID:
                        -id: corresponds to what would be in the ListOfItems: List
                        -name: display name.

                -ListOfItems: A single list of Items as explained below
                    - There is expected to be a wrapper class for the items in the list.
                        ListWrapperClass:
                            -Item: the object in the list
                                -name: display name or toString for the Item
                            -list: An id that determines what list this item is to appear.

                -horizontal: bool: if the lists need to be oriented horizontal or vertical
        */
        constructor: function (obj) {
            if (obj.ListNamesIds) {
                this.ListNamesIds = obj.ListNamesIds;
            }
            if (obj.ListOfItems) {
                this.ListOfItems = new observable(new memory({ data: obj.ListOfItems }));
            }
            else {
                this.ListOfItems = new observable(new memory());
            }
            if (obj.horizontal) {
                this.horizontal = obj.horizontal;
            }
        },
        postCreate: function () {
            this.sortList = [];
            for (var i = 0; i < this.ListNamesIds.length; i++) {
                var item = this.ListNamesIds[i];

                var listContainer = this.headerTemplate.apply(item);
                var listContainerDom = domConstruct.toDom(listContainer);

                var dndlistDom = listContainerDom.children[1];
                var listSource = new source(dndlistDom, { horizontal: this.horizontal, simpleSelection: true });
                
                var items = this.ListOfItems.filter(
                    function (value) {
                        return value.list === item.id;
                    });

                var sourceList=[];
                for (var b = 0; b < items.length; b++) {
                    var sourceItem=items[b];
                    sourceList.push({ data: sourceItem.Item.name.trim() });
                }
                
                listSource.insertNodes(false, sourceList);
                this.sortList.push({ list: item.id, data: listSource });

                this.DndSortList.appendChild(listContainerDom);
            }

        },
        /*
             - There is expected to be a wrapper class for the items in the list.
                        ListWrapperClass:
                            -Item: the object in the list
                                -name: display name or toString for the Item
                            -list: An id that determines what list this item is to appear.


        */
        updateListOfItems: function (list, update) {
            for (var i = 0; i < this.sortList.length; i++) {
                var slist = this.sortList[i];

                var newItems = list.filter(
                   function (value) {
                       return value.assigned === false;
                   });

                // get items in order
                var currentItems = slist.data.getAllNodes().map(function (node) {
                    return slist.data.getItem(node.id).data;
                });

                var itemsToBeSaved= [];
                for (var v = 0; v < newItems.length; v++) {
                    var vItem=newItems[v];
                    var boolUsedExisting = false;
                    var exist=this._exists(vItem);
                    //preserve the existing 
                    for (var w = 0; w < currentItems.length;w++){
                        var wItem=currentItems[w];
                        if (wItem === vItem.Item.name && (!exist && update)) {
                            list[vItem.id].assigned = true;
                            itemsToBeSaved.push({ data: wItem.trim() });
                            boolUsedExisting = true;
                        }
                    }
                    if (!boolUsedExisting && slist.list === vItem.list){
                        if (!exist || update) {
                            list[vItem.id].assigned = true;
                            vItem.Item.name = vItem.Item.name.trim();
                            itemsToBeSaved.push({ data: vItem.Item.name });
                            if (!exist) {
                                this.ListOfItems.push(vItem);
                            }
                        }
                    }
                }
                if(update){
                    slist.data.selectAll().deleteSelectedNodes();
                }
                slist.data.insertNodes(false, itemsToBeSaved);
            }
        },

        _exists: function (val) {
            for (var i = 0; i < this.ListOfItems.length; i++) {
                var iLOI = this.ListOfItems[i];
                if (iLOI.Item.name.trim() === val.Item.name.trim()) {
                    return true;
                }
            }
            return false;
        },

        getASourcesContentsInList: function (source) {
            return source.getAllNodes().map(function (node) {
                return source.getItem(node.id).data;
            });
        },

        getASourcesContentsInString: function (source) {
            var strRet = "", comma = "";

            var list = this.getASourcesContentsInList(source);
           
            for (var x = 0; x < list.length; x++) {
                strRet = dojoString.substitute("${0}${1}${2}", [strRet, comma, list[x]]);
                comma = ", ";
            }
            return strRet;
        },

        getSource: function (id) {
            for (var i = 0; i < this.sortList.length; i++) {
                var slist = this.sortList[i];
                if (id === slist.list) {
                    return slist.data;
                }
            }
        }
    });
    return widget;
});

},
'Sage/UI/Forms/PickListManagerForm':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define, cookie */
define([
    'dojo/_base/connect',
    'dojo/_base/declare',
    'dojo/_base/lang',
    'dojo/dom-class',
    'dojo/aspect',
    'dojo/string',
    'dojo/store/Memory',
    'Sage/UI/Dialogs',
    'Sage/UI/Forms/FormFromSData',
    'Sage/UI/Controls/TextBox',
    'Sage/UI/Controls/CheckBox',
    'Sage/Utility/_LocalStorageMixin',
    'Sage/Data/BaseSDataStore',
    'Sage/Data/SDataServiceRegistry',
    'dojo/i18n!./nls/FormFromSData'
],
function (
    dojoConnect,
    declare,
    lang,
    domClass,
    dojoAspect,
    dString,
    memory,
    Dialogs,
    FormFromSData,
    TextBox,
    CheckBox,
    _LocalStorageMixin,
    BaseSDataStore,
    SDataServiceRegistry,
    formNlsResource
) {

    var widget = declare('Sage.UI.Forms.PickListManagerForm', [FormFromSData, _LocalStorageMixin], {
        excludeOnNew: [],
        listOfSupressFields: ['createuser', 'createdate', 'modifydate', 'modifyuser'],
        dialogs: Dialogs,
        _itemsGrid: null,
        allowViaAddRule: 'Administration/Picklist/Add',
        allowViaEditRule: 'Administration/Picklist/Edit',
        allowViaViewRule: 'Administration/Picklist/View',
        allowViaDeleteRule: 'Administration/Picklist/Delete',
        formBase: 'picklists',
        duplicateCheck: [{ field: 'name', where: "lower(name) eq '${0}'", ignoreCase: true }],
        saveIfValid: { update: true, insert: true },
        _cachedListOfActiveLanguages: 'PickList_ActiveLanguages',
        _storageNameSpace: 'PickListData',

        assignControlBasedOffOfName: function (name, type, val, collection, disabledViaSec) {
            var retVal = null;

            switch (name.toLowerCase()) {
                case 'name':
                    retVal = new TextBox({
                        shouldPublishMarkDirty: false,
                        required: true,
                        disabled: disabledViaSec
                    });
                    if (typeof (val) !== 'undefined' && val !== null) {
                        retVal.textbox.value = val;
                    }
                    break;
                case 'defaultlanguage':
                    retVal = new TextBox({
                        shouldPublishMarkDirty: false,
                        disabled: this.editMode
                    });
                    if (typeof (val) !== 'undefined' && val !== null) {
                        retVal.textbox.value = val;
                    }
                    break;
            }

            return retVal;
        },
        _createGridControl: function (name, type, val, collection, disabledViaSec) {
            var control = null;
            switch (name.toLowerCase()) {
                case 'items':
                    var cols = [];
                    var selec = [];
                    for (var col_i = 0; col_i < collection.data.data.length; col_i++) {

                        var col_item = collection.data.data[col_i];
                        var col_control = null;
                        var col_column = {};
                        var reference = this;

                        switch (col_item.type.toLowerCase()) {
                            case 'xs:boolean':
                                if (this.editMode) {
                                    col_control = {
                                        editor: "radio", // use HTML radio button over dijit radio because HTML radio button works with dgrid, dijit radio button does not.
                                        editorArgs: {
                                            disabled: disabledViaSec,
                                            shouldPublishMarkDirty: false,
                                            name: col_item.name,
                                            onchange: function (event) {
                                                event.preventDefault();
                                                var key = reference._getRowIdFromCell(this);
                                                if (key) {
                                                    reference.formData.items.forEach(function(x) { 
                                                        x.isDefault = false; 
                                                    });
                                                    var formItem = reference.formData.items.find(function(x) {
                                                        return x.$key === key.innerText;
                                                    });
                                                    formItem.isDefault = true;

                                                    var grid = reference._getGrid(reference);
                                                    if (grid) {
                                                        var data = grid.store.data;
                                                        data.forEach(function(x) { x.isDefault = false; });
                                                        var item = data.find(function(x) { 
                                                            return x.$key === key.innerText;
                                                        });
                                                        item.isDefault = true;
                                                    }
                                                }
                                            }
                                        },
                                        width: 150
                                    };
                                }
                                break;
                            default:
                                if (col_item.name === 'languageCode') {
                                    // skip the language code column if there is no language code since only the default language code items can be edited here.
                                    // --- no need to show a column that will be blank values.
                                    col_control = this.formData.defaultLanguage ?
                                        {
                                            editor: TextBox,
                                            editorArgs: {
                                                disabled: true,
                                                shouldPublishMarkDirty: false,
                                                name: col_item.name
                                            },
                                            width: 150
                                        } : null;
                                } else if (col_item.name === 'code') {
                                    col_control = {
                                        editor: TextBox,
                                        editorArgs: {
                                            isValid: this.formData.defaultLanguage ? function () { return true;} : function (isFocus) {
                                                if(this.value.trim() === "") {
                                                    this.set('message', formNlsResource.PickListItemCodeRequiredeException);
                                                    this.set('state', 'Error');
                                                    return false;
                                                }

                                                var grid = reference._getGrid(reference);
                                                var key = (reference._getRowIdFromCell(this.domNode) || {}).innerText;
                                                var count = grid.store.query({code: this.value}).length;
                                                if (count > 1) {
                                                    this.set('message', this.invalidMessage);
                                                    this.set('state', 'Error');
                                                    return false;
                                                } 
                                                return true;
                                            },
                                            invalidMessage: formNlsResource.PickListItemCodeUniqueException,
                                            disabled: disabledViaSec,
                                            shouldPublishMarkDirty: false,
                                            name: col_item.name
                                        },
                                        width: 150
                                    };
                                } else {
                                    col_control = {
                                        editor: TextBox,
                                        editorArgs: {
                                            disabled: disabledViaSec,
                                            shouldPublishMarkDirty: false,
                                            name: col_item.name
                                        },
                                        width: 150
                                    };
                                }
                                break;
                        }
                        if (col_control !== null) {
                            col_column =
                                 {
                                     field: col_item.name,
                                     label: col_item.name === 'number' ? this.formNlsResource[col_item.name] : col_item.label,
                                     editable: !disabledViaSec && col_item.name !== 'languageCode',
                                     hidden: false,
                                     unhidable: false,
                                     editOn: '',
                                     autoSave: true,
                                     id: col_item.name,
                                     width: 150
                                 };

                            lang.mixin(col_column, col_control);
                            cols.push(col_column);
                            selec.push(col_item.name);
                        }
                    }
                    cols.push({
                        label: '',
                        field: '$key',
                        unhidable: true,
                        editable: false,
                        hidden: true,
                        id: '$key'
                    });

                    // At the moment the Grid should be populated from a local store, so that the form has more control over when and what gets saved.
                    // Also use control.getStore() to manipulate the store.
                    var dataStore = { store: dojo.data.ObjectStore(dojo.store.Memory({ data: [] })) };
                    if (this.formData[name]) {
                        dataStore = { store: dojo.data.ObjectStore(dojo.store.Memory({ idProperty: '$key', data: this.formData[name] })) };
                    }
                    var label = collection.label ? collection.label : this.formNlsResource[name];
                    var toolbox = [];

                    if (!disabledViaSec) {
                        toolbox.push('add');
                        toolbox.push('delete');
                    }

                    control = {
                        type: 'Grid',
                        options: {
                            tools: toolbox,
                            gridLabel: label,
                            editable: true,    // allows the column editor to be mixed in
                            selectionMode: 'single',
                            rowSelection: true,
                            columnHiding: true,  // allows the column hider to be mixed in
                            showRecordCount: true,
                            addNew: lang.partial(this._addItemToGrid, this), // set the add item function
                            deleteSelected: lang.partial(this._removeItemFromGrid, this), // set the remove item function
                            parent: this,
                            shouldPublishMarkDirty: false,
                            columns: cols,
                            classNames: 'items'
                        }
                    };
                    var language = this.formData.defaultLanguage || "";
                    this.setControlValue('defaultLanguage', language);
                    if (typeof (language) === 'string' && language.trim() !== '') {
                        dataStore.store.setData(dataStore.store.query({ languageCode: language })); // limit to just the ones we can edit... default items.
                    }
                    control.options = lang.mixin(control.options, dataStore);
                    dojoConnect.subscribe('sdata/form/setGrid', this, this._setItemsGrid);
                    break;
            }
            return control;
        },
        _getRowIdFromCell: function(cell){
            var row = cell.closest? cell.closest("tr") : cell.parentElement.parentElement;
            if (row && row.tagName.toLowerCase() === 'tr') {
                return ($(".field--key", row) || {})[0] || null;
            }
            return null;
        },
        _regenerateCellId: function (control, rowKey, itemName) {
            return '#' + control.id + '-row-' + rowKey + ' td.field-' + itemName;
        },
        _getGrid: function (context) {
            var control = ((context.activeControls || []).filter(function(x){return x.name === 'items';})[0] || {}).control;
            if (control) {
                if (control.store) {
                    return control;
                }
                var grid = control.grid;
                if (grid) {
                    return grid;
                }
            }
            return null;
        },
        _getItemFromGridsStore: function (grid, key) {
            var store = grid.store;
            if(store) {
                var index = store[key];
                if(index && index >= 0 && store[index]){
                    return store[index];
                }
            }
            return null;
        },
        _setItemsGrid: function (grid) {
            if (grid.className === 'items') {
                this._itemsGrid = grid;
            }
        },
        _addItemToGrid: function (context) {
            var maxValue = -1;
            for (var d = 0; d < this.store.data.length; d++) {
                var number = this.store.data[d];
                if (number.number > maxValue) {
                    maxValue = number.number;
                }
            }
            maxValue = Number(maxValue) + 1;

            var newRecordEntry = {};
            for (var cols_i = 0; cols_i < this.columns.length; cols_i++) {
                var cols_item = this.columns[cols_i];
                switch (cols_item.field) {
                    case 'number':
                    case '$key':
                        newRecordEntry[cols_item.field] = maxValue;
                        break;
                    case 'isDefault':
                        newRecordEntry[cols_item.field] = false;
                        break;
                    default:
                        if (cols_item.field === 'languageCode') {
                            newRecordEntry[cols_item.field] = context.formData.defaultLanguage || '';
                        } else {
                            newRecordEntry[cols_item.field] = '';
                        }
                }
            }

            this.store.add(newRecordEntry);
            this.refresh();
        },
        _removeItemFromGrid: function (context) {
            var selectedItemArr = this.getSelectedRowData();
            var noItemsSelected = typeof (selectedItemArr) === 'undefined' || selectedItemArr === null || selectedItemArr.length === 0;
            var keyVariable = this.store.idProperty;
            var id, count;
            if (noItemsSelected) {
                context.dialogs.showWarning(context.gridNlsResource.noSelectionsText, 'Infor CRM');
                return;
            }
            var somethingRemoved = false, doubleCheck = false;
            for (var i = 0; i < selectedItemArr.length; i++) {
                var container = selectedItemArr[i];
                count = this.store.data.length;
                if (container) {
                    id = container[keyVariable];
                    if (typeof (id) !== 'undefined') {
                        this.store.remove(id);
                        if (count > this.store.data.length) {
                            somethingRemoved = true;
                            console.log(dString.substitute('${0}: was removed', [id]));
                            i--;//reset to the previous index sinve we are removing an item
                        }
                    }
                }
                else {
                    doubleCheck = true;
                }
            }
            // when doing a selection of multiple rows at once, some get recorded by getSelectedRowData as undefined.
            // this may be caused by range selections, or paging or both.
            // the _grid.selection object still has a list of selected ids, so double check against it if needed.
            if (doubleCheck) {
                for (var sel_i = 0; sel_i < this.store.data.length; sel_i++) {
                    var sel_item = this.store.data[sel_i];
                    id = sel_item[keyVariable];
                    count = this.store.data.length;
                    if (id) {
                        if (this.grid._grid.selection[id] === true) {
                            this.store.remove(id);
                            if (count > this.store.data.length) {
                                somethingRemoved = true;
                                console.log(dString.substitute('${0}: was removed', [id]));
                                i--;//reset to the previous index sinve we are removing an item
                            }
                        }
                    }
                }
            }
            if (somethingRemoved) {
                this.refresh();
            }
            else {
                context.dialogs.showWarning(context.gridNlsResource.noSelectionsText, 'Infor CRM');
            }
        },
        _changeObjectPathParameters: function (path, value, propName, skip, stringifyValue) {
            if (propName === 'items' && path[path.length - 1] !== '$resources') {
                path.push('$resources');
            }
            var prev = path[path.length - 1];
            for (var path_idx = path.length - 2; path_idx > 0; path_idx--) {
                if (prev === '$resources' && prev === path[path_idx]) {
                    path.splice(path_idx, 1);
                }
            }
            return {
                propName: propName,
                path: path,
                builtUpPath: JSON.stringify(value),
                skip: skip,
                stringify: stringifyValue,
                lineEscape: propName === 'items' ? '\"' : ''
            };
        },
        _save: function (formName) {
            if (formName && formName.type && formName.type === 'click') {
                formName = null;
            }
            var sdataPkg = {}, value = false;
            var allowToContinue = this.isValid();
            if (allowToContinue) {
                sdataPkg = lang.mixin(this.formData, this.getActiveValues());
                if (sdataPkg.items) {
                    // with the deleteMissing flag about to be true, need add back the filtered out items (translated values) so they are not removed.
                    sdataPkg.items.$resources = lang.mixin(this._oformData.items, sdataPkg.items.$resources);
                    // When set to true this flag will removed items from the server, that are not included in the list being currently provided.
                    sdataPkg.items.$deleteMissing = true;
                }
                var service = Sage.Data.SDataServiceRegistry.getSDataService('system');
                var resourceRequest = new Sage.SData.Client.SDataSingleResourceRequest(service).setResourceKind('picklists');
                resourceRequest.setQueryArg('language', cookie.getCookie("SLXLanguageSetting"));

                var returnObjectHandler = {
                    isSecurityManager: true,
                    scope: this,
                    format: 'json',
                    ignoreETag: !this.editMode,
                    async: false,
                    success: function (data) {
                        value = true;
                        if (typeof (formName) === 'undefined' || formName === null || this.formBase === formName) {
                            dojoConnect.publish('Sage/picklist/form/reload', data);
                            var strWarning = dString.substitute(this.formNlsResource.messageOnSave, [data.name]);
                            this.dialogs.showWarning(strWarning, 'Infor CRM');
                        }
                    },
                    failure: function (xhr, sdata) {
                        var msgObj = JSON.parse(xhr.response);
                        var errMsg = dString.substitute('${0}(${1})', [xhr.statusText, xhr.status]);
                        if (msgObj.length > 0 && typeof (msgObj[0].message) !== 'undefined') {
                            errMsg = dString.substitute('${0}: {${1}', [errMsg, msgObj[0].message]);
                        }
                        // Handle failure
                        value = false;
                    }
                };

                var action = 'create';
                if (this.editMode) {
                    resourceRequest.setResourceSelector(dString.substitute("'${0}'", [sdataPkg['$key']]));
                    action = 'update';
                }

                resourceRequest[action](sdataPkg, returnObjectHandler);
            }
            return value;
        },
        customValidation: function (ob) {
            var retVal = null;
            var n = '';

            if (typeof (ob.name) !== 'undefined') {
                n = ob.name.toLowerCase();
            }

            switch (n) {
                case '':
                    retVal = false;
                    break;
                case 'items':
                    var codeMap = {};
                    var grid = this._getGrid(this);
                    if (grid) {
                        var items = $(".dgrid-row .field-code .dijitTextBox.dijitValidationTextBox", grid.domNode);
                        for (var i = 0; i < items.length; i++) {
                            var item = dijit.registry.byNode(items[i]);
                            if (item) {
                                var valid = true;
                                if (typeof (item.isValid) === 'function') {
                                    valid = item.isValid(true);
                                }
                                if (typeof (item.onChanged) === 'function') {
                                    item.onChanged();
                                }
                                if (typeof (valid) === 'boolean' && valid === false) {
                                    return false;
                                }
                            }
                        }
                    }
                    return true;
                case 'name':
                    if (!this.editMode) {
                        if (ob.control.value.trim() !== '') {
                            retVal = !this._checkIfDuplicate(Sage.Data.SDataServiceRegistry.getSDataService('system'), ob);
                        }
                    }
                    break;
            }
            return retVal;
        }
    });

    return widget;
});
},
'Sage/MainView/EntityMgr/AddEditEntityDetail/DisplayName':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define, cookie */
define([
    'dijit/_Widget',
    'Sage/_Templated',
    'dojo/string',
    'dojo/_base/lang',
    'dojo/_base/declare',
    'dojo/text!./templates/DisplayName.html',
    'dojo/i18n!./nls/AddEditDialog',
    'Sage/UI/Controls/TextBox',
    'dojo/dom-class',
    'dojo/dom-construct'
],
function (
    _Widget,
    _Templated,
    dojoString,
    lang,
    declare,
    template,
    nlsResources,
    crmTextBox,
    domClass,
    domConstruct
) {
    var widget = declare('Sage.MainView.EntityMgr.AddEditEntityDetail.DisplayName', [_Widget, _Templated], {
        widgetTemplate: new Simplate(eval(template)),
        widgetsInTemplate: true,
        _nlsResources: nlsResources,
        _detailUtility: null,
        _nameField: null,
        _displayField: null,
        _grdField: null,
        _trigger: null,
        _GetLocalsQuery: null,
        _baseLanguage: "en-us",
        _updateFromGrid: false,
        _editMode: false,
        display: null,
        name: null,
        _dataStore: null,
        /*
            obj:
                -dUtility->The utility class that most of the entity dialogues use.
                -editMode->if editing will be true, if creating will be false.
                -query:
                    -entityName-> entityName
                    -resourceKind-> the resourceString
                    -name-> what the name value is called ie filterName for filters or metric
                    -displayName-> will probably always be displayName, but incase it is not here is where it is set.
                -values-> {display:{data:"",validation:()},name:{data:"",validation:()}}
                    -display.data->the default value given for the displayName field.
                    -name.data->the default value given for the name field.
                        -name is assumed to be the name that the object goes by in code, so a filter or metric's name would be filterName.
                    -validation->a custom validation function to use on the field.
        */
        constructor: function (obj) {
            this._baseLanguage = cookie.getCookie("SLXLanguageSetting");
            if (obj.editMode) {
                this._editMode = obj.editMode;
            }
            if (obj.dataStore) {
                this._dataStore = obj.dataStore;
            }
            if (obj.query) {
                this._GetLocalsQuery = obj.query;
            }
            if (obj.dUtility) {
                this._detailUtility = obj.dUtility;
            }
            if (obj.values) {
                if (obj.values.display) {
                    this.display = obj.values.display;
                }
                if (obj.values.name) {
                    this.name = obj.values.name;
                }
            }
            if (this.display) {
                this._createDisplayController(this.display);
            }
            if (this.name) {
                this._createNameController(this.name);
            }
        },
        postCreate: function () {
            //display name
            this.lblDisplayName.innerHTML = this._nlsResources['lblDisplay'];
            this.displayNameTxtCntrl.appendChild(this._displayField.domNode);
            domClass.add(this._TriggerSection, 'display-none');
            // name for identifying
            this.lblName.innerHTML = this._nlsResources['lblName'];
            this.NameCntrl.appendChild(this._nameField.domNode);

        },
        _createDisplayController: function (obj) {
            var value = obj.data,
               validator = obj.validation,
               isDisabled = obj.disabled,
               invalidMessage = obj.invalidMessage;
            if (typeof (obj.mapDisplayToName) === "function") {
                this.mapDisplayToName = obj.mapDisplayToName;
            }
            if (typeof (validator) !== "function") {
                validator = this._displayNameValidator;
            }
            if (typeof (invalidMessage) !== "string") {
                invalidMessage = "";
            }
            if (typeof (isDisabled) !== "boolean") {
                isDisabled = false;
            }
            var selfAware = this;
            this._displayField = new crmTextBox({
                shouldPublishMarkDirty: false,
                validator: validator,
                invalidMessage: invalidMessage,
                disabled: isDisabled,
                onChange: function () {
                    if (selfAware._nameField.textbox.value === "") {
                        selfAware._nameField.textbox.value = selfAware.mapDisplayToName(this.value, selfAware);
                        selfAware._nameField.isValid(true);
                        selfAware._nameField.onChange();
                    }
                }
            });
            var v = '';
            if (value) {
                v = value;
            }
            this._displayField.textbox.value = v;
        },
        _displayNameValidator: function (value, constraints) {
            return true;
        },
        _createNameController: function (obj) {
            var value = obj.data,
                validator = obj.validation,
                isDisabled = obj.disabled,
                invalidMessage = obj.invalidMessage;
            if (typeof (validator) !== "function") {
                validator = this._nameValidator;
            }
            if (typeof (invalidMessage) !== "string") {
                invalidMessage = "";
            }
            if (typeof (isDisabled) !== "boolean") {
                isDisabled = false;
            }
            var selfAware = this;
            // Validation will be to make sure not special characters or whitespaces are entered
            this._nameField = new crmTextBox(
                {
                    shouldPublishMarkDirty: false,
                    required: true,
                    validator: validator,
                    invalidMessage: invalidMessage,
                    disabled: isDisabled
                });
            var v = '';
            if (value) {
                v = value;
            }
            this._nameField.textbox.value = v;
        },
        _nameValidator: function (value, constraints) {
            // value needs to start with a letter or underscore, but can also contain numbers
            var regex = '^([a-z]|[A-Z]|_)(\\w)*';
            var matches = value.match(regex, 'g');
            if (matches) {
                if (lang.isArray(matches)) {
                    return matches[0].length == value.length;
                }
                else {
                    return matches[0].length == value.length;
                }
            }
            return false;
        },
        _trimWhiteSpace: function (val) {
            return val.replace(/\s+/g, '');
        },
        _cmdTrigger: function (context) {
            this._updateFromGrid = true;
            if (this.checked) { // checked means display the language grid
                this.innerHTML = context._nlsResources.hideTranslations;
                // Hide the textbox
                domClass.add(context.displayNameTxtCntrl, 'display-none');
                domClass.remove(context.displayNameTxtCntrl, 'display');
                domClass.add(context.displayNameGrdCntrl, 'display');
                domClass.remove(context.displayNameGrdCntrl, 'display-none');
                context._shrinkGridAsNeeded();
                context._grdField.grid.resize();
            }
            else { // not checked means display just the textbox
                this.innerHTML = context._nlsResources.showTranslations;
                domClass.add(context.displayNameTxtCntrl, 'display');
                domClass.remove(context.displayNameTxtCntrl, 'display-none');
                domClass.add(context.displayNameGrdCntrl, 'display-none');
                domClass.remove(context.displayNameGrdCntrl, 'display');
            }
            this.checked = !this.checked;
        },
        _createCustomValidationTextBox: function () {
            var selfAware = this,
                custText = declare("Sage.MainView.EntityMgr.AddEditEntityFilter.customValTxtBx", Sage.UI.Controls.TextBox, {
                    shouldPublishMarkDirty: false,
                    placeHolder: "Enter Value",
                    disabled: true,
                    onChange: function (v) {
                        var updateTxtControl = true;
                        var loc = selfAware._grdField.grid.store.index[this.domNode.parentNode.parentNode.children[1].innerHTML];
                        if (loc < 0) {
                            loc = selfAware._grdField.grid.store.index[selfAware._baseLanguage];
                            updateTxtControl = false;
                        }
                        selfAware._grdField.grid.store.data[loc].display = this.value;
                        if (updateTxtControl && selfAware._grdField.grid.store.data[loc].code === selfAware._baseLanguage) {
                            selfAware._displayField.textbox.value = selfAware._grdField.grid.store.data[loc].display;
                        }
                    }
                });
            return custText;
        },
        _createRequest: function (nameValue, select, language) {
            var request = new Sage.SData.Client.SDataResourceCollectionRequest(this._detailUtility.service);
            request.setResourceKind(this._GetLocalsQuery.resourceKind);
            request.setQueryArg('where', dojoString.substitute("lower(${0}) eq '${1}'", [this._GetLocalsQuery.name, nameValue]));
            if (select !== null) {
                request.setQueryArg('select', select);
            }
            if (language) {
                request.setQueryArg('language', language);
            }
            request.setQueryArg('startIndex', 0);
            request.setQueryArg('count', 1);
            return request;
        },
        isValid: function (forCreate) {
            var failed = false, error = null;
            if (!this._nameField.disabled) {
                var _nameFieldControlNotValid = !this._nameField.isValid(true);
                failed = failed || _nameFieldControlNotValid;

                // now make sure the state of the control is boiled now into a boolean value
                if (typeof (this._nameField.state) !== "undefined" && typeof (this._nameField.required) !== "undefined") {
                    _nameFieldControlNotValid = _nameFieldControlNotValid || this._nameField.state === 'Error' || (this._nameField.state === 'Incomplete' && this._nameField.required);
                    failed = failed || _nameFieldControlNotValid;
                }
                if (_nameFieldControlNotValid) {
                    this._nameField.set('state', 'Error'); // If the control is not valid, mark  it's state as error.
                }
                this._nameField.onChanged();
            }
            if (!this._displayField.disabled) {
                var _displayFieldControlNotValid = !this._displayField.isValid(true);
                failed = failed || _displayFieldControlNotValid;
                this._displayField.onChanged();
                // now make sure the state of the control is boiled now into a boolean value
                if (typeof (this._displayField.state) !== "undefined" && typeof (this._displayField.required) !== "undefined") {
                    _displayFieldControlNotValid = _displayFieldControlNotValid || this._displayField.state === 'Error' || (this._displayField.state === 'Incomplete' && this._displayField.required);
                    failed = failed || _displayFieldControlNotValid;
                }
                if (_displayFieldControlNotValid) {
                    this._displayField.set('state', 'Error'); // If the control is not valid, mark  it's state as error.
                }
                this._displayField.onChanged();
            }
            if (!failed) {
                var context = this;
                if (!this._editMode && typeof (this.dataStore) !== "undefined" && this.dataStore !== null) { //calling from New Entity wizard
                    var props = this.dataStore.query();
                    for (var i = 0; i < props.length; i++) {
                        if (this._nameField.value === props[i].propertyName) {
                            this._nameField.invalidMessage = dojoString.substitute("${0} ${1}", [context.lblName.innerHTML, context._nlsResources.notUnique]);
                            this._nameField.set('state', 'Error');
                            failed = true;
                            break;
                        }
                    }
                }
                else {
                    var request = this._createRequest(this._nameField.textbox.value.toLowerCase(), null, this._baseLanguage);
                    request.read({
                        async: false,
                        scope: this,
                        success: function (data) {
                            if (forCreate && typeof (data) !== 'undefined' && typeof (data.$resources) !== 'undefined' && data.$resources.length == 1) {
                                failed = true;
                                this._nameField.invalidMessage = dojoString.substitute("${0} ${1} ${2}", [context.lblName.innerHTML, context._nlsResources.notUniqueFor, context._GetLocalsQuery.entityName]);
                                this._nameField.set('state', 'Error');
                            }
                            else {
                                failed = false;
                            }
                        },
                        failure: function (data) {
                            failed = true;
                            this._nameField.invalidMessage = dojoString.substitute("${0} ${1} ${2}", [context.lblName.innerHTML, context._nlsResources.notUniqueFor, context._GetLocalsQuery.entityName]);
                            this._nameField.set('state', 'Error');
                        }
                    });
                }
            }
            return !failed;
        },
        getDetails: function () {
            var obj = {};
            // use the appropreate variable names.
            obj[this._GetLocalsQuery.displayName] = this._displayField.textbox.value;
            obj[this._GetLocalsQuery.name] = this._nameField.textbox.value;
            return obj;
        }
    });
    return widget;
});
},
'Sage/MainView/EntityMgr/EntityWizard/AddEditEntity':function(){
require({cache:{
'url:Sage/MainView/EntityMgr/EntityWizard/templates/AddEditEntity.html':"<div>\r\n    <div data-dojo-type=\"dijit.Dialog\" title=\"New Entity Wizard\" data-dojo-attach-point=\"_dialog\" data-dojo-attach-event=\"onCancel:_btnCancel_OnClick\" style=\"position:absolute;width: 625px;height:625px;\">\r\n        <div data-dojo-type=\"dijit.form.Form\" style=\"height:600px !important;\" dojoattachpoint=\"Form\">\r\n            <div style=\"\">\r\n                <label style=\"font-weight:bold;\" data-dojo-attach-point=\"lblSure\">Are you sure ?</label>\r\n                <p>\r\n                    <label data-dojo-attach-point=\"lblThisStepCreateEntity\">Completing this step will create the entities and necessary schema</label>\r\n                </p>\r\n                <hr />\r\n            </div>\r\n\r\n            <table style=\"padding-left:20px; padding-top:20px;\">\r\n                <tr>\r\n                    <td style=\"text-align: right;\">\r\n                        <label style=\"font-weight:bold; text-align: right;\" data-dojo-attach-point=\"lblEntity\">Entity : </label>\r\n                    </td>\r\n                    <td style=\"padding-left: 10px;\">\r\n                        <label data-dojo-attach-point=\"createEntity\"></label>\r\n                    </td>\r\n                </tr>\r\n                <tr>\r\n                    <td style=\"vertical-align:top; padding-top:15px;text-align: right;\">\r\n                        <span><label style=\"font-weight:bold;\" data-dojo-attach-point=\"lblProperties\">Properties : </label></span>\r\n                    </td>\r\n                    <td style=\"padding-left: 10px;\">\r\n                        <ul class=\"properties\" style=\"padding-left:0;\"></ul>\r\n                    </td>\r\n                </tr>\r\n                <tr>\r\n                    <td style=\"text-align: right;\">\r\n                        <label style=\"font-weight:bold;\" data-dojo-attach-point=\"lblRelatedEntity\"></label>\r\n                    </td>\r\n                    <td style=\"padding-left: 10px;\">\r\n                        <label data-dojo-attach-point=\"relatedEntity\"></label>\r\n                    </td>\r\n                </tr>\r\n                <tr>\r\n                    <td style=\"text-align: right;\">\r\n                        <label style=\"font-weight:bold;\" data-dojo-attach-point=\"lblRelationType\"></label>\r\n                    </td>\r\n                    <td style=\"padding-left: 10px;\">\r\n                        <label data-dojo-attach-point=\"relationType\"></label>\r\n                    </td>\r\n                </tr>\r\n            </table>\r\n\r\n            <div align=\"right\" style=\"position:absolute;bottom:30px;width:90%;\">\r\n                <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnBack\" data-dojo-attach-event=\"onClick:_btnBack_OnClick\">< Back</div>\r\n                <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnNext\" data-dojo-attach-event=\"onClick:_btnNext_OnClick\">Next ></div>\r\n                <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnCancel\" data-dojo-attach-event=\"onClick:_btnCancel_OnClick\" style=\"margin-left:5px;\">Cancel</div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>"}});
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/_base/declare',
    'dojo/_base/connect',
    'dojo/number',
    'dojo/string',
    'Sage/MainView/EntityMgr/EntityWizard/_EntityWizardDialogBase',
    'dojo/text!./templates/AddEditEntity.html',
    'Sage/MainView/EntityMgr/EntityWizard/EntityWizardUtility',
    'Sage/Utility',
    'Sage/Utility/File/Attachment',
    'Sage/Data/SDataServiceRegistry',
    'Sage/UI/_DialogLoadingMixin',
    'dojo/_base/lang',
    'dijit/registry',
    'dojo/topic'
],
function (
    declare,
    connect,
    dNumber,
    dString,
    wizardDialogBase,
    template,
    //nlsResources,
    entityWizardUtility,
    utility,
    attachmentUtility,
    SDataServiceRegistry,
    _DialogLoadingMixin,
    lang,
    registry,
    topic
) {
    var widgetTemplate = utility.makeTemplateFromString(template);
    var addEditEntity = declare('Sage.MainView.EntityMgr.EntityWizard.AddEditEntity', [wizardDialogBase], {
        _dialog: null,
        id: "dlgAddEditEntity",
        widgetTemplate: widgetTemplate,
        //_nlsResources: nlsResources,
        _currentStep: entityWizardUtility.entityWizardStep.AddEditEntity,
        _fileInputOnChange: null,
        constructor: function () {
            this.inherited(arguments);
        },
        startup: function () {
            this.createEntity.innerHTML = ' ' + this.entityDetails.entityName;

            if (this.entityDetails.relatedEntity) {
                this.lblRelatedEntity.innerHTML = this._nlsResources.lblRelatedEntity;
                this.lblRelationType.innerHTML = this._nlsResources.lblRelationType;

                this.relatedEntity.innerHTML = ' ' + this.entityDetails.relatedEntity;
                this.relationType.innerHTML = ' ' + this.entityDetails.relationType;
            }
            this.inherited(arguments);
        },
        postCreate: function () {
            this._dialog.set("title", this._nlsResources.lblNewEntityWizard);
            this.lblSure.innerHTML = this._nlsResources.lblSure;
            this.lblThisStepCreateEntity.innerHTML = this._nlsResources.lblThisStepCreateEntity;
            this.lblEntity.innerHTML = this._nlsResources.lblEntity;
            this.lblProperties.innerHTML = this._nlsResources.lblProperties;
            this.btnBack.set("label", '< ' + this._nlsResources.lblBack);
            this.btnNext.set("label", this._nlsResources.lblNext + ' >'); 
            this.btnCancel.set("label", this._nlsResources.lblCancel);

            lang.mixin(this._dialog, new _DialogLoadingMixin());

            var properties = $('.properties');
            for (var i = 0; i < this.entityDetails.data.length; i++) {
                $('<li>' + this.entityDetails.data[i].displayName + '</li>').appendTo(properties);
            }
        },
        isValid: function () { 
            var myform = this.Form;
            return myform.validate();
            //return true;
        },
        _btnBack_OnClick: function () {
            var dialog = dijit.byId("dlgAddEditEntity");
            this._dialog.hide();
            dialog.destroyRecursive();
            topic.publish("/entityController/entityWizard/previousStep", this._currentStep);
        },
        createOwnerRelation: function (childProps, context) {
            var relation = {};
            relation.cardinality = "M:1";
            relation.cascadeOption = "SaveUpdate"; //default in AA
            relation.parentEntity = { "$key": this.entityDetails.entityName };
            relation.childEntity = { "$key": 'Owner' };

            relation.parentProperty = { "propertyName": 'Owner', "displayName": 'Owner', "isIncluded": true };
            relation.childProperty = { "propertyName": this.entityDetails.entityName, "displayName": this.entityDetails.entityDisplayName, "isIncluded": false };
            
            //Get foreign-key id(secCode id) thats got created now
            var seccodeId;
            for (var i = 0; i < childProps.length; i++) {
                if (childProps[i].propertyName === 'SeccodeId') {
                    seccodeId = childProps[i].id;
                    break;
                }
            }

            relation.columns = {
                "$resources": [{
                    "parentPropertyId": seccodeId,
                    "childPropertyId": this.entityDetails.ownerId
                }]
            };

            var request = new Sage.SData.Client.SDataSingleResourceRequest(SDataServiceRegistry.getSDataService('metadata')).setResourceKind(dString.substitute('relationships'));
            request.create(relation, {
                async: false,
                success: function (data) {
                },
                failure: function (data) {
                    context.entityDetails.ownerStatus = context._nlsResources.lblErrorRelation + ' Owner !';
                }
            });
        },
        _btnNext_OnClick: function () {
            var context = this;
            var entityNamePurlal = utility.pluralize(this.entityDetails.entityName);
            var dispNamePurlal = utility.pluralize(this.entityDetails.entityDisplayName);
            var resourceRequest = new Sage.SData.Client.SDataSingleResourceRequest(SDataServiceRegistry.getSDataService('metadata')).setResourceKind(dString.substitute('entities'));
            var entityInfo = {
                "name": this.entityDetails.entityName,
                "tableName": this.entityDetails.entityName.toUpperCase(),
                "displayName": this.entityDetails.entityDisplayName,
                "displayNamePlural": dispNamePurlal,
                "isDynamic": true,
                "properties": { "$resources": this.entityDetails.data },
                "package": { "$key": "SalesLogix Application Entities" },
                "sdata": { "pathName": utility.pluralize(this.entityDetails.entityName.toLowerCase()) },
                "stringExpression": "${" + this.entityDetails.entityName + "Id}"
            };
            if (this.entityDetails.relationType == "1:1") {
                entityInfo.isExtension = true;
                entityInfo.extendedEntity = {
                    "$key": this.entityDetails.relatedEntity
                };
            }
            else{
                entityInfo.isExtension = false;
            }

            this._dialog.showLoading();
            resourceRequest.create(entityInfo, {
                success: function (data) {
                    this.entityDetails.status = context._nlsResources.lblSuccessMsg;
                    //Create default relationship with Owner
                    var childProps = data.properties.$resources;
                    if (context.entityDetails.relationType !== "1:1") {
                        this.createOwnerRelation(childProps, context);
                    }

                    //Create the selected relationship
                    if (context.entityDetails.relationType === "1:M") {
                        var relation = {};
                        relation.cardinality = "1:M";
                        relation.cascadeOption = "SaveUpdate"; //default in AA
                        relation.parentEntity = { "$key": context.entityDetails.relatedEntity };
                        relation.childEntity = { "$key": context.entityDetails.entityName };

                        relation.parentProperty = { "propertyName": entityNamePurlal, "displayName": dispNamePurlal, "isIncluded": true };
                        relation.childProperty = { "propertyName": context.entityDetails.relatedEntity, "displayName": this.entityDetails.relatedEntityDispName, "isIncluded": true };

                        //Get foreign-key id(child property id) thats got created now
                        var childPropID;
                        for (var i = 0; i < childProps.length; i++) {
                            if (childProps[i].propertyName === context.entityDetails.relatedEntity + 'Id') {
                                childPropID = childProps[i].id;
                                break;
                            }
                        }

                        relation.columns = {
                                "$resources": [{
                                    "parentPropertyId": context.entityDetails.relatedPropertyId,
                                    "childPropertyId": childPropID
                                }]
                            };
                        var request = new Sage.SData.Client.SDataSingleResourceRequest(SDataServiceRegistry.getSDataService('metadata')).setResourceKind(dString.substitute('relationships'));
                        request.create(relation, {
                            success: function (data) {
                                context._dialog.hideLoading();
                                context._dialog.hide();
                                topic.publish("/entityController/entityWizard/nextStep", this._currentStep);
                            },
                            failure: function (data) {
                                context.entityDetails.selectedRelStatus = context._nlsResources.lblErrorRelation + ' ' +context.entityDetails.relatedEntity + ' !';
                                context._dialog.hideLoading();
                                context._dialog.hide();
                                topic.publish("/entityController/entityWizard/nextStep", this._currentStep);
                            },
                            scope: context
                        });
                    } else {
                        context._dialog.hideLoading();
                        context._dialog.hide();
                        topic.publish("/entityController/entityWizard/nextStep", this._currentStep);
                    }

                    //Refresh main list view
                    var listpanel = registry.byId('list');
                    if (listpanel) {
                        listpanel._listGrid._refresh();
                    }
                    
                },
                failure: function (data) {
                    this.entityDetails.status = context._nlsResources.lblErrorMsg;
                    this._dialog.hideLoading();
                    this._dialog.hide();
                    topic.publish("/entityController/entityWizard/nextStep", this._currentStep);
                },
                scope: this
            });

        }
    });
    return addEditEntity;
});
},
'Sage/MainView/EntityMgr/EntityWizard/Status':function(){
/*globals Sage, dojo, dojox, dijit, Simplate, window, Sys, define */
define([
    'dojo/_base/declare',
    'dojo/_base/connect',
    'dojo/number',
    'dojo/string',
    'Sage/MainView/EntityMgr/EntityWizard/_EntityWizardDialogBase',
    'dojo/text!./templates/Status.html',
    //'dojo/i18n!./nls/SelectFile',
    'Sage/MainView/EntityMgr/EntityWizard/EntityWizardUtility',
    'Sage/Utility',
    'Sage/Utility/File/Attachment'
],
function (
    declare,
    connect,
    dNumber,
    dString,
    wizardDialogBase,
    template,
    //nlsResources,
    entityWizardUtility,
    utility,
    attachmentUtility
) {
    var widgetTemplate = utility.makeTemplateFromString(template);
    var status = declare('Sage.MainView.EntityMgr.EntityWizard.Status', [wizardDialogBase], {
        id: "dlgStatus",
        widgetTemplate: widgetTemplate,
        //_nlsResources: nlsResources,
        _currentStep: entityWizardUtility.entityWizardStep.EntityDetails,
        _fileInputOnChange: null,
        constructor: function () {
            this.inherited(arguments);
        },
        startup: function () {
            this.statusLabel.innerHTML = this.entityDetails.status;
            if (this.entityDetails.selectedRelStatus) {
                this.selectedRelStatus.innerHTML = this.entityDetails.selectedRelStatus;
            }
            if (this.entityDetails.ownerStatus) {
                this.ownerStatus.innerHTML = this.entityDetails.ownerStatus;
            }
            
            this.inherited(arguments);
        },
        postCreate: function () {
			this._dialog.set("title", this._nlsResources.lblNewEntityWizard);
            this.lblCreateEntity.innerHTML = this._nlsResources.lblCreateEntity;
            this.lblStatus.innerHTML = this._nlsResources.lblStatus;
			this.btnFinish.set("label", this._nlsResources.lblFinish);
        },
        _btnFinish_OnClick: function () {
            this._dialog.hide();
            this.finishWizard();
        },
        isValid: function () { 
            var myform = this.Form;
            return myform.validate();
            //return true;
        },
        destroy: function () {
            this.inherited(arguments);
        }
    });
    return status;
});
},
'url:dijit/form/templates/Button.html':"<span class=\"dijit dijitReset dijitInline\" role=\"presentation\"\r\n\t><span class=\"dijitReset dijitInline dijitButtonNode\"\r\n\t\tdata-dojo-attach-event=\"ondijitclick:__onClick\" role=\"presentation\"\r\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\r\n\t\t\tdata-dojo-attach-point=\"titleNode,focusNode\"\r\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\r\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\" data-dojo-attach-point=\"iconNode\"></span\r\n\t\t\t><span class=\"dijitReset dijitToggleButtonIconChar\">&#x25CF;</span\r\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\r\n\t\t\t\tid=\"${id}_label\"\r\n\t\t\t\tdata-dojo-attach-point=\"containerNode\"\r\n\t\t\t></span\r\n\t\t></span\r\n\t></span\r\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\"\r\n\t\tdata-dojo-attach-event=\"onclick:_onClick\"\r\n\t\ttabIndex=\"-1\" role=\"presentation\" aria-hidden=\"true\" data-dojo-attach-point=\"valueNode\"\r\n/></span>\r\n",
'url:dijit/templates/Dialog.html':"<div class=\"dijitDialog\" role=\"dialog\" aria-labelledby=\"${id}_title\">\r\n\t<div data-dojo-attach-point=\"titleBar\" class=\"dijitDialogTitleBar\">\r\n\t\t<span data-dojo-attach-point=\"titleNode\" class=\"dijitDialogTitle\" id=\"${id}_title\"\r\n\t\t\t\trole=\"heading\" level=\"1\"></span>\r\n\t\t<span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${buttonCancel}\" role=\"button\" tabindex=\"-1\">\r\n\t\t\t<span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${buttonCancel}\">x</span>\r\n\t\t</span>\r\n\t</div>\r\n\t<div data-dojo-attach-point=\"containerNode\" class=\"dijitDialogPaneContent\"></div>\r\n\t${!actionBarTemplate}\r\n</div>\r\n\r\n",
'url:dijit/templates/ProgressBar.html':"<div class=\"dijitProgressBar dijitProgressBarEmpty\" role=\"progressbar\"\r\n\t><div  data-dojo-attach-point=\"internalProgress\" class=\"dijitProgressBarFull\"\r\n\t\t><div class=\"dijitProgressBarTile\" role=\"presentation\"></div\r\n\t\t><span style=\"visibility:hidden\">&#160;</span\r\n\t></div\r\n\t><div data-dojo-attach-point=\"labelNode\" class=\"dijitProgressBarLabel\" id=\"${id}_label\"></div\r\n\t><span data-dojo-attach-point=\"indeterminateHighContrastImage\"\r\n\t\t   class=\"dijitInline dijitProgressBarIndeterminateHighContrastImage\"></span\r\n></div>\r\n",
'url:dijit/form/templates/TextBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft\" id=\"widget_${id}\" role=\"presentation\"\r\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\r\n\t\t><input class=\"dijitReset dijitInputInner\" data-dojo-attach-point='textbox,focusNode' autocomplete=\"off\"\r\n\t\t\t${!nameAttrSetting} type='${type}'\r\n\t/></div\r\n></div>\r\n",
'url:dijit/templates/Tooltip.html':"<div class=\"dijitTooltip dijitTooltipLeft\" id=\"dojoTooltip\" data-dojo-attach-event=\"mouseenter:onMouseEnter,mouseleave:onMouseLeave\"\r\n\t><div class=\"dijitTooltipConnector\" data-dojo-attach-point=\"connectorNode\"></div\r\n\t><div class=\"dijitTooltipContainer dijitTooltipContents\" data-dojo-attach-point=\"containerNode\" role='alert'></div\r\n></div>\r\n",
'url:dijit/form/templates/ValidationTextBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft\"\r\n\tid=\"widget_${id}\" role=\"presentation\"\r\n\t><div class='dijitReset dijitValidationContainer'\r\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\r\n\t/></div\r\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\r\n\t\t><input class=\"dijitReset dijitInputInner\" data-dojo-attach-point='textbox,focusNode' autocomplete=\"off\"\r\n\t\t\t${!nameAttrSetting} type='${type}'\r\n\t/></div\r\n></div>\r\n",
'url:dijit/templates/Calendar.html':"<table cellspacing=\"0\" cellpadding=\"0\" class=\"dijitCalendarContainer\" role=\"grid\" aria-labelledby=\"${id}_mddb ${id}_year\" data-dojo-attach-point=\"gridNode\">\r\n\t<thead>\r\n\t\t<tr class=\"dijitReset dijitCalendarMonthContainer\" valign=\"top\">\r\n\t\t\t<th class='dijitReset dijitCalendarArrow' data-dojo-attach-point=\"decrementMonth\" scope=\"col\">\r\n\t\t\t\t<span class=\"dijitInline dijitCalendarIncrementControl dijitCalendarDecrease\" role=\"presentation\"></span>\r\n\t\t\t\t<span data-dojo-attach-point=\"decreaseArrowNode\" class=\"dijitA11ySideArrow\">-</span>\r\n\t\t\t</th>\r\n\t\t\t<th class='dijitReset' colspan=\"5\" scope=\"col\">\r\n\t\t\t\t<div data-dojo-attach-point=\"monthNode\">\r\n\t\t\t\t</div>\r\n\t\t\t</th>\r\n\t\t\t<th class='dijitReset dijitCalendarArrow' scope=\"col\" data-dojo-attach-point=\"incrementMonth\">\r\n\t\t\t\t<span class=\"dijitInline dijitCalendarIncrementControl dijitCalendarIncrease\" role=\"presentation\"></span>\r\n\t\t\t\t<span data-dojo-attach-point=\"increaseArrowNode\" class=\"dijitA11ySideArrow\">+</span>\r\n\t\t\t</th>\r\n\t\t</tr>\r\n\t\t<tr role=\"row\">\r\n\t\t\t${!dayCellsHtml}\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody data-dojo-attach-point=\"dateRowsNode\" data-dojo-attach-event=\"ondijitclick: _onDayClick\" class=\"dijitReset dijitCalendarBodyContainer\">\r\n\t\t\t${!dateRowsHtml}\r\n\t</tbody>\r\n\t<tfoot class=\"dijitReset dijitCalendarYearContainer\">\r\n\t\t<tr>\r\n\t\t\t<td class='dijitReset' valign=\"top\" colspan=\"7\" role=\"presentation\">\r\n\t\t\t\t<div class=\"dijitCalendarYearLabel\">\r\n\t\t\t\t\t<span data-dojo-attach-point=\"previousYearLabelNode\" class=\"dijitInline dijitCalendarPreviousYear\" role=\"button\"></span>\r\n\t\t\t\t\t<span data-dojo-attach-point=\"currentYearLabelNode\" class=\"dijitInline dijitCalendarSelectedYear\" role=\"button\" id=\"${id}_year\"></span>\r\n\t\t\t\t\t<span data-dojo-attach-point=\"nextYearLabelNode\" class=\"dijitInline dijitCalendarNextYear\" role=\"button\"></span>\r\n\t\t\t\t</div>\r\n\t\t\t</td>\r\n\t\t</tr>\r\n\t</tfoot>\r\n</table>\r\n",
'url:dijit/form/templates/DropDownButton.html':"<span class=\"dijit dijitReset dijitInline\"\r\n\t><span class='dijitReset dijitInline dijitButtonNode'\r\n\t\tdata-dojo-attach-event=\"ondijitclick:__onClick\" data-dojo-attach-point=\"_buttonNode\"\r\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\r\n\t\t\tdata-dojo-attach-point=\"focusNode,titleNode,_arrowWrapperNode,_popupStateNode\"\r\n\t\t\trole=\"button\" aria-haspopup=\"true\" aria-labelledby=\"${id}_label\"\r\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\"\r\n\t\t\t\tdata-dojo-attach-point=\"iconNode\"\r\n\t\t\t></span\r\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\r\n\t\t\t\tdata-dojo-attach-point=\"containerNode\"\r\n\t\t\t\tid=\"${id}_label\"\r\n\t\t\t></span\r\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonInner\"></span\r\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonChar\">&#9660;</span\r\n\t\t></span\r\n\t></span\r\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\" tabIndex=\"-1\"\r\n\t\tdata-dojo-attach-event=\"onclick:_onClick\"\r\n\t\tdata-dojo-attach-point=\"valueNode\" role=\"presentation\" aria-hidden=\"true\"\r\n/></span>\r\n",
'url:dgrid/css/dgrid.css':{"cssText":".dgrid{position:relative;overflow:hidden;border:1px solid #ddd;height:30em;display:block;}.dgrid-header{background-color:#eee;}.dgrid-header-row{position:absolute;right:17px;left:0;}.dgrid-header-scroll{position:absolute;top:0;right:0;}.dgrid-footer{position:absolute;bottom:0;width:100%;}.dgrid-header-hidden,html.has-quirks .dgrid-header-hidden .dgrid-cell{font-size:0;height:0 !important;border-top:none !important;border-bottom:none !important;margin-top:0 !important;margin-bottom:0 !important;padding-top:0 !important;padding-bottom:0 !important;}.dgrid-footer-hidden{display:none;}.dgrid-sortable{cursor:pointer;}.dgrid-header, .dgrid-header-row, .dgrid-footer{overflow:hidden;background-color:#eee;}.dgrid-row-table{border-collapse:collapse;border:none;table-layout:fixed;empty-cells:show;width:100%;height:100%;}.dgrid-cell{padding:0px;text-align:left;overflow:hidden;vertical-align:top;border:1px solid #ddd;border-top-style:none;box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;-webkit-box-sizing:border-box;}.dgrid-cell-padding{padding:3px;}.dgrid-content{position:relative;height:99%;}.dgrid-scroller{overflow-x:auto;overflow-y:scroll;position:absolute;top:0px;margin-top:25px;bottom:0px;width:100%;}.dgrid-preload{font-size:0;line-height:0;}.dgrid-loading{position:relative;height:100%;}.dgrid-above{position:absolute;bottom:0;}.ui-icon{width:16px;height:16px;background-image:url(\"images/ui-icons_222222_256x240.png\");}.ui-icon-triangle-1-e{background-position:-32px -16px;}.ui-icon-triangle-1-se{background-position:-48px -16px;}.dgrid-expando-icon{width:16px;height:16px;}.dgrid-tree-container{-webkit-transition-duration:0.3s;-moz-transition-duration:0.3s;-ms-transition-duration:0.3s;-o-transition-duration:0.3s;transition-duration:0.3s;overflow:hidden;}.dgrid-tree-container.dgrid-tree-resetting{-webkit-transition-duration:0;-moz-transition-duration:0;-ms-transition-duration:0;-o-transition-duration:0;transition-duration:0;}.dgrid-sort-arrow{background-position:-64px -16px;display:block;float:right;margin:0 4px 0 5px;height:12px;}.dgrid-sort-up .dgrid-sort-arrow{background-position:0px -16px;}.dgrid-selected{background-color:#bfd6eb;}.dgrid-input{width:99%;}html.has-mozilla .dgrid *:focus, html.has-opera .dgrid *:focusundefined{outline:1px dotted;}html.has-ie-6-7.has-no-quirks .dgrid-row-table{width:auto;}html.has-quirks .dgrid-row-table, html.has-ie-6 .dgrid-row-table{height:auto;}html.has-quirks .dgrid-header-scroll,html.has-ie-6 .dgrid-header-scroll{font-size:0;}html.has-mozilla .dgrid-focus{outline-offset:-1px;}.dgrid-scrollbar-measure{width:100px;height:100px;overflow:scroll;position:absolute;top:-9999px;}.dgrid-autoheight{height:auto;}.dgrid-autoheight .dgrid-scroller{position:relative;overflow-y:hidden;}.dgrid-autoheight .dgrid-header-scroll{display:none;}.dgrid-autoheight .dgrid-header{right:0;}#dgrid-css-dgrid-loaded{display:none;}","xCss":"html.has-mozilla .dgrid *:{/27};{/17background-image:url(\"images/ui-icons_222222_256x240.png\");}"},
'url:dgrid/css/extensions/ColumnHider.css':".dgrid-hider-toggle{background-position:0 -192px;background-color:transparent;border:none;cursor:pointer;position:absolute;right:0;top:0;}.dgrid-rtl-swap .dgrid-hider-toggle{right:auto;left:0;}.dgrid-hider-menu{position:absolute;top:0;right:17px;width:184px;background-color:#fff;border:1px solid black;z-index:99999;padding:4px;overflow-x:hidden;overflow-y:auto;}.dgrid-rtl-swap .dgrid-hider-menu{right:auto;left:17px;}.dgrid-hider-menu-row{position:relative;padding:2px;}.dgrid-hider-menu-check{position:absolute;top:2px;left:2px;padding:0;}.dgrid-hider-menu-label{display:block;padding-left:20px;}html.has-quirks .dgrid-hider-menu-check,html.has-ie-6-7 .dgrid-hider-menu-check{top:0;left:0;}#dgrid-css-extensions-ColumnHider-loaded{display:none;}",
'url:dgrid/css/extensions/ColumnReorder.css':".dgrid-header .dojoDndTarget .dgrid-cell{display:table-cell;}.dgrid-header .dojoDndItemBefore{border-left:2px dotted #000 !important;}.dgrid-header .dojoDndItemAfter{border-right:2px dotted #000 !important;}#dgrid-css-extensions-ColumnReorder-loaded{display:none;}",
'url:dgrid/css/extensions/ColumnResizer.css':{"cssText":".dgrid-column-resizer{position:absolute;width:2px;background-color:#666;z-index:1000;}.dgrid-resize-handle{height:100px;width:0;position:absolute;right:-4px;top:-4px;cursor:col-resize;z-index:999;border-left:5px solid transparent;outline:none;}html.has-ie-6 .dgrid-resize-handle{border-color:pink;filter:chroma(color=pink);}html.has-mozilla .dgrid .dgrid-resize-handle:focus,html.has-opera .dgrid .dgrid-resize-handle:focusundefined{outline:none;}.dgrid-resize-header-container{height:100%;}html.has-touch .dgrid-resize-handle{border-left:20px solid transparent;}html.has-touch .dgrid-column-resizer{width:2px;}html.has-no-quirks .dgrid-resize-header-container{position:relative;}html.has-ie-6 .dgrid-resize-header-container{position:static;}.dgrid-header .dgrid-cell-padding{overflow:hidden;}html.has-ie-6 .dgrid-header .dgrid-cell-padding{margin-right:4px;}html.has-ie-6 .dgrid-header .dgrid-sort-arrow{margin-right:0;}html.has-quirks .dgrid-header .dgrid-cell-padding, html.has-ie-6 .dgrid-header .dgrid-cell{position:relative;}#dgrid-css-extensions-ColumnResizer-loaded{display:none;}","xCss":"html.has-mozilla .dgrid .dgrid-resize-handle:{/3};{/2filter:chroma(color=pink);}"},
'url:dgrid/css/extensions/Pagination.css':".dgrid-status{padding:2px;}.dgrid-pagination .dgrid-status{float:left;}.dgrid-pagination .dgrid-navigation, .dgrid-pagination .dgrid-page-size{float:right;}.dgrid-navigation .dgrid-page-link{cursor:pointer;font-weight:bold;text-decoration:none;color:inherit;padding:0 4px;}.dgrid-first, .dgrid-last, .dgrid-next, .dgrid-previous{font-size:130%;}.dgrid-pagination .dgrid-page-disabled,.has-ie-6-7 .dgrid-navigation .dgrid-page-disabled,.has-ie.has-quirks .dgrid-navigation .dgrid-page-disabled{color:#aaa;cursor:default;}.dgrid-page-input{margin-top:1px;width:2em;text-align:center;}.dgrid-page-size{margin:1px 4px 0 4px;}#dgrid-css-extensions-Pagination-loaded{display:none;}",
'url:dojo/resources/dnd.css':{"cssText":".dojoDndAvatar{font-size:75%;color:black;}.dojoDndAvatarHeader td{padding-left:20px;padding-right:4px;height:16px;}.dojoDndAvatarHeader{background:#ccc;}.dojoDndAvatarItem{background:#eee;}.dojoDndMove .dojoDndAvatarHeader{background-image:url(images/dndNoMove.png);background-repeat:no-repeat;}.dojoDndCopy .dojoDndAvatarHeader{background-image:url(images/dndNoCopy.png);background-repeat:no-repeat;}.dojoDndMove .dojoDndAvatarCanDrop .dojoDndAvatarHeader{background-image:url(images/dndMove.png);background-repeat:no-repeat;}.dojoDndCopy .dojoDndAvatarCanDrop .dojoDndAvatarHeader{background-image:url(images/dndCopy.png);background-repeat:no-repeat;}.dojoDndHandle{cursor:move;}.dojoDndIgnore{cursor:default;}.dj_a11y .dojoDndAvatar{font-size:1em;font-weight:bold;}.dj_a11y .dojoDndAvatarHeader td{padding-left:2px !important;}.dj_a11y .dojoDndAvatarHeader td span{padding-right:5px;}","xCss":"{/4background-image:url(images/dndNoMove.png);}{/5background-image:url(images/dndNoCopy.png);}{/6background-image:url(images/dndMove.png);}{/7background-image:url(images/dndCopy.png);}"},
'url:dijit/form/templates/DropDownBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft\"\r\n\tid=\"widget_${id}\"\r\n\trole=\"combobox\"\r\n\taria-haspopup=\"true\"\r\n\tdata-dojo-attach-point=\"_popupStateNode\"\r\n\t><div class='dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton dijitArrowButtonContainer'\r\n\t\tdata-dojo-attach-point=\"_buttonNode\" role=\"presentation\"\r\n\t\t><input class=\"dijitReset dijitInputField dijitArrowButtonInner\" value=\"&#9660; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"button presentation\" aria-hidden=\"true\"\r\n\t\t\t${_buttonInputDisabled}\r\n\t/></div\r\n\t><div class='dijitReset dijitValidationContainer'\r\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\r\n\t/></div\r\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\r\n\t\t><input class='dijitReset dijitInputInner' ${!nameAttrSetting} type=\"text\" autocomplete=\"off\"\r\n\t\t\tdata-dojo-attach-point=\"textbox,focusNode\" role=\"textbox\"\r\n\t/></div\r\n></div>\r\n",
'url:dijit/templates/TooltipDialog.html':"<div role=\"alertdialog\" tabIndex=\"-1\">\r\n\t<div class=\"dijitTooltipContainer\" role=\"presentation\">\r\n\t\t<div data-dojo-attach-point=\"contentsNode\" class=\"dijitTooltipContents dijitTooltipFocusNode\">\r\n\t\t\t<div data-dojo-attach-point=\"containerNode\"></div>\r\n\t\t\t${!actionBarTemplate}\r\n\t\t</div>\r\n\t</div>\r\n\t<div class=\"dijitTooltipConnector\" role=\"presentation\" data-dojo-attach-point=\"connectorNode\"></div>\r\n</div>\r\n",
'url:Sage/UI/Controls/templates/DateTimePicker.html':"<div class=\"dateTimePicker\">\r\n        <div dojoAttachPoint=\"tooltipContainer\">\r\n        \r\n            <div dojoAttachPoint=\"dateContainer\" class=\"dateTimePicker-dateContainer\">\r\n               \r\n                    <input id=\"${id}-Calendar\" data-dojo-type=\"Sage.UI.Calendar\"\r\n                        style=\"width:inherit;\"\r\n                        textAlign=\"${textAlign}\"\r\n                           type=\"text\" \r\n                           tabindex=\"0\"\r\n                           displayMode=\"popup\"\r\n                           dojoAttachPoint=\"dateNode\"\r\n                           dojoAttachEvent=\"onValueSelected:_onValueSelected,onBlur:_onCalendarBlur\">\r\n               \r\n            </div>\r\n            \r\n            <div dojoAttachPoint=\"timeZoneContainer\" class=\"dateTimePicker-timeZoneContainer\">\r\n               \r\n                    <label for=\"${id}-TimeStart\">${timeStartText}</label><br />\r\n                    <input id=\"${id}-TimeTextBox\" data-dojo-type=\"dijit.form.TimeTextBox\" \r\n                           style=\"width:16em;\"\r\n                           textAlign=\"${textAlign}\"\r\n                           tabindex=\"0\"\r\n                           type=\"text\" dojoAttachPoint=\"timeNode\"\r\n                           constraints=\"{locale:Sys.CultureInfo.CurrentCulture.name,timePattern:Sys.CultureInfo.CurrentCulture.dateTimeFormat.ShortTimePattern.replace('tt', 'a').replace('t', 'a')}\">\r\n                    <br /><br/>\r\n                    <label for=\"${id}-TzCalculator\">${timeZoneCalculatorText}</label>\r\n                    <div id=\"timeZoneCalucaltor\" class=\"dateTimePicker-timeZoneCalculator\">\r\n                       <p style=\"width:auto;margin-top:auto\">\r\n                            <label for=\"${id}-TzSelectSource\">${timeZoneSourceText}</label><br />\r\n                            <select id=\"${id}-TzSelectSource\" data-dojo-type=\"dijit.form.ComboBox\"  dojoAttachPoint=\"timeZoneSourceComboNode\" style=\"width:15em;\">\r\n                            </select>\r\n                            <br />\r\n                            <label for=\"${id}-TzSelectDest\">${timeZoneDestText}</label><br />\r\n                           <select id=\"${id}-TzSelectDest\" data-dojo-type=\"dijit.form.ComboBox\"  dojoAttachPoint=\"timeZoneDestComboNode\" style=\"width:15em;\">\r\n                           </select>\r\n                           <br/>\r\n                            <span id=\"${id}-ConvertResults\" dojoAttachPoint=\"convertResultsNode\" style=\"float:left;padding-top:5px;\">\r\n                        </span>\r\n                        </p><br/>\r\n                        <button id=\"${id}-Convert\" data-dojo-type=\"dijit.form.Button\" dojoAttachPoint=\"timeZoneConvertButtonNode\" type=\"button\" style=\"float:right\" dojoAttachEvent=\"onClick:_convertClicked\">\r\n                            ${convertText}\r\n                        </button>\r\n                       \r\n                        \r\n                    </div>\r\n               \r\n                <div class=\"button-bar alignright\" style=\"clear: both\">\r\n                    <button id=\"${id}-OKButton\" tabindex=\"0\" data-dojo-type=\"dijit.form.Button\" dojoAttachPoint=\"OKButtonNode\" type=\"button\" dojoAttachEvent=\"onClick:_okClicked\">\r\n                        ${okText}\r\n                    </button>\r\n                    <button id=\"${id}-CancelButton\" tabindex=\"0\" data-dojo-type=\"dijit.form.Button\" dojoAttachPoint=\"CancelButtonNode\" type=\"button\" dojoAttachEvent=\"onClick:_cancelClicked\">\r\n                        ${cancelText}\r\n                    </button>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        \r\n    \r\n</div>\r\n\r\n",
'url:dijit/templates/MenuItem.html':"<tr class=\"dijitReset\" data-dojo-attach-point=\"focusNode\" role=\"menuitem\" tabIndex=\"-1\">\r\n\t<td class=\"dijitReset dijitMenuItemIconCell\" role=\"presentation\">\r\n\t\t<span role=\"presentation\" class=\"dijitInline dijitIcon dijitMenuItemIcon\" data-dojo-attach-point=\"iconNode\"></span>\r\n\t</td>\r\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" data-dojo-attach-point=\"containerNode,textDirNode\"\r\n\t\trole=\"presentation\"></td>\r\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" data-dojo-attach-point=\"accelKeyNode\"></td>\r\n\t<td class=\"dijitReset dijitMenuArrowCell\" role=\"presentation\">\r\n\t\t<span data-dojo-attach-point=\"arrowWrapper\" style=\"visibility: hidden\">\r\n\t\t\t<span class=\"dijitInline dijitIcon dijitMenuExpand\"></span>\r\n\t\t\t<span class=\"dijitMenuExpandA11y\">+</span>\r\n\t\t</span>\r\n\t</td>\r\n</tr>\r\n",
'url:dijit/templates/CheckedMenuItem.html':"<tr class=\"dijitReset\" data-dojo-attach-point=\"focusNode\" role=\"${role}\" tabIndex=\"-1\" aria-checked=\"${checked}\">\r\n\t<td class=\"dijitReset dijitMenuItemIconCell\" role=\"presentation\">\r\n\t\t<span class=\"dijitInline dijitIcon dijitMenuItemIcon dijitCheckedMenuItemIcon\" data-dojo-attach-point=\"iconNode\"></span>\r\n\t\t<span class=\"dijitMenuItemIconChar dijitCheckedMenuItemIconChar\">${!checkedChar}</span>\r\n\t</td>\r\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" data-dojo-attach-point=\"containerNode,labelNode,textDirNode\"></td>\r\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" data-dojo-attach-point=\"accelKeyNode\"></td>\r\n\t<td class=\"dijitReset dijitMenuArrowCell\" role=\"presentation\">&#160;</td>\r\n</tr>\r\n",
'url:dijit/templates/MenuSeparator.html':"<tr class=\"dijitMenuSeparator\" role=\"separator\">\r\n\t<td class=\"dijitMenuSeparatorIconCell\">\r\n\t\t<div class=\"dijitMenuSeparatorTop\"></div>\r\n\t\t<div class=\"dijitMenuSeparatorBottom\"></div>\r\n\t</td>\r\n\t<td colspan=\"3\" class=\"dijitMenuSeparatorLabelCell\">\r\n\t\t<div class=\"dijitMenuSeparatorTop dijitMenuSeparatorLabel\"></div>\r\n\t\t<div class=\"dijitMenuSeparatorBottom\"></div>\r\n\t</td>\r\n</tr>\r\n",
'url:dijit/templates/TreeNode.html':"<div class=\"dijitTreeNode\" role=\"presentation\"\r\n\t><div data-dojo-attach-point=\"rowNode\" class=\"dijitTreeRow\" role=\"presentation\"\r\n\t\t><span data-dojo-attach-point=\"expandoNode\" class=\"dijitInline dijitTreeExpando\" role=\"presentation\"></span\r\n\t\t><span data-dojo-attach-point=\"expandoNodeText\" class=\"dijitExpandoText\" role=\"presentation\"></span\r\n\t\t><span data-dojo-attach-point=\"contentNode\"\r\n\t\t\tclass=\"dijitTreeContent\" role=\"presentation\">\r\n\t\t\t<span role=\"presentation\" class=\"dijitInline dijitIcon dijitTreeIcon\" data-dojo-attach-point=\"iconNode\"></span\r\n\t\t\t><span data-dojo-attach-point=\"labelNode,focusNode\" class=\"dijitTreeLabel\" role=\"treeitem\"\r\n\t\t\t\t   tabindex=\"-1\" aria-selected=\"false\" id=\"${id}_label\"></span>\r\n\t\t</span\r\n\t></div>\r\n\t<div data-dojo-attach-point=\"containerNode\" class=\"dijitTreeNodeContainer\" role=\"presentation\"\r\n\t\t style=\"display: none;\" aria-labelledby=\"${id}_label\"></div>\r\n</div>\r\n",
'url:dijit/templates/Tree.html':"<div role=\"tree\">\r\n\t<div class=\"dijitInline dijitTreeIndent\" style=\"position: absolute; top: -9999px\" data-dojo-attach-point=\"indentDetector\"></div>\r\n\t<div class=\"dijitTreeExpando dijitTreeExpandoLoading\" data-dojo-attach-point=\"rootLoadingIndicator\"></div>\r\n\t<div data-dojo-attach-point=\"containerNode\" class=\"dijitTreeContainer\" role=\"presentation\">\r\n\t</div>\r\n</div>\r\n",
'url:dijit/form/templates/ComboButton.html':"<table class=\"dijit dijitReset dijitInline dijitLeft\"\r\n\tcellspacing='0' cellpadding='0' role=\"presentation\"\r\n\t><tbody role=\"presentation\"><tr role=\"presentation\"\r\n\t\t><td class=\"dijitReset dijitStretch dijitButtonNode\" data-dojo-attach-point=\"buttonNode\" data-dojo-attach-event=\"ondijitclick:__onClick,onkeydown:_onButtonKeyDown\"\r\n\t\t><div id=\"${id}_button\" class=\"dijitReset dijitButtonContents\"\r\n\t\t\tdata-dojo-attach-point=\"titleNode\"\r\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\r\n\t\t\t><div class=\"dijitReset dijitInline dijitIcon\" data-dojo-attach-point=\"iconNode\" role=\"presentation\"></div\r\n\t\t\t><div class=\"dijitReset dijitInline dijitButtonText circleLayout circleTheme\" id=\"${id}_label\" data-dojo-attach-point=\"containerNode\" role=\"presentation\"></div\r\n\t\t></div\r\n\t\t></td\r\n\t\t><td id=\"${id}_arrow\" class='dijitReset dijitRight dijitButtonNode dijitArrowButton'\r\n\t\t\tdata-dojo-attach-point=\"_popupStateNode,focusNode,_buttonNode\"\r\n\t\t\tdata-dojo-attach-event=\"onkeydown:_onArrowKeyDown\"\r\n\t\t\ttitle=\"${optionsTitle}\"\r\n\t\t\trole=\"button\" aria-haspopup=\"true\"\r\n\t\t\t><div class=\"dijitReset dijitArrowButtonInner\" role=\"presentation\"></div\r\n\t\t\t><div class=\"dijitReset dijitArrowButtonChar\" role=\"presentation\">&#9660;</div\r\n\t\t></td\r\n\t\t><td style=\"display:none !important;\"\r\n\t\t\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" data-dojo-attach-point=\"valueNode\"\r\n\t\t\t\tclass=\"dijitOffScreen\"\r\n\t\t\t\trole=\"presentation\" aria-hidden=\"true\"\r\n\t\t\t\tdata-dojo-attach-event=\"onclick:_onClick\"\r\n\t\t/></td></tr></tbody\r\n></table>\r\n",
'url:dijit/layout/templates/TabContainer.html':"<div class=\"dijitTabContainer\">\r\n\t<div class=\"dijitTabListWrapper\" data-dojo-attach-point=\"tablistNode\"></div>\r\n\t<div data-dojo-attach-point=\"tablistSpacer\" class=\"dijitTabSpacer ${baseClass}-spacer\"></div>\r\n\t<div class=\"dijitTabPaneWrapper ${baseClass}-container\" data-dojo-attach-point=\"containerNode\"></div>\r\n</div>\r\n",
'url:dijit/templates/Menu.html':"<table class=\"dijit dijitMenu dijitMenuPassive dijitReset dijitMenuTable\" role=\"menu\" tabIndex=\"${tabIndex}\"\r\n\t   cellspacing=\"0\">\r\n\t<tbody class=\"dijitReset\" data-dojo-attach-point=\"containerNode\"></tbody>\r\n</table>\r\n",
'url:dijit/layout/templates/_TabButton.html':"<div role=\"presentation\" data-dojo-attach-point=\"titleNode,innerDiv,tabContent\" class=\"dijitTabInner dijitTabContent\">\r\n\t<span role=\"presentation\" class=\"dijitInline dijitIcon dijitTabButtonIcon\" data-dojo-attach-point=\"iconNode\"></span>\r\n\t<span data-dojo-attach-point='containerNode,focusNode' class='tabLabel'></span>\r\n\t<span class=\"dijitInline dijitTabCloseButton dijitTabCloseIcon\" data-dojo-attach-point='closeNode'\r\n\t\t  role=\"presentation\">\r\n\t\t<span data-dojo-attach-point='closeText' class='dijitTabCloseText'>[x]</span\r\n\t\t\t\t></span>\r\n</div>\r\n",
'url:dijit/layout/templates/ScrollingTabController.html':"<div class=\"dijitTabListContainer-${tabPosition}\" style=\"visibility:hidden\">\r\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerMenuButton\"\r\n\t\t class=\"tabStripButton-${tabPosition}\"\r\n\t\t id=\"${id}_menuBtn\"\r\n\t\t data-dojo-props=\"containerId: '${containerId}', iconClass: 'dijitTabStripMenuIcon',\r\n\t\t\t\t\tdropDownPosition: ['below-alt', 'above-alt']\"\r\n\t\t data-dojo-attach-point=\"_menuBtn\" showLabel=\"false\" title=\"\">&#9660;</div>\r\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerButton\"\r\n\t\t class=\"tabStripButton-${tabPosition}\"\r\n\t\t id=\"${id}_leftBtn\"\r\n\t\t data-dojo-props=\"iconClass:'dijitTabStripSlideLeftIcon', showLabel:false, title:''\"\r\n\t\t data-dojo-attach-point=\"_leftBtn\" data-dojo-attach-event=\"onClick: doSlideLeft\">&#9664;</div>\r\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerButton\"\r\n\t\t class=\"tabStripButton-${tabPosition}\"\r\n\t\t id=\"${id}_rightBtn\"\r\n\t\t data-dojo-props=\"iconClass:'dijitTabStripSlideRightIcon', showLabel:false, title:''\"\r\n\t\t data-dojo-attach-point=\"_rightBtn\" data-dojo-attach-event=\"onClick: doSlideRight\">&#9654;</div>\r\n\t<div class='dijitTabListWrapper' data-dojo-attach-point='tablistWrapper'>\r\n\t\t<div role='tablist' data-dojo-attach-event='onkeydown:onkeydown'\r\n\t\t\t data-dojo-attach-point='containerNode' class='nowrapTabStrip'></div>\r\n\t</div>\r\n</div>",
'url:dijit/layout/templates/_ScrollingTabControllerButton.html':"<div data-dojo-attach-event=\"ondijitclick:_onClick\" class=\"dijitTabInnerDiv dijitTabContent dijitButtonContents\"  data-dojo-attach-point=\"focusNode\" role=\"button\">\r\n\t<span role=\"presentation\" class=\"dijitInline dijitTabStripIcon\" data-dojo-attach-point=\"iconNode\"></span>\r\n\t<span data-dojo-attach-point=\"containerNode,titleNode\" class=\"dijitButtonText\"></span>\r\n</div>",
'url:dojox/grid/resources/View.html':"<div class=\"dojoxGridView\" role=\"presentation\">\r\n\t<div class=\"dojoxGridHeader\" dojoAttachPoint=\"headerNode\" role=\"presentation\">\r\n\t\t<div dojoAttachPoint=\"headerNodeContainer\" style=\"width:9000em\" role=\"presentation\">\r\n\t\t\t<div dojoAttachPoint=\"headerContentNode\" role=\"row\"></div>\r\n\t\t</div>\r\n\t</div>\r\n\t<input type=\"checkbox\" class=\"dojoxGridHiddenFocus\" dojoAttachPoint=\"hiddenFocusNode\" role=\"presentation\" />\r\n\t<input type=\"checkbox\" class=\"dojoxGridHiddenFocus\" role=\"presentation\" />\r\n\t<div class=\"dojoxGridScrollbox\" dojoAttachPoint=\"scrollboxNode\" role=\"presentation\">\r\n\t\t<div class=\"dojoxGridContent\" dojoAttachPoint=\"contentNode\" hidefocus=\"hidefocus\" role=\"presentation\"></div>\r\n\t</div>\r\n</div>\r\n",
'url:dojox/grid/resources/_Grid.html':"<div hidefocus=\"hidefocus\" role=\"grid\" dojoAttachEvent=\"onmouseout:_mouseOut\">\r\n\t<div class=\"dojoxGridMasterHeader\" dojoAttachPoint=\"viewsHeaderNode\" role=\"presentation\"></div>\r\n\t<div class=\"dojoxGridMasterView\" dojoAttachPoint=\"viewsNode\" role=\"presentation\"></div>\r\n\t<div class=\"dojoxGridMasterMessages\" style=\"display: none;\" dojoAttachPoint=\"messagesNode\"></div>\r\n\t<span dojoAttachPoint=\"lastFocusNode\" tabindex=\"0\"></span>\r\n</div>\r\n",
'url:dijit/form/templates/Select.html':"<table class=\"dijit dijitReset dijitInline dijitLeft\"\r\n\tdata-dojo-attach-point=\"_buttonNode,tableNode,focusNode,_popupStateNode\" cellspacing='0' cellpadding='0'\r\n\trole=\"listbox\" aria-haspopup=\"true\"\r\n\t><tbody role=\"presentation\"><tr role=\"presentation\"\r\n\t\t><td class=\"dijitReset dijitStretch dijitButtonContents\" role=\"presentation\"\r\n\t\t\t><div class=\"dijitReset dijitInputField dijitButtonText\"  data-dojo-attach-point=\"containerNode,textDirNode\" role=\"presentation\"></div\r\n\t\t\t><div class=\"dijitReset dijitValidationContainer\"\r\n\t\t\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\r\n\t\t\t/></div\r\n\t\t\t><input type=\"hidden\" ${!nameAttrSetting} data-dojo-attach-point=\"valueNode\" value=\"${value}\" aria-hidden=\"true\"\r\n\t\t/></td\r\n\t\t><td class=\"dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton dijitArrowButtonContainer\"\r\n\t\t\tdata-dojo-attach-point=\"titleNode\" role=\"presentation\"\r\n\t\t\t><input class=\"dijitReset dijitInputField dijitArrowButtonInner\" value=\"&#9660; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\r\n\t\t\t\t${_buttonInputDisabled}\r\n\t\t/></td\r\n\t></tr></tbody\r\n></table>\r\n",
'url:dojox/form/resources/Uploader.html':"<span class=\"dijit dijitReset dijitInline\"\r\n\t><span class=\"dijitReset dijitInline dijitButtonNode\"\r\n\t\tdata-dojo-attach-event=\"ondijitclick:_onClick\"\r\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\r\n\t\t\tdata-dojo-attach-point=\"titleNode,focusNode\"\r\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\r\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\" data-dojo-attach-point=\"iconNode\"></span\r\n\t\t\t><span class=\"dijitReset dijitToggleButtonIconChar\">&#x25CF;</span\r\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\r\n\t\t\t\tid=\"${id}_label\"\r\n\t\t\t\tdata-dojo-attach-point=\"containerNode\"\r\n\t\t\t></span\r\n\t\t></span\r\n\t></span\r\n\t> \r\n\t<input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\" tabIndex=\"-1\" data-dojo-attach-point=\"valueNode\" />\r\n</span>\r\n",
'url:dijit/form/templates/CheckBox.html':"<div class=\"dijit dijitReset dijitInline\" role=\"presentation\"\r\n\t><input\r\n\t \t${!nameAttrSetting} type=\"${type}\" role=\"${type}\" aria-checked=\"false\" ${checkedAttrSetting}\r\n\t\tclass=\"dijitReset dijitCheckBoxInput\"\r\n\t\tdata-dojo-attach-point=\"focusNode\"\r\n\t \tdata-dojo-attach-event=\"ondijitclick:_onClick\"\r\n/></div>\r\n",
'url:Sage/templates/ImageButton.html':"<span id=\"${id}\" class=\"dijit dijitReset dijitInline\" role=\"presentation\">\r\n<span class=\"dijitReset dijitInline dijitButtonNode imageButtonNode\" data-dojo-attach-event=\"ondijitclick:_onClick\" role=\"presentation\">\r\n        <span class=\"dijitReset dijitStretch dijitButtonContents\"\r\n\t\t\tdata-dojo-attach-point=\"titleNode,focusNode\"\r\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\r\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\">\r\n                <img alt=\"\" src=\"\" data-dojo-attach-point=\"iconNode\"/>\r\n                <div class=\"dijitIcon dijitMenuItemIcon Global_Images icon16x16 ${imageClass}\" data-dojo-attach-point=\"iconNodeSprite\"></div>\r\n            </span\r\n\t\t\t><span class=\"dijitReset dijitToggleButtonIconChar\">&#x25CF;</span\r\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText circleLayout circleTheme\"\r\n\t\t\t\tid=\"${id}_label\"\r\n\t\t\t\tdata-dojo-attach-point=\"containerNode\"\r\n\t\t\t></span\r\n\t\t></span\r\n\t></span\r\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\"\r\n\t\ttabIndex=\"-1\" role=\"presentation\" data-dojo-attach-point=\"valueNode\"\r/></span>\r\r\n",
'url:Sage/UI/Controls/templates/DropDownSelectPickList.html':"<div>\r\n    <select id=\"${id}-Select\" data-dojo-type=\"Sage.UI.ComboBox\" shouldPublishMarkDirty=\"false\" dojoAttachPoint=\"comboBox\" value=\"${value}\" dojoAttachEvent=\"onBlur: _onBlur,onChange:_onChange\">\r\n    </select>\r\n</div>\r\n",
'url:Sage/UI/Controls/templates/DropDownSelectUser.html':"<div>\r\n    <select data-dojo-type=\"Sage.UI.ComboBox\" shouldPublishMarkDirty=\"false\" dojoAttachPoint=\"comboBox\" dojoAttachEvent=\"onBlur: _onBlur\">\r\n    </select>\r\n</div>\r\n",
'url:Sage/Utility/File/templates/FallbackFilePicker_Attachment.html':"[\r\n'<div>',\r\n    '<div dojoType=\"dijit.Dialog\" id=\"uploadFileDialog\" title=\"{%= $.attachFileText %}\" dojoAttachPoint=\"_dialog\" dojoAttachEvent=\"onHide:_onHide\">',\r\n        '<iframe src=\"about:blank\" style=\"width:0px;height:0px;border-width:0px;\" name=\"{%= $._iframeId %}\" id=\"{%= $._iframeId %}\" dojoAttachPoint=\"_iframe\" dojoAttachEvent=\"onload:_iframeLoad\"></iframe>',\r\n        '<form method=\"post\" enctype=\"multipart/form-data\" action=\"{%= $._buildPostUrl() %}\" target=\"{%= $._iframeId %}\" dojoAttachPoint=\"_postForm\" class=\"attachment-properties-form\">',\r\n            '<div dojoType=\"dojox.layout.TableContainer\" orientation=\"horiz\" cols=\"1\" labelWidth=\"160\">',\r\n                '<div data-dojo-type=\"dijit.layout.ContentPane\" label=\"{%= $.uploadFileText %}\" >',\r\n                    '<input name=\"file\" multiple=\"false\" type=\"file\" dojoAttachEvent=\"onchange:_onNewFile\" dojoAttachPoint=\"btn_FileSelect\" class=\"uploadButton\" />',\r\n                '</div>',\r\n                 '<div dojoType=\"dijit.form.TextBox\" label=\"{%= $.descriptionText %}\" name=\"description\" id=\"{%= $.id %}_tb_Description\" dojoAttachPoint=\"tb_Description\" maxlength=\"128\" ></div>',\r\n                 '<input type=\"hidden\" dojoType=\"dijit.form.TextBox\" name=\"fileName\" id=\"{%= $.id %}_tb_realFileName\" dojoAttachPoint=\"tb_realFileName\" maxlength=\"255\" />',\r\n            '</div>',\r\n            '<div class=\"general-dialog-actions\" align=\"right\">',\r\n                '<div data-dojo-type=\"dijit.form.Button\" id=\"{%= $.id %}_btn_OK\" name=\"btn_OK\" dojoAttachPoint=\"btn_OK\" dojoAttachEvent=\"onClick:_okClick\">{%= $.okText %}</div>',\r\n                '<span>&nbsp;&nbsp</span>',\r\n                '<div data-dojo-type=\"dijit.form.Button\" id=\"{%= $.id %}_btn_Cancel\" name=\"btn_Cancel\" dojoAttachPoint=\"btn_Cancel\" dojoAttachEvent=\"onClick:_cancelClick\">{%= $.cancelText %}</div>',\r\n            '</div>',\r\n            '<input type=\"hidden\" name=\"dataType\" value=\"R\" />',\r\n            '<input type=\"hidden\" name=\"attachDate\" dojoAttachPoint=\"_attachDate\"/>',\r\n            '<input type=\"hidden\" name=\"accountId\" dojoAttachPoint=\"_accountId\"/>',\r\n            '<input type=\"hidden\" name=\"activityId\" dojoAttachPoint=\"_activityId\" />',\r\n            '<input type=\"hidden\" name=\"contactId\" dojoAttachPoint=\"_contactId\" />',\r\n            '<input type=\"hidden\" name=\"contractId\" dojoAttachPoint=\"_contractId\" />',\r\n            '<input type=\"hidden\" name=\"defectId\" dojoAttachPoint=\"_defectId\" />',\r\n            '<input type=\"hidden\" name=\"historyId\" dojoAttachPoint=\"_historyId\" />',\r\n            '<input type=\"hidden\" name=\"leadId\" dojoAttachPoint=\"_leadId\" />',\r\n            '<input type=\"hidden\" name=\"opportunityId\" dojoAttachPoint=\"_opportunityId\" />',\r\n            '<input type=\"hidden\" name=\"productId\" dojoAttachPoint=\"_productId\" />',\r\n            '<input type=\"hidden\" name=\"returnId\" dojoAttachPoint=\"_returnId\" />',\r\n            '<input type=\"hidden\" name=\"salesOrderId\" dojoAttachPoint=\"_salesOrderId\" />',\r\n            '<input type=\"hidden\" name=\"ticketId\" dojoAttachPoint=\"_ticketId\" />',\r\n            '<input type=\"hidden\" name=\"userId\" dojoAttachPoint=\"_userId\" />',\r\n        '</form>',\r\n    '</div>',\r\n'</div>'\r\n]",
'url:Sage/Utility/File/templates/FallbackFilePicker_LibraryDoc.html':"[\r\n'<div>',\r\n    '<div dojoType=\"dijit.Dialog\" id=\"uploadFileDialog\" title=\"{%= $.addLibraryFileText %}\" dojoAttachPoint=\"_dialog\" dojoAttachEvent=\"onHide:_onHide\">',\r\n        '<iframe src=\"about:blank\" style=\"width:0px;height:0px;border-width:0px;\" name=\"{%= $._iframeId %}\" id=\"{%= $._iframeId %}\" dojoAttachPoint=\"_iframe\" dojoAttachEvent=\"onload:_iframeLoad\"></iframe>',\r\n        '<form method=\"post\" enctype=\"multipart/form-data\" action=\"\" target=\"{%= $._iframeId %}\" dojoAttachPoint=\"_postForm\" class=\"attachment-properties-form\">',\r\n            '<div dojoType=\"dojox.layout.TableContainer\" orientation=\"horiz\" cols=\"1\" labelWidth=\"160\">',\r\n                 '<div data-dojo-type=\"dijit.layout.ContentPane\" label=\"{%= $.uploadFileText %}\" >',\r\n                    '<input name=\"file\" multiple=\"false\" type=\"file\" dojoAttachEvent=\"onchange:_onNewFile\" dojoAttachPoint=\"btn_FileSelect\" class=\"uploadButton\" />',\r\n                 '</div>',\r\n                 '<div dojoType=\"dijit.form.TextBox\" label=\"{%= $.descriptionText %}\" name=\"description\" id=\"{%= $.id %}_tb_Description\" dojoAttachPoint=\"tb_Description\" maxlength=\"255\" ></div>',\r\n                 '<input type=\"hidden\" dojoType=\"dijit.form.TextBox\" name=\"fileName\" id=\"{%= $.id %}_tb_realFileName\" dojoAttachPoint=\"tb_realFileName\" maxlength=\"255\" />',\r\n            '</div>',\r\n            '<div class=\"general-dialog-actions\" align=\"right\">',\r\n                '<div data-dojo-type=\"dijit.form.Button\" id=\"{%= $.id %}_btn_OK\" name=\"btn_OK\" dojoAttachPoint=\"btn_OK\" dojoAttachEvent=\"onClick:_okClick\">{%= $.okText %}</div>',\r\n                '<span>&nbsp;&nbsp</span>',\r\n                '<div data-dojo-type=\"dijit.form.Button\" id=\"{%= $.id %}_btn_Cancel\" name=\"btn_Cancel\" dojoAttachPoint=\"btn_Cancel\" dojoAttachEvent=\"onClick:_cancelClick\">{%= $.cancelText %}</div>',\r\n            '</div>',\r\n        '</form>',\r\n    '</div>',\r\n'</div>'\r\n]",
'url:Sage/UI/templates/GridView.html':"[\r\n'<div data-dojo-type=\"dijit.layout.ContentPane\" class=\"HundredPercentHeight abstractGrid\" >',\r\n    '<div data-dojo-attach-point=\"headerNode\" class=\"list-panel-tbar\" role=\"toolbar\">',\r\n        '<span dojoattachpoint=\"labelSection\"></span>',\r\n        '<span dojoattachpoint=\"abstractGrid_toolBar\" class=\"right-tools\"></span>',\r\n    '</div>',\r\n    '<div dojoattachpoint=\"abstractGrid_filters\"></div>',\r\n    '<div dojoattachpoint=\"abstractGrid_grid\" class=\"gridcontainer\"></div>',\r\n'</div>'\r\n]",
'url:Sage/UI/Controls/templates/Lookup.html':"<div class=\"textcontrol lookup\">\r\n    <span id=\"${id}\" class=\"lookup\">\r\n        <input id=\"${id}_LookupText\" class=\"text-with-icons\" required=\"${required}\" type=\"text\" dojoAttachPoint=\"textbox,focusNode\" />\r\n        <a href=\"#\">\r\n            <img id=\"${id}_LookupBtn\" src=\"images/icons/Find_16x16.png\" dojoAttachPoint=\"lookupButton\" alt=\"${buttonToolTip}\" title=\"${buttonToolTip}\" />\r\n        </a>\r\n        \r\n        <img id=\"${id}_btnClearResult\" src=\"images/icons/Delete_16x16.png\" dojoAttachPoint=\"clearButton\" class=\"display-none\" alt=\"${closeButtonToolTip}\" title=\"${closeButtonToolTip}\"/>\r\n    </span>\r\n</div>",
'url:Sage/MainView/ActivityMgr/templates/ActivityEditor.html':"[\r\n'<div>',\r\n    '<div dojoType=\"dijit.Dialog\" id=\"activityDialog\" title=\"\" dojoAttachPoint=\"_dialog\" dojoAttachEvent=\"onHide:_onDlgHide\">',\r\n        '<div class=\"activity-dialog\">',  //body\r\n            '<div dojoType=\"dojox.layout.TableContainer\" orientation=\"horiz\" cols=\"1\" labelWidth=\"{%= $.labelWidth %}\" dojoAttachPoint=\"regardingContainer\">',\r\n                '<select id=\"pk_Regarding\" label=\"{%= $.regardingText %}\" id=\"{%= $.id %}_pk_Regarding\" shouldPublishMarkDirty=\"false\" dojoType=\"Sage.UI.Controls.SingleSelectPickList\" dojoAttachPoint=\"pk_Regarding\" canEditText=\"true\" itemMustExist=\"false\" maxLength=\"255\"></select>',          \r\n    '<div dojoType=\"dijit.form.TextBox\" label=\"{%= $.locationText %}\" id=\"{%= $.id %}_tb_Location\" dojoAttachPoint=\"tb_Location\" maxLength=\"255\" ></div>',\r\n            '</div>', //first tablecontainer 1 col\r\n        //Dates section for add/edit mode..................\r\n            '<div dojoType=\"dojox.layout.TableContainer\" orientation=\"horiz\" cols=\"2\" labelWidth=\"{%= $.labelWidth %}\" dojoAttachPoint=\"dateSection_AddEdit\">',\r\n                '<div shouldPublishMarkDirty=\"false\" dojoType=\"Sage.UI.Controls.DateTimePicker\" id=\"{%= $.id %}_dtp_startDate\" dojoAttachPoint=\"dtp_startDate\" displayDate=\"true\" displayTime=\"true\" label=\"{%= $.startTimeText %}\"></div>',\r\n                '<div shouldPublishMarkDirty=\"false\" dojoType=\"Sage.UI.Controls.DurationSelect\" label=\"{%= $.durationText %}\" id=\"{%= $.id %}_sel_Duration\" dojoAttachPoint=\"sel_Duration\" includeDisablingCheckbox=\"false\" valuesAreAfterStart=\"true\"></div>',\r\n                '<div dojoType=\"dijit.layout.ContentPane\" label=\"\" class=\"remove-padding\">',\r\n                    '<div dojoType=\"dijit.form.CheckBox\" label=\"{%= $.timeLessText %}\" id=\"{%= $.id %}_cb_Timeless\" dojoAttachPoint=\"cb_Timeless\" ></div>',\r\n                    '<label class=\"checkbox-label\" for=\"{%= $.id %}_cb_Timeless\">{%= $.timeLessText %}</label>',\r\n                '</div>',\r\n                '<div dojoType=\"dojox.layout.TableContainer\" label=\"{%= $.alarmText %}\" cols=\"2\" showLabels=\"false\" class=\"removeExtraSpace\" dojoAttachPoint=\"alarmContainer\">',\r\n                    '<div dojoType=\"dijit.form.CheckBox\" id=\"{%= $.id %}_cb_Alarm\" dojoAttachPoint=\"cb_Alarm\" ></div>',\r\n                    '<div shouldPublishMarkDirty=\"false\" dojoType=\"Sage.UI.Controls.DurationSelect\" id=\"{%= $.id %}_sel_AlarmDur\" dojoAttachPoint=\"sel_AlarmDur\" valuesAreAfterStart=\"false\" ></div>',\r\n                '</div>',\r\n                '<div dojoType=\"dijit.layout.ContentPane\" label=\"\" class=\"remove-padding\">',\r\n                    '<div dojoType=\"dijit.form.CheckBox\" label=\"\" id=\"{%= $.id %}_cb_AutoRollover\" dojoAttachPoint=\"cb_AutoRollover\"></div>',\r\n                    '<label class=\"checkbox-label\" for=\"{%= $.id %}_cb_AutoRollover\">{%= $.rolloverText %}</label>',\r\n                '</div>',\r\n            '</div>',\r\n        //Dates section for complete mode...................\r\n            '<div dojoType=\"dojox.layout.TableContainer\" orientation=\"horiz\" cols=\"2\" labelWidth=\"{%= $.labelWidth %}\" dojoAttachPoint=\"dateSection_Complete\">',\r\n                '<div shouldPublishMarkDirty=\"false\" dojoType=\"Sage.UI.Controls.DateTimePicker\" id=\"{%= $.id %}_dtp_completedDate\" dojoAttachPoint=\"dtp_completedDate\" displayDate=\"true\" displayTime=\"true\" label=\"{%= $.completedText %}\"></div>',\r\n                '<div shouldPublishMarkDirty=\"false\" dojoType=\"Sage.UI.Controls.DateTimePicker\" id=\"{%= $.id %}_dtp_scheduledDate\" dojoAttachPoint=\"dtp_scheduledDate\" displayDate=\"true\" displayTime=\"true\" label=\"{%= $.scheduledText %}\"></div>',\r\n                '<div dojoType=\"dijit.layout.ContentPane\" label=\"\" class=\"remove-padding\">',\r\n                    '<div dojoType=\"dijit.form.CheckBox\" label=\"{%= $.timeLessText %}\" id=\"{%= $.id %}_cb_TimelessComplete\" dojoAttachPoint=\"cb_TimelessComplete\" ></div>',\r\n                    '<label class=\"checkbox-label\" for=\"{%= $.id %}_cb_TimelessComplete\">{%= $.timeLessText %}</label>',\r\n                '</div>',\r\n                '<div shouldPublishMarkDirty=\"false\" dojoType=\"Sage.UI.Controls.DurationSelect\" label=\"{%= $.durationText %}\" id=\"{%= $.id %}_sel_DurationComplete\" dojoAttachPoint=\"sel_DurationComplete\" includeDisablingCheckbox=\"false\" valuesAreAfterStart=\"true\"></div>',\r\n            '</div>',\r\n\r\n            '<div dojoType=\"dijit.layout.TabContainer\" id=\"{%= $.id %}_tc_EditActivity\"  dojoAttachPoint=\"tc_EditActivity\" class=\"tab-container\" doLayout=\"false\">',\r\n/*  General Tab   */\r\n                '<div dojoType=\"dijit.layout.ContentPane\" id=\"{%= $.id %}_cp_General\" title=\"{%= $.tabNameGeneralText %}\" class=\"tabContent remove-padding\" dojoAttachPoint=\"cp_General\">',\r\n                    '<div dojoType=\"dojox.layout.TableContainer\" orientation=\"horiz\" cols=\"1\" labelWidth=\"{%= $.labelWidth %}\" dojoAttachPoint=\"resultContainer\" class=\"bottom-border-section add-padding\">', \r\n                        '<select shouldPublishMarkDirty=\"false\" dojoType=\"Sage.UI.Controls.SingleSelectPickList\" label=\"{%= $.resultText %}\" id=\"{%= $.id %}_pl_Result\"  name=\"pl_Result\" dojoAttachPoint=\"pl_Result\" canEditText=\"true\" itemMustExist=\"false\" maxLength=\"64\"></select>',\r\n                    '</div>',\r\n                    '<div dojoType=\"dojox.layout.TableContainer\" orientation=\"horiz\" cols=\"4\" labelWidth=\"70\" baseClass=\"contact-lead-radios\" >',\r\n                        '<input dojoType=\"dijit.form.RadioButton\" type=\"radio\" name=\"contactOrLead\" label=\"{%= $.contactText %}\" value=\"contact\" id=\"{%= $.id %}_rdo_Contact\" dojoAttachPoint=\"rdo_Contact\" dojoAttachEvent=\"onChange:_setContactLeadVisibility\" checked=\"true\" />',\r\n                        '<input dojoType=\"dijit.form.RadioButton\" type=\"radio\" name=\"contactOrLead\" label=\"{%= $.leadText %}\" value=\"lead\" id=\"{%= $.id %}_rdo_Lead\" dojoAttachPoint=\"rdo_Lead\" />',\r\n                    '</div>',\r\n                    '<div dojoType=\"dojox.layout.TableContainer\" orientation=\"horiz\" cols=\"2\" labelWidth=\"{%= $.labelWidth %}\" dojoAttachPoint=\"contactContainer\" baseClass=\"bottom-border-section\">',\r\n\r\n                        '<div dojoType=\"dijit.layout.ContentPane\" label=\"{%= $.nameText %}\" dojoAttachPoint=\"container_ContactLup\" class=\"remove-padding lookup-container\"></div>',\r\n                        '<div dojoType=\"dijit.layout.ContentPane\" label=\"{%= $.opportunityText %}\" dojoAttachPoint=\"container_OppLup\" class=\"remove-padding lookup-container\"></div>',\r\n                        '<div dojoType=\"dijit.layout.ContentPane\" label=\"{%= $.accountText %}\" dojoAttachPoint=\"container_AccountLup\"  class=\"remove-padding lookup-container\"></div>',\r\n                        '<div dojoType=\"dijit.layout.ContentPane\" label=\"{%= $.ticketText %}\" dojoAttachPoint=\"container_TicketLup\"  class=\"remove-padding lookup-container\"></div>',\r\n                    '</div>',\r\n                    '<div dojoType=\"dojox.layout.TableContainer\" orientation=\"horiz\" cols=\"2\" labelWidth=\"{%= $.labelWidth %}\" dojoAttachPoint=\"leadContainer\"  baseClass=\"bottom-border-section\" class=\"display-none\">',\r\n                        '<div dojoType=\"dijit.layout.ContentPane\" label=\"{%= $.nameText %}\" dojoAttachPoint=\"container_LeadLup\"  class=\"remove-padding lookup-container\"></div>',\r\n                        '<input dojoType=\"dijit.form.TextBox\" id=\"{%= $.id %}_tb_LeadCompanyName\" label=\"{%= $.companyText %}\" dojoAttachPoint=\"tb_LeadCompanyName\" readonly=\"true\" />',\r\n                    '</div>',\r\n                    '<div dojoType=\"dojox.layout.TableContainer\" orientation=\"horiz\" cols=\"2\" labelWidth=\"{%= $.labelWidth %}\" class=\"bottom-border-section\" dojoAttachPoint=\"categoryContainer\" >',\r\n                        '<select label=\"{%= $.priorityText %}\" id=\"{%= $.id %}_pk_Priority\" shouldPublishMarkDirty=\"false\" dojoType=\"Sage.UI.Controls.SingleSelectPickList\" dojoAttachPoint=\"pk_Priority\" canEditText=\"true\" itemMustExist=\"false\" pickListName=\"Priorities\" sort=\"false\" maxLength=\"64\" style=\"width: {%= 472 - $.labelWidth %}px;\" ></select>',\r\n                        '<div dojoType=\"dijit.layout.ContentPane\" label=\"{%= $.leaderText %}\" dojoAttachPoint=\"container_LeaderLup\" class=\"remove-padding lookup-container\" style=\"width: {%= 472 - $.labelWidth %}px;\"></div>',\r\n                        '<select label=\"{%= $.categoryText %}\" id=\"{%= $.id %}_pk_Category\" shouldPublishMarkDirty=\"false\" dojoType=\"Sage.UI.Controls.SingleSelectPickList\" dojoAttachPoint=\"pk_Category\" canEditText=\"true\" itemMustExist=\"false\" maxLength=\"64\" style=\"width: {%= 472 - $.labelWidth %}px;\"></select>',\r\n                        '<div dojoType=\"dijit.layout.ContentPane\" label=\"&nbsp;\" class=\"dijitTextBox\" style=\"border-width:0px\">&nbsp;</div>',\r\n                    '</div>',\r\n                    '<div dojoType=\"dojox.layout.TableContainer\" orientation=\"horiz\" cols=\"1\" labelWidth=\"{%= $.labelWidth %}\" class=\"valigntop\" dojoAttachPoint=\"notesContainer\">',\r\n                        '<textarea dojoType=\"dijit.form.SimpleTextarea\" id=\"{%= $.id %}_ta_Notes\" label=\"{%= $.notesText %}\" dojoAttachPoint=\"ta_Notes\" class=\"notes-text\"></textarea>',\r\n                    '</div>',\r\n                '</div>',  // end general tab\r\n/* Availability Tab   */\r\n                '<div dojoType=\"dijit.layout.ContentPane\" id=\"{%= $.id %}_cp_Availability\" title=\"{%= $.tabNameAvailabilityText %}\" class=\"tabContent remove-padding\" dojoAttachPoint=\"cp_Availability\" dojoAttachEvent=\"onShow:_onShowAvailabilityTab\">',\r\n                    '<div dojoType=\"dijit.Toolbar\" region=\"top\" splitter=\"false\" class=\"right-tools\" >',  // list-panel-tbar\r\n                        '<div dojoType=\"dijit.layout.ContentPane\" dojoAttachPoint=\"container_ResourcesLup\" class=\"remove-padding\"></div>',\r\n                    '</div>',\r\n/* Scheduler ........... */\r\n                    '<div id=\"scheduler_here\" class=\"dhx_cal_container\" style=\"width:100%;height:230px;\">',\r\n                        '<div class=\"dhx_cal_navline\">',\r\n                            '<div class=\"dhx_cal_prev_timeline_button\" style=\"right:50px;\">&nbsp;</div>',\r\n\t\t\t                '<div class=\"dhx_cal_next_timeline_button\" style=\"right:19px;\">&nbsp;</div>',\r\n//'<div class=\"dhx_cal_today_button\"></div>',\r\n\t\t\t                '<div class=\"dhx_cal_date\"></div>',\r\n//'<div class=\"dhx_cal_tab\" name=\"day_tab\" style=\"right:204px;\"></div>',\r\n//'<div class=\"dhx_cal_tab\" name=\"week_tab\" style=\"right:140px;\"></div>',\r\n                            '<div class=\"dhx_cal_tab\" name=\"timeline_tab\" style=\"right:280px;\"></div>',\r\n//'<div class=\"dhx_cal_tab\" name=\"month_tab\" style=\"right:76px;\"></div>',\r\n\t\t                '</div>',\r\n\t\t                '<div class=\"dhx_cal_header\"></div>',\r\n\t\t                '<div class=\"dhx_cal_data\"></div>',\r\n                    '</div>',\r\n                '</div>',\r\n/* Recurring Tab  */\r\n                '<div dojoType=\"dijit.layout.ContentPane\" id=\"{%= $.id %}_cp_Recurring\" title=\"{%= $.recurringText %}\" class=\"tabContent\" dojoAttachPoint=\"cp_Recurring\" dojoAttachEvent=\"onShow:_showRecurringTab\">',\r\n                    '<div shouldPublishMarkDirty=\"false\" dojoType=\"Sage.MainView.ActivityMgr.RecurringEditor\" id=\"{%= $.id %}_recEd\" labelWidth=\"{%= $.labelWidth - 20 %}\" dojoAttachPoint=\"_recurringEditor\"></div>',\r\n                '</div>',\r\n/* Attachments Tab  */\r\n                '<div dojoType=\"dijit.layout.ContentPane\" id=\"{%= $.id %}_cp_Attachments\" title=\"{%= $.tabNameAttachmentsText %}\" class=\"tabContent remove-padding\" dojoAttachPoint=\"cp_Attachments\">',\r\n                    '<div id=\"{%= $.id %}_attachmentsGridPlaceholder\" dojoAttachPoint=\"_attachmentGridPlaceholder\" style=\"width:100%;height:100%;\" ></div>',\r\n                '</div>',  //end attachments tab\r\n            '</div>',  //tab container\r\n/* Buttons       */\r\n        // Add/edit activity buttons\r\n            '<table class=\"activity-dialog-followup\" id=\"add_edit_buttons\" dojoAttachPoint=\"add_edit_buttons\">',\r\n                '<tr>',\r\n                    '<td class=\"alignleft\">',\r\n                        '<div class=\"scheduled-by-label\" dojoAttachPoint=\"lbl_ScheduledBy\"></div>',\r\n                    '</td><td class=\"alignright\">',\r\n                        '<div dojoType=\"dijit.form.Button\" id=\"{%= $.id %}_btn_Complete\" name=\"btn_Complete\" dojoAttachPoint=\"btn_Complete\" dojoAttachEvent=\"onClick:_completeClick\">{%= $.completeBtnText %}</div>',\r\n                        '<div dojoType=\"dijit.form.Button\" id=\"{%= $.id %}_btn_Delete\" name=\"btn_Delete\" dojoAttachPoint=\"btn_Delete\" dojoAttachEvent=\"onClick:_deleteClick\">{%= $.deleteText %}</div>',\r\n                        '<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>',\r\n                        '<div dojoType=\"dijit.form.Button\" id=\"{%= $.id %}_btn_OK\" name=\"btn_OK\" dojoAttachPoint=\"btn_OK\" dojoAttachEvent=\"onClick:_okClick\">{%= $.okText %}</div>',\r\n                        '<div dojoType=\"dijit.form.Button\" id=\"{%= $.id %}_btn_Cancel\" name=\"btn_Cancel\" dojoAttachPoint=\"btn_Cancel\" dojoAttachEvent=\"onClick:_cancelClick\">{%= $.cancelText %}</div>',\r\n                    '</td>',\r\n                '</tr>',\r\n            '</table>',\r\n\r\n\r\n        //complete activity buttons\r\n            '<table class=\"activity-dialog-followup display-none\" id=\"complete_buttons\" dojoAttachPoint=\"complete_buttons\">',\r\n                '<tr>',\r\n                    '<col width=\"50%\" /><col width=\"50%\" />',\r\n                    '<td class=\"alignleft\">',\r\n                        '<div dojoType=\"dojox.layout.TableContainer\" orientation=\"horiz\" cols=\"1\" labelWidth=\"{%= $.labelWidth %}\" >',\r\n                            '<select label=\"{%= $.followupText %}\" id=\"sel_Followup\" dojoType=\"dijit.form.ComboBox\" dojoAttachPoint=\"sel_Followup\">',\r\n                                '<option value=\"none\" selected=\"selected\">{%= $.noneText %}</option>',\r\n                                '<option value=\"phone\">{%= Sage.Utility.Activity.getActivityTypeName(\"atPhoneCall\") %}</option>',\r\n                                '<option value=\"meeting\">{%= Sage.Utility.Activity.getActivityTypeName(\"atAppointment\") %}</option>',\r\n                                '<option value=\"todo\">{%= Sage.Utility.Activity.getActivityTypeName(\"atToDo\") %}</option>',\r\n                            '</select>',\r\n                            '<div dojoType=\"dijit.layout.ContentPane\" label=\"\" class=\"remove-padding\">',\r\n                                '<div dojoType=\"dijit.form.CheckBox\" label=\"\" id=\"ck_coAttachments\" dojoAttachPoint=\"ck_coAttachments\" ></div>',\r\n                                '<label class=\"checkbox-label\" for=\"{%= $.id %}_ck_coAttachments\">{%= $.carryOverAttachmentsText %}</label>',\r\n                            '</div>',\r\n                            '<div dojoType=\"dijit.layout.ContentPane\" label=\"\" class=\"remove-padding\">',\r\n                                '<div dojoType=\"dijit.form.CheckBox\" label=\"\" id=\"ck_coNotes\" dojoAttachPoint=\"ck_coNotes\" ></div>',\r\n                                '<label class=\"checkbox-label\" for=\"{%= $.id %}_ck_coNotes\">{%= $.carryOverNotesText %}</label>',\r\n                            '</div>',\r\n                        '</div>',\r\n                    '</td><td class=\"alignright valignbottom\" rowspan=\"2\">',\r\n                        '<div dojoType=\"dijit.form.Button\" id=\"{%= $.id %}_btn_asScheduled\" name=\"btn_asScheduled\" dojoAttachPoint=\"btn_asScheduled\" dojoAttachEvent=\"onClick:_asScheduledClick\">{%= $.asScheduledText %}</div>',\r\n                        '<div dojoType=\"dijit.form.Button\" id=\"{%= $.id %}_btn_Now\" name=\"btn_Now\" dojoAttachPoint=\"btn_Now\" dojoAttachEvent=\"onClick:_nowClick\">{%= $.nowText %}</div>',\r\n                        '<div dojoType=\"dijit.form.Button\" id=\"{%= $.id %}_btn_CancelComplete\" name=\"btn_Cancel\" dojoAttachPoint=\"btn_CancelComplete\" dojoAttachEvent=\"onClick:_cancelClick\">{%= $.cancelText %}</div>',\r\n                    '</td>',\r\n                '</tr><tr>',\r\n                    '<td class=\"alignleft\" >',\r\n                        '<div class=\"scheduled-by-label\" dojoAttachPoint=\"lbl_ScheduledByComp\"></div>',\r\n                    '</td>',\r\n                '</tr>',\r\n            '</table>',\r\n\r\n\r\n\r\n        //Confirmations button bar...\r\n            '<table class=\"button-bar display-none\" id=\"confirmation_edit_buttons\" dojoAttachPoint=\"confirmation_edit_buttons\">',\r\n                '<tr>',\r\n                    '<td class=\"alignleft\" style=\"width:{%= $.labelWidth %}px;\">',\r\n                        '<label for=\"{%= $.id %}_ta_confirmationResponse\" id=\"responseLabel\" dojoAttachPoint=\"responseLabel\">{%= $.responseText %}</label>',\r\n                    '</td>',\r\n                    '<td class=\"alignleft\">',\r\n                        '<textarea dojoType=\"dijit.form.SimpleTextarea\" id=\"{%= $.id %}_ta_confirmationResponse\" dojoAttachPoint=\"ta_confirmationResponse\" class=\"notes-text dijitTextBox\" maxLength=\"128\" ></textarea>',\r\n                    '</td><td class=\"alignright valignbottom\">',\r\n                        '<span id=\"newConfButtons\" dojoAttachPoint=\"newConfButtons\">',\r\n                            '<div dojoType=\"dijit.form.Button\" id=\"{%= $.id %}_btn_accept\" name=\"btn_accept\" dojoAttachPoint=\"btn_accept\" dojoAttachEvent=\"onClick:_acceptConfClick\">{%= $.acceptText %}</div>',\r\n                            '<div dojoType=\"dijit.form.Button\" id=\"{%= $.id %}_btn_decline\" name=\"btn_decline\" dojoAttachPoint=\"btn_decline\" dojoAttachEvent=\"onClick:_declineClick\">{%= $.declineText %}</div>',\r\n                            '<div dojoType=\"dijit.form.Button\" id=\"{%= $.id %}_btn_cancelConf\" name=\"btn_cancelConf\" dojoAttachPoint=\"btn_cancelConf\" dojoAttachEvent=\"onClick:_cancelClick\">{%= $.cancelText %}</div>',\r\n                        '</span>',\r\n                        '<span id=\"otherConfButtons\" dojoAttachPoint=\"otherConfButtons\" class=\"display-none\">',\r\n                            '<div dojoType=\"dijit.form.Button\" id=\"{%= $.id %}_btn_deleteConf\" name=\"btn_deleteConf\" dojoAttachPoint=\"btn_deleteConf\" dojoAttachEvent=\"onClick:_deleteConfClick\">{%= $.deleteConfText %}</div>',\r\n                            '<div dojoType=\"dijit.form.Button\" id=\"{%= $.id %}_btn_closeConf\" name=\"btn_closeConf\" dojoAttachPoint=\"btn_closeConf\" dojoAttachEvent=\"onClick:_cancelClick\">{%= $.closeText %}</div>',\r\n                        '</span>',\r\n                    '</td>',\r\n                '</tr>',\r\n            '</table>',\r\n        '</div>', //body\r\n    '</div>',  //dialog\r\n'</div>' //root node\r\n]\r\n",
'url:Sage/MainView/ActivityMgr/AttendeeLookup/templates/SpeedSearchLookup.html':"[\r\n'<div>',\r\n    '<div data-dojo-type=\"dijit.Dialog\" id=\"{%= $.id %}-Dialog\" title=\"\" dojoAttachPoint=\"_dialog\" >', //dialog\r\n         '<div class=\"event-dialog\">',\r\n        '<div style=\"padding:5px;\" id=\"{%= $.id %}-Condition-container\">',\r\n            '<input id=\"Text1\" type=\"text\" style=\"width:85%;\"  data-dojo-attach-point=\"_valueBox\" data-dojo-attach-event=\"onkeypress:_onKeyPress\"/>',     \r\n            '<button id=\"{%= $.id %}-Search\" data-dojo-type=\"dijit.form.Button\" type=\"button\" dojoAttachPoint=\"searchButton\" dojoAttachEvent=\"onClick:_doSearch\">{%= $.srchBtnCaption %}</button>',\r\n          \r\n        '</div>',    \r\n        '<div data-dojo-attach-point=\"contentNode\">',  \r\n        '<div id=\"{%= $.id %}-Grid-container\" dojoAttachPoint=\"_speedSearchGrid\"  style=\"width:auto;height:400px;\"></div>',\r\n        '</div>',\r\n            '<div class=\"lookupButtonWrapper\">',           \r\n                '<button data-dojo-type=\"dijit.form.Button\" type=\"button\" id=\"{%= $.id %}-GridSelectButton\" ',\r\n                    'onClick=\"dijit.byId(\\'{%= $.id %}\\').getGridSelections(); \">{%= $.okText %}',\r\n                   '</button>',            \r\n                '<button data-dojo-type=\"dijit.form.Button\" type=\"button\" id=\"{%= $.id %}-CloseButton\" ',\r\n                    'onClick=\"dijit.byId(\\'{%= $.id %}-Dialog\\').hide();\">{%= $.cancelText %}</button>',\r\n            '</div>',\r\n             '</div>',\r\n     '</div> ', //dialog   \r\n'</div>'\r\n]",
'url:Sage/UI/Controls/templates/SingleSelectPickList.html':"<div>\r\n    <select id=\"${id}-Combo\" data-dojo-type=\"Sage.UI.ComboBox\" shouldPublishMarkDirty=\"false\" required=\"${required}\" dojoAttachPoint=\"comboBox\" dojoAttachEvent=\"onChange:_onChange,onKeyDown:_onKeyDown\"  tabindex=\"${tabIndex}\">\r\n    </select>\r\n</div>\r\n",
'url:Sage/MainView/ActivityMgr/templates/RecurringEditor.html':"\r\n['<div>',\r\n    '<table style=\"width:100%\">',\r\n        '<tr>',\r\n            '<td class=\"recurring-selectors\">',  //radio buttons...\r\n                '<div>{%= $.activityOccurrsText %}</div>',\r\n                '<div>',\r\n                    '<input dojoType=\"dijit.form.RadioButton\" type=\"radio\" name=\"recurPeriod\" value=\"None\" id=\"{%= $.id %}_rdo_Once\" dojoAttachPoint=\"rdo_Once\" checked=\"true\" dojoAttachEvent=\"onChange:_onceChanged\" />',  //  \r\n                    '<label for=\"{%= $.id %}_rdo_Once\">&nbsp;{%= $.onceText %}</label>',\r\n                '</div><div>',\r\n                    '<input dojoType=\"dijit.form.RadioButton\" type=\"radio\" name=\"recurPeriod\" value=\"daily\" id=\"{%= $.id %}_rdo_Daily\" dojoAttachPoint=\"rdo_Daily\" dojoAttachEvent=\"onChange:_dailyChanged\" />',\r\n                    '<label for=\"{%= $.id %}_rdo_Daily\">&nbsp;{%= $.dailyText %}</label>',\r\n                '</div><div>',\r\n                    '<input dojoType=\"dijit.form.RadioButton\" type=\"radio\" name=\"recurPeriod\" value=\"weekly\" id=\"{%= $.id %}_rdo_Weekly\" dojoAttachPoint=\"rdo_Weekly\" dojoAttachEvent=\"onChange:_weeklyChanged\" />',\r\n                    '<label for=\"{%= $.id %}_rdo_Weekly\">&nbsp;{%= $.weeklyText %}</label>',\r\n                '</div><div>',\r\n                    '<input dojoType=\"dijit.form.RadioButton\" type=\"radio\" name=\"recurPeriod\" value=\"monthly\" id=\"{%= $.id %}_rdo_Monthly\" dojoAttachPoint=\"rdo_Monthly\" dojoAttachEvent=\"onChange:_monthlyChanged\" />',\r\n                    '<label for=\"{%= $.id %}_rdo_Monthly\">&nbsp;{%= $.monthlyText %}</label>',\r\n                '</div><div>',\r\n                    '<input dojoType=\"dijit.form.RadioButton\" type=\"radio\" name=\"recurPeriod\" value=\"yearly\" id=\"{%= $.id %}_rdo_Yearly\" dojoAttachPoint=\"rdo_Yearly\" dojoAttachEvent=\"onChange:_yearlyChanged\" />',\r\n                    '<label for=\"{%= $.id %}_rdo_Yearly\">&nbsp;{%= $.yearlyText %}</label>',\r\n                '</div>',\r\n            '</td>',\r\n            '<td>',  //panel for each different recurring type...\r\n                '<div dojoType=\"dijit.layout.StackContainer\" dojoAttachPoint=\"_panelContainer\" class=\"recurring-body\" >',\r\n                    '<div dojoType=\"dijit.layout.ContentPane\" dojoAttachPoint=\"_oncePanel\" class=\"recurring-panel\"  >',\r\n                        '{%= $.occursOnceText %}',\r\n                    '</div>',\r\n//daily panel...............................\r\n                    '<div dojoType=\"dijit.layout.ContentPane\" dojoAttachPoint=\"_dailyPanel\" class=\"recurring-panel\"  >',\r\n                        '<div>',\r\n                            '<div class=\"recurring-radio-label\" style=\"min-width:{%= $.labelWidth %}px;\">',\r\n                                '<input dojoType=\"dijit.form.RadioButton\" type=\"radio\" name=\"dailyEvery\" value=\"days\" id=\"{%= $.id %}_rdoDailyEvery\" checked=\"true\" dojoAttachPoint=\"_rdoDailyEvery\" dojoAttachEvent=\"onChange:_dailyEveryChanged\" />',\r\n                                '<label for=\"{%= $.id %}_rdoDailyEvery\" class=\"padded-inline-label\">{%= $.everyText %}</label>',\r\n                            '</div>',\r\n                            '<input dojoType=\"Sage.UI.NumberTextBox\" shouldPublishMarkDirty=\"false\" value=\"1\" constraints=\"{places: 0, type: \\'decimal\\'}\" dojoAttachPoint=\"_dailyEveryText\" class=\"small-inline-textbox\" dojoAttachEvent=\"onChange:_intervalChanged\" />',\r\n                            '<span class=\"padded-inline-label\">{%= $.daysText %}</span>',\r\n                        '</div>',\r\n                        '<div>',\r\n                            '<div class=\"recurring-radio-label\" style=\"min-width:{%= $.labelWidth %}px;\">',\r\n                                '<input dojoType=\"dijit.form.RadioButton\" type=\"radio\" name=\"dailyEvery\" value=\"daysAfter\" id=\"{%= $.id %}_rdoDailyEveryAfter\" dojoAttachPoint=\"_rdoDailyEveryAfter\" />',\r\n                                '<label for=\"{%= $.id %}_rdoDailyEveryAfter\" class=\"padded-inline-label\">{%= $.everyText %}</label>',\r\n                            '</div>',\r\n                            '<input dojoType=\"Sage.UI.NumberTextBox\" shouldPublishMarkDirty=\"false\" value=\"1\" constraints=\"{places: 0, type: \\'decimal\\'}\" dojoAttachPoint=\"_dailyEveryAfterText\" disabled=\"true\" class=\"small-inline-textbox\" dojoAttachEvent=\"onChange:_intervalChanged\" />',\r\n                            '<span class=\"padded-inline-label\">{%= $.daysAfterText %}</span>',\r\n                            '</div>',\r\n                    '</div>',\r\n//weekly panel............................\r\n                    '<div dojoType=\"dijit.layout.ContentPane\" dojoAttachPoint=\"_weeklyPanel\" class=\"recurring-panel\"  >',\r\n                        '<div>',\r\n                            '<div class=\"recurring-radio-label\" style=\"min-width:{%= $.labelWidth %}px;\">',\r\n                                '<input dojoType=\"dijit.form.RadioButton\" type=\"radio\" name=\"weeklyEvery\" value=\"weeksOn\" id=\"{%= $.id %}_rdoWeeklyEvery\" checked=\"true\" dojoAttachPoint=\"_rdoWeeklyEvery\" dojoAttachEvent=\"onChange:_weeklyEveryChanged\" />',\r\n                                '<label for=\"{%= $.id %}_rdoWeeklyEvery\" class=\"padded-inline-label\">{%= $.everyText %}</label>',\r\n                            '</div>',\r\n                            '<input dojoType=\"Sage.UI.NumberTextBox\" shouldPublishMarkDirty=\"false\" value=\"1\" constraints=\"{places: 0, type: \\'decimal\\'}\" dojoAttachPoint=\"_weeklyEveryText\" class=\"small-inline-textbox\" dojoAttachEvent=\"onChange:_intervalChanged\" />',\r\n                            '<span class=\"padded-inline-label\">{%= $.weeksOnText %}</span>',\r\n                        '</div>',\r\n                        '<div style=\"white-space:normal;padding-bottom:10px;margin:5px 0 0 20px;\">',\r\n                            '<span class=\"no-wrap\">',\r\n                                '<input dojoType=\"dijit.form.CheckBox\" type=\"checkbox\" name=\"chkMonday\" value=\"mon\" id=\"{%= $.id %}_chkMonday\" dojoAttachPoint=\"_chkMonday\" dojoAttachEvent=\"onClick:_dayChecked\" />',\r\n                                '<label for=\"{%= $.id %}_chkMonday\" class=\"padded-inline-label\">{%= $.monText %}</label>',\r\n                            '</span>',\r\n                            '<span class=\"no-wrap\">',\r\n                                '<input dojoType=\"dijit.form.CheckBox\" type=\"checkbox\" name=\"chkTuesday\" value=\"tue\" id=\"{%= $.id %}_chkTuesday\" dojoAttachPoint=\"_chkTuesday\" dojoAttachEvent=\"onClick:_dayChecked\" />',\r\n                                '<label for=\"{%= $.id %}_chkTuesday\" class=\"padded-inline-label\">{%= $.tueText %}</label>',\r\n                            '</span>',\r\n                            '<span class=\"no-wrap\">',\r\n                                '<input dojoType=\"dijit.form.CheckBox\" type=\"checkbox\" name=\"chkWednesday\" value=\"wed\" id=\"{%= $.id %}_chkWednesday\" dojoAttachPoint=\"_chkWednesday\" dojoAttachEvent=\"onClick:_dayChecked\" />',\r\n                                '<label for=\"{%= $.id %}_chkWednesday\" class=\"padded-inline-label\">{%= $.wedText %}</label>',\r\n                            '</span>',\r\n                            '<span class=\"no-wrap\">',\r\n                                '<input dojoType=\"dijit.form.CheckBox\" type=\"checkbox\" name=\"chkThursday\" value=\"thu\" id=\"{%= $.id %}_chkThursday\" dojoAttachPoint=\"_chkThursday\" dojoAttachEvent=\"onClick:_dayChecked\" />',\r\n                                '<label for=\"{%= $.id %}_chkThursday\" class=\"padded-inline-label\">{%= $.thurText %}</label>',\r\n                            '</span>',\r\n                            '<span class=\"no-wrap\">',\r\n                                '<input dojoType=\"dijit.form.CheckBox\" type=\"checkbox\" name=\"chkFriday\" value=\"fri\" id=\"{%= $.id %}_chkFriday\" dojoAttachPoint=\"_chkFriday\" dojoAttachEvent=\"onClick:_dayChecked\" />',\r\n                                '<label for=\"{%= $.id %}_chkFriday\" class=\"padded-inline-label\">{%= $.friText %}</label>',\r\n                            '</span>',\r\n                            '<span class=\"no-wrap\">',\r\n                                '<input dojoType=\"dijit.form.CheckBox\" type=\"checkbox\" name=\"chkSaturday\" value=\"sat\" id=\"{%= $.id %}_chkSaturday\" dojoAttachPoint=\"_chkSaturday\" dojoAttachEvent=\"onClick:_dayChecked\" />',\r\n                                '<label for=\"{%= $.id %}_chkSaturday\" class=\"padded-inline-label\">{%= $.satText %}</label>',\r\n                            '</span>',\r\n                            '<span class=\"no-wrap\">',\r\n                                '<input dojoType=\"dijit.form.CheckBox\" type=\"checkbox\" name=\"chkSunday\" value=\"sun\" id=\"{%= $.id %}_chkSunday\" dojoAttachPoint=\"_chkSunday\" dojoAttachEvent=\"onClick:_dayChecked\" />',\r\n                                '<label for=\"{%= $.id %}_chkSunday\" class=\"padded-inline-label\">{%= $.sunText %}</label>',\r\n                            '</span>',\r\n                        '</div>',\r\n                        '<div>',\r\n                            '<div class=\"recurring-radio-label\" style=\"min-width:{%= $.labelWidth %}px;\">',\r\n                                '<input dojoType=\"dijit.form.RadioButton\" type=\"radio\" name=\"weeklyEvery\" value=\"weeksAfter\" id=\"{%= $.id %}_rdoWeeklyEveryAfter\" dojoAttachPoint=\"_rdoWeeklyEveryAfter\" />',\r\n                                '<label for=\"{%= $.id %}_rdoWeeklyEveryAfter\" class=\"padded-inline-label\">{%= $.everyText %}</label>',\r\n                            '</div>',\r\n                            '<input dojoType=\"Sage.UI.NumberTextBox\" shouldPublishMarkDirty=\"false\" value=\"1\" constraints=\"{places: 0, type: \\'decimal\\'}\" dojoAttachPoint=\"_weeklyEveryAfterText\" disabled=\"true\" class=\"small-inline-textbox\" dojoAttachEvent=\"onChange:_calculateEnd\" />',\r\n                            '<span class=\"padded-inline-label\">{%= $.weeksAfterText %}</span>',\r\n                        '</div>',\r\n                    '</div>',\r\n//monthly panel.........................................................\r\n                    '<div dojoType=\"dijit.layout.ContentPane\" dojoAttachPoint=\"_monthlyPanel\" class=\"recurring-panel\"  >',\r\n                        '<div>',\r\n                            '<div class=\"recurring-radio-label\" style=\"min-width:{%= $.labelWidth %}px;\">',\r\n                                '<input dojoType=\"dijit.form.RadioButton\" type=\"radio\" name=\"monthlyOn\" value=\"monthyOn\" id=\"{%= $.id %}_rdoMonthlyOn\" checked=\"true\" dojoAttachPoint=\"_rdoMonthlyOn\" dojoAttachEvent=\"onChange:_monthlyOnChanged\" />',\r\n                                '<label for=\"{%= $.id %}_rdoMonthlyOn\" class=\"padded-inline-label\">{%= $.everyText %}</label>',\r\n                            '</div>',\r\n                            '<input dojoType=\"Sage.UI.NumberTextBox\" shouldPublishMarkDirty=\"false\" value=\"1\" constraints=\"{places: 0, type: \\'decimal\\'}\" dojoAttachPoint=\"_monthlyEveryText\" class=\"small-inline-textbox\" dojoAttachEvent=\"onChange:_intervalChanged\" />',\r\n                            '<span class=\"padded-inline-label\">{%= $.monthsOnText %}</span>',\r\n                            '<select dojoType=\"dijit.form.Select\" dojoAttachPoint=\"_datesSelect\" dojoAttachEvent=\"onChange:_calculateEnd\" maxHeight=\"300\"></select>',\r\n                        '</div>',\r\n                        '<div>',\r\n                            '<div class=\"recurring-radio-label\" style=\"min-width:{%= $.labelWidth %}px;\">',\r\n                                '<input dojoType=\"dijit.form.RadioButton\" type=\"radio\" name=\"monthlyOn\" value=\"monthyOnThe\" id=\"{%= $.id %}_rdoMonthlyOnThe\" dojoAttachPoint=\"_rdoMonthlyOnThe\" />', // dojoAttachEvent=\"onChange:_monthlyOnChanged\"\r\n                                '<label for=\"{%= $.id %}_rdoMonthlyOnThe\" class=\"padded-inline-label\">{%= $.everyText %}</label>',\r\n                            '</div>',\r\n                            '<input dojoType=\"Sage.UI.NumberTextBox\" shouldPublishMarkDirty=\"false\" value=\"1\" constraints=\"{places: 0, type: \\'decimal\\'}\" dojoAttachPoint=\"_monthlyOnTheText\" disabled=\"true\" class=\"small-inline-textbox\" dojoAttachEvent=\"onChange:_intervalChanged\" />',\r\n                            '<span class=\"padded-inline-label\">{%= $.monthsOnTheText %}</span>',\r\n                            '<select dojoType=\"dijit.form.Select\" dojoAttachPoint=\"_weeksSelect\" disabled=\"true\" dojoAttachEvent=\"onChange:_calculateEnd\"></select>',\r\n                            '<select dojoType=\"dijit.form.Select\" dojoAttachPoint=\"_weekdaySelect\" disabled=\"true\" dojoAttachEvent=\"onChange:_calculateEnd\"></select>',\r\n                        '</div>',\r\n                        '<div>',\r\n                            '<div class=\"recurring-radio-label\" style=\"min-width:{%= $.labelWidth %}px;\">',\r\n                                '<input dojoType=\"dijit.form.RadioButton\" type=\"radio\" name=\"monthlyOn\" value=\"monthyAfter\" id=\"{%= $.id %}_rdoMonthlyAfter\" dojoAttachPoint=\"_rdoMonthlyAfter\" dojoAttachEvent=\"onChange:_monthlyOnChanged\" />',\r\n                                '<label for=\"{%= $.id %}_rdoMonthlyAfter\" class=\"padded-inline-label\">{%= $.everyText %}</label>',\r\n                            '</div>',\r\n                            '<input dojoType=\"Sage.UI.NumberTextBox\" shouldPublishMarkDirty=\"false\" value=\"1\" constraints=\"{places: 0, type: \\'decimal\\'}\" dojoAttachPoint=\"_monthlyAfterText\" disabled=\"true\" class=\"small-inline-textbox\" dojoAttachEvent=\"onChange:_calculateEnd\" />',\r\n                            '<span class=\"padded-inline-label\">{%= $.monthsAfterText %}</span>',\r\n                        '</div>',\r\n                    '</div>',\r\n// yearly panel..............\r\n                    '<div dojoType=\"dijit.layout.ContentPane\" dojoAttachPoint=\"_yearlyPanel\" class=\"recurring-panel\"  >',\r\n                        '<div>',\r\n                            '<div class=\"recurring-radio-label\" style=\"min-width:{%= $.labelWidth %}px;\">',\r\n                                '<input dojoType=\"dijit.form.RadioButton\" type=\"radio\" name=\"yearlyOn\" value=\"yearlyOn\" id=\"{%= $.id %}_rdoYearlyOn\" checked=\"true\" dojoAttachPoint=\"_rdoYearlyOn\" dojoAttachEvent=\"onChange:_yearlyOnChanged\" />',\r\n                                '<label for=\"{%= $.id %}_rdoYearlyOn\" class=\"padded-inline-label\">{%= $.everyText %}</label>',\r\n                            '</div>',\r\n                            '<input dojoType=\"Sage.UI.NumberTextBox\" shouldPublishMarkDirty=\"false\" value=\"1\" constraints=\"{places: 0, type: \\'decimal\\'}\" dojoAttachPoint=\"_yearlyEveryText\" class=\"small-inline-textbox\" dojoAttachEvent=\"onChange:_intervalChanged\" />',\r\n                            '<span class=\"padded-inline-label\">{%= $.yearsOnText %}</span>',\r\n                            '<select dojoType=\"dijit.form.Select\" dojoAttachPoint=\"_monthNamesSelect\" dojoAttachEvent=\"onChange:_yearlyRecurDateChanged\"></select>',\r\n                            '<select dojoType=\"dijit.form.Select\" maxHeight=\"300\" dojoAttachPoint=\"_yearDatesSelect\" dojoAttachEvent=\"onChange:_yearlyRecurDateChanged\"></select>',\r\n                        '</div>',\r\n                        '<div>',\r\n                            '<div class=\"recurring-radio-label\" style=\"min-width:{%= $.labelWidth  %}px;\">',\r\n                                '<input dojoType=\"dijit.form.RadioButton\" type=\"radio\" name=\"yearlyOn\" value=\"yearlyOnThe\" id=\"{%= $.id %}_rdoYearlyOnThe\" dojoAttachPoint=\"_rdoYearlyOnThe\" />',\r\n                                '<label for=\"{%= $.id %}_rdoYearlyOnThe\" class=\"padded-inline-label\">{%= $.theText %}</label>',\r\n                            '</div>',\r\n                            '<select dojoType=\"dijit.form.Select\" dojoAttachPoint=\"_yearWeeksSelect\" disabled=\"true\" dojoAttachEvent=\"onChange:_yearlyRecurDateChanged\"></select>',\r\n                            '<select dojoType=\"dijit.form.Select\" dojoAttachPoint=\"_yearWeekdaySelect\" disabled=\"true\" dojoAttachEvent=\"onChange:_yearlyRecurDateChanged\"></select>',\r\n                            '<label class=\"padded-inline-label\">{%= $.inText %}</label>',\r\n                            '<select dojoType=\"dijit.form.Select\" dojoAttachPoint=\"_yearMonthNamesSelect\" disabled=\"true\" dojoAttachEvent=\"onChange:_yearlyRecurDateChanged\"></select>',\r\n                        '</div>',\r\n                        '<div>',\r\n                            '<div class=\"recurring-radio-label\" style=\"min-width:{%= $.labelWidth %}px;\">',\r\n                                '<input dojoType=\"dijit.form.RadioButton\" type=\"radio\" name=\"yearlyOn\" value=\"yearlyEveryAfter\" id=\"{%= $.id %}_rdoYearlyEveryAfter\" dojoAttachPoint=\"_rdoYearlyEveryAfter\" dojoAttachEvent=\"onChange:_yearlyOnChanged\" />',\r\n                                '<label for=\"{%= $.id %}_rdoYearlyEveryAfter\" class=\"padded-inline-label\">{%= $.everyText %}</label>',\r\n                            '</div>',\r\n                            '<input dojoType=\"Sage.UI.NumberTextBox\" shouldPublishMarkDirty=\"false\" value=\"1\" constraints=\"{places: 0, type: \\'decimal\\'}\" dojoAttachPoint=\"_yearlyEveryAfterText\" disabled=\"true\" class=\"small-inline-textbox\" dojoAttachEvent=\"onChange:_calculateEnd\" />',\r\n                            '<span class=\"padded-inline-label\">{%= $.yearsAfterText %}</span>',\r\n                            '</div>',\r\n                    '</div>',\r\n                '</div>', //stack container\r\n// End date calculator section.........................................\r\n                '<div dojoAttachPoint=\"_startEndCalculator\" class=\"display-none\">',\r\n                    '<hr />',\r\n                    '<table>',\r\n                        '<tr>',\r\n                            '<td>{%= $.startRecurringText %}</td>',\r\n                            '<td>',\r\n                                '<div dojoType=\"Sage.UI.Controls.DateTimePicker\" shouldPublishMarkDirty=\"false\" id=\"{%= $.id %}_dtp_StartRecur\" value=\"{%= $.startDate %}\" dojoAttachPoint=\"dtp_startRecur\" displayDate=\"true\" displayTime=\"false\" dojoAttachEvent=\"onChange:_recurringStartDateChanged\" readOnly=\"true\" ></div>',\r\n                            '</td>',\r\n                        '</tr>',\r\n                        '<tr>',\r\n                            '<td>',\r\n                                '<input dojoType=\"dijit.form.RadioButton\" type=\"radio\" name=\"endRecur\" value=\"endAfterNum\" id=\"{%= $.id %}_rdoEndAfterNum\" dojoAttachPoint=\"_rdoEndAfter\" dojoAttachEvent=\"onChange:_endCalcModeChanged\" checked=\"true\" />',\r\n                                '<label for=\"{%= $.id %}_rdoEndAfterNum\" class=\"padded-inline-label\">{%= $.endAfterText  %}</label>',\r\n                            '</td><td>',\r\n                                '<input dojoType=\"Sage.UI.NumberTextBox\" shouldPublishMarkDirty=\"false\" value=\"2\" constraints=\"{places: 0, type: \\'decimal\\', max: 999, min: 1}\" maxlength=\"3\" id=\"{%= $.id %}_num_Occurances\" dojoAttachPoint=\"num_Occurances\" class=\"small-inline-textbox\" dojoAttachEvent=\"onChange:_numOccurancesChanged\" />',\r\n                                '<span class=\"padded-inline-label\">{%= $.occurrencesText %}</span>',\r\n                            '</td>',\r\n                        '</tr><tr>',\r\n                            '<td>',\r\n                                '<input dojoType=\"dijit.form.RadioButton\" type=\"radio\" name=\"endRecur\" value=\"endOn\" id=\"{%= $.id %}_rdoEndOn\" dojoAttachPoint=\"_rdoEndOn\" />',\r\n                                '<label for=\"{%= $.id %}_rdoEndOn\" class=\"padded-inline-label\">{%= $.endOnText %}</label>',\r\n                            '</td>',\r\n                            '<td>',\r\n                                '<div dojoType=\"Sage.UI.Controls.DateTimePicker\" shouldPublishMarkDirty=\"false\" id=\"{%= $.id %}_dtp_EndRecur\" dojoAttachPoint=\"dtp_endRecur\" displayDate=\"true\" displayTime=\"false\" dojoAttachEvent=\"onChange:_endRecurChanged\" ></div>',\r\n                            '</td>',\r\n                        '</tr>',\r\n                    '</table>',\r\n                '</div>',\r\n            '</td>',\r\n        '</tr>',\r\n    '</table>',\r\n'</div>']",
'url:Sage/MainView/ActivityMgr/templates/HistoryEditor.html':"\r\n[\r\n'<div>',\r\n    '<div dojoType=\"dijit.Dialog\" id=\"historyDialog\" title=\"\" dojoAttachPoint=\"_dialog\" dojoAttachEvent=\"onHide:_onDlgHide\">',\r\n        '<div class=\"activity-dialog\">',  //body\r\n            '<div class=\"activity-dialog-content\">',\r\n            '<div dojoType=\"dojox.layout.TableContainer\" orientation=\"horiz\" cols=\"1\" labelWidth=\"{%= $.labelWidth %}\" dojoAttachPoint=\"regardingContainer\">',\r\n                '<select label=\"{%= $.regardingText %}\" shouldPublishMarkDirty=\"false\" id=\"{%= $.id %}_pk_Regarding\" dojoType=\"Sage.UI.Controls.SingleSelectPickList\" dojoAttachPoint=\"pk_Regarding\" canEditText=\"true\" itemMustExist=\"false\" maxLength=\"255\"></select>',\r\n                '<div dojoType=\"Sage.UI.Controls.TextBox\" shouldPublishMarkDirty=\"false\" label=\"{%= $.locationText %}\" id=\"{%= $.id %}_tb_Location\" dojoAttachPoint=\"tb_Location\" maxLength=\"255\" ></div>',\r\n            '</div>', //first tablecontainer 1 col\r\n            '<div dojoType=\"dojox.layout.TableContainer\" orientation=\"horiz\" cols=\"2\" labelWidth=\"{%= $.labelWidth %}\" dojoAttachPoint=\"dateSection_AddEdit\">',\r\n                '<div dojoType=\"Sage.UI.Controls.DateTimePicker\" shouldPublishMarkDirty=\"false\" id=\"{%= $.id %}_dtp_CompletetdDate\" dojoAttachPoint=\"dtp_completedDate\" displayDate=\"true\" displayTime=\"true\" label=\"{%= $.completedDateText %}\"></div>',\r\n                '<div dojoType=\"Sage.UI.Controls.DateTimePicker\" shouldPublishMarkDirty=\"false\" id=\"{%= $.id %}_dtp_StartDate\" dojoAttachPoint=\"dtp_startDate\" displayDate=\"true\" displayTime=\"true\" label=\"{%= $.startTimeText %}\"></div>',\r\n                '<div dojoType=\"dijit.layout.ContentPane\" label=\"\" class=\"remove-padding\">',\r\n                    '<div dojoType=\"dijit.form.CheckBox\" label=\"{%= $.timeLessText %}\" id=\"{%= $.id %}_cb_Timeless\" dojoAttachPoint=\"cb_Timeless\" ></div>',\r\n                    '<label class=\"checkbox-label\" for=\"cb_Timeless\">{%= $.timeLessText %}</label>',\r\n                '</div>',\r\n                 '<div dojoType=\"Sage.UI.Controls.DurationSelect\" shouldPublishMarkDirty=\"false\" label=\"{%= $.durationText %}\" id=\"{%= $.id %}_sel_Duration\" dojoAttachPoint=\"sel_Duration\" includeDisablingCheckbox=\"false\" valuesAreAfterStart=\"true\"></div>',\r\n                '<div dojoType=\"dijit.layout.ContentPane\" label=\"\" class=\"remove-padding\">',\r\n                '</div>',\r\n            '</div>', //second tablecontainer 2 col\r\n\r\n            '<div dojoType=\"dijit.layout.TabContainer\" id=\"{%= $.id %}_tc_EditHistory\"  dojoAttachPoint=\"tc_EditHistory\" class=\"tab-container\" doLayout=\"false\">',\r\n/*  General Tab   */\r\n                '<div dojoType=\"dijit.layout.ContentPane\" id=\"{%= $.id %}_cp_General\" title=\"{%= $.tabNameGeneralText %}\" class=\"tabContent remove-padding\" dojoAttachPoint=\"cp_General\">',\r\n                    '<div dojoType=\"dojox.layout.TableContainer\" orientation=\"horiz\" cols=\"2\" labelWidth=\"{%= $.labelWidth %}\" dojoAttachPoint=\"result_Section\" class=\"bottom-border-section add-padding\">',\r\n                        '<select label=\"{%= $.resultText %}\" id=\"{%= $.id %}_tb_Result\" shouldPublishMarkDirty=\"false\" dojoType=\"Sage.UI.Controls.SingleSelectPickList\" dojoAttachPoint=\"pk_Result\" canEditText=\"true\" itemMustExist=\"false\" maxLength=\"64\"></select>',\r\n                    '</div>',\r\n                    '<div dojoType=\"dojox.layout.TableContainer\" orientation=\"horiz\" cols=\"4\" labelWidth=\"70\" baseClass=\"contact-lead-radios\" >',\r\n                        '<input dojoType=\"dijit.form.RadioButton\" type=\"radio\" name=\"contactOrLead\" label=\"{%= $.contactText %}\" value=\"contact\" id=\"{%= $.id %}_rdo_Contact\" dojoAttachPoint=\"rdo_Contact\" dojoAttachEvent=\"onChange:_setContactLeadVisibility\" checked=\"true\" />',\r\n                        '<input dojoType=\"dijit.form.RadioButton\" type=\"radio\" name=\"contactOrLead\" label=\"{%= $.leadText %}\" value=\"lead\" id=\"{%= $.id %}_rdo_Lead\" dojoAttachPoint=\"rdo_Lead\" />',\r\n                    '</div>',\r\n                    '<div dojoType=\"dojox.layout.TableContainer\" orientation=\"horiz\" cols=\"2\" labelWidth=\"{%= $.labelWidth %}\" dojoAttachPoint=\"contactContainer\" baseClass=\"bottom-border-section\">',\r\n                        '<div dojoType=\"dijit.layout.ContentPane\" label=\"{%= $.nameText %}\" dojoAttachPoint=\"container_ContactLup\" class=\"remove-padding lookup-container\"></div>',\r\n                        '<div dojoType=\"dijit.layout.ContentPane\" label=\"{%= $.opportunityText %}\" dojoAttachPoint=\"container_OppLup\" class=\"remove-padding lookup-container\"></div>',\r\n                        '<div dojoType=\"dijit.layout.ContentPane\" label=\"{%= $.accountText %}\" dojoAttachPoint=\"container_AccountLup\"  class=\"remove-padding lookup-container\"></div>',\r\n                        '<div dojoType=\"dijit.layout.ContentPane\" label=\"{%= $.ticketText %}\" dojoAttachPoint=\"container_TicketLup\"  class=\"remove-padding lookup-container\"></div>',\r\n                    '</div>',\r\n                    '<div dojoType=\"dojox.layout.TableContainer\" orientation=\"horiz\" cols=\"2\" labelWidth=\"{%= $.labelWidth %}\" dojoAttachPoint=\"leadContainer\"  baseClass=\"bottom-border-section\" class=\"display-none\">',\r\n                        '<div dojoType=\"dijit.layout.ContentPane\" label=\"{%= $.nameText %}\" dojoAttachPoint=\"container_LeadLup\"  class=\"remove-padding lookup-container\"></div>',\r\n                        '<input dojoType=\"dijit.form.TextBox\" id=\"{%= $.id %}_tb_LeadCompanyName\" label=\"{%= $.companyText %}\" dojoAttachPoint=\"tb_LeadCompanyName\" readonly=\"true\" />',\r\n                    '</div>',                       \r\n                    '<div dojoType=\"dojox.layout.TableContainer\" orientation=\"horiz\" cols=\"2\" labelWidth=\"{%= $.labelWidth %}\"  class=\"bottom-border-section\" dojoAttachPoint=\"categoryContainer\">',\r\n                        '<select label=\"{%= $.categoryText %}\" id=\"{%= $.id %}_pk_Category\" shouldPublishMarkDirty=\"false\" dojoType=\"Sage.UI.Controls.SingleSelectPickList\" dojoAttachPoint=\"pk_Category\" canEditText=\"true\" itemMustExist=\"false\" maxLength=\"64\"  style=\"width: {%= 472 - $.labelWidth %}px;\" ></select>', \r\n                         '<div dojoType=\"dijit.layout.ContentPane\" label=\"{%= $.leaderText %}\" dojoAttachPoint=\"container_LeaderLup\" class=\"remove-padding lookup-container\" style=\"width: {%= 472 - $.labelWidth %}px;\"></div>',\r\n                         '<select label=\"{%= $.priorityText %}\" id=\"{%= $.id %}_pk_Priority\" shouldPublishMarkDirty=\"false\" dojoType=\"Sage.UI.Controls.SingleSelectPickList\" dojoAttachPoint=\"pk_Priority\" canEditText=\"true\" itemMustExist=\"false\" pickListName=\"Priorities\" sort=\"false\" maxLength=\"64\" style=\"width: {%= 472 - $.labelWidth %}px;\"></select>',                          \r\n                    '</div>',\r\n                    '<div dojoType=\"dojox.layout.TableContainer\" orientation=\"horiz\" cols=\"1\" labelWidth=\"{%= $.labelWidth %}\"  class=\"valigntop\" dojoAttachPoint=\"notesContainer\">',\r\n                        '<textarea dojoType=\"dijit.form.SimpleTextarea\" id=\"{%= $.id %}_ta_Notes\" label=\"{%= $.notesText %}\" dojoAttachPoint=\"ta_Notes\" class=\"notes-text\" ></textarea>',\r\n                    '</div>',\r\n                '</div>',  // end general tab\r\n\r\n              /* Attachments Tab  */\r\n                '<div dojoType=\"dijit.layout.ContentPane\" id=\"{%= $.id %}_cp_Attachments\" title=\"{%= $.tabNameAttachmentsText %}\" class=\"tabContent\" dojoAttachPoint=\"cp_Attachments\" dojoAttachEvent=\"onShow:_showAttachmentsTab\">',\r\n                    '<div id=\"{%= $.id %}_attachmentsGridPlaceholder\" dojoAttachPoint=\"_attachmentGridPlaceholder\" style=\"width:100%;height:100%;\" ></div>',\r\n                '</div>',  //end attachments tab\r\n            '</div>', //end tab container\r\n            '</div>',\r\n            '<table class=\"activity-dialog-followup\">',\r\n                '<col width=\"50%\" /><col width=\"50%\" />',\r\n                 '<tr>',\r\n                    '<td class=\"alignleft\">',\r\n                        //followUp section\r\n                        '<div dojoType=\"dojox.layout.TableContainer\" orientation=\"horiz\" cols=\"1\" labelWidth=\"{%= $.labelWidth %}\" dojoAttachPoint=\"followUp_Section\" >',\r\n                            '<select label=\"{%= $.followupText %}\" id=\"{%= $.id %}_followUpSelect\" dojoType=\"dijit.form.ComboBox\" dojoAttachPoint=\"sel_Followup\">',\r\n                                '<option value=\"none\" selected=\"selected\">{%= $.noneText %}</option>',\r\n                                '<option value=\"atPhoneCall\">{%= Sage.Utility.Activity.getActivityTypeName(\"atPhoneCall\") %}</option>',\r\n                                '<option value=\"atAppointment\">{%= Sage.Utility.Activity.getActivityTypeName(\"atAppointment\") %}</option>',\r\n                                '<option value=\"atToDo\">{%= Sage.Utility.Activity.getActivityTypeName(\"atToDo\") %}</option>',\r\n                            '</select>',\r\n                            '<div dojoType=\"dijit.layout.ContentPane\" label=\"\" class=\"remove-padding\">',\r\n                                '<div dojoType=\"dijit.form.CheckBox\" label=\"\" id=\"{%= $.id %}_ck_coAttachments\" dojoAttachPoint=\"ck_coAttachments\" ></div>',\r\n                                '<label class=\"checkbox-label\" for=\"{%= $.id %}_ck_coAttachments\">{%= $.carryOverAttachmentsText %}</label>',\r\n                            '</div>',\r\n                            '<div dojoType=\"dijit.layout.ContentPane\" label=\"\" class=\"remove-padding\">',\r\n                                '<div dojoType=\"dijit.form.CheckBox\" label=\"\" id=\"{%= $.id %}_ck_coNotes\" dojoAttachPoint=\"ck_coNotes\" ></div>',\r\n                                '<label class=\"checkbox-label\" for=\"{%= $.id %}_ck_coNotes\">{%= $.carryOverNotesText %}</label>',\r\n                            '</div>',\r\n                        '</div>',//end followUp section\r\n                    '</td>',\r\n                    '<td class=\"alignright valignbottom\" rowspan=\"2\" ojoAttachPoint=\"add_edit_buttons\" >',\r\n                        '<div dojoType=\"dijit.form.Button\" id=\"{%= $.id %}_btnDelete\" name=\"btn_Delete\" dojoAttachPoint=\"btn_Delete\" dojoAttachEvent=\"onClick:_deleteClick\">{%= $.deleteText %}</div>',\r\n                        '<div dojoType=\"dijit.form.Button\" id=\"{%= $.id %}_btn_OK\" name=\"btn_OK\" dojoAttachPoint=\"btn_OK\" dojoAttachEvent=\"onClick:_okClick\">{%= $.okText %}</div>',\r\n                        '<div dojoType=\"dijit.form.Button\" id=\"{%= $.id %}_btn_Cancel\" name=\"btn_Cancel\" dojoAttachPoint=\"btn_Cancel\" dojoAttachEvent=\"onClick:_cancelClick\">{%= $. cancelText %}</div>',\r\n                    '</td>',\r\n                '</tr>',\r\n                '<tr>',\r\n                   '<td class=\"alignleft\">',\r\n                      '<div class=\"scheduled-by-label\" dojoAttachPoint=\"lbl_ScheduledBy\"></div>',\r\n                   '</td>',\r\n                '</tr>',\r\n            '</table>',\r\n        '</div>', //body\r\n    '</div>',  //dialog\r\n'</div>' //root node\r\n]\r\n",
'url:Sage/MainView/EntityMgr/templates/EditEntityOptionsDlg.html':"<div>\r\n    <div dojotype=\"dijit.Dialog\" title=\"\" dojoattachpoint=\"_dialog\" dojoattachevent=\"onHide:_onDlgHide\" style=\"width:60%;\">\r\n        <div class=\"recur-activity-dialog\">\r\n            <table class=\"detailTableContainer formtable HundredPercentWidth\">\r\n                <tr>\r\n                    <td class=\"FManagerDialogFieldLabel\">\r\n                        <div style=\"padding:0 !important;\" class=\"lbl alignright\">\r\n                            <label style=\"line-height:32px !important;\" data-dojo-attach-point=\"lblName\">\r\n                                Name\r\n                            </label>\r\n                        </div>\r\n                        <div class=\"fld  dijitInline\" data-dojo-attach-point=\"filterName\">\r\n                            <input disabled data-dojo-type=\"dijit.form.ValidationTextBox\" data-dojo-props=\"required: true\" data-dojo-attach-point=\"Name\" />\r\n                        </div>\r\n                    </td>\r\n                </tr>\r\n\r\n                <tr>\r\n                    <td class=\"FManagerDialogFieldLabel\">\r\n                        <div style=\"padding:0 !important;\" class=\"lbl alignright\">\r\n                            <label style=\"line-height:32px !important;\" data-dojo-attach-point=\"lblDisplayName\">\r\n                                Display Name\r\n                            </label>\r\n                        </div>\r\n                        <div class=\"fld  dijitInline\" data-dojo-attach-point=\"filterName\">\r\n                            <input data-dojo-type=\"dijit.form.ValidationTextBox\" data-dojo-props=\"required: true\" data-dojo-attach-point=\"DisplayName\" />\r\n                        </div>\r\n                    </td>\r\n                </tr>\r\n                <tr>\r\n                    <td class=\"FManagerDialogFieldLabel\">\r\n                        <div style=\"padding:0 !important;\" class=\"lbl alignright\">\r\n                            <label style=\"line-height:32px !important;\" data-dojo-attach-point=\"lblPluralName\">\r\n                                Display Plural Name\r\n                            </label>\r\n                        </div>\r\n                        <div class=\"fld dijitInline\" data-dojo-attach-point=\"displayName\">\r\n                            <input data-dojo-type=\"dijit.form.ValidationTextBox\" data-dojo-props=\"required: true\" data-dojo-attach-point=\"PluralName\" style=\"\" />\r\n                        </div>\r\n                    </td>\r\n                </tr>\r\n                <tr>\r\n                    <td class=\"FManagerDialogFieldLabel\">\r\n                        <div style=\"\" class=\"lbl alignright\">\r\n                            <label data-dojo-attach-point=\"lblTitle\">Title (String Expression)</label>\r\n                        </div>\r\n                        <div class=\"fld dijitInline\" data-dojo-attach-point=\"viewTitle\"></div>\r\n                    </td>\r\n                </tr>\r\n                <tr>\r\n                    <td class=\"FManagerDialogFieldLabel\">\r\n                        <div style=\"\" class=\"lbl alignright\">\r\n                            <label data-dojo-attach-point=\"lblExtension\" for=\"IsExtension\">Is Extension</label>\r\n                            <input type=\"checkbox\" data-dojo-attach-point=\"IsExtension\"\r\n                                   data-dojo-type=\"dijit/form/CheckBox\" />\r\n                        </div>\r\n                        <div class=\"fld dijitInline\" data-dojo-attach-point=\"entityDP\">\r\n                        </div>\r\n                    </td>\r\n                </tr>\r\n                <tr>\r\n                    <td class=\"FManagerDialogFieldLabel\">\r\n                        <div style=\"padding:0 !important;\" class=\"lbl alignright\">\r\n                            <label style=\"line-height:32px !important;\" data-dojo-attach-point=\"lblHistory\">\r\n                                Track History To\r\n                            </label>\r\n                        </div>\r\n                        <div class=\"fld  dijitInline\" data-dojo-attach-point=\"filterName\">\r\n                            <input disabled data-dojo-type=\"dijit.form.TextBox\" data-dojo-attach-point=\"History\" />\r\n                        </div>\r\n                    </td>\r\n                </tr>\r\n                <tr>\r\n                    <td class=\"FManagerDialogFieldLabel\">\r\n                        <div style=\"width:248px;\" class=\"lbl alignright\">\r\n                            <label data-dojo-attach-point=\"lblAdvancedOptions\" for=\"\">Advanced Options</label>\r\n                        </div>\r\n                        <div class=\"fld dijitInline\" data-dojo-attach-point=\"BulkUpdateVal\" style=\"padding-top:4px; outline:1px solid #999999\">\r\n                            <label data-dojo-attach-point=\"lblImport\" style=\"display:inline-block; width: 100px; text-align:right;\">Import</label>\r\n                            <input type=\"checkbox\" data-dojo-attach-point=\"CanImport\"\r\n                                   data-dojo-type=\"dijit/form/CheckBox\"/>\r\n                            <label data-dojo-attach-point=\"lblCanPut\" style=\"display:inline-block; width: 100px; text-align:right;\">Put</label>\r\n                            <input type=\"checkbox\" data-dojo-attach-point=\"CanPut\"\r\n                                   data-dojo-type=\"dijit/form/CheckBox\" />\r\n                            <br />\r\n                            <label data-dojo-attach-point=\"lblMatch\" style=\"display:inline-block; width: 100px; text-align:right;\" for=\"\">Match</label>\r\n                            <input style=\"margin-top: 4px;\" type=\"checkbox\" data-dojo-attach-point=\"CanMatch\"\r\n                                   data-dojo-type=\"dijit/form/CheckBox\"/>\r\n                            <label data-dojo-attach-point=\"lblCanPost\" style=\"display:inline-block; width: 100px; text-align:right;\">Post</label>\r\n                            <input type=\"checkbox\" data-dojo-attach-point=\"CanPost\"\r\n                                   data-dojo-type=\"dijit/form/CheckBox\" />\r\n                            <br />\r\n                            <label data-dojo-attach-point=\"lblBulkUpdate\" style=\"display:inline-block; width: 100px; text-align:right;\" for=\"\">Bulk Update</label>\r\n                            <input style=\"margin-top: 4px;\" type=\"checkbox\" data-dojo-attach-point=\"BulkUpdate\"\r\n                                   data-dojo-type=\"dijit/form/CheckBox\"/>\r\n                            <label data-dojo-attach-point=\"lblCanDelete\" style=\"display:inline-block; width: 100px; text-align:right;\">Delete</label>\r\n                            <input type=\"checkbox\" data-dojo-attach-point=\"CanDelete\"\r\n                                   data-dojo-type=\"dijit/form/CheckBox\" />\r\n                            <br />\r\n                            <label data-dojo-attach-point=\"lblAudited\" style=\"display:inline-block; width: 100px; text-align:right;\" for=\"Audited\">Audited</label>\r\n                            <input style=\"margin-top:4px;\" type=\"checkbox\" data-dojo-attach-point=\"Audited\"\r\n                                   data-dojo-type=\"dijit/form/CheckBox\" />\r\n                        </div>\r\n                    </td>\r\n                </tr>\r\n            </table>\r\n\r\n            <div class=\"button-bar alignright\">\r\n                <div data-dojo-type=\"dijit.form.Button\" id=\"{%= $.id%}_btn_OK\" name=\"btn_OK\" dojoattachpoint=\"btn_OK\" dojoattachevent=\"onClick:_okClick\">OK</div>\r\n                <div data-dojo-type=\"dijit.form.Button\" id=\"{%= $.id%}_btn_Cancel\" name=\"btn_Cancel\" dojoattachpoint=\"btn_Cancel\" dojoattachevent=\"onClick:_cancelClick\">Cancel</div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n",
'url:Sage/MainView/EntityMgr/AddEditEntityDetail/templates/DistinctDetailsView.html':"[\r\n'<div>',\r\n    '<table class=\"detailTableContainer formtable HundredPercentWidth\">',\r\n        '<tr data-dojo-attach-point=\"_filterDetailsSection\">',\r\n            '<td class=\"FManagerDialogFieldLabel\">',\r\n\t\t\t\t'<div style=\"padding:0 !important;\" class=\"lbl alignright\">',\r\n                    '<label style=\"line-height:32px !important;\" data-dojo-attach-point=\"lblEntityFiltersDetailsContains\">',\r\n                    '</label>',\r\n\t\t\t    '</div>',\r\n                '<div class=\"fld dijitInline\" data-dojo-attach-point=\"txtEntityFiltersDetailsContains\"></div>',\r\n            '</td>',\r\n        '</tr>',\r\n    '</table>',\r\n'</div>'\r\n ]",
'url:Sage/MainView/EntityMgr/AddEditEntityDetail/templates/RangeDetailsView.html':"[\r\n'<div>',\r\n     '<div data-dojo-attach-point=\"characterContainer\" >',\r\n     '</div>',\t\r\n     '<table  class=\"detailTableContainer HundredPercentWidth\">',\r\n        '<tr>',\r\n            '<td class=\"FManagerDialogFieldLabel\">',\r\n                '<div style=\"padding:0 !important;\" class=\"lbl alignright\">',\r\n                    '<label  data-dojo-attach-point=\"rangeGridLabel\">',\r\n                    '</label>',\r\n                '</div>',\r\n                 '<div class=\"fld  dijitInline\">&nbsp</div>',\r\n            '</td>',\r\n        '</tr>',\r\n        '<tr>',\r\n            '<td class=\"FManagerDialogFieldLabel\">',\r\n                '<div style=\"padding:0 !important;\" class=\"lbl alignright dijitInline\">&nbsp</div>',\r\n                '<div class=\"fld dijitInline\" data-dojo-attach-point=\"rangegridwhole\"></div>',\r\n            '</td>',\r\n        '</tr>',\r\n    '</table>',\r\n'</div>'\r\n]\r\n",
'url:Sage/MainView/EntityMgr/AddEditEntityDetail/templates/AMDDetailsView.html':"[\r\n'<div>',\r\n    '<table class=\"detailTableContainer  formtable HundredPercentWidth\">',\r\n        '<tr data-dojo-attach-point=\"_filterDetailsSection\">',\r\n            '<td  class=\"FManagerDialogFieldLabel\">',\r\n\t\t\t\t'<div style=\"padding:0 !important;\" class=\"lbl alignright\">',\r\n                        '<label style=\"line-height:32px !important;\" data-dojo-attach-point=\"lblEntityFiltersDetailsAggregation\">',\r\n                    '</label>',\r\n\t\t\t    '</div>',\r\n                '<div class=\"fld  dijitInline\" data-dojo-attach-point=\"dpEntityFiltersDetailsAggregation\"></div>',\r\n            '</td>',\r\n        '</tr>',\r\n    '</table>',\r\n'</div>'\r\n]",
'url:Sage/MainView/EntityMgr/AddEditEntityDetail/templates/ADDMDDetailsView.html':"[\r\n'<div>',    \r\n    '<div data-dojo-attach-point=\"aggregate\">',\r\n    '</div>',\t\t\r\n    '<table class=\"detailTableContainer HundredPercentWidth\">',\r\n        '<tr data-dojo-attach-point=\"_MetricsFromSection\">',\r\n            '<td class=\"FManagerDialogFieldLabel\">',\r\n    \t\t    '<div style=\"padding:0 !important;\" class=\"lbl alignright\">',\r\n                    '<label style=\"line-height:32px !important;\" data-dojo-attach-point=\"lblMetricRangeFrom\">',\r\n                    '</label>',\r\n\t\t\t    '</div>',\r\n                 '<div data-dojo-attach-point=\"fieldsContainerFrom\"></div>',\r\n            '</td>',\r\n        '</tr>',\r\n        '<tr data-dojo-attach-point=\"_MetricsToSection\">',\r\n            '<td class=\"FManagerDialogFieldLabel\">',\r\n\t\t\t\t'<div style=\"padding:0 !important;\" class=\"lbl alignright\">',\r\n                    '<label style=\"line-height:32px !important;\" data-dojo-attach-point=\"lblMetricRangeTo\">',\r\n                    '</label>',\r\n\t\t\t    '</div>',\r\n                 '<div data-dojo-attach-point=\"fieldsContainerTo\"></div>',\r\n            '</td>',\r\n        '</tr>',\r\n    '</table>',\r\n'</div>'\r\n]\r\n",
'url:Sage/UI/Controls/templates/PropertyDropDown.html':"[\r\n'<div class=\"fld propertyDiv dijitInline\">',\r\n    '<input data-dojo-type=\"dijit.form.ValidationTextBox\" dojoattachpoint=\"entitySelected\"/>',\r\n    '<div data-dojo-type=\"dijit.form.Button\" iconclass=\"myIcon\" dojoattachevent=\"onClick:showDDTree\" class=\"transparentDropDown\" dojoattachpoint=\"transparentDropDown\" />',\r\n'</div>'\r\n]",
'url:Sage/MainView/EntityMgr/AddEditEntityDetail/templates/UserLookupDetailsView.html':"[\r\n'<div>',\r\n    '<table  class=\"detailTableContainer HundredPercentWidth\">',\r\n        '<tr>',\r\n            '<td class=\"FManagerDialogFieldLabel\">',\r\n                '<div style=\"padding:0 !important;\" class=\"lbl alignright\">',\r\n                    '<label  data-dojo-attach-point=\"lookupGridLabel\">',\r\n                    '</label>',\r\n                '</div>',\r\n                 '<div class=\"fld  dijitInline\">&nbsp</div>',\r\n            '</td>',\r\n\r\n       '</tr>',\r\n        '<tr>',\r\n            '<td class=\"FManagerDialogFieldLabel\">',\r\n                '<div style=\"padding:0 !important;\" class=\"lbl alignright dijitInline\">&nbsp</div>',\r\n                '<div class=\"fld dijitInline rangegridwhole\" data-dojo-attach-point=\"rangegridwhole\"></div>',\r\n            '</td>',\r\n        '</tr>',\r\n    '</table>',\r\n'</div>'\r\n]\r\n",
'url:Sage/MainView/EntityMgr/EntityWizard/templates/SelectEntityType.html':"<div>\r\n    <div data-dojo-type=\"dijit.Dialog\" title=\"New Entity Wizard\" data-dojo-attach-point=\"_dialog\" data-dojo-attach-event=\"onCancel:_btnCancel_OnClick\" style=\"position:absolute;width: 625px;height:625px;\">\r\n        <div data-dojo-type=\"dijit.form.Form\" style=\"height:600px !important;\">\r\n            <div>\r\n                <label style=\"font-size:16px; font-weight:bold;\">Welcome to the New Entity Wizard</label>\r\n                <p>This Wizard takes you through the steps for creating a new entity.</p>\r\n\r\n                <div style=\"margin-top:40px;margin-left:40px;\">\r\n                    <input data-dojo-type=\"dijit/form/RadioButton\" name=\"EntityType\" value=\"existing\" /> <label style=\"font-weight:bold;\">Create a business entity from an existing table</label> <br />\r\n                    <ul>\r\n                        <li><p>The schema can be modified using the Saleslogix DB Manager within the legacy Architect or Administrator</p></li>\r\n                    </ul>\r\n                </div>\r\n                <div style=\"margin-top:20px;margin-left:40px;\">\r\n                    <input data-dojo-type=\"dijit/form/RadioButton\" checked name=\"EntityType\" value=\"New\" /> <label style=\"font-weight:bold;\">Create a business entity and a new table</label> <br />\r\n                    <ul>\r\n                        <li><p>The table will automatically be created based on the definition of the entity</p></li>\r\n                    </ul>\r\n                </div>\r\n            </div>\r\n            <br />\r\n            <div data-dojo-attach-point=\"divValidationMessage\" style=\"color:red\">\r\n                <span data-dojo-attach-point=\"spanValidationMessage\">&nbsp;</span>\r\n            </div>\r\n            <div align=\"right\" style=\"position:absolute;bottom:30px;width:90%;\">\r\n                <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnNext\" data-dojo-attach-event=\"onClick:_btnNext_OnClick\">Next></div>\r\n                <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnCancel\" data-dojo-attach-event=\"onClick:_btnCancel_OnClick\" style=\"margin-left:5px;\">Cancel</div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>",
'url:Sage/MainView/EntityMgr/EntityWizard/templates/EntityDetails.html':"<div>\r\n    <div data-dojo-type=\"dijit.Dialog\" title=\"New Entity Wizard\" data-dojo-attach-point=\"_dialog\" data-dojo-attach-event=\"onCancel:_btnCancel_OnClick\" style=\"position:absolute;width: 625px;height:625px;\">\r\n        <div data-dojo-type=\"dijit.form.Form\" style=\"height:600px !important;\" dojoattachpoint=\"Form\">\r\n\r\n            <div style=\"padding-bottom:30px;\">\r\n                <label style=\"font-weight:bold;\" data-dojo-attach-point=\"lblCreateEntity\">Create Entity</label>\r\n                <p><label data-dojo-attach-point=\"lblCreateEntityFromTable\">Create a new entity from a table</label></p>\r\n                <hr />\r\n            </div>\r\n            \r\n            <table class=\"detailTableContainer formtable HundredPercentWidth\">\r\n                <tr data-dojo-attach-point=\"_displayNameSection\">\r\n                    <td class=\"FManagerDialogFieldLabel\">\r\n                        <div style=\"padding:0 !important;\" class=\"lbl alignright\">\r\n                            <label style=\"line-height:32px !important;\" data-dojo-attach-point=\"lblDisplayName\">\r\n                                Display Name\r\n                            </label>\r\n                        </div>\r\n                        <div class=\"fld dijitInline\" data-dojo-attach-point=\"displayName\">\r\n                        </div>\r\n                    </td>\r\n                </tr>\r\n                <tr data-dojo-attach-point=\"_filterNameSection\">\r\n                    <td class=\"FManagerDialogFieldLabel\">\r\n                        <div style=\"padding:0 !important;\" class=\"lbl alignright\">\r\n                            <label style=\"line-height:32px !important;\" data-dojo-attach-point=\"lblEntityName\">\r\n                                Entity Name\r\n                            </label>\r\n                        </div>\r\n                        <div class=\"fld  dijitInline\" data-dojo-attach-point=\"Name\">\r\n                        </div>\r\n                    </td>\r\n                </tr>\r\n                <tr data-dojo-attach-point=\"_filterNameSection\">\r\n                    <td class=\"FManagerDialogFieldLabel\">\r\n                        <div class=\"lbl alignright\">\r\n                            <label style=\"line-height:32px !important;\">\r\n                            </label>\r\n                        </div>\r\n                        <div class=\"fld  dijitInline\"  data-dojo-attach-point=\"\" style=\"color:red\">\r\n                            <label style=\"line-height:32px !important;\" data-dojo-attach-point=\"divValidationMessage\">\r\n                            </label>\r\n                        </div>\r\n                    </td>\r\n                </tr>\r\n            </table>\r\n\r\n            <div align=\"right\" style=\"position:absolute;bottom:30px;width:90%;\">\r\n                <!--<div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnBack\" data-dojo-attach-event=\"onClick:_btnBack_OnClick\">Back</div>-->\r\n                <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnNext\" data-dojo-attach-event=\"onClick:_btnNext_OnClick\">Next ></div>\r\n                <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnCancel\" data-dojo-attach-event=\"onClick:_btnCancel_OnClick\" style=\"margin-left:5px;\">Cancel</div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>",
'url:Sage/MainView/EntityMgr/EntityWizard/templates/Relationship.html':"<div>\r\n    <div data-dojo-type=\"dijit.Dialog\" title=\"New Entity Wizard\" data-dojo-attach-point=\"_dialog\" data-dojo-attach-event=\"onCancel:_btnCancel_OnClick\" style=\"position:absolute;width: 625px;height:625px;\">\r\n        <div data-dojo-type=\"dijit.form.Form\" style=\"height:600px !important;\" dojoattachpoint=\"Form\">\r\n            <div style=\"padding-bottom:30px;\">\r\n                <label style=\"font-weight:bold;\" data-dojo-attach-point=\"lblRelationship\">Primary Relationship</label>\r\n                <p>\r\n                    <label data-dojo-attach-point=\"lblSelectEntity\">Choose wheather this entity has a primary relationship to another entity</label>\r\n                </p>\r\n                <hr />\r\n            </div>\r\n\r\n            <table class=\"detailTableContainer formtable HundredPercentWidth\">\r\n                <tr data-dojo-attach-point=\"_TypeDropDownSection\">\r\n                    <td class=\"FManagerDialogFieldLabel\">\r\n\r\n                        <div style=\"padding:0 !important;\" class=\"lbl alignright\">\r\n                            <label style=\"line-height:32px !important;\" data-dojo-attach-point=\"lblExistingEntity\">\r\n                                Relate to an existing Entity\r\n                            </label>\r\n                        </div>\r\n                        <div style=\"padding-top:6px;\">\r\n                            <input type=\"checkbox\" data-dojo-attach-point=\"IsExtension\"\r\n                                   data-dojo-type=\"dijit/form/CheckBox\" />\r\n                        </div>\r\n                    </td>\r\n                </tr>\r\n                <tr data-dojo-attach-point=\"_TypeDropDownSection\">\r\n                    <td class=\"FManagerDialogFieldLabel\">\r\n                        <div style=\"padding:0 !important;\" class=\"lbl alignright\">\r\n                            <label style=\"line-height:32px !important;\" data-dojo-attach-point=\"lblRelatedEntity\">\r\n                                Related Entity\r\n                            </label>\r\n                        </div>\r\n                        <div class=\"fld dijitInline\" data-dojo-attach-point=\"typePkg\"></div>\r\n                    </td>\r\n                </tr>\r\n                <tr data-dojo-attach-point=\"_TypeDropDownSection\">\r\n                    <td class=\"FManagerDialogFieldLabel\">\r\n                        <div style=\"padding:0 !important;\" class=\"lbl alignright\">\r\n                            <label style=\"line-height:32px !important;\" data-dojo-attach-point=\"lblRelationType\">\r\n                                Relation Type\r\n                            </label>\r\n                        </div>\r\n                        <div class=\"fld dijitInline\" data-dojo-attach-point=\"typeRel\"></div>\r\n                    </td>\r\n                </tr>\r\n            </table>\r\n            <br />\r\n            <div data-dojo-attach-point=\"divValidationMessage\" style=\"color:red\">\r\n                <span data-dojo-attach-point=\"spanValidationMessage\">&nbsp;</span>\r\n            </div>\r\n            <div align=\"right\" style=\"position:absolute;bottom:30px;width:90%;\">\r\n                <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnBack\" data-dojo-attach-event=\"onClick:_btnBack_OnClick\">< Back</div>\r\n                <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnNext\" data-dojo-attach-event=\"onClick:_btnNext_OnClick\">Next ></div>\r\n                <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnCancel\" data-dojo-attach-event=\"onClick:_btnCancel_OnClick\" style=\"margin-left:5px;\">Cancel</div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>",
'url:Sage/MainView/EntityMgr/EntityWizard/templates/EntityProperties.html':"<div>\r\n    <div data-dojo-type=\"dijit.Dialog\" title=\"New Entity Wizard\" data-dojo-attach-point=\"_dialog\" data-dojo-attach-event=\"onCancel:_btnCancel_OnClick\" style=\"position:absolute;width: 625px;height:625px;\">\r\n        <div style=\"padding-bottom:30px;\">\r\n            <label style=\"font-weight:bold;\" data-dojo-attach-point=\"lblEnterProperties\">Enter Fields</label>\r\n            <p><label data-dojo-attach-point=\"lblAddNewProperty\">Click the add(+) button to add new fields to the entity</label></p>\r\n            <hr />\r\n        </div>\r\n        <div data-dojo-type=\"dijit.form.Form\"  style=\"height:400px !important;\" class=\"mainContentContent DialogMainForm\">\r\n            <div style=\"width:100%;\" class=\"fld dijitInline\" data-dojo-attach-point=\"placeGrid\"></div>\r\n        </div>\r\n        <div data-dojo-attach-point=\"divValidationMessage\" style=\"color:red\">\r\n            <span data-dojo-attach-point=\"spanValidationMessage\">&nbsp;</span>\r\n        </div>\r\n        <div class=\"lookupButtonWrapper\">\r\n            <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnBack\" data-dojo-attach-event=\"onClick:_btnBack_OnClick\">< Back</div>\r\n            <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnNext\" data-dojo-attach-event=\"onClick:_btnNext_OnClick\">Next ></div>\r\n            <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnCancel\" data-dojo-attach-event=\"onClick:_btnCancel_OnClick\" style=\"margin-left:5px;\">Cancel</div>\r\n        </div>\r\n    </div>\r\n</div>",
'url:Sage/MainView/EntityMgr/AddEditEntityDetail/templates/AddEditPropertiesDialog.html':"[\r\n'<div>',\r\n\t'<div data-dojo-type=\"dijit.Dialog\" class=\"OverrideDialogOverflowToHidden FullPageDialogue\" data-dojo-attach-point=\"_dialog\">',\r\n        '<div data-dojo-type=\"dijit.form.Form\" data-dojo-attach-point=\"addEditFiltersForm\" class=\"FManagerDialogForm\" >',\r\n            '<div class=\"mainContentContent DialogMainForm\">',                 \r\n                '<div data-dojo-attach-point=\"_DisplayName\"></div>',\r\n                '<table data-dojo-attach-point=\"_DynamicSection\" style=\"overflow-y:auto!important;\" class=\"detailTableContainer formtable HundredPercentWidth\">',\r\n                '</table>',\r\n                '<div data-dojo-attach-point=\"_DetailsSection\"></div>',\r\n            '</div>',\r\n            '<div>',\r\n                '<div data-dojo-attach-point=\"divValidationMessage\" class=\"errorText\">',\r\n                     '<span data-dojo-attach-point=\"spanValidationMessage\">&nbsp;</span>',\r\n                 '</div>',\r\n                '<div class=\"lookupButtonWrapper\">',                    \r\n                    '<span data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"cmdSave\" data-dojo-attach-event=\"onClick:_cmdSave_OnClick\"></span>',\r\n                    '<span data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"cmdCancel\" data-dojo-attach-event=\"onClick:_cmdCancel_OnClick\"></span>',\r\n                '</div>',\r\n            '</div>',\r\n        '</div>',\r\n\t'</div>',\r\n'</div>'\r\n ]",
'url:Sage/MainView/EntityMgr/AddEditEntityDetail/templates/DisplayName.html':"\r\n[\r\n'<div>',\r\n    '<table class=\"detailTableContainer formtable HundredPercentWidth\">',\r\n        '<tr data-dojo-attach-point=\"_DisplaySection\">',\r\n\t\t    '<td class=\"FManagerDialogFieldLabel\">',\r\n\t\t\t    '<div style=\"padding:0 !important;\" class=\"lbl alignright\">',\r\n                    '<label style=\"line-height:32px !important;\" data-dojo-attach-point=\"lblDisplayName\"/>',\r\n\t\t\t\t'</div>',\r\n\t\t\t\t'<div class=\"fld dijitInline\" data-dojo-attach-point=\"displayNameTxtCntrl\"></div>',\r\n            '</td>',\r\n\t    '</tr>',\r\n        '<tr data-dojo-attach-point=\"_TriggerSection\">',\r\n\t\t    '<td class=\"FManagerDialogFieldLabel\">',\r\n\t\t\t    '<div style=\"padding:0 !important;\" class=\"lbl alignright\">',\r\n                    '<label style=\"line-height:32px !important;\" data-dojo-attach-point=\"lblTriggerName\"></label>',\r\n\t\t\t\t'</div>',\r\n\t\t\t\t'<div class=\"fld dijitInline\" data-dojo-attach-point=\"triggerCntrl\">',\r\n                    '<a data-dojo-attach-point=\"triggerCntrlLink\"></a>',\r\n                '</div>',\r\n            '</td>',\r\n\t    '</tr>',\r\n        '<tr data-dojo-attach-point=\"_LineSection\">',\r\n\t\t    '<td class=\"FManagerDialogFieldLabel\">',\r\n\t\t\t\t'<div style=\"padding:0 !important;\" class=\"lbl alignright\">',\r\n                    '<label style=\"line-height:32px !important;\" data-dojo-attach-point=\"lblName\"/>',\r\n\t\t\t\t '</div>',\r\n\t\t\t     '<div class=\"fld  dijitInline\" data-dojo-attach-point=\"NameCntrl\"/>',\r\n\t\t    '</td>',\r\n\t    '</tr>',\r\n    '</table>',\r\n'</div>'\r\n]",
'url:Sage/MainView/EntityMgr/EntityWizard/templates/AddEditEntity.html':"<div>\r\n    <div data-dojo-type=\"dijit.Dialog\" title=\"New Entity Wizard\" data-dojo-attach-point=\"_dialog\" data-dojo-attach-event=\"onCancel:_btnCancel_OnClick\" style=\"position:absolute;width: 625px;height:625px;\">\r\n        <div data-dojo-type=\"dijit.form.Form\" style=\"height:600px !important;\" dojoattachpoint=\"Form\">\r\n            <div style=\"\">\r\n                <label style=\"font-weight:bold;\" data-dojo-attach-point=\"lblSure\">Are you sure ?</label>\r\n                <p>\r\n                    <label data-dojo-attach-point=\"lblThisStepCreateEntity\">Completing this step will create the entities and necessary schema</label>\r\n                </p>\r\n                <hr />\r\n            </div>\r\n\r\n            <table style=\"padding-left:20px; padding-top:20px;\">\r\n                <tr>\r\n                    <td style=\"text-align: right;\">\r\n                        <label style=\"font-weight:bold; text-align: right;\" data-dojo-attach-point=\"lblEntity\">Entity : </label>\r\n                    </td>\r\n                    <td style=\"padding-left: 10px;\">\r\n                        <label data-dojo-attach-point=\"createEntity\"></label>\r\n                    </td>\r\n                </tr>\r\n                <tr>\r\n                    <td style=\"vertical-align:top; padding-top:15px;text-align: right;\">\r\n                        <span><label style=\"font-weight:bold;\" data-dojo-attach-point=\"lblProperties\">Properties : </label></span>\r\n                    </td>\r\n                    <td style=\"padding-left: 10px;\">\r\n                        <ul class=\"properties\" style=\"padding-left:0;\"></ul>\r\n                    </td>\r\n                </tr>\r\n                <tr>\r\n                    <td style=\"text-align: right;\">\r\n                        <label style=\"font-weight:bold;\" data-dojo-attach-point=\"lblRelatedEntity\"></label>\r\n                    </td>\r\n                    <td style=\"padding-left: 10px;\">\r\n                        <label data-dojo-attach-point=\"relatedEntity\"></label>\r\n                    </td>\r\n                </tr>\r\n                <tr>\r\n                    <td style=\"text-align: right;\">\r\n                        <label style=\"font-weight:bold;\" data-dojo-attach-point=\"lblRelationType\"></label>\r\n                    </td>\r\n                    <td style=\"padding-left: 10px;\">\r\n                        <label data-dojo-attach-point=\"relationType\"></label>\r\n                    </td>\r\n                </tr>\r\n            </table>\r\n\r\n            <div align=\"right\" style=\"position:absolute;bottom:30px;width:90%;\">\r\n                <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnBack\" data-dojo-attach-event=\"onClick:_btnBack_OnClick\">< Back</div>\r\n                <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnNext\" data-dojo-attach-event=\"onClick:_btnNext_OnClick\">Next ></div>\r\n                <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnCancel\" data-dojo-attach-event=\"onClick:_btnCancel_OnClick\" style=\"margin-left:5px;\">Cancel</div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>",
'url:Sage/MainView/EntityMgr/EntityWizard/templates/Status.html':"<div>\r\n    <div data-dojo-type=\"dijit.Dialog\" title=\"New Entity Wizard\" data-dojo-attach-point=\"_dialog\" data-dojo-attach-event=\"onCancel:_btnCancel_OnClick\" style=\"position:absolute;width: 625px;height:625px;\">\r\n        <div data-dojo-type=\"dijit.form.Form\" style=\"height:600px !important;\" dojoattachpoint=\"Form\">\r\n\r\n            <div style=\"\">\r\n                <label style=\"font-weight:bold;\" data-dojo-attach-point=\"lblCreateEntity\">Create Entity</label>\r\n                <p><label data-dojo-attach-point=\"lblStatus\">Status</label></p>\r\n                <hr />\r\n            </div>\r\n\r\n            <div style=\"padding-bottom: 30px;\">\r\n                <p><label data-dojo-attach-point=\"statusLabel\" style=\"font-weight: bold;\"></label>\r\n                </p>\r\n                <p>\r\n                    <label data-dojo-attach-point=\"selectedRelStatus\" style=\"font-weight: bold;\"></label>\r\n                </p>\r\n                <p>\r\n                    <label data-dojo-attach-point=\"ownerStatus\" style=\"font-weight: bold;\"></label>\r\n                </p>\r\n            </div>\r\n\r\n\r\n            <div align=\"right\" style=\"position:absolute;bottom:30px;width:90%;\">\r\n                <div data-dojo-type=\"dijit.form.Button\" data-dojo-attach-point=\"btnFinish\" data-dojo-attach-event=\"onClick:_btnFinish_OnClick\" style=\"margin-left:5px;\">Finish</div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>",
'*now':function(r){r(['dojo/i18n!*preload*Sage/nls/Dialog*["ar","ca","cs","da","de-de","el","en-au","en-ca","en-gb","en-us","es-es","fi","fr-ch","fr-fr","he-il","hu","it-it","ja-jp","ko-kr","nb","nl","pl","pt-br","pt-pt","ro","ru","sk","sl","sv","th","tr","zh","zh-cn","zh-hant","zh-hans","zh-hk","zh-tw","af-za","sq-al","gsw-fr","am-et","ar-dz","ar-bh","ar-eg","ar-iq","ar-jo","ar-kw","ar-lb","ar-ly","ar-ma","ar-om","ar-qa","ar-sa","ar-sy","ar-tn","ar-ae","ar-ye","hy-am","as-in","az-cyrl-az","az-latn-az","bn-bd","bn-in","ba-ru","eu-es","be-by","bs-cyrl-ba","bs-latn-ba","br-fr","bg-bg","ca-es","zh-cn","zh-sg","zh-hk","zh-mo","zh-tw","co-fr","crm-en-us-de-ch","hr-hr","hr-ba","cs-cz","da-dk","prs-af","dv-mv","nl-be","nl-nl","en-au","en-bz","en-ca","en-029","en-in","en-ie","en-jm","en-my","en-nz","en-ph","en-sg","en-za","en-tt","en-gb","en-us","en-fr","en-kz","en-kg","en-mx","en-ch","en-ye","en-zw","et-ee","fo-fo","fil-ph","fi-fi","fr-be","fr-ca","fr-fr","fr-lu","fr-mc","fr-ch","fy-nl","gl-es","ka-ge","de-at","de-de","de-li","de-lu","de-ch","el-gr","kl-gl","gu-in","ha-latn-ng","he-il","hi-in","hu-hu","is-is","ig-ng","id-id","iu-latn-ca","iu-cans-ca","ga-ie","xh-za","zu-za","it-it","it-ch","ja-jp","kn-in","kk-kz","km-kh","qut-gt","rw-rw","sw-ke","kok-in","ko-kr","ky-kg","lo-la","lv-lv","lt-lt","dsb-de","lb-lu","mk-mk","ms-bn","ms-my","ml-in","mt-mt","mi-nz","arn-cl","mr-in","moh-ca","mn-mn","mn-mong-cn","ne-np","nb-no","nn-no","oc-fr","or-in","ps-af","fa-ir","pl-pl","pt-br","pt-pt","pa-in","quz-bo","quz-ec","quz-pe","ro-ro","rm-ch","ru-ru","sah-ru","smn-fi","smj-no","smj-se","se-fi","se-no","se-se","sms-fi","sma-no","sma-se","sa-in","gd-gb","sr-cyrl-ba","sr-cyrl-me","sr-cyrl-cs","sr-cyrl-rs","sr-latn-ba","sr-latn-me","sr-latn-cs","sr-latn-rs","nso-za","tn-za","si-lk","sk-sk","sl-si","es-ar","es-ve","es-bo","es-cl","es-co","es-cr","es-do","es-ec","es-sv","es-gt","es-hn","es-mx","es-ni","es-pa","es-py","es-pe","es-pr","es-es","es-us","es-uy","sv-fi","sv-se","syr-sy","tg-cyrl-tj","tzm-latn-dz","ta-in","tt-ru","te-in","th-th","bo-cn","tr-tr","tk-tm","uk-ua","hsb-de","ur-pk","ug-cn","uz-cyrl-uz","uz-latn-uz","vi-vn","cy-gb","wo-sn","ii-cn","yo-ng","ROOT"]']);}
}});
define("Sage/Dialog", [], 1);
